(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.VideomailClient = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(_dereq_,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["add-eventlistener-with-options"] = factory();
	else
		root["add-eventlistener-with-options"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = addEventListenerWithOptions;

	var _checkSupport = __webpack_require__(1);

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	/**
	 * Add event listener with additional options
	 * @param {EventTarget} target - The EventTarget element
	 * @param {string} name - The name of the event
	 * @param {function} listener - The event listener callback
	 * @param {object} options - The options explicitly passed from caller
	 * @param {string} optionName - The additioanl option to add to the event listener 
	 */
	function addEventListenerWithOptions(target, name, listener, options) {
	    var optionName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'passive';

	    if (target.addEventListener !== undefined) {
	        var listenerOptions = _checkSupport.SupportMap[optionName] ? Object.assign({}, options, _defineProperty({}, optionName, true)) : options;
	        target.addEventListener(name, listener, listenerOptions);
	    }
	}

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.SupportMap = undefined;

	var _OptionsMap;

	var _constants = __webpack_require__(2);

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var OptionsMap = (_OptionsMap = {}, _defineProperty(_OptionsMap, _constants.PASSIVE, false), _defineProperty(_OptionsMap, _constants.CAPTURE, false), _defineProperty(_OptionsMap, _constants.ONCE, false), _OptionsMap);

	var getOptionsMap = function getOptionsMap() {
	    Object.keys(OptionsMap).forEach(function (k, i) {
	        OptionsMap[k] = checkSupportForProperty(k);
	    });

	    return OptionsMap;
	};

	function checkSupportForProperty(property) {
	    if (!!OptionsMap[property]) {
	        return OptionsMap[property];
	    }

	    try {
	        var opts = Object.defineProperty({}, property, {
	            get: function get() {
	                OptionsMap[property] = true;
	            }
	        });
	        window.addEventListener("test", null, opts);
	        window.removeListener("test", null);
	    } catch (e) {}

	    return OptionsMap[property];
	}

	var SupportMap = exports.SupportMap = getOptionsMap();

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var PASSIVE = exports.PASSIVE = 'passive';
	var CAPTURE = exports.CAPTURE = 'capture';
	var ONCE = exports.ONCE = 'once';

/***/ }
/******/ ])
});
;
},{}],2:[function(_dereq_,module,exports){
var EventEmitter          = _dereq_('events').EventEmitter,
    inherits              = _dereq_('inherits'),
    raf                   = _dereq_('raf'),
    methods;


//the same as off window unless polyfilled or in node
var defaultRAFObject = {
    requestAnimationFrame: raf,
    cancelAnimationFrame: raf.cancel
};

function returnTrue(){ return true; }

//manage FPS if < 60, else return true;
function makeThrottle(fps){
    var delay = 1000/fps;
    var lastTime = Date.now();


    if( fps<=0 || fps === Infinity ){
        return returnTrue;
    }

    //if an fps throttle has been set then we'll assume
    //it natively runs at 60fps,
    var half = Math.ceil(1000 / 60) / 2;

    return function(){
        //if a custom fps is requested
        var now = Date.now();
        //is this frame within 8.5ms of the target?
        //if so then next frame is gonna be too late
        if(now - lastTime < delay - half){
            return false;
        }
        lastTime = now;
        return true;
    };
}


/**
 * Animitter provides event-based loops for the browser and node,
 * using `requestAnimationFrame`
 * @param {Object} [opts]
 * @param {Number} [opts.fps=Infinity] the framerate requested, defaults to as fast as it can (60fps on window)
 * @param {Number} [opts.delay=0] milliseconds delay between invoking `start` and initializing the loop
 * @param {Object} [opts.requestAnimationFrameObject=global] the object on which to find `requestAnimationFrame` and `cancelAnimationFrame` methods
 * @param {Boolean} [opts.fixedDelta=false] if true, timestamps will pretend to be executed at fixed intervals always
 * @constructor
 */
function Animitter( opts ){
    opts = opts || {};

    this.__delay = opts.delay || 0;

    /** @expose */
    this.fixedDelta = !!opts.fixedDelta;

    /** @expose */
    this.frameCount = 0;
    /** @expose */
    this.deltaTime = 0;
    /** @expose */
    this.elapsedTime = 0;

    /** @private */
    this.__running = false;
    /** @private */
    this.__completed = false;

    this.setFPS(opts.fps || Infinity);
    this.setRequestAnimationFrameObject(opts.requestAnimationFrameObject || defaultRAFObject);
}

inherits(Animitter, EventEmitter);

function onStart(scope){
    var now = Date.now();
    var rAFID;
    //dont let a second animation start on the same object
    //use *.on('update',fn)* instead
    if(scope.__running){
        return scope;
    }

    exports.running += 1;
    scope.__running = true;
    scope.__lastTime = now;
    scope.deltaTime = 0;

    //emit **start** once at the beginning
    scope.emit('start', scope.deltaTime, 0, scope.frameCount);

    var lastRAFObject = scope.requestAnimationFrameObject;

    var drawFrame = function(){
        if(lastRAFObject !== scope.requestAnimationFrameObject){
            //if the requestAnimationFrameObject switched in-between,
            //then re-request with the new one to ensure proper update execution context
            //i.e. VRDisplay#submitFrame() may only be requested through VRDisplay#requestAnimationFrame(drawFrame)
            lastRAFObject = scope.requestAnimationFrameObject;
            scope.requestAnimationFrameObject.requestAnimationFrame(drawFrame);
            return;
        }
        if(scope.__isReadyForUpdate()){
            scope.update();
        }
        if(scope.__running){
            rAFID = scope.requestAnimationFrameObject.requestAnimationFrame(drawFrame);
        } else {
            scope.requestAnimationFrameObject.cancelAnimationFrame(rAFID);
        }
    };

    scope.requestAnimationFrameObject.requestAnimationFrame(drawFrame);

    return scope;
}

methods = {
    //EventEmitter Aliases
    off     : EventEmitter.prototype.removeListener,
    trigger : EventEmitter.prototype.emit,

    /**
     * stops the animation and marks it as completed
     * @emit Animitter#complete
     * @returns {Animitter}
     */
    complete: function(){
        this.stop();
        this.__completed = true;
        this.emit('complete', this.frameCount, this.deltaTime);
        return this;
    },

    /**
     * stops the animation and removes all listeners
     * @emit Animitter#stop
     * @returns {Animitter}
     */
    dispose: function(){
        this.stop();
        this.removeAllListeners();
        return this;
    },

    /**
     * get milliseconds between the last 2 updates
     *
     * @return {Number}
     */
    getDeltaTime: function(){
        return this.deltaTime;
    },

    /**
     * get the total milliseconds that the animation has ran.
     * This is the cumlative value of the deltaTime between frames
     *
     * @return {Number}
     */
    getElapsedTime: function(){
        return this.elapsedTime;
    },

    /**
     * get the instances frames per second as calculated by the last delta
     *
     * @return {Number}
     */
    getFPS: function(){
        return this.deltaTime > 0 ? 1000 / this.deltaTime : 0;
        if(this.deltaTime){
            return 1000 / this.deltaTime;
        }
    },

    /**
     * get the explicit FPS limit set via `Animitter#setFPS(fps)` or
     * via the initial `options.fps` property
     *
     * @returns {Number} either as set or Infinity
     */
    getFPSLimit: function(){
        return this.__fps;
    },

    /**
     * get the number of frames that have occurred
     *
     * @return {Number}
     */
    getFrameCount: function(){
        return this.frameCount;
    },


    /**
     * get the object providing `requestAnimationFrame`
     * and `cancelAnimationFrame` methods
     * @return {Object}
     */
    getRequestAnimationFrameObject: function(){
        return this.requestAnimationFrameObject;
    },

    /**
     * is the animation loop active
     *
     * @return {boolean}
     */
    isRunning: function(){
        return this.__running;
    },

    /**
     * is the animation marked as completed
     *
     * @return {boolean}
     */
    isCompleted: function(){
        return this.__completed;
    },

    /**
     * reset the animation loop, marks as incomplete,
     * leaves listeners intact
     *
     * @emit Animitter#reset
     * @return {Animitter}
     */
    reset: function(){
        this.stop();
        this.__completed = false;
        this.__lastTime = 0;
        this.deltaTime = 0;
        this.elapsedTime = 0;
        this.frameCount = 0;

        this.emit('reset', 0, 0, this.frameCount);
        return this;
    },

    /**
     * set the framerate for the animation loop
     *
     * @param {Number} fps
     * @return {Animitter}
     */
    setFPS: function(fps){
        this.__fps = fps;
        this.__isReadyForUpdate = makeThrottle(fps);
        return this;
    },

    /**
     * set the object that will provide `requestAnimationFrame`
     * and `cancelAnimationFrame` methods to this instance
     * @param {Object} object
     * @return {Animitter}
     */
    setRequestAnimationFrameObject: function(object){
        if(typeof object.requestAnimationFrame !== 'function' || typeof object.cancelAnimationFrame !== 'function'){
            throw new Error("Invalid object provide to `setRequestAnimationFrameObject`");
        }
        this.requestAnimationFrameObject = object;
        return this;
    },

    /**
     * start an animation loop
     * @emit Animitter#start
     * @return {Animitter}
     */
    start: function(){
        var self = this;
        if(this.__delay){
            setTimeout(function(){
                onStart(self);
            }, this.__delay);
        } else {
            onStart(this);
        }
        return this;
    },

    /**
     * stops the animation loop, does not mark as completed
     *
     * @emit Animitter#stop
     * @return {Animitter}
     */
    stop: function(){
        if( this.__running ){
            this.__running = false;
            exports.running -= 1;
            this.emit('stop', this.deltaTime, this.elapsedTime, this.frameCount);
        }
        return this;
    },

    /**
     * update the animation loop once
     *
     * @emit Animitter#update
     * @return {Animitter}
     */
    update: function(){
        this.frameCount++;
        /** @private */
        var now = Date.now();
        this.__lastTime = this.__lastTime || now;
        this.deltaTime = (this.fixedDelta || exports.globalFixedDelta) ? 1000/Math.min(60, this.__fps) : now - this.__lastTime;
        this.elapsedTime += this.deltaTime;
        this.__lastTime = now;

        this.emit('update', this.deltaTime, this.elapsedTime, this.frameCount);
        return this;
    }
};



for(var method in methods){
    Animitter.prototype[method] = methods[method];
}


/**
 * create an animitter instance,
 * @param {Object} [options]
 * @param {Function} fn( deltaTime:Number, elapsedTime:Number, frameCount:Number )
 * @returns {Animitter}
 */
function createAnimitter(options, fn){

    if( arguments.length === 1 && typeof options === 'function'){
        fn = options;
        options = {};
    }

    var _instance = new Animitter( options );

    if( fn ){
        _instance.on('update', fn);
    }

    return _instance;
}

module.exports = exports = createAnimitter;

/**
 * create an animitter instance,
 * where the scope is bound in all functions
 * @param {Object} [options]
 * @param {Function} fn( deltaTime:Number, elapsedTime:Number, frameCount:Number )
 * @returns {Animitter}
 */
exports.bound = function(options, fn){

    var loop = createAnimitter(options, fn),
        functionKeys = functions(Animitter.prototype),
        hasBind = !!Function.prototype.bind,
        fnKey;

    for(var i=0; i<functionKeys.length; i++){
        fnKey = functionKeys[i];
        loop[fnKey] = hasBind ? loop[fnKey].bind(loop) : bind(loop[fnKey], loop);
    }

    return loop;
};


exports.Animitter = Animitter;

/**
 * if true, all `Animitter` instances will behave as if `options.fixedDelta = true`
 */
exports.globalFixedDelta = false;

//helpful to inherit from when using bundled
exports.EventEmitter = EventEmitter;
//keep a global counter of all loops running, helpful to watch in dev tools
exports.running = 0;

function bind(fn, scope){
    if(typeof fn.bind === 'function'){
        return fn.bind(scope);
    }
    return function(){
        return fn.apply(scope, arguments);
    };
}

function functions(obj){
    var keys = Object.keys(obj);
    var arr = [];
    for(var i=0; i<keys.length; i++){
        if(typeof obj[keys[i]] === 'function'){
            arr.push(keys[i]);
        }
    }
    return arr;
}



//polyfill Date.now for real-old browsers
Date.now = Date.now || function now() {
    return new Date().getTime();
};

},{"events":23,"inherits":36,"raf":51}],3:[function(_dereq_,module,exports){
(function (Buffer){
(function (w) {
  "use strict";

  function findBest(atobNative) {
    // normal window
    if ('function' === typeof atobNative) { return atobNative; }


    // browserify (web worker)
    if ('function' === typeof Buffer) {
      return function atobBrowserify(a) {
        //!! Deliberately using an API that's deprecated in node.js because
        //!! this file is for browsers and we expect them to cope with it.
        //!! Discussion: github.com/node-browser-compat/atob/pull/9
        return new Buffer(a, 'base64').toString('binary');
      };
    }

    // ios web worker with base64js
    if ('object' === typeof w.base64js) {
      // bufferToBinaryString
      // https://git.coolaj86.com/coolaj86/unibabel.js/blob/master/index.js#L50
      return function atobWebWorker_iOS(a) {
        var buf = w.base64js.b64ToByteArray(a);
        return Array.prototype.map.call(buf, function (ch) {
          return String.fromCharCode(ch);
        }).join('');
      };
    }

		return function () {
			// ios web worker without base64js
			throw new Error("You're probably in an old browser or an iOS webworker." +
				" It might help to include beatgammit's base64-js.");
    };
  }

  var atobBest = findBest(w.atob);
  w.atob = atobBest;

  if ((typeof module === 'object') && module && module.exports) {
    module.exports = atobBest;
  }
}(window));

}).call(this,_dereq_("buffer").Buffer)

},{"buffer":8}],4:[function(_dereq_,module,exports){
var toBuffer = _dereq_('typedarray-to-buffer')
var isFloat32Array = _dereq_('validate.io-float32array')

module.exports = function (float32Array) {
  if (!float32Array) {
    throw new Error('A Float32Array parameter is missing.')
  }

  if (!isFloat32Array(float32Array)) {
    throw new Error('The parameter is not a Float32Array.')
  }

  this.toBuffer = function () {
    var l = float32Array.length
    var arr = new Int16Array(l)
    var i

    for (i = 0; i < l; i++) {
      arr[i] = Math.min(1, float32Array[i]) * 0x7FFF
    }

    return toBuffer(arr)
  }
}

},{"typedarray-to-buffer":77,"validate.io-float32array":82}],5:[function(_dereq_,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],6:[function(_dereq_,module,exports){

},{}],7:[function(_dereq_,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],8:[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":5,"ieee754":34}],9:[function(_dereq_,module,exports){
var toBuffer = _dereq_('typedarray-to-buffer')
var atob = _dereq_('atob')
var isBrowser = typeof document !== 'undefined' && typeof document.createElement === 'function'

// cached, used only once for browser environments
var verifiedImageType

module.exports = function (canvas, options) {
  var self = this

  options = options || {}
  options.image = options.image ? options.image : {}
  options.image.types = options.image.types ? options.image.types : []

  // validate some options this class needs
  if (options.image.types.length > 2) {
    throw new Error('Too many image types are specified!')
  } else if (options.image.types.length < 1) {
    // Set a default image type, just to be robust
    options.image.types = isBrowser ? ['webp', 'jpeg'] : ['png']
  }

  if (!options.image.quality) {
    options.image.quality = 0.5 // default
  }

  var quality = parseFloat(options.image.quality)

  function composeImageType (index) {
    var imageType

    if (options.image.types[index]) {
      imageType = 'image/' + options.image.types[index]
    }

    return imageType
  }

  function isMatch (uri, imageType) {
    var match = uri && uri.match(imageType)

    match && options.debug && options.debug('Image type %s verified', imageType)

    return match
  }

  // Performance tweak, we do not need a big canvas for finding out the supported image type
  function getTestCanvas () {
    var testCanvas

    if (isBrowser) {
      testCanvas = document.createElement('canvas')
      testCanvas.width = testCanvas.height = 1
    } else {
      testCanvas = canvas
    }

    return testCanvas
  }

  function canvasSupportsImageTypeAsync (imageType, cb) {
    try {
      getTestCanvas().toDataURL(imageType, function (err, uri) {
        if (err) {
          cb(err)
        } else {
          cb(null, isMatch(uri, imageType))
        }
      })
    } catch (exc) {
      cb(null, false)
    }
  }

  function canvasSupportsImageTypeSync (imageType) {
    var match

    try {
      var testCanvas = getTestCanvas()
      var uri = testCanvas.toDataURL && testCanvas.toDataURL(imageType)

      match = isMatch(uri, imageType)
    } catch (exc) {
      // Can happen when i.E. a spider is coming. Just be robust here and continue.
      options.debug &&
      options.logger.debug('Failed to call toDataURL() on canvas for image type %s', imageType)
    }

    return match
  }

  function verifyImageTypeAsync (imageType, cb) {
    canvasSupportsImageTypeAsync(imageType, function (err, match) {
      if (err) {
        cb(err)
      } else {
        if (match) {
          cb(null, imageType)
        } else {
          imageType = composeImageType(1)

          canvasSupportsImageTypeAsync(imageType, function (err, match) {
            if (err) {
              cb(err)
            } else {
              cb(null, match ? imageType : null)
            }
          })
        }
      }
    })
  }

  function verifyImageTypeSync (imageType) {
    if (!canvasSupportsImageTypeSync(imageType)) {
      if (options.image.types[1]) {
        imageType = composeImageType(1)

        if (!canvasSupportsImageTypeSync(imageType)) {
          imageType = null
        }
      } else {
        imageType = null
      }
    }

    !imageType && options.debug && options.logger.debug('Unable to verify image type')

    return imageType
  }

  // callbacks are needed for server side tests
  function verifyImageType (cb) {
    var imageType = composeImageType(0)

    if (cb) {
      verifyImageTypeAsync(imageType, cb)
    } else {
      return verifyImageTypeSync(imageType)
    }
  }

  // this method is proven to be fast, see
  // http://jsperf.com/data-uri-to-buffer-performance/3
  function uriToBuffer (uri) {
    var uriSplitted = uri.split(',')[1]
    var bytes

    // Beware that the atob function might be a static one for server side tests
    if (typeof (atob) === 'function') {
      bytes = atob(uriSplitted)
    } else if (typeof (self.constructor.atob) === 'function') {
      bytes = self.constructor.atob(uriSplitted)
    } else {
      throw new Error('atob function is missing')
    }

    var arr = new Uint8Array(bytes.length)

    // http://mrale.ph/blog/2014/12/24/array-length-caching.html
    for (var i = 0, l = bytes.length; i < l; i++) {
      arr[i] = bytes.charCodeAt(i)
    }

    return toBuffer(arr)
  }

  function toBufferSync () {
    var imageType = self.getImageType()
    var buffer

    if (imageType) {
      var uri = canvas.toDataURL(imageType, quality)
      buffer = uriToBuffer(uri)
    }

    return buffer
  }

  function toBufferAsync (cb) {
    self.getImageType(function (err, imageType) {
      if (err) {
        cb(err)
      } else if (!imageType) {
        cb()
      } else {
        canvas.toDataURL(imageType, function (err, uri) {
          if (err) {
            cb(err)
          } else {
            cb(null, uriToBuffer(uri))
          }
        })
      }
    })
  }

  this.toBuffer = function (cb) {
    if (cb) {
      toBufferAsync(cb)
    } else {
      return toBufferSync()
    }
  }

  // browsers do not need a callback, but tests do
  this.getImageType = function (cb) {
    // only run for the first time this constructor is called and
    // cache result for the next calls
    if (cb) {
      if (!verifiedImageType || !isBrowser) {
        verifyImageType(function (err, newVerifiedImageType) {
          if (err) {
            cb(err)
          } else {
            verifiedImageType = newVerifiedImageType
            cb(null, verifiedImageType)
          }
        })
      } else {
        cb(null, verifiedImageType)
      }
    } else {
      // on the browser side we do cache it for speed
      if (!verifiedImageType || !isBrowser) {
        verifiedImageType = verifyImageType()
      }

      return verifiedImageType
    }
  }
}

},{"atob":3,"typedarray-to-buffer":77}],10:[function(_dereq_,module,exports){
// contains, add, remove, toggle
var indexof = _dereq_('indexof')

module.exports = ClassList

function ClassList(elem) {
    var cl = elem.classList

    if (cl) {
        return cl
    }

    var classList = {
        add: add
        , remove: remove
        , contains: contains
        , toggle: toggle
        , toString: $toString
        , length: 0
        , item: item
    }

    return classList

    function add(token) {
        var list = getTokens()
        if (indexof(list, token) > -1) {
            return
        }
        list.push(token)
        setTokens(list)
    }

    function remove(token) {
        var list = getTokens()
            , index = indexof(list, token)

        if (index === -1) {
            return
        }

        list.splice(index, 1)
        setTokens(list)
    }

    function contains(token) {
        return indexof(getTokens(), token) > -1
    }

    function toggle(token) {
        if (contains(token)) {
            remove(token)
            return false
        } else {
            add(token)
            return true
        }
    }

    function $toString() {
        return elem.className
    }

    function item(index) {
        var tokens = getTokens()
        return tokens[index] || null
    }

    function getTokens() {
        var className = elem.className

        return filter(className.split(" "), isTruthy)
    }

    function setTokens(list) {
        var length = list.length

        elem.className = list.join(" ")
        classList.length = length

        for (var i = 0; i < list.length; i++) {
            classList[i] = list[i]
        }

        delete list[length]
    }
}

function filter (arr, fn) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i])) ret.push(arr[i])
    }
    return ret
}

function isTruthy(value) {
    return !!value
}

},{"indexof":35}],11:[function(_dereq_,module,exports){
/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_")) 
	|| document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
	  classListProp = "classList"
	, protoProp = "prototype"
	, elemCtrProto = view.Element[protoProp]
	, objCtr = Object
	, strTrim = String[protoProp].trim || function () {
		return this.replace(/^\s+|\s+$/g, "");
	}
	, arrIndexOf = Array[protoProp].indexOf || function (item) {
		var
			  i = 0
			, len = this.length
		;
		for (; i < len; i++) {
			if (i in this && this[i] === item) {
				return i;
			}
		}
		return -1;
	}
	// Vendors: please allow content code to instantiate DOMExceptions
	, DOMEx = function (type, message) {
		this.name = type;
		this.code = DOMException[type];
		this.message = message;
	}
	, checkTokenAndGetIndex = function (classList, token) {
		if (token === "") {
			throw new DOMEx(
				  "SYNTAX_ERR"
				, "An invalid or illegal string was specified"
			);
		}
		if (/\s/.test(token)) {
			throw new DOMEx(
				  "INVALID_CHARACTER_ERR"
				, "String contains an invalid character"
			);
		}
		return arrIndexOf.call(classList, token);
	}
	, ClassList = function (elem) {
		var
			  trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
			, classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
			, i = 0
			, len = classes.length
		;
		for (; i < len; i++) {
			this.push(classes[i]);
		}
		this._updateClassName = function () {
			elem.setAttribute("class", this.toString());
		};
	}
	, classListProto = ClassList[protoProp] = []
	, classListGetter = function () {
		return new ClassList(this);
	}
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
	return this[i] || null;
};
classListProto.contains = function (token) {
	token += "";
	return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
	;
	do {
		token = tokens[i] + "";
		if (checkTokenAndGetIndex(this, token) === -1) {
			this.push(token);
			updated = true;
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.remove = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
		, index
	;
	do {
		token = tokens[i] + "";
		index = checkTokenAndGetIndex(this, token);
		while (index !== -1) {
			this.splice(index, 1);
			updated = true;
			index = checkTokenAndGetIndex(this, token);
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.toggle = function (token, force) {
	token += "";

	var
		  result = this.contains(token)
		, method = result ?
			force !== true && "remove"
		:
			force !== false && "add"
	;

	if (method) {
		this[method](token);
	}

	if (force === true || force === false) {
		return force;
	} else {
		return !result;
	}
};
classListProto.toString = function () {
	return this.join(" ");
};

if (objCtr.defineProperty) {
	var classListPropDesc = {
		  get: classListGetter
		, enumerable: true
		, configurable: true
	};
	try {
		objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
	} catch (ex) { // IE 8 doesn't support enumerable:true
		if (ex.number === -0x7FF5EC54) {
			classListPropDesc.enumerable = false;
			objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
		}
	}
} else if (objCtr[protoProp].__defineGetter__) {
	elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(self));

} else {
// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
	"use strict";

	var testElement = document.createElement("_");

	testElement.classList.add("c1", "c2");

	// Polyfill for IE 10/11 and Firefox <26, where classList.add and
	// classList.remove exist but support only one argument at a time.
	if (!testElement.classList.contains("c2")) {
		var createMethod = function(method) {
			var original = DOMTokenList.prototype[method];

			DOMTokenList.prototype[method] = function(token) {
				var i, len = arguments.length;

				for (i = 0; i < len; i++) {
					token = arguments[i];
					original.call(this, token);
				}
			};
		};
		createMethod('add');
		createMethod('remove');
	}

	testElement.classList.toggle("c3", false);

	// Polyfill for IE 10 and Firefox <24, where classList.toggle does not
	// support the second argument.
	if (testElement.classList.contains("c3")) {
		var _toggle = DOMTokenList.prototype.toggle;

		DOMTokenList.prototype.toggle = function(token, force) {
			if (1 in arguments && !this.contains(token) === !force) {
				return force;
			} else {
				return _toggle.call(this, token);
			}
		};

	}

	testElement = null;
}());

}

}


},{}],12:[function(_dereq_,module,exports){
var DOCUMENT_POSITION_CONTAINED_BY = 16

module.exports = contains

function contains(container, elem) {
    if (container.contains) {
        return container.contains(elem)
    }

    var comparison = container.compareDocumentPosition(elem)

    return comparison === 0 || comparison & DOCUMENT_POSITION_CONTAINED_BY
}

},{}],13:[function(_dereq_,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":_dereq_("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":40}],14:[function(_dereq_,module,exports){
//     create-error.js 0.3.1
//     (c) 2013 Tim Griesser
//     This source may be freely distributed under the MIT license.
(function(factory) {

"use strict";

// A simple utility for subclassing the "Error"
// object in multiple environments, while maintaining
// relevant stack traces, messages, and prototypes.
factory(function() {

var toString = Object.prototype.toString;

// Creates an new error type with a "name",
// and any additional properties that should be set
// on the error instance.
return function() {
  var args = new Array(arguments.length);
  for (var i = 0; i < args.length; ++i) {
    args[i] = arguments[i];
  }
  var name       = getName(args);
  var target     = getTarget(args);
  var properties = getProps(args);
  function ErrorCtor(message, obj) {
    attachProps(this, properties);
    attachProps(this, obj);
    this.message = (message || this.message);
    if (message instanceof Error) {
      this.message = message.message;
      this.stack = message.stack;
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  function Err() { this.constructor = ErrorCtor; }
  Err.prototype = target['prototype'];
  ErrorCtor.prototype = new Err();
  ErrorCtor.prototype.name = ('' + name) || 'CustomError';
  return ErrorCtor;
};

// Just a few helpers to clean up the function above
// https://github.com/petkaantonov/bluebird/wiki/Optimization-killers
function getName(args) {
  if (args.length === 0) return '';
  return isError(args[0]) ? (args[1] || '') : args[0];
}
function getTarget(args) {
  if (args.length === 0) return Error;
  return isError(args[0]) ? args[0] : Error;
}
function getProps(args) {
  if (args.length === 0) return null;
  return isError(args[0]) ? args[2] : args[1];
}
function inheritedKeys(obj) {
  var ret = [];
  for (var key in obj) {
    ret.push(key);
  }
  return ret;
}

// Right now we're just assuming that a function in the first argument is an error.
function isError(obj) {
  return (typeof obj === "function");
}

// We don't need the full underscore check here, since it should either be
// an object-literal, or nothing at all.
function isObject(obj) {
  return (obj && typeof obj === "object" && toString.call(obj) === "[object Object]");
}

// Used to attach attributes to the error object in the constructor.
function attachProps(context, target) {
  if (isObject(target)) {
    var keys = inheritedKeys(target);
    for (var i = 0, l = keys.length; i < l; ++i) {
      context[keys[i]] = clone(target[keys[i]]);
    }
  }
}

// Don't need the full-out "clone" mechanism here, since if you're
// trying to set things other than empty arrays/objects on your
// sub-classed `Error` object, you're probably doing it wrong.
function clone(target) {
  if (target == null || typeof target !== "object") return target;
  var cloned = target.constructor ? target.constructor() : Object.create(null);
  for (var attr in target) {
    if (target.hasOwnProperty(attr)) {
      cloned[attr] = target[attr];
    }
  }
  return cloned;
}

});

// Boilerplate UMD definition block...
})(function(createErrorLib) {
  if (typeof define === "function" && define.amd) {
    define(createErrorLib);
  } else if (typeof exports === 'object') {
    module.exports = createErrorLib();
  } else {
    var root = this;
    var lastcreateError = root.createError;
    var createError = root.createError = createErrorLib();
    createError.noConflict = function() {
      root.createError = lastcreateError;
      return createError;
    };
  }
});

},{}],15:[function(_dereq_,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.deepmerge = factory());
}(this, function () { 'use strict';

	var isMergeableObject = function isMergeableObject(value) {
		return isNonNullObject(value)
			&& !isSpecial(value)
	};

	function isNonNullObject(value) {
		return !!value && typeof value === 'object'
	}

	function isSpecial(value) {
		var stringValue = Object.prototype.toString.call(value);

		return stringValue === '[object RegExp]'
			|| stringValue === '[object Date]'
			|| isReactElement(value)
	}

	// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
	var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

	function isReactElement(value) {
		return value.$$typeof === REACT_ELEMENT_TYPE
	}

	function emptyTarget(val) {
		return Array.isArray(val) ? [] : {}
	}

	function cloneUnlessOtherwiseSpecified(value, options) {
		return (options.clone !== false && options.isMergeableObject(value))
			? deepmerge(emptyTarget(value), value, options)
			: value
	}

	function defaultArrayMerge(target, source, options) {
		return target.concat(source).map(function(element) {
			return cloneUnlessOtherwiseSpecified(element, options)
		})
	}

	function getMergeFunction(key, options) {
		if (!options.customMerge) {
			return deepmerge
		}
		var customMerge = options.customMerge(key);
		return typeof customMerge === 'function' ? customMerge : deepmerge
	}

	function getEnumerableOwnPropertySymbols(target) {
		return Object.getOwnPropertySymbols
			? Object.getOwnPropertySymbols(target).filter(function(symbol) {
				return target.propertyIsEnumerable(symbol)
			})
			: []
	}

	function getKeys(target) {
		return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
	}

	function mergeObject(target, source, options) {
		var destination = {};
		if (options.isMergeableObject(target)) {
			getKeys(target).forEach(function(key) {
				destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
			});
		}
		getKeys(source).forEach(function(key) {
			if (!options.isMergeableObject(source[key]) || !target[key]) {
				destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
			} else {
				destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
			}
		});
		return destination
	}

	function deepmerge(target, source, options) {
		options = options || {};
		options.arrayMerge = options.arrayMerge || defaultArrayMerge;
		options.isMergeableObject = options.isMergeableObject || isMergeableObject;

		var sourceIsArray = Array.isArray(source);
		var targetIsArray = Array.isArray(target);
		var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

		if (!sourceAndTargetTypesMatch) {
			return cloneUnlessOtherwiseSpecified(source, options)
		} else if (sourceIsArray) {
			return options.arrayMerge(target, source, options)
		} else {
			return mergeObject(target, source, options)
		}
	}

	deepmerge.all = function deepmergeAll(array, options) {
		if (!Array.isArray(array)) {
			throw new Error('first argument should be an array')
		}

		return array.reduce(function(prev, next) {
			return deepmerge(prev, next, options)
		}, {})
	};

	var deepmerge_1 = deepmerge;

	return deepmerge_1;

}));

},{}],16:[function(_dereq_,module,exports){
module.exports = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) return arguments[i];
    }
};

},{}],17:[function(_dereq_,module,exports){
var util = _dereq_('util')
var global = _dereq_('global')
var EventEmitter = _dereq_('events')

var makeDespot = function () {
  var Despot = function () {
    if (global._singletonDespotInstance) {
      return global._singletonDespotInstance
    } else {
      global._singletonDespotInstance = this
      EventEmitter.call(this)
    }
  }

  util.inherits(Despot, EventEmitter)

  return new Despot()
}

module.exports = makeDespot()

},{"events":23,"global":30,"util":81}],18:[function(_dereq_,module,exports){
'use strict'

var document = _dereq_('global/document')
var Event = _dereq_('geval')
var Keys = _dereq_('./keys')

module.exports = Visibility

function Visibility () {
  var keys = Keys(document)
  if (!keys) return noopShim()

  return {
    visible: visible,
    onChange: Event(listen)
  }

  function visible () {
    return !document[keys.hidden]
  }

  function listen (broadcast) {
    document.addEventListener(keys.event, function onVisibilityChange () {
      broadcast(visible())
    })
  }
}

function noopShim () {
  return {
    visible: function () {
      return true
    },
    onChange: noop
  }
}

function noop () {}

},{"./keys":19,"geval":28,"global/document":29}],19:[function(_dereq_,module,exports){
'use strict'

module.exports = keys

function keys (document) {
  var prefix = detectPrefix(document)
  if (prefix == null) return
  return {
    hidden: lowercaseFirst(prefix + 'Hidden'),
    event: prefix + 'visibilitychange'
  }
}

function detectPrefix (document) {
  if (document.hidden != null) return ''
  if (document.mozHidden != null) return 'moz'
  if (document.msHidden != null) return 'ms'
  if (document.webkitHidden != null) return 'webkit'
}

function lowercaseFirst (string) {
  return string.substring(0, 1).toLowerCase() + string.substring(1)
}

},{}],20:[function(_dereq_,module,exports){
(function (process,Buffer){
var stream = _dereq_('readable-stream')
var eos = _dereq_('end-of-stream')
var inherits = _dereq_('inherits')
var shift = _dereq_('stream-shift')

var SIGNAL_FLUSH = (Buffer.from && Buffer.from !== Uint8Array.from)
  ? Buffer.from([0])
  : new Buffer([0])

var onuncork = function(self, fn) {
  if (self._corked) self.once('uncork', fn)
  else fn()
}

var autoDestroy = function (self, err) {
  if (self._autoDestroy) self.destroy(err)
}

var destroyer = function(self, end) {
  return function(err) {
    if (err) autoDestroy(self, err.message === 'premature close' ? null : err)
    else if (end && !self._ended) self.end()
  }
}

var end = function(ws, fn) {
  if (!ws) return fn()
  if (ws._writableState && ws._writableState.finished) return fn()
  if (ws._writableState) return ws.end(fn)
  ws.end()
  fn()
}

var toStreams2 = function(rs) {
  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)
}

var Duplexify = function(writable, readable, opts) {
  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)
  stream.Duplex.call(this, opts)

  this._writable = null
  this._readable = null
  this._readable2 = null

  this._autoDestroy = !opts || opts.autoDestroy !== false
  this._forwardDestroy = !opts || opts.destroy !== false
  this._forwardEnd = !opts || opts.end !== false
  this._corked = 1 // start corked
  this._ondrain = null
  this._drained = false
  this._forwarding = false
  this._unwrite = null
  this._unread = null
  this._ended = false

  this.destroyed = false

  if (writable) this.setWritable(writable)
  if (readable) this.setReadable(readable)
}

inherits(Duplexify, stream.Duplex)

Duplexify.obj = function(writable, readable, opts) {
  if (!opts) opts = {}
  opts.objectMode = true
  opts.highWaterMark = 16
  return new Duplexify(writable, readable, opts)
}

Duplexify.prototype.cork = function() {
  if (++this._corked === 1) this.emit('cork')
}

Duplexify.prototype.uncork = function() {
  if (this._corked && --this._corked === 0) this.emit('uncork')
}

Duplexify.prototype.setWritable = function(writable) {
  if (this._unwrite) this._unwrite()

  if (this.destroyed) {
    if (writable && writable.destroy) writable.destroy()
    return
  }

  if (writable === null || writable === false) {
    this.end()
    return
  }

  var self = this
  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))

  var ondrain = function() {
    var ondrain = self._ondrain
    self._ondrain = null
    if (ondrain) ondrain()
  }

  var clear = function() {
    self._writable.removeListener('drain', ondrain)
    unend()
  }

  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks

  this._writable = writable
  this._writable.on('drain', ondrain)
  this._unwrite = clear

  this.uncork() // always uncork setWritable
}

Duplexify.prototype.setReadable = function(readable) {
  if (this._unread) this._unread()

  if (this.destroyed) {
    if (readable && readable.destroy) readable.destroy()
    return
  }

  if (readable === null || readable === false) {
    this.push(null)
    this.resume()
    return
  }

  var self = this
  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))

  var onreadable = function() {
    self._forward()
  }

  var onend = function() {
    self.push(null)
  }

  var clear = function() {
    self._readable2.removeListener('readable', onreadable)
    self._readable2.removeListener('end', onend)
    unend()
  }

  this._drained = true
  this._readable = readable
  this._readable2 = readable._readableState ? readable : toStreams2(readable)
  this._readable2.on('readable', onreadable)
  this._readable2.on('end', onend)
  this._unread = clear

  this._forward()
}

Duplexify.prototype._read = function() {
  this._drained = true
  this._forward()
}

Duplexify.prototype._forward = function() {
  if (this._forwarding || !this._readable2 || !this._drained) return
  this._forwarding = true

  var data

  while (this._drained && (data = shift(this._readable2)) !== null) {
    if (this.destroyed) continue
    this._drained = this.push(data)
  }

  this._forwarding = false
}

Duplexify.prototype.destroy = function(err) {
  if (this.destroyed) return
  this.destroyed = true

  var self = this
  process.nextTick(function() {
    self._destroy(err)
  })
}

Duplexify.prototype._destroy = function(err) {
  if (err) {
    var ondrain = this._ondrain
    this._ondrain = null
    if (ondrain) ondrain(err)
    else this.emit('error', err)
  }

  if (this._forwardDestroy) {
    if (this._readable && this._readable.destroy) this._readable.destroy()
    if (this._writable && this._writable.destroy) this._writable.destroy()
  }

  this.emit('close')
}

Duplexify.prototype._write = function(data, enc, cb) {
  if (this.destroyed) return cb()
  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))
  if (data === SIGNAL_FLUSH) return this._finish(cb)
  if (!this._writable) return cb()

  if (this._writable.write(data) === false) this._ondrain = cb
  else cb()
}

Duplexify.prototype._finish = function(cb) {
  var self = this
  this.emit('preend')
  onuncork(this, function() {
    end(self._forwardEnd && self._writable, function() {
      // haxx to not emit prefinish twice
      if (self._writableState.prefinished === false) self._writableState.prefinished = true
      self.emit('prefinish')
      onuncork(self, cb)
    })
  })
}

Duplexify.prototype.end = function(data, enc, cb) {
  if (typeof data === 'function') return this.end(null, null, data)
  if (typeof enc === 'function') return this.end(data, null, enc)
  this._ended = true
  if (data) this.write(data)
  if (!this._writableState.ending) this.write(SIGNAL_FLUSH)
  return stream.Writable.prototype.end.call(this, cb)
}

module.exports = Duplexify

}).call(this,_dereq_('_process'),_dereq_("buffer").Buffer)

},{"_process":50,"buffer":8,"end-of-stream":22,"inherits":36,"readable-stream":62,"stream-shift":68}],21:[function(_dereq_,module,exports){
'use strict';

function polyfill(window) {
  const ElementPrototype = window.Element.prototype;

  if (typeof ElementPrototype.matches !== 'function') {
    ElementPrototype.matches = ElementPrototype.msMatchesSelector || ElementPrototype.mozMatchesSelector || ElementPrototype.webkitMatchesSelector || function matches(selector) {
      let element = this;
      const elements = (element.document || element.ownerDocument).querySelectorAll(selector);
      let index = 0;

      while (elements[index] && elements[index] !== element) {
        ++index;
      }

      return Boolean(elements[index]);
    };
  }

  if (typeof ElementPrototype.closest !== 'function') {
    ElementPrototype.closest = function closest(selector) {
      let element = this;

      while (element && element.nodeType === 1) {
        if (element.matches(selector)) {
          return element;
        }

        element = element.parentNode;
      }

      return null;
    };
  }
}

module.exports = polyfill;


},{}],22:[function(_dereq_,module,exports){
var once = _dereq_('once');

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;

},{"once":47}],23:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],24:[function(_dereq_,module,exports){
module.exports = stringify
stringify.default = stringify
stringify.stable = deterministicStringify
stringify.stableStringify = deterministicStringify

var arr = []

// Regular stringify
function stringify (obj, replacer, spacer) {
  decirc(obj, '', [], undefined)
  var res = JSON.stringify(obj, replacer, spacer)
  while (arr.length !== 0) {
    var part = arr.pop()
    part[0][part[1]] = part[2]
  }
  return res
}
function decirc (val, k, stack, parent) {
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        parent[k] = '[Circular]'
        arr.push([parent, k, val])
        return
      }
    }
    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, stack, val)
      }
    } else {
      var keys = Object.keys(val)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        decirc(val[key], key, stack, val)
      }
    }
    stack.pop()
  }
}

// Stable-stringify
function compareFunction (a, b) {
  if (a < b) {
    return -1
  }
  if (a > b) {
    return 1
  }
  return 0
}

function deterministicStringify (obj, replacer, spacer) {
  var tmp = deterministicDecirc(obj, '', [], undefined) || obj
  var res = JSON.stringify(tmp, replacer, spacer)
  while (arr.length !== 0) {
    var part = arr.pop()
    part[0][part[1]] = part[2]
  }
  return res
}

function deterministicDecirc (val, k, stack, parent) {
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        parent[k] = '[Circular]'
        arr.push([parent, k, val])
        return
      }
    }
    if (typeof val.toJSON === 'function') {
      return
    }
    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, stack, val)
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {}
      var keys = Object.keys(val).sort(compareFunction)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        deterministicDecirc(val[key], key, stack, val)
        tmp[key] = val[key]
      }
      if (parent !== undefined) {
        arr.push([parent, k, val])
        parent[k] = tmp
      } else {
        return tmp
      }
    }
    stack.pop()
  }
}

},{}],25:[function(_dereq_,module,exports){
(function (global){
"use strict";

/**
 * filesize
 *
 * @copyright 2019 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 4.1.2
 */
(function (global) {
	var b = /^(b|B)$/,
	    symbol = {
		iec: {
			bits: ["b", "Kib", "Mib", "Gib", "Tib", "Pib", "Eib", "Zib", "Yib"],
			bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
		},
		jedec: {
			bits: ["b", "Kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Yb"],
			bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
		}
	},
	    fullform = {
		iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
		jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
	};

	/**
  * filesize
  *
  * @method filesize
  * @param  {Mixed}   arg        String, Int or Float to transform
  * @param  {Object}  descriptor [Optional] Flags
  * @return {String}             Readable file size String
  */
	function filesize(arg) {
		var descriptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		var result = [],
		    val = 0,
		    e = void 0,
		    base = void 0,
		    bits = void 0,
		    ceil = void 0,
		    full = void 0,
		    fullforms = void 0,
		    locale = void 0,
		    neg = void 0,
		    num = void 0,
		    output = void 0,
		    round = void 0,
		    unix = void 0,
		    separator = void 0,
		    spacer = void 0,
		    standard = void 0,
		    symbols = void 0;

		if (isNaN(arg)) {
			throw new TypeError("Invalid number");
		}

		bits = descriptor.bits === true;
		unix = descriptor.unix === true;
		base = descriptor.base || 2;
		round = descriptor.round !== void 0 ? descriptor.round : unix ? 1 : 2;
		locale = descriptor.locale !== void 0 ? descriptor.locale : "";
		separator = descriptor.separator !== void 0 ? descriptor.separator : "";
		spacer = descriptor.spacer !== void 0 ? descriptor.spacer : unix ? "" : " ";
		symbols = descriptor.symbols || {};
		standard = base === 2 ? descriptor.standard || "jedec" : "jedec";
		output = descriptor.output || "string";
		full = descriptor.fullform === true;
		fullforms = descriptor.fullforms instanceof Array ? descriptor.fullforms : [];
		e = descriptor.exponent !== void 0 ? descriptor.exponent : -1;
		num = Number(arg);
		neg = num < 0;
		ceil = base > 2 ? 1000 : 1024;

		// Flipping a negative number to determine the size
		if (neg) {
			num = -num;
		}

		// Determining the exponent
		if (e === -1 || isNaN(e)) {
			e = Math.floor(Math.log(num) / Math.log(ceil));

			if (e < 0) {
				e = 0;
			}
		}

		// Exceeding supported length, time to reduce & multiply
		if (e > 8) {
			e = 8;
		}

		if (output === "exponent") {
			return e;
		}

		// Zero is now a special case because bytes divide by 1
		if (num === 0) {
			result[0] = 0;
			result[1] = unix ? "" : symbol[standard][bits ? "bits" : "bytes"][e];
		} else {
			val = num / (base === 2 ? Math.pow(2, e * 10) : Math.pow(1000, e));

			if (bits) {
				val = val * 8;

				if (val >= ceil && e < 8) {
					val = val / ceil;
					e++;
				}
			}

			result[0] = Number(val.toFixed(e > 0 ? round : 0));
			result[1] = base === 10 && e === 1 ? bits ? "kb" : "kB" : symbol[standard][bits ? "bits" : "bytes"][e];

			if (unix) {
				result[1] = standard === "jedec" ? result[1].charAt(0) : e > 0 ? result[1].replace(/B$/, "") : result[1];

				if (b.test(result[1])) {
					result[0] = Math.floor(result[0]);
					result[1] = "";
				}
			}
		}

		// Decorating a 'diff'
		if (neg) {
			result[0] = -result[0];
		}

		// Applying custom symbol
		result[1] = symbols[result[1]] || result[1];

		if (locale === true) {
			result[0] = result[0].toLocaleString();
		} else if (locale.length > 0) {
			result[0] = result[0].toLocaleString(locale);
		} else if (separator.length > 0) {
			result[0] = result[0].toString().replace(".", separator);
		}

		// Returning Array, Object, or String (default)
		if (output === "array") {
			return result;
		}

		if (full) {
			result[1] = fullforms[e] ? fullforms[e] : fullform[standard][e] + (bits ? "bit" : "byte") + (result[0] === 1 ? "" : "s");
		}

		if (output === "object") {
			return { value: result[0], symbol: result[1] };
		}

		return result.join(spacer);
	}

	// Partial application for functional programming
	filesize.partial = function (opt) {
		return function (arg) {
			return filesize(arg, opt);
		};
	};

	// CommonJS, AMD, script tag
	if (typeof exports !== "undefined") {
		module.exports = filesize;
	} else if (typeof define === "function" && define.amd !== void 0) {
		define(function () {
			return filesize;
		});
	} else {
		global.filesize = filesize;
	}
})(typeof window !== "undefined" ? window : global);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],26:[function(_dereq_,module,exports){
'use strict';

exports.__esModule = true;
exports.default = getFormData;
exports.getFieldData = getFieldData;
var NODE_LIST_CLASSES = {
  '[object HTMLCollection]': true,
  '[object NodeList]': true,
  '[object RadioNodeList]': true

  // .type values for elements which can appear in .elements and should be ignored
};var IGNORED_ELEMENT_TYPES = {
  'button': true,
  'fieldset': true,
  'reset': true,
  'submit': true
};

var CHECKED_INPUT_TYPES = {
  'checkbox': true,
  'radio': true
};

var TRIM_RE = /^\s+|\s+$/g;

var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * @param {HTMLFormElement} form
 * @param {Object} options
 * @return {Object.<string,(string|Array.<string>)>} an object containing
 *   submittable value(s) held in the form's .elements collection, with
 *   properties named as per element names or ids.
 */

function getFormData(form) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { trim: false };

  if (!form) {
    throw new Error('A form is required by getFormData, was given form=' + form);
  }

  var data = {};
  var elementName = void 0;
  var elementNames = [];
  var elementNameLookup = {};

  // Get unique submittable element names for the form
  for (var i = 0, l = form.elements.length; i < l; i++) {
    var element = form.elements[i];
    if (IGNORED_ELEMENT_TYPES[element.type] || element.disabled) {
      continue;
    }
    elementName = element.name || element.id;
    if (elementName && !elementNameLookup[elementName]) {
      elementNames.push(elementName);
      elementNameLookup[elementName] = true;
    }
  }

  // Extract element data name-by-name for consistent handling of special cases
  // around elements which contain multiple inputs.
  for (var _i = 0, _l = elementNames.length; _i < _l; _i++) {
    elementName = elementNames[_i];
    var value = getFieldData(form, elementName, options);
    if (value != null) {
      data[elementName] = value;
    }
  }

  return data;
}

/**
 * @param {HTMLFormElement} form
 * @param {string} fieldName
 * @param {Object} options
 * @return {(string|Array.<string>)} submittable value(s) in the form for a
 *   named element from its .elements collection, or null if there was no
 *   element with that name or the element had no submittable value(s).
 */
function getFieldData(form, fieldName) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { trim: false };

  if (!form) {
    throw new Error('A form is required by getFieldData, was given form=' + form);
  }
  if (!fieldName && toString.call(fieldName) !== '[object String]') {
    throw new Error('A field name is required by getFieldData, was given fieldName=' + fieldName);
  }

  var element = form.elements[fieldName];
  if (!element || element.disabled) {
    return null;
  }

  if (!NODE_LIST_CLASSES[toString.call(element)]) {
    return getFormElementValue(element, options.trim);
  }

  // Deal with multiple form controls which have the same name
  var data = [];
  var allRadios = true;
  for (var i = 0, l = element.length; i < l; i++) {
    if (element[i].disabled) {
      continue;
    }
    if (allRadios && element[i].type !== 'radio') {
      allRadios = false;
    }
    var value = getFormElementValue(element[i], options.trim);
    if (value != null) {
      data = data.concat(value);
    }
  }

  // Special case for an element with multiple same-named inputs which were all
  // radio buttons: if there was a selected value, only return the value.
  if (allRadios && data.length === 1) {
    return data[0];
  }

  return data.length > 0 ? data : null;
}

/**
 * @param {HTMLElement} element a form element.
 * @param {booleam} trim should values for text entry inputs be trimmed?
 * @return {(string|Array.<string>|File|Array.<File>)} the element's submittable
 *   value(s), or null if it had none.
 */
function getFormElementValue(element, trim) {
  var value = null;
  var type = element.type;


  if (type === 'select-one') {
    if (element.options.length) {
      value = element.options[element.selectedIndex].value;
    }
    return value;
  }

  if (type === 'select-multiple') {
    value = [];
    for (var i = 0, l = element.options.length; i < l; i++) {
      if (element.options[i].selected) {
        value.push(element.options[i].value);
      }
    }
    if (value.length === 0) {
      value = null;
    }
    return value;
  }

  // If a file input doesn't have a files attribute, fall through to using its
  // value attribute.
  if (type === 'file' && 'files' in element) {
    if (element.multiple) {
      value = slice.call(element.files);
      if (value.length === 0) {
        value = null;
      }
    } else {
      // Should be null if not present, according to the spec
      value = element.files[0];
    }
    return value;
  }

  if (!CHECKED_INPUT_TYPES[type]) {
    value = trim ? element.value.replace(TRIM_RE, '') : element.value;
  } else if (element.checked) {
    value = element.value;
  }

  return value;
}

// For UMD build access to getFieldData
getFormData.getFieldData = getFieldData;
},{}],27:[function(_dereq_,module,exports){
module.exports = Event

function Event() {
    var listeners = []

    return { broadcast: broadcast, listen: event }

    function broadcast(value) {
        for (var i = 0; i < listeners.length; i++) {
            listeners[i](value)
        }
    }

    function event(listener) {
        listeners.push(listener)

        return removeListener

        function removeListener() {
            var index = listeners.indexOf(listener)
            if (index !== -1) {
                listeners.splice(index, 1)
            }
        }
    }
}

},{}],28:[function(_dereq_,module,exports){
var Event = _dereq_('./event.js')

module.exports = Source

function Source(broadcaster) {
    var tuple = Event()

    broadcaster(tuple.broadcast)

    return tuple.listen
}

},{"./event.js":27}],29:[function(_dereq_,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = _dereq_('min-document');

var doccy;

if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}

module.exports = doccy;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":6}],30:[function(_dereq_,module,exports){
(function (global){
var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],31:[function(_dereq_,module,exports){
module.exports = shim

function shim (element, value) {
    if (value === undefined) {
        return element.style.display === 'none'
    }

    element.style.display = value ? 'none' : ''
}

},{}],32:[function(_dereq_,module,exports){
// HumanizeDuration.js - https://git.io/j0HgmQ

;(function () {
  // This has to be defined separately because of a bug: we want to alias
  // `gr` and `el` for backwards-compatiblity. In a breaking change, we can
  // remove `gr` entirely.
  // See https://github.com/EvanHahn/HumanizeDuration.js/issues/143 for more.
  var greek = {
    y: function (c) { return c === 1 ? '' : '' },
    mo: function (c) { return c === 1 ? '' : '' },
    w: function (c) { return c === 1 ? '' : '' },
    d: function (c) { return c === 1 ? '' : '' },
    h: function (c) { return c === 1 ? '' : '' },
    m: function (c) { return c === 1 ? '' : '' },
    s: function (c) { return c === 1 ? '' : '' },
    ms: function (c) { return c === 1 ? '  ' : '  ' },
    decimal: ','
  }

  var languages = {
    ar: {
      y: function (c) { return c === 1 ? '' : '' },
      mo: function (c) { return c === 1 ? '' : '' },
      w: function (c) { return c === 1 ? '' : '' },
      d: function (c) { return c === 1 ? '' : '' },
      h: function (c) { return c === 1 ? '' : '' },
      m: function (c) {
        return ['', ''][getArabicForm(c)]
      },
      s: function (c) { return c === 1 ? '' : '' },
      ms: function (c) { return c === 1 ? '  ' : '  ' },
      decimal: ','
    },
    bg: {
      y: function (c) { return ['', '', ''][getSlavicForm(c)] },
      mo: function (c) { return ['', '', ''][getSlavicForm(c)] },
      w: function (c) { return ['', '', ''][getSlavicForm(c)] },
      d: function (c) { return ['', '', ''][getSlavicForm(c)] },
      h: function (c) { return ['', '', ''][getSlavicForm(c)] },
      m: function (c) { return ['', '', ''][getSlavicForm(c)] },
      s: function (c) { return ['', '', ''][getSlavicForm(c)] },
      ms: function (c) { return ['', '', ''][getSlavicForm(c)] },
      decimal: ','
    },
    ca: {
      y: function (c) { return 'any' + (c === 1 ? '' : 's') },
      mo: function (c) { return 'mes' + (c === 1 ? '' : 'os') },
      w: function (c) { return 'setman' + (c === 1 ? 'a' : 'es') },
      d: function (c) { return 'di' + (c === 1 ? 'a' : 'es') },
      h: function (c) { return 'hor' + (c === 1 ? 'a' : 'es') },
      m: function (c) { return 'minut' + (c === 1 ? '' : 's') },
      s: function (c) { return 'segon' + (c === 1 ? '' : 's') },
      ms: function (c) { return 'milisegon' + (c === 1 ? '' : 's') },
      decimal: ','
    },
    cs: {
      y: function (c) { return ['rok', 'roku', 'roky', 'let'][getCzechOrSlovakForm(c)] },
      mo: function (c) { return ['msc', 'msce', 'msce', 'msc'][getCzechOrSlovakForm(c)] },
      w: function (c) { return ['tden', 'tdne', 'tdny', 'tdn'][getCzechOrSlovakForm(c)] },
      d: function (c) { return ['den', 'dne', 'dny', 'dn'][getCzechOrSlovakForm(c)] },
      h: function (c) { return ['hodina', 'hodiny', 'hodiny', 'hodin'][getCzechOrSlovakForm(c)] },
      m: function (c) { return ['minuta', 'minuty', 'minuty', 'minut'][getCzechOrSlovakForm(c)] },
      s: function (c) { return ['sekunda', 'sekundy', 'sekundy', 'sekund'][getCzechOrSlovakForm(c)] },
      ms: function (c) { return ['milisekunda', 'milisekundy', 'milisekundy', 'milisekund'][getCzechOrSlovakForm(c)] },
      decimal: ','
    },
    da: {
      y: 'r',
      mo: function (c) { return 'mned' + (c === 1 ? '' : 'er') },
      w: function (c) { return 'uge' + (c === 1 ? '' : 'r') },
      d: function (c) { return 'dag' + (c === 1 ? '' : 'e') },
      h: function (c) { return 'time' + (c === 1 ? '' : 'r') },
      m: function (c) { return 'minut' + (c === 1 ? '' : 'ter') },
      s: function (c) { return 'sekund' + (c === 1 ? '' : 'er') },
      ms: function (c) { return 'millisekund' + (c === 1 ? '' : 'er') },
      decimal: ','
    },
    de: {
      y: function (c) { return 'Jahr' + (c === 1 ? '' : 'e') },
      mo: function (c) { return 'Monat' + (c === 1 ? '' : 'e') },
      w: function (c) { return 'Woche' + (c === 1 ? '' : 'n') },
      d: function (c) { return 'Tag' + (c === 1 ? '' : 'e') },
      h: function (c) { return 'Stunde' + (c === 1 ? '' : 'n') },
      m: function (c) { return 'Minute' + (c === 1 ? '' : 'n') },
      s: function (c) { return 'Sekunde' + (c === 1 ? '' : 'n') },
      ms: function (c) { return 'Millisekunde' + (c === 1 ? '' : 'n') },
      decimal: ','
    },
    el: greek,
    en: {
      y: function (c) { return 'year' + (c === 1 ? '' : 's') },
      mo: function (c) { return 'month' + (c === 1 ? '' : 's') },
      w: function (c) { return 'week' + (c === 1 ? '' : 's') },
      d: function (c) { return 'day' + (c === 1 ? '' : 's') },
      h: function (c) { return 'hour' + (c === 1 ? '' : 's') },
      m: function (c) { return 'minute' + (c === 1 ? '' : 's') },
      s: function (c) { return 'second' + (c === 1 ? '' : 's') },
      ms: function (c) { return 'millisecond' + (c === 1 ? '' : 's') },
      decimal: '.'
    },
    es: {
      y: function (c) { return 'ao' + (c === 1 ? '' : 's') },
      mo: function (c) { return 'mes' + (c === 1 ? '' : 'es') },
      w: function (c) { return 'semana' + (c === 1 ? '' : 's') },
      d: function (c) { return 'da' + (c === 1 ? '' : 's') },
      h: function (c) { return 'hora' + (c === 1 ? '' : 's') },
      m: function (c) { return 'minuto' + (c === 1 ? '' : 's') },
      s: function (c) { return 'segundo' + (c === 1 ? '' : 's') },
      ms: function (c) { return 'milisegundo' + (c === 1 ? '' : 's') },
      decimal: ','
    },
    fa: {
      y: '',
      mo: '',
      w: '',
      d: '',
      h: '',
      m: '',
      s: '',
      ms: ' ',
      decimal: '.'
    },
    fi: {
      y: function (c) { return c === 1 ? 'vuosi' : 'vuotta' },
      mo: function (c) { return c === 1 ? 'kuukausi' : 'kuukautta' },
      w: function (c) { return 'viikko' + (c === 1 ? '' : 'a') },
      d: function (c) { return 'piv' + (c === 1 ? '' : '') },
      h: function (c) { return 'tunti' + (c === 1 ? '' : 'a') },
      m: function (c) { return 'minuutti' + (c === 1 ? '' : 'a') },
      s: function (c) { return 'sekunti' + (c === 1 ? '' : 'a') },
      ms: function (c) { return 'millisekunti' + (c === 1 ? '' : 'a') },
      decimal: ','
    },
    fr: {
      y: function (c) { return 'an' + (c >= 2 ? 's' : '') },
      mo: 'mois',
      w: function (c) { return 'semaine' + (c >= 2 ? 's' : '') },
      d: function (c) { return 'jour' + (c >= 2 ? 's' : '') },
      h: function (c) { return 'heure' + (c >= 2 ? 's' : '') },
      m: function (c) { return 'minute' + (c >= 2 ? 's' : '') },
      s: function (c) { return 'seconde' + (c >= 2 ? 's' : '') },
      ms: function (c) { return 'milliseconde' + (c >= 2 ? 's' : '') },
      decimal: ','
    },
    gr: greek,
    hr: {
      y: function (c) {
        if (c % 10 === 2 || c % 10 === 3 || c % 10 === 4) {
          return 'godine'
        }
        return 'godina'
      },
      mo: function (c) {
        if (c === 1) {
          return 'mjesec'
        } else if (c === 2 || c === 3 || c === 4) {
          return 'mjeseca'
        }
        return 'mjeseci'
      },
      w: function (c) {
        if (c % 10 === 1 && c !== 11) {
          return 'tjedan'
        }
        return 'tjedna'
      },
      d: function (c) { return c === 1 ? 'dan' : 'dana' },
      h: function (c) {
        if (c === 1) {
          return 'sat'
        } else if (c === 2 || c === 3 || c === 4) {
          return 'sata'
        }
        return 'sati'
      },
      m: function (c) {
        var mod10 = c % 10
        if ((mod10 === 2 || mod10 === 3 || mod10 === 4) && (c < 10 || c > 14)) {
          return 'minute'
        }
        return 'minuta'
      },
      s: function (c) {
        if ((c === 10 || c === 11 || c === 12 || c === 13 || c === 14 || c === 16 || c === 17 || c === 18 || c === 19) || (c % 10 === 5)) {
          return 'sekundi'
        } else if (c % 10 === 1) {
          return 'sekunda'
        } else if (c % 10 === 2 || c % 10 === 3 || c % 10 === 4) {
          return 'sekunde'
        }
        return 'sekundi'
      },
      ms: function (c) {
        if (c === 1) {
          return 'milisekunda'
        } else if (c % 10 === 2 || c % 10 === 3 || c % 10 === 4) {
          return 'milisekunde'
        }
        return 'milisekundi'
      },
      decimal: ','
    },
    hu: {
      y: 'v',
      mo: 'hnap',
      w: 'ht',
      d: 'nap',
      h: 'ra',
      m: 'perc',
      s: 'msodperc',
      ms: 'ezredmsodperc',
      decimal: ','
    },
    id: {
      y: 'tahun',
      mo: 'bulan',
      w: 'minggu',
      d: 'hari',
      h: 'jam',
      m: 'menit',
      s: 'detik',
      ms: 'milidetik',
      decimal: '.'
    },
    is: {
      y: 'r',
      mo: function (c) { return 'mnu' + (c === 1 ? 'ur' : 'ir') },
      w: function (c) { return 'vik' + (c === 1 ? 'a' : 'ur') },
      d: function (c) { return 'dag' + (c === 1 ? 'ur' : 'ar') },
      h: function (c) { return 'klukkutm' + (c === 1 ? 'i' : 'ar') },
      m: function (c) { return 'mnt' + (c === 1 ? 'a' : 'ur') },
      s: function (c) { return 'seknd' + (c === 1 ? 'a' : 'ur') },
      ms: function (c) { return 'milliseknd' + (c === 1 ? 'a' : 'ur') },
      decimal: '.'
    },
    it: {
      y: function (c) { return 'ann' + (c === 1 ? 'o' : 'i') },
      mo: function (c) { return 'mes' + (c === 1 ? 'e' : 'i') },
      w: function (c) { return 'settiman' + (c === 1 ? 'a' : 'e') },
      d: function (c) { return 'giorn' + (c === 1 ? 'o' : 'i') },
      h: function (c) { return 'or' + (c === 1 ? 'a' : 'e') },
      m: function (c) { return 'minut' + (c === 1 ? 'o' : 'i') },
      s: function (c) { return 'second' + (c === 1 ? 'o' : 'i') },
      ms: function (c) { return 'millisecond' + (c === 1 ? 'o' : 'i') },
      decimal: ','
    },
    ja: {
      y: '',
      mo: '',
      w: '',
      d: '',
      h: '',
      m: '',
      s: '',
      ms: '',
      decimal: '.'
    },
    ko: {
      y: '',
      mo: '',
      w: '',
      d: '',
      h: '',
      m: '',
      s: '',
      ms: ' ',
      decimal: '.'
    },
    lo: {
      y: '',
      mo: '',
      w: '',
      d: '',
      h: '',
      m: '',
      s: '',
      ms: '',
      decimal: ','
    },
    lt: {
      y: function (c) { return ((c % 10 === 0) || (c % 100 >= 10 && c % 100 <= 20)) ? 'met' : 'metai' },
      mo: function (c) { return ['mnuo', 'mnesiai', 'mnesi'][getLithuanianForm(c)] },
      w: function (c) { return ['savait', 'savaits', 'savaii'][getLithuanianForm(c)] },
      d: function (c) { return ['diena', 'dienos', 'dien'][getLithuanianForm(c)] },
      h: function (c) { return ['valanda', 'valandos', 'valand'][getLithuanianForm(c)] },
      m: function (c) { return ['minut', 'minuts', 'minui'][getLithuanianForm(c)] },
      s: function (c) { return ['sekund', 'sekunds', 'sekundi'][getLithuanianForm(c)] },
      ms: function (c) { return ['milisekund', 'milisekunds', 'milisekundi'][getLithuanianForm(c)] },
      decimal: ','
    },
    ms: {
      y: 'tahun',
      mo: 'bulan',
      w: 'minggu',
      d: 'hari',
      h: 'jam',
      m: 'minit',
      s: 'saat',
      ms: 'milisaat',
      decimal: '.'
    },
    nl: {
      y: 'jaar',
      mo: function (c) { return c === 1 ? 'maand' : 'maanden' },
      w: function (c) { return c === 1 ? 'week' : 'weken' },
      d: function (c) { return c === 1 ? 'dag' : 'dagen' },
      h: 'uur',
      m: function (c) { return c === 1 ? 'minuut' : 'minuten' },
      s: function (c) { return c === 1 ? 'seconde' : 'seconden' },
      ms: function (c) { return c === 1 ? 'milliseconde' : 'milliseconden' },
      decimal: ','
    },
    no: {
      y: 'r',
      mo: function (c) { return 'mned' + (c === 1 ? '' : 'er') },
      w: function (c) { return 'uke' + (c === 1 ? '' : 'r') },
      d: function (c) { return 'dag' + (c === 1 ? '' : 'er') },
      h: function (c) { return 'time' + (c === 1 ? '' : 'r') },
      m: function (c) { return 'minutt' + (c === 1 ? '' : 'er') },
      s: function (c) { return 'sekund' + (c === 1 ? '' : 'er') },
      ms: function (c) { return 'millisekund' + (c === 1 ? '' : 'er') },
      decimal: ','
    },
    pl: {
      y: function (c) { return ['rok', 'roku', 'lata', 'lat'][getPolishForm(c)] },
      mo: function (c) { return ['miesic', 'miesica', 'miesice', 'miesicy'][getPolishForm(c)] },
      w: function (c) { return ['tydzie', 'tygodnia', 'tygodnie', 'tygodni'][getPolishForm(c)] },
      d: function (c) { return ['dzie', 'dnia', 'dni', 'dni'][getPolishForm(c)] },
      h: function (c) { return ['godzina', 'godziny', 'godziny', 'godzin'][getPolishForm(c)] },
      m: function (c) { return ['minuta', 'minuty', 'minuty', 'minut'][getPolishForm(c)] },
      s: function (c) { return ['sekunda', 'sekundy', 'sekundy', 'sekund'][getPolishForm(c)] },
      ms: function (c) { return ['milisekunda', 'milisekundy', 'milisekundy', 'milisekund'][getPolishForm(c)] },
      decimal: ','
    },
    pt: {
      y: function (c) { return 'ano' + (c === 1 ? '' : 's') },
      mo: function (c) { return c === 1 ? 'ms' : 'meses' },
      w: function (c) { return 'semana' + (c === 1 ? '' : 's') },
      d: function (c) { return 'dia' + (c === 1 ? '' : 's') },
      h: function (c) { return 'hora' + (c === 1 ? '' : 's') },
      m: function (c) { return 'minuto' + (c === 1 ? '' : 's') },
      s: function (c) { return 'segundo' + (c === 1 ? '' : 's') },
      ms: function (c) { return 'milissegundo' + (c === 1 ? '' : 's') },
      decimal: ','
    },
    ro: {
      y: function (c) { return c === 1 ? 'an' : 'ani' },
      mo: function (c) { return c === 1 ? 'lun' : 'luni' },
      w: function (c) { return c === 1 ? 'sptmn' : 'sptmni' },
      d: function (c) { return c === 1 ? 'zi' : 'zile' },
      h: function (c) { return c === 1 ? 'or' : 'ore' },
      m: function (c) { return c === 1 ? 'minut' : 'minute' },
      s: function (c) { return c === 1 ? 'secund' : 'secunde' },
      ms: function (c) { return c === 1 ? 'milisecund' : 'milisecunde' },
      decimal: ','
    },
    ru: {
      y: function (c) { return ['', '', ''][getSlavicForm(c)] },
      mo: function (c) { return ['', '', ''][getSlavicForm(c)] },
      w: function (c) { return ['', '', ''][getSlavicForm(c)] },
      d: function (c) { return ['', '', ''][getSlavicForm(c)] },
      h: function (c) { return ['', '', ''][getSlavicForm(c)] },
      m: function (c) { return ['', '', ''][getSlavicForm(c)] },
      s: function (c) { return ['', '', ''][getSlavicForm(c)] },
      ms: function (c) { return ['', '', ''][getSlavicForm(c)] },
      decimal: ','
    },
    uk: {
      y: function (c) { return ['', '', ''][getSlavicForm(c)] },
      mo: function (c) { return ['', '', ''][getSlavicForm(c)] },
      w: function (c) { return ['', '', ''][getSlavicForm(c)] },
      d: function (c) { return ['', '', ''][getSlavicForm(c)] },
      h: function (c) { return ['', '', ''][getSlavicForm(c)] },
      m: function (c) { return ['', '', ''][getSlavicForm(c)] },
      s: function (c) { return ['', '', ''][getSlavicForm(c)] },
      ms: function (c) { return ['', '', ''][getSlavicForm(c)] },
      decimal: ','
    },
    ur: {
      y: '',
      mo: function (c) { return c === 1 ? '' : '' },
      w: function (c) { return c === 1 ? '' : '' },
      d: '',
      h: function (c) { return c === 1 ? '' : '' },
      m: '',
      s: '',
      ms: ' ',
      decimal: '.'
    },
    sk: {
      y: function (c) { return ['rok', 'roky', 'roky', 'rokov'][getCzechOrSlovakForm(c)] },
      mo: function (c) { return ['mesiac', 'mesiace', 'mesiace', 'mesiacov'][getCzechOrSlovakForm(c)] },
      w: function (c) { return ['tde', 'tdne', 'tdne', 'tdov'][getCzechOrSlovakForm(c)] },
      d: function (c) { return ['de', 'dni', 'dni', 'dn'][getCzechOrSlovakForm(c)] },
      h: function (c) { return ['hodina', 'hodiny', 'hodiny', 'hodn'][getCzechOrSlovakForm(c)] },
      m: function (c) { return ['minta', 'minty', 'minty', 'mint'][getCzechOrSlovakForm(c)] },
      s: function (c) { return ['sekunda', 'sekundy', 'sekundy', 'seknd'][getCzechOrSlovakForm(c)] },
      ms: function (c) { return ['milisekunda', 'milisekundy', 'milisekundy', 'miliseknd'][getCzechOrSlovakForm(c)] },
      decimal: ','
    },
    sv: {
      y: 'r',
      mo: function (c) { return 'mnad' + (c === 1 ? '' : 'er') },
      w: function (c) { return 'veck' + (c === 1 ? 'a' : 'or') },
      d: function (c) { return 'dag' + (c === 1 ? '' : 'ar') },
      h: function (c) { return 'timm' + (c === 1 ? 'e' : 'ar') },
      m: function (c) { return 'minut' + (c === 1 ? '' : 'er') },
      s: function (c) { return 'sekund' + (c === 1 ? '' : 'er') },
      ms: function (c) { return 'millisekund' + (c === 1 ? '' : 'er') },
      decimal: ','
    },
    tr: {
      y: 'yl',
      mo: 'ay',
      w: 'hafta',
      d: 'gn',
      h: 'saat',
      m: 'dakika',
      s: 'saniye',
      ms: 'milisaniye',
      decimal: ','
    },
    th: {
      y: '',
      mo: '',
      w: '',
      d: '',
      h: '',
      m: '',
      s: '',
      ms: '',
      decimal: '.'
    },
    vi: {
      y: 'nm',
      mo: 'thng',
      w: 'tun',
      d: 'ngy',
      h: 'gi',
      m: 'pht',
      s: 'giy',
      ms: 'mili giy',
      decimal: ','
    },
    zh_CN: {
      y: '',
      mo: '',
      w: '',
      d: '',
      h: '',
      m: '',
      s: '',
      ms: '',
      decimal: '.'
    },
    zh_TW: {
      y: '',
      mo: '',
      w: '',
      d: '',
      h: '',
      m: '',
      s: '',
      ms: '',
      decimal: '.'
    }
  }

  // You can create a humanizer, which returns a function with default
  // parameters.
  function humanizer (passedOptions) {
    var result = function humanizer (ms, humanizerOptions) {
      var options = extend({}, result, humanizerOptions || {})
      return doHumanization(ms, options)
    }

    return extend(result, {
      language: 'en',
      delimiter: ', ',
      spacer: ' ',
      conjunction: '',
      serialComma: true,
      units: ['y', 'mo', 'w', 'd', 'h', 'm', 's'],
      languages: {},
      round: false,
      unitMeasures: {
        y: 31557600000,
        mo: 2629800000,
        w: 604800000,
        d: 86400000,
        h: 3600000,
        m: 60000,
        s: 1000,
        ms: 1
      }
    }, passedOptions)
  }

  // The main function is just a wrapper around a default humanizer.
  var humanizeDuration = humanizer({})

  // Build dictionary from options
  function getDictionary (options) {
    var languagesFromOptions = [options.language]

    if (options.hasOwnProperty('fallbacks')) {
      if (isArray(options.fallbacks) && options.fallbacks.length) {
        languagesFromOptions = languagesFromOptions.concat(options.fallbacks)
      } else {
        throw new Error('fallbacks must be an array with at least one element')
      }
    }

    for (var i = 0; i < languagesFromOptions.length; i++) {
      var languageToTry = languagesFromOptions[i]
      if (options.languages.hasOwnProperty(languageToTry)) {
        return options.languages[languageToTry]
      } else if (languages.hasOwnProperty(languageToTry)) {
        return languages[languageToTry]
      }
    }

    throw new Error('No language found.')
  }

  // doHumanization does the bulk of the work.
  function doHumanization (ms, options) {
    var i, len, piece

    // Make sure we have a positive number.
    // Has the nice sideffect of turning Number objects into primitives.
    ms = Math.abs(ms)

    var dictionary = getDictionary(options)
    var pieces = []

    // Start at the top and keep removing units, bit by bit.
    var unitName, unitMS, unitCount
    for (i = 0, len = options.units.length; i < len; i++) {
      unitName = options.units[i]
      unitMS = options.unitMeasures[unitName]

      // What's the number of full units we can fit?
      if (i + 1 === len) {
        if (options.hasOwnProperty('maxDecimalPoints')) {
          // We need to use this expValue to avoid rounding functionality of toFixed call
          var expValue = Math.pow(10, options.maxDecimalPoints)
          var unitCountFloat = (ms / unitMS)
          unitCount = parseFloat((Math.floor(expValue * unitCountFloat) / expValue).toFixed(options.maxDecimalPoints))
        } else {
          unitCount = ms / unitMS
        }
      } else {
        unitCount = Math.floor(ms / unitMS)
      }

      // Add the string.
      pieces.push({
        unitCount: unitCount,
        unitName: unitName
      })

      // Remove what we just figured out.
      ms -= unitCount * unitMS
    }

    var firstOccupiedUnitIndex = 0
    for (i = 0; i < pieces.length; i++) {
      if (pieces[i].unitCount) {
        firstOccupiedUnitIndex = i
        break
      }
    }

    if (options.round) {
      var ratioToLargerUnit, previousPiece
      for (i = pieces.length - 1; i >= 0; i--) {
        piece = pieces[i]
        piece.unitCount = Math.round(piece.unitCount)

        if (i === 0) { break }

        previousPiece = pieces[i - 1]

        ratioToLargerUnit = options.unitMeasures[previousPiece.unitName] / options.unitMeasures[piece.unitName]
        if ((piece.unitCount % ratioToLargerUnit) === 0 || (options.largest && ((options.largest - 1) < (i - firstOccupiedUnitIndex)))) {
          previousPiece.unitCount += piece.unitCount / ratioToLargerUnit
          piece.unitCount = 0
        }
      }
    }

    var result = []
    for (i = 0, pieces.length; i < len; i++) {
      piece = pieces[i]
      if (piece.unitCount) {
        result.push(render(piece.unitCount, piece.unitName, dictionary, options))
      }

      if (result.length === options.largest) { break }
    }

    if (result.length) {
      if (!options.conjunction || result.length === 1) {
        return result.join(options.delimiter)
      } else if (result.length === 2) {
        return result.join(options.conjunction)
      } else if (result.length > 2) {
        return result.slice(0, -1).join(options.delimiter) + (options.serialComma ? ',' : '') + options.conjunction + result.slice(-1)
      }
    } else {
      return render(0, options.units[options.units.length - 1], dictionary, options)
    }
  }

  function render (count, type, dictionary, options) {
    var decimal
    if (options.decimal === void 0) {
      decimal = dictionary.decimal
    } else {
      decimal = options.decimal
    }

    var countStr = count.toString().replace('.', decimal)

    var dictionaryValue = dictionary[type]
    var word
    if (typeof dictionaryValue === 'function') {
      word = dictionaryValue(count)
    } else {
      word = dictionaryValue
    }

    return countStr + options.spacer + word
  }

  function extend (destination) {
    var source
    for (var i = 1; i < arguments.length; i++) {
      source = arguments[i]
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          destination[prop] = source[prop]
        }
      }
    }
    return destination
  }

  // Internal helper function for Polish language.
  function getPolishForm (c) {
    if (c === 1) {
      return 0
    } else if (Math.floor(c) !== c) {
      return 1
    } else if (c % 10 >= 2 && c % 10 <= 4 && !(c % 100 > 10 && c % 100 < 20)) {
      return 2
    } else {
      return 3
    }
  }

  // Internal helper function for Russian and Ukranian languages.
  function getSlavicForm (c) {
    if (Math.floor(c) !== c) {
      return 2
    } else if ((c % 100 >= 5 && c % 100 <= 20) || (c % 10 >= 5 && c % 10 <= 9) || c % 10 === 0) {
      return 0
    } else if (c % 10 === 1) {
      return 1
    } else if (c > 1) {
      return 2
    } else {
      return 0
    }
  }

  // Internal helper function for Slovak language.
  function getCzechOrSlovakForm (c) {
    if (c === 1) {
      return 0
    } else if (Math.floor(c) !== c) {
      return 1
    } else if (c % 10 >= 2 && c % 10 <= 4 && c % 100 < 10) {
      return 2
    } else {
      return 3
    }
  }

  // Internal helper function for Lithuanian language.
  function getLithuanianForm (c) {
    if (c === 1 || (c % 10 === 1 && c % 100 > 20)) {
      return 0
    } else if (Math.floor(c) !== c || (c % 10 >= 2 && c % 100 > 20) || (c % 10 >= 2 && c % 100 < 10)) {
      return 1
    } else {
      return 2
    }
  }

  // Internal helper function for Arabic language.
  function getArabicForm (c) {
    if (c <= 2) { return 0 }
    if (c > 2 && c < 11) { return 1 }
    return 0
  }

  // We need to make sure we support browsers that don't have
  // `Array.isArray`, so we define a fallback here.
  var isArray = Array.isArray || function (arg) {
    return Object.prototype.toString.call(arg) === '[object Array]'
  }

  humanizeDuration.getSupportedLanguages = function getSupportedLanguages () {
    var result = []
    for (var language in languages) {
      if (languages.hasOwnProperty(language) && language !== 'gr') {
        result.push(language)
      }
    }
    return result
  }

  humanizeDuration.humanizer = humanizer

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return humanizeDuration
    })
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = humanizeDuration
  } else {
    this.humanizeDuration = humanizeDuration
  }
})(); // eslint-disable-line semi

},{}],33:[function(_dereq_,module,exports){
var split = _dereq_('browser-split')
var ClassList = _dereq_('class-list')

var w = typeof window === 'undefined' ? _dereq_('html-element') : window
var document = w.document
var Text = w.Text

function context () {

  var cleanupFuncs = []

  function h() {
    var args = [].slice.call(arguments), e = null
    function item (l) {
      var r
      function parseClass (string) {
        // Our minimal parser doesnt understand escaping CSS special
        // characters like `#`. Dont use them. More reading:
        // https://mathiasbynens.be/notes/css-escapes .

        var m = split(string, /([\.#]?[^\s#.]+)/)
        if(/^\.|#/.test(m[1]))
          e = document.createElement('div')
        forEach(m, function (v) {
          var s = v.substring(1,v.length)
          if(!v) return
          if(!e)
            e = document.createElement(v)
          else if (v[0] === '.')
            ClassList(e).add(s)
          else if (v[0] === '#')
            e.setAttribute('id', s)
        })
      }

      if(l == null)
        ;
      else if('string' === typeof l) {
        if(!e)
          parseClass(l)
        else
          e.appendChild(r = document.createTextNode(l))
      }
      else if('number' === typeof l
        || 'boolean' === typeof l
        || l instanceof Date
        || l instanceof RegExp ) {
          e.appendChild(r = document.createTextNode(l.toString()))
      }
      //there might be a better way to handle this...
      else if (isArray(l))
        forEach(l, item)
      else if(isNode(l))
        e.appendChild(r = l)
      else if(l instanceof Text)
        e.appendChild(r = l)
      else if ('object' === typeof l) {
        for (var k in l) {
          if('function' === typeof l[k]) {
            if(/^on\w+/.test(k)) {
              (function (k, l) { // capture k, l in the closure
                if (e.addEventListener){
                  e.addEventListener(k.substring(2), l[k], false)
                  cleanupFuncs.push(function(){
                    e.removeEventListener(k.substring(2), l[k], false)
                  })
                }else{
                  e.attachEvent(k, l[k])
                  cleanupFuncs.push(function(){
                    e.detachEvent(k, l[k])
                  })
                }
              })(k, l)
            } else {
              // observable
              e[k] = l[k]()
              cleanupFuncs.push(l[k](function (v) {
                e[k] = v
              }))
            }
          }
          else if(k === 'style') {
            if('string' === typeof l[k]) {
              e.style.cssText = l[k]
            }else{
              for (var s in l[k]) (function(s, v) {
                if('function' === typeof v) {
                  // observable
                  e.style.setProperty(s, v())
                  cleanupFuncs.push(v(function (val) {
                    e.style.setProperty(s, val)
                  }))
                } else
                  var match = l[k][s].match(/(.*)\W+!important\W*$/);
                  if (match) {
                    e.style.setProperty(s, match[1], 'important')
                  } else {
                    e.style.setProperty(s, l[k][s])
                  }
              })(s, l[k][s])
            }
          } else if(k === 'attrs') {
            for (var v in l[k]) {
              e.setAttribute(v, l[k][v])
            }
          }
          else if (k.substr(0, 5) === "data-") {
            e.setAttribute(k, l[k])
          } else {
            e[k] = l[k]
          }
        }
      } else if ('function' === typeof l) {
        //assume it's an observable!
        var v = l()
        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))

        cleanupFuncs.push(l(function (v) {
          if(isNode(v) && r.parentElement)
            r.parentElement.replaceChild(v, r), r = v
          else
            r.textContent = v
        }))
      }

      return r
    }
    while(args.length)
      item(args.shift())

    return e
  }

  h.cleanup = function () {
    for (var i = 0; i < cleanupFuncs.length; i++){
      cleanupFuncs[i]()
    }
    cleanupFuncs.length = 0
  }

  return h
}

var h = module.exports = context()
h.context = context

function isNode (el) {
  return el && el.nodeName && el.nodeType
}

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function isArray (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}



},{"browser-split":7,"class-list":10,"html-element":6}],34:[function(_dereq_,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],35:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],36:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],37:[function(_dereq_,module,exports){
var containers = []; // will store container HTMLElement references
var styleElements = []; // will store {prepend: HTMLElement, append: HTMLElement}

var usage = 'insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).';

function insertCss(css, options) {
    options = options || {};

    if (css === undefined) {
        throw new Error(usage);
    }

    var position = options.prepend === true ? 'prepend' : 'append';
    var container = options.container !== undefined ? options.container : document.querySelector('head');
    var containerId = containers.indexOf(container);

    // first time we see this container, create the necessary entries
    if (containerId === -1) {
        containerId = containers.push(container) - 1;
        styleElements[containerId] = {};
    }

    // try to get the correponding container + position styleElement, create it otherwise
    var styleElement;

    if (styleElements[containerId] !== undefined && styleElements[containerId][position] !== undefined) {
        styleElement = styleElements[containerId][position];
    } else {
        styleElement = styleElements[containerId][position] = createStyleElement();

        if (position === 'prepend') {
            container.insertBefore(styleElement, container.childNodes[0]);
        } else {
            container.appendChild(styleElement);
        }
    }

    // strip potential UTF-8 BOM if css was read from a file
    if (css.charCodeAt(0) === 0xFEFF) { css = css.substr(1, css.length); }

    // actually add the stylesheet
    if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText += css
    } else {
        styleElement.textContent += css;
    }

    return styleElement;
};

function createStyleElement() {
    var styleElement = document.createElement('style');
    styleElement.setAttribute('type', 'text/css');
    return styleElement;
}

module.exports = insertCss;
module.exports.insertCss = insertCss;

},{}],38:[function(_dereq_,module,exports){
/*! npm.im/intervalometer */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function intervalometer(cb, request, cancel, requestParameter) {
	var requestId;
	var previousLoopTime;
	function loop(now) {
		// must be requested before cb() because that might call .stop()
		requestId = request(loop, requestParameter);

		// called with "ms since last call". 0 on start()
		cb(now - (previousLoopTime || now));

		previousLoopTime = now;
	}
	return {
		start: function start() {
			if (!requestId) { // prevent double starts
				loop(0);
			}
		},
		stop: function stop() {
			cancel(requestId);
			requestId = null;
			previousLoopTime = 0;
		}
	};
}

function frameIntervalometer(cb) {
	return intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);
}

function timerIntervalometer(cb, delay) {
	return intervalometer(cb, setTimeout, clearTimeout, delay);
}

exports.intervalometer = intervalometer;
exports.frameIntervalometer = frameIntervalometer;
exports.timerIntervalometer = timerIntervalometer;
},{}],39:[function(_dereq_,module,exports){
/*! npm.im/iphone-inline-video 2.2.2 */
'use strict';

var intervalometer = _dereq_('intervalometer');

function preventEvent(element, eventName, test) {
	function handler(e) {
		if (!test || test(element, eventName)) {
			e.stopImmediatePropagation();
			// // console.log(eventName, 'prevented on', element);
		}
	}
	element.addEventListener(eventName, handler);

	// Return handler to allow to disable the prevention. Usage:
	// const preventionHandler = preventEvent(el, 'click');
	// el.removeEventHandler('click', preventionHandler);
	return handler;
}

function proxyProperty(object, propertyName, sourceObject, copyFirst) {
	function get() {
		return sourceObject[propertyName];
	}
	function set(value) {
		sourceObject[propertyName] = value;
	}

	if (copyFirst) {
		set(object[propertyName]);
	}

	Object.defineProperty(object, propertyName, {get: get, set: set});
}

function proxyEvent(object, eventName, sourceObject) {
	sourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });
}

function dispatchEventAsync(element, type) {
	Promise.resolve().then(function () {
		element.dispatchEvent(new Event(type));
	});
}

var iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;

var IIV = 'bfred-it:iphone-inline-video';
var IIVEvent = 'bfred-it:iphone-inline-video:event';
var IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';
var IIVPause = 'bfred-it:iphone-inline-video:nativepause';

/**
 * UTILS
 */

function getAudioFromVideo(video) {
	var audio = new Audio();
	proxyEvent(video, 'play', audio);
	proxyEvent(video, 'playing', audio);
	proxyEvent(video, 'pause', audio);
	audio.crossOrigin = video.crossOrigin;

	// 'data:' causes audio.networkState > 0
	// which then allows to keep <audio> in a resumable playing state
	// i.e. once you set a real src it will keep playing if it was if .play() was called
	audio.src = video.src || video.currentSrc || 'data:';

	// // if (audio.src === 'data:') {
	//   TODO: wait for video to be selected
	// // }
	return audio;
}

var lastRequests = [];
var requestIndex = 0;
var lastTimeupdateEvent;

function setTime(video, time, rememberOnly) {
	// Allow one timeupdate event every 200+ ms
	if ((lastTimeupdateEvent || 0) + 200 < Date.now()) {
		video[IIVEvent] = true;
		lastTimeupdateEvent = Date.now();
	}
	if (!rememberOnly) {
		video.currentTime = time;
	}
	lastRequests[++requestIndex % 3] = time * 100 | 0 / 100;
}

function isPlayerEnded(player) {
	return player.driver.currentTime >= player.video.duration;
}

function update(timeDiff) {
	var player = this;
	// // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);
	if (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {
		if (!player.hasAudio) {
			player.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);
			if (player.video.loop && isPlayerEnded(player)) {
				player.driver.currentTime = 0;
			}
		}
		setTime(player.video, player.driver.currentTime);
	} else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {
		// This should happen when the source is available but:
		// - it's potentially playing (.paused === false)
		// - it's not ready to play
		// - it's not loading
		// If it hasAudio, that will be loaded in the 'emptied' handler below
		player.video.load();
		// // console.log('Will load');
	}

	// // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');

	if (player.video.ended) {
		delete player.video[IIVEvent]; // Allow timeupdate event
		player.video.pause(true);
	}
}

/**
 * METHODS
 */

function play() {
	// // console.log('play');
	var video = this;
	var player = video[IIV];

	// If it's fullscreen, use the native player
	if (video.webkitDisplayingFullscreen) {
		video[IIVPlay]();
		return;
	}

	if (player.driver.src !== 'data:' && player.driver.src !== video.src) {
		// // console.log('src changed on play', video.src);
		setTime(video, 0, true);
		player.driver.src = video.src;
	}

	if (!video.paused) {
		return;
	}
	player.paused = false;

	if (video.buffered.length === 0) {
		// .load() causes the emptied event
		// the alternative is .play()+.pause() but that triggers play/pause events, even worse
		// possibly the alternative is preventing this event only once
		video.load();
	}

	player.driver.play();
	player.updater.start();

	if (!player.hasAudio) {
		dispatchEventAsync(video, 'play');
		if (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {
			// // console.log('onplay');
			dispatchEventAsync(video, 'playing');
		}
	}
}
function pause(forceEvents) {
	// // console.log('pause');
	var video = this;
	var player = video[IIV];

	player.driver.pause();
	player.updater.stop();

	// If it's fullscreen, the developer the native player.pause()
	// This is at the end of pause() because it also
	// needs to make sure that the simulation is paused
	if (video.webkitDisplayingFullscreen) {
		video[IIVPause]();
	}

	if (player.paused && !forceEvents) {
		return;
	}

	player.paused = true;
	if (!player.hasAudio) {
		dispatchEventAsync(video, 'pause');
	}

	// Handle the 'ended' event only if it's not fullscreen
	if (video.ended && !video.webkitDisplayingFullscreen) {
		video[IIVEvent] = true;
		dispatchEventAsync(video, 'ended');
	}
}

/**
 * SETUP
 */

function addPlayer(video, hasAudio) {
	var player = {};
	video[IIV] = player;
	player.paused = true; // Track whether 'pause' events have been fired
	player.hasAudio = hasAudio;
	player.video = video;
	player.updater = intervalometer.frameIntervalometer(update.bind(player));

	if (hasAudio) {
		player.driver = getAudioFromVideo(video);
	} else {
		video.addEventListener('canplay', function () {
			if (!video.paused) {
				// // console.log('oncanplay');
				dispatchEventAsync(video, 'playing');
			}
		});
		player.driver = {
			src: video.src || video.currentSrc || 'data:',
			muted: true,
			paused: true,
			pause: function () {
				player.driver.paused = true;
			},
			play: function () {
				player.driver.paused = false;
				// Media automatically goes to 0 if .play() is called when it's done
				if (isPlayerEnded(player)) {
					setTime(video, 0);
				}
			},
			get ended() {
				return isPlayerEnded(player);
			}
		};
	}

	// .load() causes the emptied event
	video.addEventListener('emptied', function () {
		// // console.log('driver src is', player.driver.src);
		var wasEmpty = !player.driver.src || player.driver.src === 'data:';
		if (player.driver.src && player.driver.src !== video.src) {
			// // console.log('src changed to', video.src);
			setTime(video, 0, true);
			player.driver.src = video.src;
			// Playing videos will only keep playing if no src was present when .play()ed
			if (wasEmpty || (!hasAudio && video.autoplay)) {
				player.driver.play();
			} else {
				player.updater.stop();
			}
		}
	}, false);

	// Stop programmatic player when OS takes over
	video.addEventListener('webkitbeginfullscreen', function () {
		if (!video.paused) {
			// Make sure that the <audio> and the syncer/updater are stopped
			video.pause();

			// Play video natively
			video[IIVPlay]();
		} else if (hasAudio && player.driver.buffered.length === 0) {
			// If the first play is native,
			// the <audio> needs to be buffered manually
			// so when the fullscreen ends, it can be set to the same current time
			player.driver.load();
		}
	});
	if (hasAudio) {
		video.addEventListener('webkitendfullscreen', function () {
			// Sync audio to new video position
			player.driver.currentTime = video.currentTime;
			// // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');
		});

		// Allow seeking
		video.addEventListener('seeking', function () {
			if (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {
				// // console.log('User-requested seeking');
				player.driver.currentTime = video.currentTime;
			}
		});
	}
}

function preventWithPropOrFullscreen(el) {
	var isAllowed = el[IIVEvent];
	delete el[IIVEvent];
	return !el.webkitDisplayingFullscreen && !isAllowed;
}

function overloadAPI(video) {
	var player = video[IIV];
	video[IIVPlay] = video.play;
	video[IIVPause] = video.pause;
	video.play = play;
	video.pause = pause;
	proxyProperty(video, 'paused', player.driver);
	proxyProperty(video, 'muted', player.driver, true);
	proxyProperty(video, 'playbackRate', player.driver, true);
	proxyProperty(video, 'ended', player.driver);
	proxyProperty(video, 'loop', player.driver, true);

	// IIV works by seeking 60 times per second.
	// These events are now useless.
	preventEvent(video, 'seeking', function (el) { return !el.webkitDisplayingFullscreen; });
	preventEvent(video, 'seeked', function (el) { return !el.webkitDisplayingFullscreen; });

	// Limit timeupdate events
	preventEvent(video, 'timeupdate', preventWithPropOrFullscreen);

	// Prevent occasional native ended events
	preventEvent(video, 'ended', preventWithPropOrFullscreen);
}

function enableInlineVideo(video, opts) {
	if ( opts === void 0 ) opts = {};

	// Stop if already enabled
	if (video[IIV]) {
		return;
	}

	// Allow the user to skip detection
	if (!opts.everywhere) {
		// Only iOS8 and 9 are supported
		if (!iOS8or9) {
			return;
		}

		// Stop if it's not an allowed device
		if (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {
			return;
		}
	}

	// Try to pause
	video.pause();

	// Prevent autoplay.
	// An non-started autoplaying video can't be .pause()'d
	var willAutoplay = video.autoplay;
	video.autoplay = false;

	addPlayer(video, !video.muted);
	overloadAPI(video);
	video.classList.add('IIV');

	// Autoplay
	if (video.muted && willAutoplay) {
		video.play();
		video.addEventListener('playing', function restoreAutoplay() {
			video.autoplay = true;
			video.removeEventListener('playing', restoreAutoplay);
		});
	}

	if (!/iPhone|iPod|iPad/.test(navigator.platform)) {
		console.warn('iphone-inline-video is not guaranteed to work in emulated environments');
	}
}

module.exports = enableInlineVideo;

},{"intervalometer":38}],40:[function(_dereq_,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],41:[function(_dereq_,module,exports){
'use strict';
var numberIsNan = _dereq_('number-is-nan');

module.exports = Number.isFinite || function (val) {
	return !(typeof val !== 'number' || numberIsNan(val) || val === Infinity || val === -Infinity);
};

},{"number-is-nan":46}],42:[function(_dereq_,module,exports){
module.exports = isPowerOfTwo

function isPowerOfTwo(n) {
  return n !== 0 && (n & (n - 1)) === 0
}
},{}],43:[function(_dereq_,module,exports){
module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}

},{}],44:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

"use strict";

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function(obj) {
  var ret = {};
  var key;
  if (!(obj instanceof Object && !Array.isArray(obj))) {
    throw new Error('keyMirror(...): Argument must be an object.');
  }
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;

},{}],45:[function(_dereq_,module,exports){
'use strict';
var numberIsFinite = _dereq_('is-finite');

module.exports = Number.isInteger || function (x) {
	return numberIsFinite(x) && Math.floor(x) === x;
};

},{"is-finite":41}],46:[function(_dereq_,module,exports){
'use strict';
module.exports = Number.isNaN || function (x) {
	return x !== x;
};

},{}],47:[function(_dereq_,module,exports){
var wrappy = _dereq_('wrappy')
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}

},{"wrappy":85}],48:[function(_dereq_,module,exports){
(function (process){
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);



}).call(this,_dereq_('_process'))

},{"_process":50}],49:[function(_dereq_,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,_dereq_('_process'))

},{"_process":50}],50:[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],51:[function(_dereq_,module,exports){
(function (global){
var now = _dereq_('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":48}],52:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = _dereq_('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Readable = _dereq_('./_stream_readable');
var Writable = _dereq_('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":54,"./_stream_writable":56,"core-util-is":13,"inherits":36,"process-nextick-args":49}],53:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = _dereq_('./_stream_transform');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":55,"core-util-is":13,"inherits":36}],54:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = _dereq_('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = _dereq_('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = _dereq_('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = _dereq_('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = _dereq_('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = _dereq_('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = _dereq_('./internal/streams/BufferList');
var destroyImpl = _dereq_('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":52,"./internal/streams/BufferList":57,"./internal/streams/destroy":58,"./internal/streams/stream":59,"_process":50,"core-util-is":13,"events":23,"inherits":36,"isarray":60,"process-nextick-args":49,"safe-buffer":66,"string_decoder/":61,"util":6}],55:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = _dereq_('./_stream_duplex');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":52,"core-util-is":13,"inherits":36}],56:[function(_dereq_,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = _dereq_('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: _dereq_('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = _dereq_('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = _dereq_('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = _dereq_('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},_dereq_("timers").setImmediate)

},{"./_stream_duplex":52,"./internal/streams/destroy":58,"./internal/streams/stream":59,"_process":50,"core-util-is":13,"inherits":36,"process-nextick-args":49,"safe-buffer":66,"timers":76,"util-deprecate":79}],57:[function(_dereq_,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = _dereq_('safe-buffer').Buffer;
var util = _dereq_('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":66,"util":6}],58:[function(_dereq_,module,exports){
'use strict';

/*<replacement>*/

var pna = _dereq_('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":49}],59:[function(_dereq_,module,exports){
module.exports = _dereq_('events').EventEmitter;

},{"events":23}],60:[function(_dereq_,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],61:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = _dereq_('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":66}],62:[function(_dereq_,module,exports){
exports = module.exports = _dereq_('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = _dereq_('./lib/_stream_writable.js');
exports.Duplex = _dereq_('./lib/_stream_duplex.js');
exports.Transform = _dereq_('./lib/_stream_transform.js');
exports.PassThrough = _dereq_('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":52,"./lib/_stream_passthrough.js":53,"./lib/_stream_readable.js":54,"./lib/_stream_transform.js":55,"./lib/_stream_writable.js":56}],63:[function(_dereq_,module,exports){
'use strict';

var readystate = module.exports = _dereq_('./readystate')
  , win = (new Function('return this'))()
  , complete = 'complete'
  , root = true
  , doc = win ? win.document : null
  , html = doc ? doc.documentElement : null
  , docReadyState = function () { return doc ? doc.readyState : null; };

(function wrapper() {
  //
  // Bail out early if the document is already fully loaded. This means that this
  // script is loaded after the onload event.
  //

  if (complete === docReadyState()) {
    return readystate.change(complete);
  }

  //
  // Use feature detection to see what kind of browser environment we're dealing
  // with. Old versions of Internet Explorer do not support the addEventListener
  // interface so we can also safely assume that we need to fall back to polling.
  //
  var modern = doc && !!doc.addEventListener
    , prefix = modern ? '' : 'on'
    , on = modern ? 'addEventListener' : 'attachEvent'
    , off = modern ? 'removeEventListener' : 'detachEvent'
    , doScroll = html ? html.doScroll : null;

  if (!modern && 'function' === typeof doScroll) {
    try { root = !win.frameElement; }
    catch (e) {}

    if (root) (function polling() {
      try { doScroll('left'); }
      catch (e) { return setTimeout(polling, 50); }

      readystate.change('interactive');
    }());
  }

  /**
   * Handle the various of event listener calls.
   *
   * @param {Event} evt Simple DOM event.
   * @api private
   */
  function change(evt) {
    evt = evt || win.event;

    if ('readystatechange' === evt.type) {
      readystate.change(docReadyState());
      if (complete !== docReadyState()) return;
    }

    if ('load' === evt.type) readystate.change('complete');
    else readystate.change('interactive');

    //
    // House keeping, remove our assigned event listeners.
    //
    (evt.type === 'load' ? win : doc)[off](evt.type, change, false);
  }

  //
  // Assign a shit load of event listeners so we can update our internal state.
  //
  doc[on](prefix +'DOMContentLoaded', change, false);
  doc[on](prefix +'readystatechange', change, false);
  win[on](prefix +'load', change, false);
} ());

},{"./readystate":64}],64:[function(_dereq_,module,exports){
'use strict';

/**
 * Generate a new prototype method which will the given function once the
 * desired state has been reached. The returned function accepts 2 arguments:
 *
 * - fn: The assigned function which needs to be called.
 * - context: Context/this value of the function we need to execute.
 *
 * @param {String} state The state we need to operate upon.
 * @returns {Function}
 * @api private
 */
function generate(state) {
  return function proxy(fn, context) {
    var rs = this;

    if (rs.is(state)) {
      setTimeout(function () {
        fn.call(context, rs.readyState);
      }, 0);
    } else {
      if (!rs._events[state]) rs._events[state] = [];
      rs._events[state].push({ fn: fn, context: context });
    }

    return rs;
  };
}

/**
 * RS (readyState) instance.
 *
 * @constructor
 * @api public
 */
function RS() {
  this.readyState = RS.UNKNOWN;
  this._events = {};
}

/**
 * The environment can be in different states. The following states are
 * generated:
 *
 * - ALL:         The I don't really give a fuck state.
 * - UNKNOWN:     We got an unknown readyState we should start listening for events.
 * - LOADING:     Environment is currently loading.
 * - INTERACTIVE: Environment is ready for modification.
 * - COMPLETE:    All resources have been loaded.
 *
 * Please note that the order of the `states` string/array is of vital
 * importance as it's used in the readyState check.
 *
 * @type {Number}
 * @private
 */
RS.states = 'ALL,UNKNOWN,LOADING,INTERACTIVE,COMPLETE'.split(',');

for (var s = 0, state; s < RS.states.length; s++) {
  state = RS.states[s];

  RS[state] = RS.prototype[state] = s;
  RS.prototype[state.toLowerCase()] = generate(state);
}

/**
 * A change in the environment has been detected so we need to change our
 * readyState and call assigned event listeners and those of the previous
 * states.
 *
 * @param {Number} state The new readyState that we detected.
 * @returns {RS}
 * @api private
 */
RS.prototype.change = function change(state) {
  state = this.clean(state, true);

  var j
    , name
    , i = 0
    , listener
    , rs = this
    , previously = rs.readyState;

  if (previously >= state) return rs;

  rs.readyState = state;

  for (; i < RS.states.length; i++) {
    if (i > state) break;
    name = RS.states[i];

    if (name in rs._events) {
      for (j = 0; j < rs._events[name].length; j++) {
        listener = rs._events[name][j];
        listener.fn.call(listener.context || rs, previously);
      }

      delete rs._events[name];
    }
  }

  return rs;
};

/**
 * Check if we're currently in a given readyState.
 *
 * @param {String|Number} state The required readyState.
 * @returns {Boolean} Indication if this state has been reached.
 * @api public
 */
RS.prototype.is = function is(state) {
  return this.readyState >= this.clean(state, true);
};

/**
 * Transform a state to a number or toUpperCase.
 *
 * @param {Mixed} state State to transform.
 * @param {Boolean} nr Change to number.
 * @returns {Mixed}
 * @api public
 */
RS.prototype.clean = function transform(state, nr) {
  var type = typeof state;

  if (nr) return 'number' !== type
  ? +RS[state.toUpperCase()] || 0
  : state;

  return ('number' === type ? RS.states[state] : state).toUpperCase();
};

/**
 * Removes all event listeners. Useful when you want to unload readystatechange
 * completely so that it won't react to any events anymore. See
 * https://github.com/unshiftio/readystate/issues/8
 *
 * @returns {Function} rs so that calls can be chained.
 * @api public
 */
RS.prototype.removeAllListeners = function removeAllListeners() {
  this._events = {};
  return this;
}

//
// Expose the module.
//
module.exports = new RS();

},{}],65:[function(_dereq_,module,exports){
/**
 * request-frame - requestAnimationFrame & cancelAnimationFrame polyfill for optimal cross-browser development.
 * @version v1.5.3
 * @license MIT
 * Copyright Julien Etienne 2015 All Rights Reserved.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.requestFrame = factory());
}(this, (function () { 'use strict';

/**
 * @param  {String} type - request | cancel | native.
 * @return {Function} Timing function.
 */
function requestFrame(type) {
    // The only vendor prefixes required.
    var vendors = ['moz', 'webkit'];

    // Disassembled timing function abbreviations.
    var aF = 'AnimationFrame';
    var rqAF = 'Request' + aF;

    // Checks for firefox 4 - 10 function pair mismatch.
    var mozRAF = window.mozRequestAnimationFrame;
    var mozCAF = window.mozCancelAnimationFrame;
    var hasMozMismatch = mozRAF && !mozCAF;

    // Final assigned functions.
    var assignedRequestAnimationFrame;
    var assignedCancelAnimationFrame;

    // Initial time of the timing lapse.
    var previousTime = 0;

    var requestFrameMain;

    // Date.now polyfill, mainly for legacy IE versions.
    if (!Date.now) {
        Date.now = function () {
            return new Date().getTime();
        };
    }

    /**
     * hasIOS6RequestAnimationFrameBug.
     * @See {@Link https://gist.github.com/julienetie/86ac394ec41f1271ff0a}
     * - for Commentary.
     * @Copyright 2015 - Julien Etienne. 
     * @License: MIT.
     */
    function hasIOS6RequestAnimationFrameBug() {
        var webkitRAF = window.webkitRequestAnimationFrame;
        var rAF = window.requestAnimationFrame;

        // CSS/ Device with max for iOS6 Devices.
        var hasMobileDeviceWidth = screen.width <= 768 ? true : false;

        // Only supports webkit prefixed requestAnimtionFrane.
        var requiresWebkitprefix = !(webkitRAF && rAF);

        // iOS6 webkit browsers don't support performance now.
        var hasNoNavigationTiming = window.performance ? false : true;

        var iOS6Notice = 'setTimeout is being used as a substitiue for \n            requestAnimationFrame due to a bug within iOS 6 builds';

        var hasIOS6Bug = requiresWebkitprefix && hasMobileDeviceWidth && hasNoNavigationTiming;

        var bugCheckresults = function bugCheckresults(timingFnA, timingFnB, notice) {
            if (timingFnA || timingFnB) {
                console.warn(notice);
                return true;
            } else {
                return false;
            }
        };

        var displayResults = function displayResults(hasBug, hasBugNotice, webkitFn, nativeFn) {
            if (hasBug) {
                return bugCheckresults(webkitFn, nativeFn, hasBugNotice);
            } else {
                return false;
            }
        };

        return displayResults(hasIOS6Bug, iOS6Notice, webkitRAF, rAF);
    }

    /**
     * Native clearTimeout function.
     * @return {Function}
     */
    function clearTimeoutWithId(id) {
        clearTimeout(id);
    }

    /**
     * Based on a polyfill by Erik, introduced by Paul Irish & 
     * further improved by Darius Bacon.
     * @see  {@link http://www.paulirish.com/2011/
     * requestanimationframe-for-smart-animating}
     * @see  {@link https://github.com/darius/requestAnimationFrame/blob/
     * master/requestAnimationFrame.js}
     * @callback {Number} Timestamp.
     * @return {Function} setTimeout Function.
     */
    function setTimeoutWithTimestamp(callback) {
        var immediateTime = Date.now();
        var lapsedTime = Math.max(previousTime + 16, immediateTime);
        return setTimeout(function () {
            callback(previousTime = lapsedTime);
        }, lapsedTime - immediateTime);
    }

    /**
     * Queries the native function, prefixed function 
     * or use the setTimeoutWithTimestamp function.
     * @return {Function}
     */
    function queryRequestAnimationFrame() {
        if (Array.prototype.filter) {
            assignedRequestAnimationFrame = window['request' + aF] || window[vendors.filter(function (vendor) {
                if (window[vendor + rqAF] !== undefined) return vendor;
            }) + rqAF] || setTimeoutWithTimestamp;
        } else {
            return setTimeoutWithTimestamp;
        }
        if (!hasIOS6RequestAnimationFrameBug()) {
            return assignedRequestAnimationFrame;
        } else {
            return setTimeoutWithTimestamp;
        }
    }

    /**
     * Queries the native function, prefixed function 
     * or use the clearTimeoutWithId function.
     * @return {Function}
     */
    function queryCancelAnimationFrame() {
        var cancellationNames = [];
        if (Array.prototype.map) {
            vendors.map(function (vendor) {
                return ['Cancel', 'CancelRequest'].map(function (cancellationNamePrefix) {
                    cancellationNames.push(vendor + cancellationNamePrefix + aF);
                });
            });
        } else {
            return clearTimeoutWithId;
        }

        /**
         * Checks for the prefixed cancelAnimationFrame implementation.
         * @param  {Array} prefixedNames - An array of the prefixed names. 
         * @param  {Number} i - Iteration start point.
         * @return {Function} prefixed cancelAnimationFrame function.
         */
        function prefixedCancelAnimationFrame(prefixedNames, i) {
            var cancellationFunction = void 0;
            for (; i < prefixedNames.length; i++) {
                if (window[prefixedNames[i]]) {
                    cancellationFunction = window[prefixedNames[i]];
                    break;
                }
            }
            return cancellationFunction;
        }

        // Use truthly function
        assignedCancelAnimationFrame = window['cancel' + aF] || prefixedCancelAnimationFrame(cancellationNames, 0) || clearTimeoutWithId;

        // Check for iOS 6 bug
        if (!hasIOS6RequestAnimationFrameBug()) {
            return assignedCancelAnimationFrame;
        } else {
            return clearTimeoutWithId;
        }
    }

    function getRequestFn() {
        if (hasMozMismatch) {
            return setTimeoutWithTimestamp;
        } else {
            return queryRequestAnimationFrame();
        }
    }

    function getCancelFn() {
        return queryCancelAnimationFrame();
    }

    function setNativeFn() {
        if (hasMozMismatch) {
            window.requestAnimationFrame = setTimeoutWithTimestamp;
            window.cancelAnimationFrame = clearTimeoutWithId;
        } else {
            window.requestAnimationFrame = queryRequestAnimationFrame();
            window.cancelAnimationFrame = queryCancelAnimationFrame();
        }
    }

    /**
     * The type value "request" singles out firefox 4 - 10 and 
     * assigns the setTimeout function if plausible.
     */

    switch (type) {
        case 'request':
        case '':
            requestFrameMain = getRequestFn();
            break;

        case 'cancel':
            requestFrameMain = getCancelFn();
            break;

        case 'native':
            setNativeFn();
            break;
        default:
            throw new Error('RequestFrame parameter is not a type.');
    }
    return requestFrameMain;
}

return requestFrame;

})));

},{}],66:[function(_dereq_,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = _dereq_('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":8}],67:[function(_dereq_,module,exports){
var hasProp = Object.prototype.hasOwnProperty;

function throwsMessage(err) {
	return '[Throws: ' + (err ? err.message : '?') + ']';
}

function safeGetValueFromPropertyOnObject(obj, property) {
	if (hasProp.call(obj, property)) {
		try {
			return obj[property];
		}
		catch (err) {
			return throwsMessage(err);
		}
	}

	return obj[property];
}

function ensureProperties(obj) {
	var seen = [ ]; // store references to objects we have seen before

	function visit(obj) {
		if (obj === null || typeof obj !== 'object') {
			return obj;
		}

		if (seen.indexOf(obj) !== -1) {
			return '[Circular]';
		}
		seen.push(obj);

		if (typeof obj.toJSON === 'function') {
			try {
				var fResult = visit(obj.toJSON());
				seen.pop();
				return fResult;
			} catch(err) {
				return throwsMessage(err);
			}
		}

		if (Array.isArray(obj)) {
			var aResult = obj.map(visit);
			seen.pop();
			return aResult;
		}

		var result = Object.keys(obj).reduce(function(result, prop) {
			// prevent faulty defined getter properties
			result[prop] = visit(safeGetValueFromPropertyOnObject(obj, prop));
			return result;
		}, {});
		seen.pop();
		return result;
	};

	return visit(obj);
}

module.exports = function(data, replacer, space) {
	return JSON.stringify(ensureProperties(data), replacer, space);
}

module.exports.ensureProperties = ensureProperties;

},{}],68:[function(_dereq_,module,exports){
module.exports = shift

function shift (stream) {
  var rs = stream._readableState
  if (!rs) return null
  return rs.objectMode ? stream.read() : stream.read(getStateLength(rs))
}

function getStateLength (state) {
  if (state.buffer.length) {
    // Since node 6.3.0 state.buffer is a BufferList not an array
    if (state.buffer.head) {
      return state.buffer.head.data.length
    }

    return state.buffer[0].length
  }

  return state.length
}

},{}],69:[function(_dereq_,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function Agent() {
  this._defaults = [];
}

['use', 'on', 'once', 'set', 'query', 'type', 'accept', 'auth', 'withCredentials', 'sortQuery', 'retry', 'ok', 'redirects', 'timeout', 'buffer', 'serialize', 'parse', 'ca', 'key', 'pfx', 'cert'].forEach(function (fn) {
  // Default setting for all requests from this agent
  Agent.prototype[fn] = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this._defaults.push({
      fn: fn,
      args: args
    });

    return this;
  };
});

Agent.prototype._setDefaults = function (req) {
  this._defaults.forEach(function (def) {
    req[def.fn].apply(req, _toConsumableArray(def.args));
  });
};

module.exports = Agent;
},{}],70:[function(_dereq_,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Root reference for iframes.
 */
var root;

if (typeof window !== 'undefined') {
  // Browser window
  root = window;
} else if (typeof self === 'undefined') {
  // Other environments
  console.warn('Using browser-only version of superagent in non-browser environment');
  root = void 0;
} else {
  // Web Worker
  root = self;
}

var Emitter = _dereq_('component-emitter');

var safeStringify = _dereq_('fast-safe-stringify');

var RequestBase = _dereq_('./request-base');

var isObject = _dereq_('./is-object');

var ResponseBase = _dereq_('./response-base');

var Agent = _dereq_('./agent-base');
/**
 * Noop.
 */


function noop() {}
/**
 * Expose `request`.
 */


module.exports = function (method, url) {
  // callback
  if (typeof url === 'function') {
    return new exports.Request('GET', method).end(url);
  } // url first


  if (arguments.length === 1) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports = module.exports;
var request = exports;
exports.Request = Request;
/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest && (!root.location || root.location.protocol !== 'file:' || !root.ActiveXObject)) {
    return new XMLHttpRequest();
  }

  try {
    return new ActiveXObject('Microsoft.XMLHTTP');
  } catch (err) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP.6.0');
  } catch (err) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP.3.0');
  } catch (err) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP');
  } catch (err) {}

  throw new Error('Browser-only version of superagent could not find XHR');
};
/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */


var trim = ''.trim ? function (s) {
  return s.trim();
} : function (s) {
  return s.replace(/(^\s*|\s*$)/g, '');
};
/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) pushEncodedKeyValuePair(pairs, key, obj[key]);
  }

  return pairs.join('&');
}
/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */


function pushEncodedKeyValuePair(pairs, key, val) {
  if (val === undefined) return;

  if (val === null) {
    pairs.push(encodeURIComponent(key));
    return;
  }

  if (Array.isArray(val)) {
    val.forEach(function (v) {
      pushEncodedKeyValuePair(pairs, key, v);
    });
  } else if (isObject(val)) {
    for (var subkey in val) {
      if (Object.prototype.hasOwnProperty.call(val, subkey)) pushEncodedKeyValuePair(pairs, "".concat(key, "[").concat(subkey, "]"), val[subkey]);
    }
  } else {
    pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
  }
}
/**
 * Expose serialization method.
 */


request.serializeObject = serialize;
/**
 * Parse the given x-www-form-urlencoded `str`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');

    if (pos === -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}
/**
 * Expose parser.
 */


request.parseString = parseString;
/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  form: 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};
/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': safeStringify
};
/**
 * Default parsers.
 *
 *     superagent.parse['application/xml'] = function(str){
 *       return { object parsed from str };
 *     };
 *
 */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};
/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');

    if (index === -1) {
      // could be empty line, just skip it
      continue;
    }

    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}
/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */


function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[/+]json($|[^-\w])/.test(mime);
}
/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */


function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr; // responseText is accessible only if responseType is '' or 'text' and on older browsers

  this.text = this.req.method !== 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status; // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request

  if (status === 1223) {
    status = 204;
  }

  this._setStatusProperties(status);

  this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  this.header = this.headers; // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.

  this.header['content-type'] = this.xhr.getResponseHeader('content-type');

  this._setHeaderProperties(this.header);

  if (this.text === null && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method === 'HEAD' ? null : this._parseBody(this.text ? this.text : this.xhr.response);
  }
} // eslint-disable-next-line new-cap


ResponseBase(Response.prototype);
/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function (str) {
  var parse = request.parse[this.type];

  if (this.req._parser) {
    return this.req._parser(this, str);
  }

  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }

  return parse && str && (str.length > 0 || str instanceof Object) ? parse(str) : null;
};
/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */


Response.prototype.toError = function () {
  var req = this.req;
  var method = req.method;
  var url = req.url;
  var msg = "cannot ".concat(method, " ").concat(url, " (").concat(this.status, ")");
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;
  return err;
};
/**
 * Expose `Response`.
 */


request.Response = Response;
/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case

  this._header = {}; // coerces header names to lowercase

  this.on('end', function () {
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch (err2) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = err2; // issue #675: return the raw response if the response parsing fails

      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType === 'undefined' ? self.xhr.responseText : self.xhr.response; // issue #876: return the http status code if the response parsing fails

        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);
    var new_err;

    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch (err2) {
      new_err = err2; // ok() callback can throw
    } // #1000 don't catch errors from the callback to avoid double calling it


    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}
/**
 * Mixin `Emitter` and `RequestBase`.
 */
// eslint-disable-next-line new-cap


Emitter(Request.prototype); // eslint-disable-next-line new-cap

RequestBase(Request.prototype);
/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function (type) {
  this.set('Content-Type', request.types[type] || type);
  return this;
};
/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.accept = function (type) {
  this.set('Accept', request.types[type] || type);
  return this;
};
/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.auth = function (user, pass, options) {
  if (arguments.length === 1) pass = '';

  if (_typeof(pass) === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }

  if (!options) {
    options = {
      type: typeof btoa === 'function' ? 'basic' : 'auto'
    };
  }

  var encoder = function encoder(string) {
    if (typeof btoa === 'function') {
      return btoa(string);
    }

    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};
/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.query = function (val) {
  if (typeof val !== 'string') val = serialize(val);
  if (val) this._query.push(val);
  return this;
};
/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw new Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }

  return this;
};

Request.prototype._getFormData = function () {
  if (!this._formData) {
    this._formData = new root.FormData();
  }

  return this._formData;
};
/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */


Request.prototype.callback = function (err, res) {
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};
/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */


Request.prototype.crossDomainError = function () {
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;
  err.status = this.status;
  err.method = this.method;
  err.url = this.url;
  this.callback(err);
}; // This only warns, because the request is still likely to work


Request.prototype.agent = function () {
  console.warn('This is not supported in browser version of superagent');
  return this;
};

Request.prototype.buffer = Request.prototype.ca;
Request.prototype.ca = Request.prototype.agent; // This throws, because it can't send/receive data as expected

Request.prototype.write = function () {
  throw new Error('Streaming is not supported in browser version of superagent');
};

Request.prototype.pipe = Request.prototype.write;
/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj host object
 * @return {Boolean} is a host object
 * @api private
 */

Request.prototype._isHost = function (obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && _typeof(obj) === 'object' && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
};
/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.end = function (fn) {
  if (this._endCalled) {
    console.warn('Warning: .end() was called twice. This is not supported in superagent');
  }

  this._endCalled = true; // store callback

  this._callback = fn || noop; // querystring

  this._finalizeQueryString();

  this._end();
};

Request.prototype._setUploadTimeout = function () {
  var self = this; // upload timeout it's wokrs only if deadline timeout is off

  if (this._uploadTimeout && !this._uploadTimeoutTimer) {
    this._uploadTimeoutTimer = setTimeout(function () {
      self._timeoutError('Upload timeout of ', self._uploadTimeout, 'ETIMEDOUT');
    }, this._uploadTimeout);
  }
}; // eslint-disable-next-line complexity


Request.prototype._end = function () {
  if (this._aborted) return this.callback(new Error('The request has been aborted even before .end() was called'));
  var self = this;
  this.xhr = request.getXHR();
  var xhr = this.xhr;
  var data = this._formData || this._data;

  this._setTimeouts(); // state change


  xhr.onreadystatechange = function () {
    var readyState = xhr.readyState;

    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }

    if (readyState !== 4) {
      return;
    } // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"


    var status;

    try {
      status = xhr.status;
    } catch (err) {
      status = 0;
    }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }

    self.emit('end');
  }; // progress


  var handleProgress = function handleProgress(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;

      if (e.percent === 100) {
        clearTimeout(self._uploadTimeoutTimer);
      }
    }

    e.direction = direction;
    self.emit('progress', e);
  };

  if (this.hasListeners('progress')) {
    try {
      xhr.addEventListener('progress', handleProgress.bind(null, 'download'));

      if (xhr.upload) {
        xhr.upload.addEventListener('progress', handleProgress.bind(null, 'upload'));
      }
    } catch (err) {// Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  if (xhr.upload) {
    this._setUploadTimeout();
  } // initiate request


  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  } // CORS


  if (this._withCredentials) xhr.withCredentials = true; // body

  if (!this._formData && this.method !== 'GET' && this.method !== 'HEAD' && typeof data !== 'string' && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];

    var _serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];

    if (!_serialize && isJSON(contentType)) {
      _serialize = request.serialize['application/json'];
    }

    if (_serialize) data = _serialize(data);
  } // set header fields


  for (var field in this.header) {
    if (this.header[field] === null) continue;
    if (Object.prototype.hasOwnProperty.call(this.header, field)) xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  } // send stuff


  this.emit('request', this); // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined

  xhr.send(typeof data === 'undefined' ? null : data);
};

request.agent = function () {
  return new Agent();
};

['GET', 'POST', 'OPTIONS', 'PATCH', 'PUT', 'DELETE'].forEach(function (method) {
  Agent.prototype[method.toLowerCase()] = function (url, fn) {
    var req = new request.Request(method, url);

    this._setDefaults(req);

    if (fn) {
      req.end(fn);
    }

    return req;
  };
});
Agent.prototype.del = Agent.prototype.delete;
/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function (url, data, fn) {
  var req = request('GET', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.head = function (url, data, fn) {
  var req = request('HEAD', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.options = function (url, data, fn) {
  var req = request('OPTIONS', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


function del(url, data, fn) {
  var req = request('DELETE', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request.del = del;
request.delete = del;
/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function (url, data, fn) {
  var req = request('PATCH', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.post = function (url, data, fn) {
  var req = request('POST', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.put = function (url, data, fn) {
  var req = request('PUT', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
},{"./agent-base":69,"./is-object":71,"./request-base":72,"./response-base":73,"component-emitter":75,"fast-safe-stringify":24}],71:[function(_dereq_,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
function isObject(obj) {
  return obj !== null && _typeof(obj) === 'object';
}

module.exports = isObject;
},{}],72:[function(_dereq_,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = _dereq_('./is-object');
/**
 * Expose `RequestBase`.
 */


module.exports = RequestBase;
/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in RequestBase.prototype) {
    if (Object.prototype.hasOwnProperty.call(RequestBase.prototype, key)) obj[key] = RequestBase.prototype[key];
  }

  return obj;
}
/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.clearTimeout = function () {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  clearTimeout(this._uploadTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  delete this._uploadTimeoutTimer;
  return this;
};
/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.parse = function (fn) {
  this._parser = fn;
  return this;
};
/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.responseType = function (val) {
  this._responseType = val;
  return this;
};
/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.serialize = function (fn) {
  this._serializer = fn;
  return this;
};
/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 * - upload is the time  since last bit of data was sent or received. This timeout works only if deadline timeout is off
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.timeout = function (options) {
  if (!options || _typeof(options) !== 'object') {
    this._timeout = options;
    this._responseTimeout = 0;
    this._uploadTimeout = 0;
    return this;
  }

  for (var option in options) {
    if (Object.prototype.hasOwnProperty.call(options, option)) {
      switch (option) {
        case 'deadline':
          this._timeout = options.deadline;
          break;

        case 'response':
          this._responseTimeout = options.response;
          break;

        case 'upload':
          this._uploadTimeout = options.upload;
          break;

        default:
          console.warn('Unknown timeout option', option);
      }
    }
  }

  return this;
};
/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.retry = function (count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = ['ECONNRESET', 'ETIMEDOUT', 'EADDRINFO', 'ESOCKETTIMEDOUT'];
/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err an error
 * @param {Response} [res] response
 * @returns {Boolean} if segment should be retried
 */

RequestBase.prototype._shouldRetry = function (err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }

  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);

      if (override === true) return true;
      if (override === false) return false; // undefined falls back to defaults
    } catch (err2) {
      console.error(err2);
    }
  }

  if (res && res.status && res.status >= 500 && res.status !== 501) return true;

  if (err) {
    if (err.code && ERROR_CODES.indexOf(err.code) !== -1) return true; // Superagent timeout

    if (err.timeout && err.code === 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }

  return false;
};
/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */


RequestBase.prototype._retry = function () {
  this.clearTimeout(); // node

  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;
  return this._end();
};
/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */


RequestBase.prototype.then = function (resolve, reject) {
  var _this = this;

  if (!this._fullfilledPromise) {
    var self = this;

    if (this._endCalled) {
      console.warn('Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises');
    }

    this._fullfilledPromise = new Promise(function (resolve, reject) {
      self.on('abort', function () {
        var err = new Error('Aborted');
        err.code = 'ABORTED';
        err.status = _this.status;
        err.method = _this.method;
        err.url = _this.url;
        reject(err);
      });
      self.end(function (err, res) {
        if (err) reject(err);else resolve(res);
      });
    });
  }

  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype.catch = function (cb) {
  return this.then(undefined, cb);
};
/**
 * Allow for extension
 */


RequestBase.prototype.use = function (fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function (cb) {
  if (typeof cb !== 'function') throw new Error('Callback required');
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};
/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};
/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */


RequestBase.prototype.getHeader = RequestBase.prototype.get;
/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, val) {
  if (isObject(field)) {
    for (var key in field) {
      if (Object.prototype.hasOwnProperty.call(field, key)) this.set(key, field[key]);
    }

    return this;
  }

  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
}; // eslint-disable-next-line valid-jsdoc

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field field name
 */


RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};
/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name name of field
 * @param {String|Blob|File|Buffer|fs.ReadStream} val value of field
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.field = function (name, val) {
  // name should be either a string or an object.
  if (name === null || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      if (Object.prototype.hasOwnProperty.call(name, key)) this.field(key, name[key]);
    }

    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      if (Object.prototype.hasOwnProperty.call(val, i)) this.field(name, val[i]);
    }

    return this;
  } // val should be defined now


  if (val === null || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }

  if (typeof val === 'boolean') {
    val = String(val);
  }

  this._getFormData().append(name, val);

  return this;
};
/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request} request
 * @api public
 */


RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }

  this._aborted = true;
  if (this.xhr) this.xhr.abort(); // browser

  if (this.req) this.req.abort(); // node

  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', "Bearer ".concat(user));
      break;

    default:
      break;
  }

  return this;
};
/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */


RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on === undefined) on = true;
  this._withCredentials = on;
  return this;
};
/**
 * Set the max redirects to `n`. Does nothing in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};
/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n number of bytes
 * @return {Request} for chaining
 */


RequestBase.prototype.maxResponseSize = function (n) {
  if (typeof n !== 'number') {
    throw new TypeError('Invalid argument');
  }

  this._maxResponseSize = n;
  return this;
};
/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */


RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};
/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */
// eslint-disable-next-line complexity


RequestBase.prototype.send = function (data) {
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw new Error("Can't merge these send calls");
  } // merge


  if (isObj && isObject(this._data)) {
    for (var key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) this._data[key] = data[key];
    }
  } else if (typeof data === 'string') {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];

    if (type === 'application/x-www-form-urlencoded') {
      this._data = this._data ? "".concat(this._data, "&").concat(data) : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  } // default to json


  if (!type) this.type('json');
  return this;
};
/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};
/**
 * Compose querystring to append to req.url
 *
 * @api private
 */


RequestBase.prototype._finalizeQueryString = function () {
  var query = this._query.join('&');

  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }

  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');

    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');

      if (typeof this._sort === 'function') {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }

      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
}; // For backwards compat only


RequestBase.prototype._appendQueryString = function () {
  console.warn('Unsupported');
};
/**
 * Invoke callback with timeout error.
 *
 * @api private
 */


RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }

  var err = new Error("".concat(reason + timeout, "ms exceeded"));
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function () {
  var self = this; // deadline

  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function () {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  } // response timeout


  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function () {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};
},{"./is-object":71}],73:[function(_dereq_,module,exports){
"use strict";

/**
 * Module dependencies.
 */
var utils = _dereq_('./utils');
/**
 * Expose `ResponseBase`.
 */


module.exports = ResponseBase;
/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    if (Object.prototype.hasOwnProperty.call(ResponseBase.prototype, key)) obj[key] = ResponseBase.prototype[key];
  }

  return obj;
}
/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};
/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */


ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util
  // content-type
  var ct = header['content-type'] || '';
  this.type = utils.type(ct); // params

  var params = utils.params(ct);

  for (var key in params) {
    if (Object.prototype.hasOwnProperty.call(params, key)) this[key] = params[key];
  }

  this.links = {}; // links

  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (err) {// ignore
  }
};
/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */


ResponseBase.prototype._setStatusProperties = function (status) {
  var type = status / 100 | 0; // status / class

  this.statusCode = status;
  this.status = this.statusCode;
  this.statusType = type; // basics

  this.info = type === 1;
  this.ok = type === 2;
  this.redirect = type === 3;
  this.clientError = type === 4;
  this.serverError = type === 5;
  this.error = type === 4 || type === 5 ? this.toError() : false; // sugar

  this.created = status === 201;
  this.accepted = status === 202;
  this.noContent = status === 204;
  this.badRequest = status === 400;
  this.unauthorized = status === 401;
  this.notAcceptable = status === 406;
  this.forbidden = status === 403;
  this.notFound = status === 404;
  this.unprocessableEntity = status === 422;
};
},{"./utils":74}],74:[function(_dereq_,module,exports){
"use strict";

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */
exports.type = function (str) {
  return str.split(/ *; */).shift();
};
/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.params = function (str) {
  return str.split(/ *; */).reduce(function (obj, str) {
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();
    if (key && val) obj[key] = val;
    return obj;
  }, {});
};
/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.parseLinks = function (str) {
  return str.split(/ *, */).reduce(function (obj, str) {
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};
/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */


exports.cleanHeader = function (header, changesOrigin) {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header.host; // secuirty

  if (changesOrigin) {
    delete header.authorization;
    delete header.cookie;
  }

  return header;
};
},{}],75:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],76:[function(_dereq_,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = _dereq_('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,_dereq_("timers").setImmediate,_dereq_("timers").clearImmediate)

},{"process/browser.js":50,"timers":76}],77:[function(_dereq_,module,exports){
(function (Buffer){
/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <https://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = _dereq_('is-typedarray').strict

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = Buffer.from(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to `Buffer.from`
    return Buffer.from(arr)
  }
}

}).call(this,_dereq_("buffer").Buffer)

},{"buffer":8,"is-typedarray":43}],78:[function(_dereq_,module,exports){
/*!
 * UAParser.js v0.7.20
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright  2012-2019 Faisal Salman <f@faisalman.com>
 * Licensed under MIT License
 */

(function (window, undefined) {

    'use strict';

    //////////////
    // Constants
    /////////////


    var LIBVERSION  = '0.7.20',
        EMPTY       = '',
        UNKNOWN     = '?',
        FUNC_TYPE   = 'function',
        UNDEF_TYPE  = 'undefined',
        OBJ_TYPE    = 'object',
        STR_TYPE    = 'string',
        MAJOR       = 'major', // deprecated
        MODEL       = 'model',
        NAME        = 'name',
        TYPE        = 'type',
        VENDOR      = 'vendor',
        VERSION     = 'version',
        ARCHITECTURE= 'architecture',
        CONSOLE     = 'console',
        MOBILE      = 'mobile',
        TABLET      = 'tablet',
        SMARTTV     = 'smarttv',
        WEARABLE    = 'wearable',
        EMBEDDED    = 'embedded';


    ///////////
    // Helper
    //////////


    var util = {
        extend : function (regexes, extensions) {
            var mergedRegexes = {};
            for (var i in regexes) {
                if (extensions[i] && extensions[i].length % 2 === 0) {
                    mergedRegexes[i] = extensions[i].concat(regexes[i]);
                } else {
                    mergedRegexes[i] = regexes[i];
                }
            }
            return mergedRegexes;
        },
        has : function (str1, str2) {
          if (typeof str1 === "string") {
            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
          } else {
            return false;
          }
        },
        lowerize : function (str) {
            return str.toLowerCase();
        },
        major : function (version) {
            return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g,'').split(".")[0] : undefined;
        },
        trim : function (str) {
          return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
        }
    };


    ///////////////
    // Map helper
    //////////////


    var mapper = {

        rgx : function (ua, arrays) {

            var i = 0, j, k, p, q, matches, match;

            // loop through all regexes maps
            while (i < arrays.length && !matches) {

                var regex = arrays[i],       // even sequence (0,2,4,..)
                    props = arrays[i + 1];   // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {

                    matches = regex[j++].exec(ua);

                    if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            // check if given property is actually array
                            if (typeof q === OBJ_TYPE && q.length > 0) {
                                if (q.length == 2) {
                                    if (typeof q[1] == FUNC_TYPE) {
                                        // assign modified match
                                        this[q[0]] = q[1].call(this, match);
                                    } else {
                                        // assign given value, ignore regex match
                                        this[q[0]] = q[1];
                                    }
                                } else if (q.length == 3) {
                                    // check whether function or regex
                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                        // call function (usually string mapper)
                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                    } else {
                                        // sanitize match using given regex
                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                    }
                                } else if (q.length == 4) {
                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                }
                            } else {
                                this[q] = match ? match : undefined;
                            }
                        }
                    }
                }
                i += 2;
            }
        },

        str : function (str, map) {

            for (var i in map) {
                // check if array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                    for (var j = 0; j < map[i].length; j++) {
                        if (util.has(map[i][j], str)) {
                            return (i === UNKNOWN) ? undefined : i;
                        }
                    }
                } else if (util.has(map[i], str)) {
                    return (i === UNKNOWN) ? undefined : i;
                }
            }
            return str;
        }
    };


    ///////////////
    // String map
    //////////////


    var maps = {

        browser : {
            oldsafari : {
                version : {
                    '1.0'   : '/8',
                    '1.2'   : '/1',
                    '1.3'   : '/3',
                    '2.0'   : '/412',
                    '2.0.2' : '/416',
                    '2.0.3' : '/417',
                    '2.0.4' : '/419',
                    '?'     : '/'
                }
            }
        },

        device : {
            amazon : {
                model : {
                    'Fire Phone' : ['SD', 'KF']
                }
            },
            sprint : {
                model : {
                    'Evo Shift 4G' : '7373KT'
                },
                vendor : {
                    'HTC'       : 'APA',
                    'Sprint'    : 'Sprint'
                }
            }
        },

        os : {
            windows : {
                version : {
                    'ME'        : '4.90',
                    'NT 3.11'   : 'NT3.51',
                    'NT 4.0'    : 'NT4.0',
                    '2000'      : 'NT 5.0',
                    'XP'        : ['NT 5.1', 'NT 5.2'],
                    'Vista'     : 'NT 6.0',
                    '7'         : 'NT 6.1',
                    '8'         : 'NT 6.2',
                    '8.1'       : 'NT 6.3',
                    '10'        : ['NT 6.4', 'NT 10.0'],
                    'RT'        : 'ARM'
                }
            }
        }
    };


    //////////////
    // Regex map
    /////////////


    var regexes = {

        browser : [[

            // Presto based
            /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
            /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
            /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80
            ], [NAME, VERSION], [

            /(opios)[\/\s]+([\w\.]+)/i                                          // Opera mini on iphone >= 8.0
            ], [[NAME, 'Opera Mini'], VERSION], [

            /\s(opr)\/([\w\.]+)/i                                               // Opera Webkit
            ], [[NAME, 'Opera'], VERSION], [

            // Mixed
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i,
                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer

            // Trident based
            /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,
                                                                                // Avant/IEMobile/SlimBrowser/Baidu
            /(?:ms|\()(ie)\s([\w\.]+)/i,                                        // Internet Explorer

            // Webkit/KHTML based
            /(rekonq)\/([\w\.]*)/i,                                             // Rekonq
            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon)\/([\w\.-]+)/i
                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            ], [NAME, VERSION], [

            /(konqueror)\/([\w\.]+)/i                                           // Konqueror
            ], [[NAME, 'Konqueror'], VERSION], [

            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
            ], [[NAME, 'IE'], VERSION], [

            /(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i                          // Microsoft Edge
            ], [[NAME, 'Edge'], VERSION], [

            /(yabrowser)\/([\w\.]+)/i                                           // Yandex
            ], [[NAME, 'Yandex'], VERSION], [

            /(puffin)\/([\w\.]+)/i                                              // Puffin
            ], [[NAME, 'Puffin'], VERSION], [

            /(focus)\/([\w\.]+)/i                                               // Firefox Focus
            ], [[NAME, 'Firefox Focus'], VERSION], [

            /(opt)\/([\w\.]+)/i                                                 // Opera Touch
            ], [[NAME, 'Opera Touch'], VERSION], [

            /((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i         // UCBrowser
            ], [[NAME, 'UCBrowser'], VERSION], [

            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
            ], [[NAME, /_/g, ' '], VERSION], [

            /(windowswechat qbcore)\/([\w\.]+)/i                                // WeChat Desktop for Windows Built-in Browser
            ], [[NAME, 'WeChat(Win) Desktop'], VERSION], [

            /(micromessenger)\/([\w\.]+)/i                                      // WeChat
            ], [[NAME, 'WeChat'], VERSION], [

            /(brave)\/([\w\.]+)/i                                              // Brave browser
            ], [[NAME, 'Brave'], VERSION], [

            /(qqbrowserlite)\/([\w\.]+)/i                                       // QQBrowserLite
            ], [NAME, VERSION], [

            /(QQ)\/([\d\.]+)/i                                                  // QQ, aka ShouQ
            ], [NAME, VERSION], [

            /m?(qqbrowser)[\/\s]?([\w\.]+)/i                                    // QQBrowser
            ], [NAME, VERSION], [

            /(BIDUBrowser)[\/\s]?([\w\.]+)/i                                    // Baidu Browser
            ], [NAME, VERSION], [

            /(2345Explorer)[\/\s]?([\w\.]+)/i                                   // 2345 Browser
            ], [NAME, VERSION], [

            /(MetaSr)[\/\s]?([\w\.]+)/i                                         // SouGouBrowser
            ], [NAME], [

            /(LBBROWSER)/i                                      // LieBao Browser
            ], [NAME], [

            /xiaomi\/miuibrowser\/([\w\.]+)/i                                   // MIUI Browser
            ], [VERSION, [NAME, 'MIUI Browser']], [

            /;fbav\/([\w\.]+);/i                                                // Facebook App for iOS & Android
            ], [VERSION, [NAME, 'Facebook']], [

            /safari\s(line)\/([\w\.]+)/i,                                       // Line App for iOS
            /android.+(line)\/([\w\.]+)\/iab/i                                  // Line App for Android
            ], [NAME, VERSION], [

            /headlesschrome(?:\/([\w\.]+)|\s)/i                                 // Chrome Headless
            ], [VERSION, [NAME, 'Chrome Headless']], [

            /\swv\).+(chrome)\/([\w\.]+)/i                                      // Chrome WebView
            ], [[NAME, /(.+)/, '$1 WebView'], VERSION], [

            /((?:oculus|samsung)browser)\/([\w\.]+)/i
            ], [[NAME, /(.+(?:g|us))(.+)/, '$1 $2'], VERSION], [                // Oculus / Samsung Browser

            /android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i        // Android Browser
            ], [VERSION, [NAME, 'Android Browser']], [

            /(sailfishbrowser)\/([\w\.]+)/i                                     // Sailfish Browser
            ], [[NAME, 'Sailfish Browser'], VERSION], [

            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i
                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION], [

            /(dolfin)\/([\w\.]+)/i                                              // Dolphin
            ], [[NAME, 'Dolphin'], VERSION], [

            /((?:android.+)crmo|crios)\/([\w\.]+)/i                             // Chrome for Android/iOS
            ], [[NAME, 'Chrome'], VERSION], [

            /(coast)\/([\w\.]+)/i                                               // Opera Coast
            ], [[NAME, 'Opera Coast'], VERSION], [

            /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
            ], [VERSION, [NAME, 'Firefox']], [

            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
            ], [VERSION, [NAME, 'Mobile Safari']], [

            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
            ], [VERSION, NAME], [

            /webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i  // Google Search Appliance on iOS
            ], [[NAME, 'GSA'], VERSION], [

            /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
            ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [

            /(webkit|khtml)\/([\w\.]+)/i
            ], [NAME, VERSION], [

            // Gecko based
            /(navigator|netscape)\/([\w\.-]+)/i                                 // Netscape
            ], [[NAME, 'Netscape'], VERSION], [
            /(swiftfox)/i,                                                      // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i,

                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla

            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir
            /(links)\s\(([\w\.]+)/i,                                            // Links
            /(gobrowser)\/?([\w\.]*)/i,                                         // GoBrowser
            /(ice\s?browser)\/v?([\w\._]+)/i,                                   // ICE Browser
            /(mosaic)[\/\s]([\w\.]+)/i                                          // Mosaic
            ], [NAME, VERSION]
        ],

        cpu : [[

            /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i                     // AMD64
            ], [[ARCHITECTURE, 'amd64']], [

            /(ia32(?=;))/i                                                      // IA32 (quicktime)
            ], [[ARCHITECTURE, util.lowerize]], [

            /((?:i[346]|x)86)[;\)]/i                                            // IA32
            ], [[ARCHITECTURE, 'ia32']], [

            // PocketPC mistakenly identified as PowerPC
            /windows\s(ce|mobile);\sppc;/i
            ], [[ARCHITECTURE, 'arm']], [

            /((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i                           // PowerPC
            ], [[ARCHITECTURE, /ower/, '', util.lowerize]], [

            /(sun4\w)[;\)]/i                                                    // SPARC
            ], [[ARCHITECTURE, 'sparc']], [

            /((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+[;l]))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i
                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ], [[ARCHITECTURE, util.lowerize]]
        ],

        device : [[

            /\((ipad|playbook);[\w\s\),;-]+(rim|apple)/i                        // iPad/PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [

            /applecoremedia\/[\w\.]+ \((ipad)/                                  // iPad
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [

            /(apple\s{0,1}tv)/i                                                 // Apple TV
            ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple']], [

            /(archos)\s(gamepad2?)/i,                                           // Archos
            /(hp).+(touchpad)/i,                                                // HP TouchPad
            /(hp).+(tablet)/i,                                                  // HP Tablet
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /\s(nook)[\w\s]+build\/(\w+)/i,                                     // Nook
            /(dell)\s(strea[kpr\s\d]*[\dko])/i                                  // Dell Streak
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(kf[A-z]+)\sbuild\/.+silk\//i                                      // Kindle Fire HD
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
            /(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i                         // Fire Phone
            ], [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [
            /android.+aft([bms])\sbuild/i                                       // Fire TV
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, SMARTTV]], [

            /\((ip[honed|\s\w*]+);.+(apple)/i                                   // iPod/iPhone
            ], [MODEL, VENDOR, [TYPE, MOBILE]], [
            /\((ip[honed|\s\w*]+);/i                                            // iPod/iPhone
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [

            /(blackberry)[\s-]?(\w+)/i,                                         // BlackBerry
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i,
                                                                                // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
            /(hp)\s([\w\s]+\w)/i,                                               // HP iPAQ
            /(asus)-?(\w+)/i                                                    // Asus
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /\(bb10;\s(\w+)/i                                                   // BlackBerry 10
            ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [
                                                                                // Asus Tablets
            /android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone|p00c)/i
            ], [MODEL, [VENDOR, 'Asus'], [TYPE, TABLET]], [

            /(sony)\s(tablet\s[ps])\sbuild\//i,                                  // Sony
            /(sony)?(?:sgp.+)\sbuild\//i
            ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Tablet'], [TYPE, TABLET]], [
            /android.+\s([c-g]\d{4}|so[-l]\w+)(?=\sbuild\/|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ], [MODEL, [VENDOR, 'Sony'], [TYPE, MOBILE]], [

            /\s(ouya)\s/i,                                                      // Ouya
            /(nintendo)\s([wids3u]+)/i                                          // Nintendo
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [

            /android.+;\s(shield)\sbuild/i                                      // Nvidia
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [

            /(playstation\s[34portablevi]+)/i                                   // Playstation
            ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [

            /(sprint\s(\w+))/i                                                  // Sprint Phones
            ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [

            /(htc)[;_\s-]+([\w\s]+(?=\)|\sbuild)|\w+)/i,                        // HTC
            /(zte)-(\w*)/i,                                                     // ZTE
            /(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i
                                                                                // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

            /(nexus\s9)/i                                                       // HTC Nexus 9
            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [

            /d\/huawei([\w\s-]+)[;\)]/i,
            /(nexus\s6p)/i                                                      // Huawei
            ], [MODEL, [VENDOR, 'Huawei'], [TYPE, MOBILE]], [

            /(microsoft);\s(lumia[\s\w]+)/i                                     // Microsoft Lumia
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /[\s\(;](xbox(?:\sone)?)[\s\);]/i                                   // Microsoft Xbox
            ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [
            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
            ], [[MODEL, /\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [

                                                                                // Motorola
            /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i,
            /mot[\s-]?(\w*)/i,
            /(XT\d{3,4}) build\//i,
            /(nexus\s6)/i
            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [
            /android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i
            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [

            /hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i            // HbbTV devices
            ], [[VENDOR, util.trim], [MODEL, util.trim], [TYPE, SMARTTV]], [

            /hbbtv.+maple;(\d+)/i
            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, 'Samsung'], [TYPE, SMARTTV]], [

            /\(dtv[\);].+(aquos)/i                                              // Sharp
            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [

            /android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,
            /((SM-T\w+))/i
            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [                  // Samsung
            /smart-tv.+(samsung)/i
            ], [VENDOR, [TYPE, SMARTTV], MODEL], [
            /((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,
            /(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i,
            /sec-((sgh\w+))/i
            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [

            /sie-(\w*)/i                                                        // Siemens
            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [

            /(maemo|nokia).*(n900|lumia\s\d+)/i,                                // Nokia
            /(nokia)[\s_-]?([\w-]*)/i
            ], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [

            /android[x\d\.\s;]+\s([ab][1-7]\-?[0178a]\d\d?)/i                   // Acer
            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

            /android.+([vl]k\-?\d{3})\s+build/i                                 // LG Tablet
            ], [MODEL, [VENDOR, 'LG'], [TYPE, TABLET]], [
            /android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i                     // LG Tablet
            ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [
            /(lg) netcast\.tv/i                                                 // LG SmartTV
            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
            /(nexus\s[45])/i,                                                   // LG
            /lg[e;\s\/-]+(\w*)/i,
            /android.+lg(\-?[\d\w]+)\s+build/i
            ], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [

            /(lenovo)\s?(s(?:5000|6000)(?:[\w-]+)|tab(?:[\s\w]+))/i             // Lenovo tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [
            /android.+(ideatab[a-z0-9\-\s]+)/i                                  // Lenovo
            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [
            /(lenovo)[_\s-]?([\w-]+)/i
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /linux;.+((jolla));/i                                               // Jolla
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /((pebble))app\/[\d\.]+\s/i                                         // Pebble
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [

            /android.+;\s(oppo)\s?([\w\s]+)\sbuild/i                            // OPPO
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /crkey/i                                                            // Google Chromecast
            ], [[MODEL, 'Chromecast'], [VENDOR, 'Google']], [

            /android.+;\s(glass)\s\d/i                                          // Google Glass
            ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [

            /android.+;\s(pixel c)[\s)]/i                                       // Google Pixel C
            ], [MODEL, [VENDOR, 'Google'], [TYPE, TABLET]], [

            /android.+;\s(pixel( [23])?( xl)?)[\s)]/i                              // Google Pixel
            ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [

            /android.+;\s(\w+)\s+build\/hm\1/i,                                 // Xiaomi Hongmi 'numeric' models
            /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
            /android.+(mi[\s\-_]*(?:a\d|one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i,    
                                                                                // Xiaomi Mi
            /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i       // Redmi Phones
            ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [
            /android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i            // Mi Pad tablets
            ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [
            /android.+;\s(m[1-5]\snote)\sbuild/i                                // Meizu
            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [
            /(mz)-([\w-]{2,})/i
            ], [[VENDOR, 'Meizu'], MODEL, [TYPE, MOBILE]], [

            /android.+a000(1)\s+build/i,                                        // OnePlus
            /android.+oneplus\s(a\d{4})\s+build/i
            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

            /android.+[;\/]\s*(RCT[\d\w]+)\s+build/i                            // RCA Tablets
            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [

            /android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i                      // Dell Venue Tablets
            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i                         // Verizon Tablet
            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [

            /android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i     // Barnes & Noble Tablet
            ], [[VENDOR, 'Barnes & Noble'], MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i                           // Barnes & Noble Tablet
            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [

            /android.+;\s(k88)\sbuild/i                                         // ZTE K Series Tablet
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(gen\d{3})\s+build.*49h/i                         // Swiss GEN Mobile
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [

            /android.+[;\/]\s*(zur\d{3})\s+build/i                              // Swiss ZUR Tablet
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [

            /android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i                         // Zeki Tablets
            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [

            /(android).+[;\/]\s+([YR]\d{2})\s+build/i,
            /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i        // Dragon Touch Tablet
            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i                            // Insignia Tablets
            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [

            /android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i                    // NextBook Tablets
            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i
            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [                    // Voice Xtreme Phones

            /android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i                     // LvTel Phones
            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [

            /android.+;\s(PH-1)\s/i
            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [                // Essential PH-1

            /android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i          // Envizen Tablets
            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i          // Le Pan Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i                         // MachSpeed Tablets
            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i                // Trinity Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*TU_(1491)\s+build/i                               // Rotor Tablets
            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [

            /android.+(KS(.+))\s+build/i                                        // Amazon Kindle Tablets
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [

            /android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i                      // Gigaset Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /\s(tablet|tab)[;\/]/i,                                             // Unidentifiable Tablet
            /\s(mobile)(?:[;\/]|\ssafari)/i                                     // Unidentifiable Mobile
            ], [[TYPE, util.lowerize], VENDOR, MODEL], [

            /[\s\/\(](smart-?tv)[;\)]/i                                         // SmartTV
            ], [[TYPE, SMARTTV]], [

            /(android[\w\.\s\-]{0,9});.+build/i                                 // Generic Android Device
            ], [MODEL, [VENDOR, 'Generic']]
        ],

        engine : [[

            /windows.+\sedge\/([\w\.]+)/i                                       // EdgeHTML
            ], [VERSION, [NAME, 'EdgeHTML']], [

            /webkit\/537\.36.+chrome\/(?!27)/i                                  // Blink
            ], [[NAME, 'Blink']], [

            /(presto)\/([\w\.]+)/i,                                             // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,     
                                                                                // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
            ], [NAME, VERSION], [

            /rv\:([\w\.]{1,9}).+(gecko)/i                                       // Gecko
            ], [VERSION, NAME]
        ],

        os : [[

            // Windows based
            /microsoft\s(windows)\s(vista|xp)/i                                 // Windows (iTunes)
            ], [NAME, VERSION], [
            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
            /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i,                   // Windows Phone
            /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

            // Mobile/Embedded OS
            /\((bb)(10);/i                                                      // BlackBerry 10
            ], [[NAME, 'BlackBerry'], VERSION], [
            /(blackberry)\w*\/?([\w\.]*)/i,                                     // Blackberry
            /(tizen)[\/\s]([\w\.]+)/i,                                          // Tizen
            /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|sailfish|contiki)[\/\s-]?([\w\.]*)/i
                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki/Sailfish OS
            ], [NAME, VERSION], [
            /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i                  // Symbian
            ], [[NAME, 'Symbian'], VERSION], [
            /\((series40);/i                                                    // Series 40
            ], [NAME], [
            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
            ], [[NAME, 'Firefox OS'], VERSION], [

            // Console
            /(nintendo|playstation)\s([wids34portablevu]+)/i,                   // Nintendo/Playstation

            // GNU/Linux based
            /(mint)[\/\s\(]?(\w*)/i,                                            // Mint
            /(mageia|vectorlinux)[;\s]/i,                                       // Mageia/VectorLinux
            /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i,
                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus
            /(hurd|linux)\s?([\w\.]*)/i,                                        // Hurd/Linux
            /(gnu)\s?([\w\.]*)/i                                                // GNU
            ], [NAME, VERSION], [

            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
            ], [[NAME, 'Chromium OS'], VERSION],[

            // Solaris
            /(sunos)\s?([\w\.\d]*)/i                                            // Solaris
            ], [[NAME, 'Solaris'], VERSION], [

            // BSD based
            /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i                    // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
            ], [NAME, VERSION],[

            /(haiku)\s(\w+)/i                                                   // Haiku
            ], [NAME, VERSION],[

            /cfnetwork\/.+darwin/i,
            /ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i             // iOS
            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [

            /(mac\sos\sx)\s?([\w\s\.]*)/i,
            /(macintosh|mac(?=_powerpc)\s)/i                                    // Mac OS
            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

            // Other
            /((?:open)?solaris)[\/\s-]?([\w\.]*)/i,                             // Solaris
            /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i,                                // AIX
            /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i,
                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS/Fuchsia
            /(unix)\s?([\w\.]*)/i                                               // UNIX
            ], [NAME, VERSION]
        ]
    };


    /////////////////
    // Constructor
    ////////////////
    var UAParser = function (uastring, extensions) {

        if (typeof uastring === 'object') {
            extensions = uastring;
            uastring = undefined;
        }

        if (!(this instanceof UAParser)) {
            return new UAParser(uastring, extensions).getResult();
        }

        var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
        var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;

        this.getBrowser = function () {
            var browser = { name: undefined, version: undefined };
            mapper.rgx.call(browser, ua, rgxmap.browser);
            browser.major = util.major(browser.version); // deprecated
            return browser;
        };
        this.getCPU = function () {
            var cpu = { architecture: undefined };
            mapper.rgx.call(cpu, ua, rgxmap.cpu);
            return cpu;
        };
        this.getDevice = function () {
            var device = { vendor: undefined, model: undefined, type: undefined };
            mapper.rgx.call(device, ua, rgxmap.device);
            return device;
        };
        this.getEngine = function () {
            var engine = { name: undefined, version: undefined };
            mapper.rgx.call(engine, ua, rgxmap.engine);
            return engine;
        };
        this.getOS = function () {
            var os = { name: undefined, version: undefined };
            mapper.rgx.call(os, ua, rgxmap.os);
            return os;
        };
        this.getResult = function () {
            return {
                ua      : this.getUA(),
                browser : this.getBrowser(),
                engine  : this.getEngine(),
                os      : this.getOS(),
                device  : this.getDevice(),
                cpu     : this.getCPU()
            };
        };
        this.getUA = function () {
            return ua;
        };
        this.setUA = function (uastring) {
            ua = uastring;
            return this;
        };
        return this;
    };

    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER = {
        NAME    : NAME,
        MAJOR   : MAJOR, // deprecated
        VERSION : VERSION
    };
    UAParser.CPU = {
        ARCHITECTURE : ARCHITECTURE
    };
    UAParser.DEVICE = {
        MODEL   : MODEL,
        VENDOR  : VENDOR,
        TYPE    : TYPE,
        CONSOLE : CONSOLE,
        MOBILE  : MOBILE,
        SMARTTV : SMARTTV,
        TABLET  : TABLET,
        WEARABLE: WEARABLE,
        EMBEDDED: EMBEDDED
    };
    UAParser.ENGINE = {
        NAME    : NAME,
        VERSION : VERSION
    };
    UAParser.OS = {
        NAME    : NAME,
        VERSION : VERSION
    };

    ///////////
    // Export
    //////////


    // check js environment
    if (typeof(exports) !== UNDEF_TYPE) {
        // nodejs env
        if (typeof module !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
    } else {
        // requirejs env (optional)
        if (typeof(define) === 'function' && define.amd) {
            define(function () {
                return UAParser;
            });
        } else if (window) {
            // browser env
            window.UAParser = UAParser;
        }
    }

    // jQuery/Zepto specific (optional)
    // Note:
    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
    //   and we should catch that.
    var $ = window && (window.jQuery || window.Zepto);
    if (typeof $ !== UNDEF_TYPE && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function () {
            return parser.getUA();
        };
        $.ua.set = function (uastring) {
            parser.setUA(uastring);
            var result = parser.getResult();
            for (var prop in result) {
                $.ua[prop] = result[prop];
            }
        };
    }

})(typeof window === 'object' ? window : this);

},{}],79:[function(_dereq_,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],80:[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],81:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":80,"_process":50,"inherits":36}],82:[function(_dereq_,module,exports){
'use strict';

// FUNCTIONS //

var isStr = Object.prototype.toString;


// IS FLOAT32ARRAY //

/**
* FUNCTION: isFloat32Array( value )
*	Validates if a value is a Float32Array.
*
* @param {*} value - value to validate
* @returns {Boolean} boolean indicating if a value is a Float32Array
*/
function isFloat32Array( value ) {
	return isStr.call( value ) === '[object Float32Array]';
} // end FUNCTION isFloat32Array()


// EXPORTS //

module.exports = isFloat32Array;

},{}],83:[function(_dereq_,module,exports){
(function (process,global){
'use strict'

var Transform = _dereq_('readable-stream').Transform
var duplexify = _dereq_('duplexify')
var WS = _dereq_('ws')
var Buffer = _dereq_('safe-buffer').Buffer

module.exports = WebSocketStream

function buildProxy (options, socketWrite, socketEnd) {
  var proxy = new Transform({
    objectMode: options.objectMode
  })

  proxy._write = socketWrite
  proxy._flush = socketEnd

  return proxy
}

function WebSocketStream(target, protocols, options) {
  var stream, socket

  var isBrowser = process.title === 'browser'
  var isNative = !!global.WebSocket
  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode

  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {
    // accept the "options" Object as the 2nd argument
    options = protocols
    protocols = null

    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {
      protocols = options.protocol;
    }
  }

  if (!options) options = {}

  if (options.objectMode === undefined) {
    options.objectMode = !(options.binary === true || options.binary === undefined)
  }

  var proxy = buildProxy(options, socketWrite, socketEnd)

  if (!options.objectMode) {
    proxy._writev = writev
  }

  // browser only: sets the maximum socket buffer size before throttling
  var bufferSize = options.browserBufferSize || 1024 * 512

  // browser only: how long to wait when throttling
  var bufferTimeout = options.browserBufferTimeout || 1000

  // use existing WebSocket object that was passed in
  if (typeof target === 'object') {
    socket = target
  // otherwise make a new one
  } else {
    // special constructor treatment for native websockets in browsers, see
    // https://github.com/maxogden/websocket-stream/issues/82
    if (isNative && isBrowser) {
      socket = new WS(target, protocols)
    } else {
      socket = new WS(target, protocols, options)
    }

    socket.binaryType = 'arraybuffer'
  }

  // was already open when passed in
  if (socket.readyState === socket.OPEN) {
    stream = proxy
  } else {
    stream = stream = duplexify(undefined, undefined, options)
    if (!options.objectMode) {
      stream._writev = writev
    }
    socket.onopen = onopen
  }

  stream.socket = socket

  socket.onclose = onclose
  socket.onerror = onerror
  socket.onmessage = onmessage

  proxy.on('close', destroy)

  var coerceToBuffer = !options.objectMode

  function socketWriteNode(chunk, enc, next) {
    // avoid errors, this never happens unless
    // destroy() is called
    if (socket.readyState !== socket.OPEN) {
      next()
      return
    }

    if (coerceToBuffer && typeof chunk === 'string') {
      chunk = Buffer.from(chunk, 'utf8')
    }
    socket.send(chunk, next)
  }

  function socketWriteBrowser(chunk, enc, next) {
    if (socket.bufferedAmount > bufferSize) {
      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)
      return
    }

    if (coerceToBuffer && typeof chunk === 'string') {
      chunk = Buffer.from(chunk, 'utf8')
    }

    try {
      socket.send(chunk)
    } catch(err) {
      return next(err)
    }

    next()
  }

  function socketEnd(done) {
    socket.close()
    done()
  }

  function onopen() {
    stream.setReadable(proxy)
    stream.setWritable(proxy)
    stream.emit('connect')
  }

  function onclose() {
    stream.end()
    stream.destroy()
  }

  function onerror(err) {
    stream.destroy(err)
  }

  function onmessage(event) {
    var data = event.data
    if (data instanceof ArrayBuffer) data = Buffer.from(data)
    else data = Buffer.from(data, 'utf8')
    proxy.push(data)
  }

  function destroy() {
    socket.close()
  }

  // this is to be enabled only if objectMode is false
  function writev (chunks, cb) {
    var buffers = new Array(chunks.length)
    for (var i = 0; i < chunks.length; i++) {
      if (typeof chunks[i].chunk === 'string') {
        buffers[i] = Buffer.from(chunks[i], 'utf8')
      } else {
        buffers[i] = chunks[i].chunk
      }
    }

    this._write(Buffer.concat(buffers), 'binary', cb)
  }

  return stream
}

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":50,"duplexify":20,"readable-stream":62,"safe-buffer":66,"ws":84}],84:[function(_dereq_,module,exports){

var ws = null

if (typeof WebSocket !== 'undefined') {
  ws = WebSocket
} else if (typeof MozWebSocket !== 'undefined') {
  ws = MozWebSocket
} else if (typeof window !== 'undefined') {
  ws = window.WebSocket || window.MozWebSocket
}

module.exports = ws

},{}],85:[function(_dereq_,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],86:[function(_dereq_,module,exports){
module.exports={
  "name": "videomail-client",
  "version": "2.6.7",
  "description": "A wicked npm package to record videos directly in the browser, wohooo!",
  "author": "Michael Heuberger <michael.heuberger@binarykitchen.com>",
  "contributors": [
    {
      "name": "Michael Heuberger",
      "email": "michael.heuberger@binarykitchen.com"
    }
  ],
  "homepage": "https://videomail.io",
  "repository": {
    "type": "git",
    "url": "https://github.com/binarykitchen/videomail-client.git"
  },
  "license": "CC0-1.0",
  "readmeFilename": "README.md",
  "module": "src/index.js",
  "main": "dist/videomail-client.js",
  "scripts": {
    "test": "gulp test",
    "start": "NODE_NO_HTTP2=1 gulp examples",
    "audit": "yarn run audit-ci --config audit-ci.json",
    "patch": "./env/dev/release.sh --importance=patch",
    "minor": "./env/dev/release.sh --importance=minor",
    "major": "./env/dev/release.sh --importance=major"
  },
  "engines": {
    "node": ">=8.12.0",
    "yarn": ">=1.3.0",
    "npm": ">=5.4.0"
  },
  "keywords": [
    "webcam",
    "video",
    "videomail",
    "encoder",
    "getusermedia",
    "audio",
    "recorder"
  ],
  "browserslist": [
    "last 5 versions",
    "> 1%",
    "Explorer >= 11",
    "Firefox ESR",
    "iOS >= 9",
    "android >= 4"
  ],
  "dependencies": {
    "add-eventlistener-with-options": "1.25.5",
    "animitter": "3.0.0",
    "audio-sample": "1.0.5",
    "canvas-to-buffer": "1.0.14",
    "classlist.js": "1.1.20150312",
    "contains": "0.1.1",
    "create-error": "0.3.1",
    "deepmerge": "3.3.0",
    "defined": "1.0.0",
    "despot": "1.1.3",
    "document-visibility": "1.0.1",
    "element-closest": "3.0.1",
    "filesize": "4.1.2",
    "get-form-data": "2.0.0",
    "hidden": "1.1.1",
    "humanize-duration": "3.18.0",
    "hyperscript": "2.0.2",
    "insert-css": "2.0.0",
    "iphone-inline-video": "2.2.2",
    "is-power-of-two": "1.0.0",
    "keymirror": "0.1.1",
    "number-is-integer": "1.0.1",
    "readystate": "0.4.1",
    "request-frame": "1.5.3",
    "safe-json-stringify": "1.2.0",
    "superagent": "5.1.0",
    "ua-parser-js": "0.7.20",
    "websocket-stream": "5.5.0"
  },
  "devDependencies": {
    "@babel/core": "7.4.5",
    "@babel/polyfill": "7.4.4",
    "@babel/preset-env": "7.4.5",
    "audit-ci": "2.0.1",
    "autoprefixer": "9.6.0",
    "babel-eslint": "10.0.2",
    "babelify": "10.0.0",
    "body-parser": "1.19.0",
    "browserify": "16.2.3",
    "connect-send-json": "1.0.0",
    "cssnano": "4.1.10",
    "del": "4.1.1",
    "eslint": "5.16.0",
    "fancy-log": "1.3.3",
    "glob": "7.1.4",
    "gulp": "4.0.2",
    "gulp-bump": "3.1.3",
    "gulp-bytediff": "1.0.0",
    "gulp-concat": "2.6.1",
    "gulp-connect": "5.7.0",
    "gulp-derequire": "2.1.0",
    "gulp-if": "2.0.2",
    "gulp-inject-string": "1.1.2",
    "gulp-load-plugins": "1.6.0",
    "gulp-plumber": "1.2.1",
    "gulp-postcss": "8.0.0",
    "gulp-rename": "1.4.0",
    "gulp-sourcemaps": "2.6.5",
    "gulp-standard": "12.0.0",
    "gulp-stylus": "2.7.0",
    "gulp-terser": "1.2.0",
    "gulp-todo": "7.1.1",
    "minimist": "1.2.0",
    "nib": "1.1.2",
    "router": "1.3.3",
    "ssl-root-cas": "1.3.1",
    "standard": "12.0.1",
    "tape": "4.10.2",
    "tape-catch": "1.0.6",
    "tape-run": "6.0.0",
    "vinyl-buffer": "1.0.1",
    "vinyl-source-stream": "2.0.0",
    "watchify": "3.11.1"
  }
}

},{}],87:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _deepmerge = _interopRequireDefault(_dereq_("deepmerge"));

var _readystate = _interopRequireDefault(_dereq_("readystate"));

var _util = _interopRequireDefault(_dereq_("util"));

var _options = _interopRequireDefault(_dereq_("./options"));

var _constants = _interopRequireDefault(_dereq_("./constants"));

var _events = _interopRequireDefault(_dereq_("./events"));

var _collectLogger = _interopRequireDefault(_dereq_("./util/collectLogger"));

var _eventEmitter = _interopRequireDefault(_dereq_("./util/eventEmitter"));

var _container = _interopRequireDefault(_dereq_("./wrappers/container"));

var _replay = _interopRequireDefault(_dereq_("./wrappers/visuals/replay"));

var _optionsWrapper = _interopRequireDefault(_dereq_("./wrappers/optionsWrapper"));

var _browser = _interopRequireDefault(_dereq_("./util/browser"));

var _resource = _interopRequireDefault(_dereq_("./resource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var collectLogger;
var browser;

function adjustOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var localOptions = (0, _deepmerge.default)(_options.default, options, {
    arrayMerge: function arrayMerge(destination, source) {
      return source;
    }
  });
  collectLogger = collectLogger || new _collectLogger.default(localOptions);
  localOptions.logger = collectLogger;
  localOptions.debug = localOptions.logger.debug;

  _optionsWrapper.default.addFunctions(localOptions);

  return localOptions;
}

function getBrowser(localOptions) {
  if (!browser) {
    browser = new _browser.default(localOptions);
  }

  return browser;
}

var VideomailClient = function VideomailClient(options) {
  var localOptions = adjustOptions(options);
  var container = new _container.default(localOptions);
  var debug = localOptions.debug;
  var replay;

  _eventEmitter.default.call(this, localOptions, 'VideomailClient'); // expose all possible events


  this.events = _events.default;

  function build() {
    var building = false;

    _readystate.default.interactive(function (previousState) {
      debug('Client: interactive(),', 'previousState =', previousState + ',', '!building =', !building + ',', '!isBuilt() =', !container.isBuilt()); // it can happen that it gets called twice, i.E. when an error is thrown
      // in the middle of the build() fn

      if (!building && !container.isBuilt()) {
        building = true;

        try {
          container.build();
        } catch (exc) {
          throw exc;
        } finally {
          building = false;
        }
      }
    });
  }

  this.show = function () {
    if (container.isBuilt()) {
      container.show();
    } else {
      this.once(_events.default.BUILT, container.show);
    }
  }; // automatically adds a <video> element inside the given parentElement and loads
  // it with the videomail


  this.replay = function (videomail, parentElement) {
    function buildReplay() {
      if (typeof parentElement === 'string') {
        parentElement = document.getElementById(parentElement);
      }

      if (!parentElement) {
        if (!container.isBuilt()) {
          // this will try build all over again
          container.build();
        }

        if (!container.hasElement()) {
          // if container.setElement() failed too, then complain
          _readystate.default.removeAllListeners();

          throw new Error('Unable to replay video without a container nor parent element.');
        }
      } else {
        if (container.isOutsideElementOf(parentElement)) {
          replay = new _replay.default(parentElement, localOptions);
          replay.build();
        }
      }

      if (!replay) {
        replay = container.getReplay();
      }

      if (!parentElement) {
        parentElement = replay.getParentElement();
      }

      if (videomail) {
        videomail = container.addPlayerDimensions(videomail, parentElement);
      }

      if (container.isOutsideElementOf(parentElement)) {
        // replay element must be outside of the container
        container.hideForm({
          deep: true
        });
      } else {
        container.loadForm(videomail);
      } // slight delay needed to avoid HTTP 416 errors (request range unavailable)


      setTimeout(function () {
        replay.setVideomail(videomail);
        container.showReplayOnly();
      }, 10e2); // not sure, but probably can be reduced a bit
    }

    _readystate.default.interactive(buildReplay);
  };

  this.startOver = function (params) {
    if (replay) {
      replay.hide();
      replay.reset();
    }

    container.startOver(params);
  };

  this.unload = function (e) {
    _readystate.default.removeAllListeners();

    container.unload(e);
  };

  this.hide = function () {
    container.hide();
  };

  this.get = function (alias, cb) {
    new _resource.default(localOptions).get(alias, function (err, videomail) {
      if (err) {
        cb(err);
      } else {
        cb(null, container.addPlayerDimensions(videomail));
      }
    });
  };

  this.canRecord = function () {
    return getBrowser(localOptions).canRecord();
  }; // return true when a video has been recorded but is not sent yet


  this.isDirty = function () {
    return container.isDirty();
  };

  this.isRecording = function () {
    return container.isRecording();
  };

  this.submit = function () {
    container.submit();
  };

  this.getLogLines = function () {
    if (localOptions.logger && localOptions.logger.getLines) {
      return localOptions.logger.getLines();
    }
  };

  build();
};

_util.default.inherits(VideomailClient, _eventEmitter.default);

Object.keys(_constants.default.public).forEach(function (name) {
  VideomailClient[name] = _constants.default.public[name];
}); // just another convenient thing

VideomailClient.events = _events.default;
var _default = VideomailClient;
exports.default = _default;

},{"./constants":88,"./events":89,"./options":90,"./resource":91,"./util/browser":94,"./util/collectLogger":95,"./util/eventEmitter":96,"./wrappers/container":103,"./wrappers/optionsWrapper":106,"./wrappers/visuals/replay":116,"deepmerge":15,"readystate":63,"util":81}],88:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// constants (changing these only break down functionality, so be careful)
var _default = {
  SITE_NAME_LABEL: 'x-videomail-site-name',
  VERSION_LABEL: 'videomailClientVersion',
  public: {
    ENC_TYPE_APP_JSON: 'application/json',
    ENC_TYPE_FORM: 'application/x-www-form-urlencoded'
  }
};
exports.default = _default;

},{}],89:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _keymirror = _interopRequireDefault(_dereq_("keymirror"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _keymirror.default)({
  BUILT: null,
  // all dom elements are ready, are in the DOM
  FORM_READY: null,
  // form is ready, available in the DOM
  LOADING_USER_MEDIA: null,
  // asking for webcam access
  USER_MEDIA_READY: null,
  // user media (= webcam) is ready, loaded
  CONNECTING: null,
  // socket is connecting to server
  CONNECTED: null,
  // socket is connected to server
  DISCONNECTED: null,
  // socket to server is disconnected
  COUNTDOWN: null,
  // countdown for recording has started
  RECORDING: null,
  // webcam is recording
  STOPPING: null,
  // recording is being stopped (= preview)
  PROGRESS: null,
  // start sending
  BEGIN_AUDIO_ENCODING: null,
  // encoding video
  BEGIN_VIDEO_ENCODING: null,
  // encoding video
  RESETTING: null,
  // resetting everything to go back to initial state
  PAUSED: null,
  // recording is being paused
  RESUMING: null,
  // recording is resumed
  PREVIEW: null,
  // video preview is set
  PREVIEW_SHOWN: null,
  // video preview is shown
  REPLAY_SHOWN: null,
  // submitted video is shown
  INVALID: null,
  // form is invalid
  VALIDATING: null,
  // form is being validated
  VALID: null,
  // form is valid
  SUBMITTING: null,
  // form is being submitted
  SUBMITTED: null,
  // form has been successfully submitted
  ERROR: null,
  // an error occured
  BLOCKING: null,
  // something serious, most likely an error, is shown and blocks
  SENDING_FIRST_FRAME: null,
  // emitted before the first frame is being computed
  FIRST_FRAME_SENT: null,
  // emitted once when fist frame has been sent to server
  HIDE: null,
  // emitted when hidden
  NOTIFYING: null,
  // notifies user about something (not blocking)
  ENABLING_AUDIO: null,
  // about to enable audio
  DISABLING_AUDIO: null,
  // about to disable audio
  LOADED_META_DATA: null,
  // raised when webcam knows its dimensions
  EVENT_EMITTED: null,
  // for debugging only, is emitted when an event is emitted lol,
  GOING_BACK: null,
  // switch from replaying back to recording
  STARTING_OVER: null,
  // starting all over again back to its inital state
  ASKING_WEBCAM_PERMISSION: null,
  // when about to ask for webcam permissions
  VISIBLE: null,
  // document just became visible
  INVISIBLE: null,
  // document just became INvisible
  SWITCH_FACING_MODE: null // to switch camera on mobiles between fron and back

});

exports.default = _default;

},{"keymirror":44}],90:[function(_dereq_,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _package = _dereq_("../package.json");

var PRODUCTION = process.env.NODE_ENV === 'production';
/* eslint-disable no-multi-spaces */

/* eslint indent: ["error", 2, { "ignoreComments": true }] */

var _default = {
  logger: null,
  // define logging instance. leave null for default, console.
  logStackSize: 30,
  // limits the stack size of log outputs to collect
  verbose: !PRODUCTION,
  // set true to log more info
  baseUrl: 'https://videomail.io',
  // leave as it, permanent url to post videos
  socketUrl: 'wss://videomail.io',
  // leave as it, permanent url to send frames
  siteName: 'videomail-client-demo',
  // Required for API, use https://videomail.io/whitelist
  cache: true,
  // reduces GET queries when loading videos
  insertCss: true,
  // inserts predefined CSS, see examples
  enablePause: true,
  // enable pause/resume button
  enableAutoPause: true,
  // automatically pauses when window becomes inactive
  enableSpace: true,
  // hitting space can pause recording
  submitWithVideomail: false,
  // when enabled, all videomail metadata is submitted
  // under the `videomail` key inside the form data body.
  disableSubmit: false,
  // set this to true if you do not want to submit videos,
  // but just want to record and replay these temporarily
  enableAutoValidation: true,
  // automatically validates all form inputs if any exist and
  // does not /enable disable submit button after recording
  // when something else seems invalid.
  enableAutoSubmission: true,
  // automatically submits the form where the videomail-client
  // appears upon press of submit button. disable it when
  // you want a framework to deal with the form submission itself.
  enctype: 'application/json',
  // enctype for the form submission. currently implemented are:
  // 'application/json' and 'application/x-www-form-urlencoded'
  // default CSS selectors you can alter, see examples
  selectors: {
    containerId: 'videomail',
    replayClass: 'replay',
    userMediaClass: 'userMedia',
    visualsClass: 'visuals',
    buttonClass: null,
    // can also be used as a default class for all buttons
    buttonsClass: 'buttons',
    recordButtonClass: 'record',
    pauseButtonClass: 'pause',
    resumeButtonClass: 'resume',
    previewButtonClass: 'preview',
    recordAgainButtonClass: 'recordAgain',
    submitButtonClass: 'submit',
    subjectInputName: 'subject',
    // the form input name for subject
    fromInputName: 'from',
    // the form input name for the from email
    toInputName: 'to',
    // the form input name for the to email
    bodyInputName: 'body',
    // the form input name for the message (body)
    sendCopyInputName: 'sendCopy',
    // the form checkbox name for sending myself a copy
    keyInputName: 'videomail_key',
    parentKeyInputName: 'videomail_parent_key',
    aliasInputName: 'videomail_alias',
    formId: null,
    // automatically detects form if any
    submitButtonId: null,
    // semi-automatically detects submit button in the form
    // but if that does not work, try using the
    submitButtonSelector: null // submitButtonSelector

  },
  audio: {
    enabled: false,
    // set to true for experimential audio recording
    'switch': false,
    // enables a switcher for audio recording (on/off)
    volume: 0.2,
    // must be between 0 .. 1 but 0.20 is recommeded to avoid
    // distorting at the higher volume peaks
    bufferSize: 2048 // decides how often the audio is being sampled, must be a power of two.
    // the higher the less traffic, but harder to adjust with rubberband
    // to match with the video length on server side during encoding

  },
  video: {
    fps: 15,
    // depends on your connection
    limitSeconds: 30,
    // recording automatically stops after that limit
    countdown: 3,
    // set it to 0 or false to disable it
    // it is recommended to set one dimension only and leave the other one to auto
    // because each webcam has a different aspect ratio
    width: 'auto',
    // or use an integer for exact pixels
    height: 'auto',
    // or use an integer for exact pixels
    facingMode: 'user',
    // can be 'user', 'environment', 'left' or 'right'. useful for mobiles.
    facingModeButton: false
  },
  image: {
    quality: 0.44,
    types: ['webp', 'jpeg'] // recommended settings to make most of all browsers

  },
  // alter these text for internationalisation
  text: {
    pausedHeader: 'Paused',
    pausedHint: null,
    sending: 'Teleporting',
    encoding: 'Encoding',
    limitReached: 'Limit reached',
    buttons: {
      'record': 'Record video',
      'recordAgain': 'Record again',
      'resume': 'Resume',
      'pause': 'Pause',
      'preview': 'Preview'
    }
  },
  notifier: {
    entertain: false,
    // when true, user is entertained while waiting, see examples
    entertainClass: 'bg',
    entertainLimit: 6,
    entertainInterval: 9000
  },
  timeouts: {
    userMedia: 20e3,
    // in milliseconds, increase if you want user give more time to enable webcam
    connection: 1e4,
    // in seconds, increase if api is slow
    pingInterval: 45e3 // in milliseconds, keeps webstream (connection) alive when pausing

  },
  callbacks: {
    // a custom callback to tweak form data before posting to server
    // this is for advanced use only and shouldn't be used if possible
    adjustFormDataBeforePosting: null
  },
  defaults: {
    from: null,
    // define default FROM email address
    to: null,
    // define default TO email address
    subject: null,
    // define default subject line
    body: null // define default body content

  },
  // a special flag to indicate that everything to be initialised
  // serves only for playing existing videomails with the replay function
  playerOnly: false,
  // show errors inside the container?
  displayErrors: true,
  // true = all form inputs get disabled and disappear when browser can't record
  adjustFormOnBrowserError: false,
  // when true, any errors will be sent to the videomail server for analysis
  // ps: can be a function too returning a boolean
  reportErrors: false,
  // just for testing purposes to simulate browser agent handling
  fakeUaString: null,
  version: _package.version
};
exports.default = _default;

}).call(this,_dereq_('_process'))

},{"../package.json":86,"_process":50}],91:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _superagent = _interopRequireDefault(_dereq_("superagent"));

var _constants = _interopRequireDefault(_dereq_("./constants"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CACHE_KEY = 'alias';

function _default(options) {
  var cache = {};

  function applyDefaultValue(videomail, name) {
    if (options.defaults[name] && !videomail[name]) {
      videomail[name] = options.defaults[name];
    }

    return videomail;
  }

  function applyDefaultValues(videomail) {
    if (options.defaults) {
      videomail = applyDefaultValue(videomail, 'from');
      videomail = applyDefaultValue(videomail, 'to');
      videomail = applyDefaultValue(videomail, 'subject');
      videomail = applyDefaultValue(videomail, 'body');
    }

    return videomail;
  }

  function packError(err, res) {
    if (res && res.body && res.body.error) {
      // use the server generated text instead of the superagent's default text
      err = res.body.error;

      if (!err.message && res.text) {
        err.message = res.text;
      }
    }

    return err;
  }

  function fetch(alias, cb) {
    _superagent.default.get('/videomail/' + alias + '/snapshot').set('Accept', 'application/json').set(_constants.default.SITE_NAME_LABEL, options.siteName).timeout(options.timeouts.connection).end(function (err, res) {
      err = packError(err, res);

      if (err) {
        cb(err);
      } else {
        var videomail = res.body ? res.body : null;

        if (options.cache) {
          cache[CACHE_KEY] = videomail;
        }

        cb(null, videomail);
      }
    });
  }

  function write(method, videomail, identifier, cb) {
    if (!cb) {
      cb = identifier;
      identifier = null;
    }

    var queryParams = {};
    var url = options.baseUrl + '/videomail/';
    var request;

    if (identifier) {
      url += identifier;
    }

    request = (0, _superagent.default)(method, url);
    queryParams[_constants.default.SITE_NAME_LABEL] = options.siteName;
    request.query(queryParams).send(videomail).timeout(options.timeout).end(function (err, res) {
      err = packError(err, res);

      if (err) {
        cb(err);
      } else {
        if (options.cache && videomail[CACHE_KEY]) {
          cache[videomail[CACHE_KEY]] = res.body.videomail;
        }

        cb(null, res.body.videomail, res.body);
      }
    });
  }

  this.get = function (alias, cb) {
    if (options.cache && cache[alias]) {
      // keep all callbacks async
      setTimeout(function () {
        cb(null, cache[alias]);
      }, 0);
    } else {
      fetch(alias, cb);
    }
  };

  this.reportError = function (err, cb) {
    var queryParams = {};
    var url = options.baseUrl + '/client-error/';
    var request = (0, _superagent.default)('post', url);
    queryParams[_constants.default.SITE_NAME_LABEL] = options.siteName;
    request.query(queryParams).send(err).timeout(options.timeout).end(function (err, res) {
      err = packError(err, res);

      if (err) {
        cb && cb(err);
      } else {
        cb && cb();
      }
    });
  };

  this.post = function (videomail, cb) {
    videomail = applyDefaultValues(videomail); // always good to know the version of the client
    // the videomail was submitted with

    videomail[_constants.default.VERSION_LABEL] = options.version;

    if (options.callbacks.adjustFormDataBeforePosting) {
      options.callbacks.adjustFormDataBeforePosting(videomail, function (err, adjustedVideomail) {
        if (err) {
          cb(err);
        } else {
          write('post', adjustedVideomail, cb);
        }
      });
    } else {
      write('post', videomail, cb);
    }
  };

  this.put = function (videomail, cb) {
    write('put', videomail, videomail.key, cb);
  };

  this.form = function (formData, url, cb) {
    var formType;

    switch (options.enctype) {
      case _constants.default.public.ENC_TYPE_APP_JSON:
        formType = 'json';
        break;

      case _constants.default.public.ENC_TYPE_FORM:
        formType = 'form';
        break;

      default:
        // keep all callbacks async
        setTimeout(function () {
          cb(new Error('Invalid enctype given: ' + options.enctype));
        }, 0);
    }

    if (formType) {
      _superagent.default.post(url).type(formType).send(formData).timeout(options.timeout).end(function (err, res) {
        err = packError(err, res);

        if (err) {
          cb(err);
        } else {
          cb(null, res);
        }
      });
    }
  };
}

},{"./constants":88,"superagent":70}],92:[function(_dereq_,module,exports){
"use strict";

module.exports = '@-webkit-keyframes blink{0%{opacity:.9}35%{opacity:.9}50%{opacity:.1}85%{opacity:.1}to{opacity:.9}}@keyframes blink{0%{opacity:.9}35%{opacity:.9}50%{opacity:.1}85%{opacity:.1}to{opacity:.9}}.IIV::-webkit-media-controls-play-button,.IIV::-webkit-media-controls-start-playback-button{opacity:0;pointer-events:none;width:5px}.videomail .visuals{position:relative}.videomail .visuals video.replay{width:100%;height:100%}.videomail .countdown,.videomail .pausedHeader,.videomail .pausedHint,.videomail .recordNote,.videomail .recordTimer{margin:0;height:auto}.videomail .countdown,.videomail .facingMode,.videomail .paused,.videomail .recordNote,.videomail .recordTimer,.videomail noscript{position:absolute}.videomail .countdown,.videomail .pausedHeader,.videomail .pausedHint,.videomail .recordNote,.videomail .recordTimer,.videomail noscript{font-weight:700}.videomail .countdown,.videomail .paused,.videomail noscript{width:100%;top:50%;-webkit-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%)}.videomail .countdown,.videomail .pausedHeader,.videomail .pausedHint{text-align:center;text-shadow:0 0 2px #fff}.videomail .countdown,.videomail .pausedHeader{opacity:.85;font-size:440%}.videomail .pausedHint{font-size:150%}.videomail .facingMode{right:.7em;bottom:.6em;background:rgba(10,10,10,.3);color:hsla(0,0%,96.1%,.9);font-family:monospace;border:none;padding:.1em .3em;font-size:1.2em;z-index:10;outline:none;-webkit-transition:all .2s ease;-o-transition:all .2s ease;transition:all .2s ease}.videomail .facingMode:hover{background:rgba(50,50,50,.7);cursor:pointer}.videomail .recordNote,.videomail .recordTimer{right:.7em;background:rgba(10,10,10,.8);padding:.4em .4em .3em;-webkit-transition:all 1s ease;-o-transition:all 1s ease;transition:all 1s ease;color:#00d814;font-family:monospace;opacity:.9}.videomail .recordNote.near,.videomail .recordTimer.near{color:#eb9369}.videomail .recordNote.nigh,.videomail .recordTimer.nigh{color:#ea4b2a}.videomail .recordTimer{top:.7em}.videomail .recordNote{top:3.6em}.videomail .recordNote:before{content:"REC";-webkit-animation:blink 1s infinite;animation:blink 1s infinite}.videomail .notifier{overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;height:100%}.videomail .radioGroup{display:block}.videomail video{margin-bottom:0}';

},{}],93:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _isPowerOfTwo = _interopRequireDefault(_dereq_("is-power-of-two"));

var _audioSample = _interopRequireDefault(_dereq_("audio-sample"));

var _videomailError = _interopRequireDefault(_dereq_("./videomailError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANNELS = 1; // for inspiration see
// https://github.com/saebekassebil/microphone-stream
// todo code needs rewrite

function _default(userMedia, options) {
  var scriptProcessor;
  var audioInput;
  var vcAudioContext;

  function getAudioContextClass() {
    return window.AudioContext || window.webkitAudioContext;
  }

  function hasAudioContext() {
    return !!getAudioContextClass() && !!getAudioContext();
  }

  function getAudioContext() {
    // instantiate only once
    if (!vcAudioContext) {
      var AudioContext = getAudioContextClass();
      vcAudioContext = new AudioContext();
    }

    return vcAudioContext;
  }

  function onAudioProcess(e, cb) {
    if (!userMedia.isRecording() || userMedia.isPaused()) {
      return;
    } // Returns a Float32Array containing the PCM data associated with the channel,
    // defined by the channel parameter (with 0 representing the first channel)


    var float32Array = e.inputBuffer.getChannelData(0);
    cb(new _audioSample.default(float32Array));
  }

  this.init = function (localMediaStream) {
    options.debug('AudioRecorder: init()'); // creates an audio node from the microphone incoming stream

    var volume = getAudioContext().createGain();

    try {
      audioInput = getAudioContext().createMediaStreamSource(localMediaStream);
    } catch (exc) {
      throw _videomailError.default.create('Webcam has no audio', exc.toString(), options);
    }

    if (!(0, _isPowerOfTwo.default)(options.audio.bufferSize)) {
      throw _videomailError.default.create('Audio buffer size must be a power of two.', options);
    } else if (!options.audio.volume || options.audio.volume > 1) {
      throw _videomailError.default.create('Audio volume must be between zero and one.', options);
    }

    volume.gain.value = options.audio.volume; // Create a ScriptProcessorNode with the given bufferSize and
    // a single input and output channel

    scriptProcessor = getAudioContext().createScriptProcessor(options.audio.bufferSize, CHANNELS, CHANNELS); // connect stream to our scriptProcessor

    audioInput.connect(scriptProcessor); // connect our scriptProcessor to the previous destination

    scriptProcessor.connect(getAudioContext().destination); // connect volume

    audioInput.connect(volume);
    volume.connect(scriptProcessor);
  };

  this.record = function (cb) {
    options.debug('AudioRecorder: record()');

    scriptProcessor.onaudioprocess = function (e) {
      onAudioProcess(e, cb);
    };
  };

  this.stop = function () {
    options.debug('AudioRecorder: stop()');

    if (scriptProcessor) {
      scriptProcessor.onaudioprocess = undefined;
    }

    if (audioInput) {
      audioInput.disconnect();
    } // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/close


    if (hasAudioContext()) {
      if (getAudioContext().close) {
        getAudioContext().close().then(function () {
          options.debug('AudioRecorder: audio context is closed');
          vcAudioContext = null;
        }).catch(function (err) {
          throw _videomailError.default.create(err, options);
        });
      } else {
        vcAudioContext = null;
      }
    }
  };

  this.getSampleRate = function () {
    if (hasAudioContext()) {
      return getAudioContext().sampleRate;
    } else {
      return -1;
    }
  };
}

},{"./videomailError":101,"audio-sample":4,"is-power-of-two":42}],94:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _uaParserJs = _interopRequireDefault(_dereq_("ua-parser-js"));

var _defined = _interopRequireDefault(_dereq_("defined"));

var _videomailError = _interopRequireDefault(_dereq_("./videomailError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Browser = function Browser(options) {
  options = options || {};
  var firefoxDownload = 'http://www.mozilla.org/firefox/update/';
  var edgeDownload = 'https://www.microsoft.com/en-us/download/details.aspx?id=48126';
  var chromeDownload = 'http://www.google.com/chrome/';
  var chromiumDownload = 'http://www.chromium.org/getting-involved/download-chromium';
  var browseHappyLink = 'http://browsehappy.com';
  var ua = (0, _defined.default)(options.fakeUaString, typeof window !== 'undefined' && window.navigator && window.navigator.userAgent, '');
  var uaParser = new _uaParserJs.default(ua).getResult();
  var isIOS = uaParser.os.name === 'iOS';
  var browserVersion = parseFloat(uaParser.browser.version);
  var isChrome = uaParser.browser.name === 'Chrome';
  var isChromium = uaParser.browser.name === 'Chromium';
  var firefox = uaParser.browser.name === 'Firefox';
  var osVersion = parseFloat(uaParser.os.version);
  var isWindows = uaParser.os.name === 'Windows';
  var isEdge = uaParser.browser.name === 'Edge' || isWindows && osVersion >= 10;
  var isIE = /IE/.test(uaParser.browser.name);
  var isSafari = /Safari/.test(uaParser.browser.name);
  var isOpera = /Opera/.test(uaParser.browser.name);
  var isAndroid = /Android/.test(uaParser.os.name);
  var chromeBased = isChrome || isChromium;
  var isFacebook = uaParser.browser.name === 'Facebook'; // Facebook App for iOS & Android

  var isMobile = isIOS || isAndroid;
  var isOkSafari = isSafari && browserVersion >= 11;
  var isOkIOS = isIOS && osVersion >= 11;
  var isBadIOS = isIOS && osVersion < 11;
  var okBrowser = chromeBased || firefox || isAndroid || isOpera || isEdge || isOkSafari || isOkIOS;
  var self = this;
  var videoType;

  function getRecommendation() {
    var warning;

    if (firefox) {
      if (isIOS) {
        warning = 'Firefox on iOS is not ready for cameras yet. Hopefully in near future ...';
      } else {
        warning = 'Probably you need to <a href="' + firefoxDownload + '" target="_blank">' + 'upgrade Firefox</a> to fix this.';
      }
    } else if (isChrome) {
      if (isIOS) {
        warning = 'Use Safari instead. Apple doesn\'t give Chrome access to iPhone cameras (booo).';
      } else {
        warning = 'Probably you need to <a href="' + chromeDownload + '" target="_blank">' + 'upgrade Chrome</a> to fix this.';
      }
    } else if (isChromium) {
      warning = 'Probably you need to <a href="' + chromiumDownload + '" target="_blank">' + 'upgrade Chromium</a> to fix this.';
    } else if (isIE) {
      warning = 'Instead of Internet Explorer you need to upgrade to' + ' <a href="' + edgeDownload + '" target="_blank">Edge</a>.';
    } else if (isOkSafari) {
      warning = 'Probably you need to shut down Safari and restart it, this for correct webcam access.';
    } else if (isSafari) {
      warning = 'Safari below version 11 has no webcam support.<br/>Better upgrade Safari or pick' + ' <a href="' + chromeDownload + '" target="_blank">Chrome</a>,' + ' <a href="' + firefoxDownload + '" target="_blank">Firefox</a> or Android.';
    }

    return warning;
  }

  function getUserMediaWarning() {
    var warning;

    if (isBadIOS) {
      warning = 'On iPads or iPhones below iOS v11 this camera feature is missing.<br/><br/>' + 'For now, we recommend you to upgrade iOS or to use an Android device.';
    } else {
      warning = getRecommendation();
    }

    if (!warning) {
      if (self.isChromeBased() || self.isFirefox() || isSafari) {
        warning = 'For the webcam feature, your browser needs an upgrade.';
      } else {
        if (isFacebook) {
          warning = 'Hence we recommend you to use a real browser like ' + '<a href="' + chromeDownload + '" target="_blank">Chrome</a>, ' + '<a href="' + firefoxDownload + '" target="_blank">Firefox</a> or ' + '<a href="' + edgeDownload + '" target="_blank">Edge</a>.';
        } else {
          warning = 'Hence we recommend you to use either ' + '<a href="' + chromeDownload + '" target="_blank">Chrome</a>, ' + '<a href="' + firefoxDownload + '" target="_blank">Firefox</a>, ' + '<a href="' + edgeDownload + '" target="_blank">Edge</a> or Android.';
        }
      }
    }

    return warning;
  }

  function getPlaybackWarning() {
    var warning = getRecommendation();

    if (!warning) {
      warning = '<a href="' + browseHappyLink + '" target="_blank">Upgrading your browser</a> might help.';
    }

    return warning;
  }

  function canPlayType(video, type) {
    var canPlayType;

    if (video && video.canPlayType) {
      canPlayType = video.canPlayType('video/' + type);
    }

    return canPlayType;
  } // just temporary


  this.canRecord = function () {
    var hasNavigator = typeof navigator !== 'undefined';
    var canRecord = false;

    if (hasNavigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      canRecord = true;
    } else {
      var getUserMediaType = hasNavigator && _typeof(navigator.getUserMedia_);

      canRecord = getUserMediaType === 'function';
    }

    return canRecord;
  };

  this.checkRecordingCapabilities = function () {
    var err;

    if (!okBrowser || !this.canRecord()) {
      var classList = [];

      if (isBadIOS) {
        classList.push(_videomailError.default.IOS_PROBLEM);
      } else {
        classList.push(_videomailError.default.BROWSER_PROBLEM);
      }

      var message; // good to be able to distinguish between two reasons why and what sort of camera it is

      if (!okBrowser) {
        if (isMobile) {
          message = 'Sorry, your browser is unable to use your mobile camera';
        } else {
          message = 'Sorry, your browser is unable to use webcams';
        }
      } else {
        if (isMobile) {
          if (isFacebook) {
            message = 'Sorry, the Facebook app cannot record from your mobile camera';
          } else {
            message = 'Sorry, your browser cannot record from your mobile camera';
          }
        } else {
          message = 'Sorry, your browser cannot record from webcams';
        }
      }

      if (isBadIOS) {
        // on older iphones length of JSON is limited and breaking
        // so just dont report and ignore
        options.reportErrors = false;
      }

      err = _videomailError.default.create({
        message: message
      }, getUserMediaWarning(), options, {
        classList: classList
      });
    }

    return err;
  };

  this.checkPlaybackCapabilities = function (video) {
    options.debug('Browser: checkPlaybackCapabilities()');
    var err;
    var message;

    if (!video) {
      message = 'No HTML5 support for video tag!';
    } else if (!this.getVideoType(video)) {
      message = 'Your old browser cannot support modern video codecs';
    } else if (!video.setAttribute) {
      // fixes "Not implemented" error on older browsers
      message = 'Unable to set video attributes in your old browser';
    }

    if (message) {
      err = _videomailError.default.create(message, getPlaybackWarning(), options);
    }

    return err;
  };

  this.checkBufferTypes = function () {
    var err;

    if (typeof window === 'undefined' || typeof window.atob === 'undefined') {
      err = _videomailError.default.create('atob is not supported', options);
    } else if (typeof window.ArrayBuffer === 'undefined') {
      err = _videomailError.default.create('ArrayBuffers are not supported', options);
    } else if (typeof window.Uint8Array === 'undefined') {
      err = _videomailError.default.create('Uint8Arrays are not supported', options);
    }

    return err;
  };

  this.getVideoType = function (video) {
    if (!videoType) {
      // there is a bug in canPlayType within chrome for mp4
      if (canPlayType(video, 'mp4') && !chromeBased) {
        videoType = 'mp4';
      } else if (canPlayType(video, 'webm')) {
        videoType = 'webm';
      }
    }

    return videoType;
  };

  this.getNoAccessIssue = function () {
    var message = 'Unable to access webcam';
    var explanation;

    if (this.isChromeBased()) {
      explanation = 'Click on the allow button to grant access to your webcam.';
    } else if (this.isFirefox()) {
      explanation = 'Please grant Firefox access to your webcam.';
    } else {
      explanation = 'Your system does not let your browser access your webcam.';
    }

    return _videomailError.default.create(message, explanation, options);
  };

  this.isChromeBased = function () {
    return chromeBased;
  };

  this.isFirefox = function () {
    return firefox;
  };

  this.isEdge = function () {
    return isEdge;
  };

  this.isAndroid = function () {
    return isAndroid;
  };

  this.isMobile = function () {
    return uaParser.device.type === 'mobile';
  };

  this.isOkSafari = function () {
    return isOkSafari;
  };

  this.getUsefulData = function () {
    return {
      browser: uaParser.browser,
      device: uaParser.device,
      os: uaParser.os,
      engine: uaParser.engine,
      userAgent: ua
    };
  };
};

var _default = Browser; // so that we also can require() it from videomailError.js within

exports.default = _default;
module.exports = Browser;

},{"./videomailError":101,"defined":16,"ua-parser-js":78}],95:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _util = _interopRequireDefault(_dereq_("util"));

var _browser = _interopRequireDefault(_dereq_("./browser"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var localOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var browser = new _browser.default(localOptions);
  var logger = localOptions.logger || console;
  var containerId = localOptions.selectors && localOptions.selectors.containerId || 'undefined container id';
  var stack = [];

  function lifo(level, parameters) {
    var line = _util.default.format.apply(_util.default, parameters);

    if (stack.length > localOptions.logStackSize) {
      stack.pop();
    }

    stack.push('[' + level + '] ' + line);
    return line;
  }

  function addContainerId(firstArgument) {
    return '#' + containerId + ' [' + new Date().toLocaleTimeString() + '] > ' + firstArgument;
  } // workaround: since we cannot overwrite console.log without having the correct file and line number
  // we'll use groupCollapsed() and trace() instead to get these.


  this.debug = function () {
    // always add it for better client error reports
    var args = [].slice.call(arguments, 0);
    args[0] = addContainerId(args[0]);
    var output = lifo('debug', args);

    if (localOptions.verbose) {
      if (browser.isFirefox()) {
        logger.debug(output);
      } else if (logger.groupCollapsed) {
        logger.groupCollapsed(output);
        logger.trace('Trace');
        logger.groupEnd();
      } else if (logger.debug) {
        logger.debug(output);
      } else {
        // last resort if everything else fails for any weird reasons
        console.log(output);
      }
    }
  };

  this.error = function () {
    var args = [].slice.call(arguments, 0);
    args[0] = addContainerId(args[0]);
    logger.error(lifo('error', args));
  };

  this.warn = function () {
    var args = [].slice.call(arguments, 0);
    args[0] = addContainerId(args[0]);
    logger.warn(lifo('warn', args));
  };

  this.getLines = function () {
    return stack;
  };
}

},{"./browser":94,"util":81}],96:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _despot = _interopRequireDefault(_dereq_("despot"));

var _videomailError = _interopRequireDefault(_dereq_("./videomailError"));

var _events = _interopRequireDefault(_dereq_("./../events"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: MAKE EVENT EMITTING IN DESPOT NOT GLOBAL BUT BY CONTAINER ID INSTEAD
function _default(options, name) {
  this.emit = function (event) {
    var args = Array.prototype.slice.call(arguments, 0);

    if (!event) {
      throw _videomailError.default.create('You cannot emit without an event.', options);
    } // Automatically convert errors to videomail errors


    if (event === _events.default.ERROR) {
      var err = args[1];
      err = _videomailError.default.create(err, options);
      args[1] = err;
    }

    if (options.debug) {
      if (event !== 'removeListener' && event !== 'newListener') {
        var moreArguments;

        if (args[1]) {
          moreArguments = args.slice(1);
        }

        if (moreArguments) {
          options.debug('%s emits: %s', name, event, moreArguments);
        } else {
          options.debug('%s emits: %s', name, event);
        }
      }
    }

    var result = _despot.default.emit.apply(_despot.default, args); // Todo: have this emitted through a configuration because it is pretty noisy
    // if (event !== Events.EVENT_EMITTED)
    //     this.emit(Events.EVENT_EMITTED, event)


    return result;
  };

  this.on = function (eventName, cb) {
    return _despot.default.on(eventName, cb);
  };

  this.once = function (eventName, cb) {
    return _despot.default.once(eventName, cb);
  };

  this.listeners = function (eventName) {
    return _despot.default.listeners(eventName);
  };

  this.removeListener = function (eventName, cb) {
    return _despot.default.removeListener(eventName, cb);
  };

  this.removeAllListeners = function () {
    _despot.default.removeAllListeners();
  };
}

},{"./../events":89,"./videomailError":101,"despot":17}],97:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _filesize2 = _interopRequireDefault(_dereq_("filesize"));

var _humanizeDuration = _interopRequireDefault(_dereq_("humanize-duration"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// todo get rid of this class and use those imports directly
var _default = {
  filesize: function filesize(bytes, round) {
    return (0, _filesize2.default)(bytes, {
      round: round
    });
  },
  toTime: function toTime(t) {
    return (0, _humanizeDuration.default)(t);
  }
};
exports.default = _default;

},{"filesize":25,"humanize-duration":32}],98:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// taken from
// https://bbc.github.io/tal/jsdoc/events_mediaevent.js.html
var _default = [// The user agent begins looking for media data, as part of
// the resource selection algorithm.
'loadstart', // The user agent is intentionally not currently fetching media data,
// but does not have the entire media resource downloaded. networkState equals NETWORK_IDLE
'suspend', // Playback has begun. Fired after the play() method has returned,
// or when the autoplay attribute has caused playback to begin.
// paused is newly false.
// 'play', commented out since it has special treatment
// The user agent has just determined the duration and dimensions of the
// media resource and the timed tracks are ready.
// readyState is newly equal to HAVE_METADATA or greater for the first time.
// 'loadedmetadata', commented out since it has special treatment
// The user agent is fetching media data.
'progress', // The user agent is intentionally not currently fetching media data,
// but does not have the entire media resource downloaded.
// 'suspend', // commented out, we are already listening to it in code
// Event The user agent stops fetching the media data before it is completely downloaded,
// but not due to an error.  error is an object with the code MEDIA_ERR_ABORTED.
'abort', // A media element whose networkState was previously not in the NETWORK_EMPTY
// state has just switched to that state (either because of a fatal error
// during load that's about to be reported, or because the load() method was
// invoked while the resource selection algorithm was already running).
'emptied', // The user agent is trying to fetch media data, but data is
// unexpectedly not forthcoming
'stalled', // Playback has been paused. Fired after the pause() method has returned.
// paused is newly true.
'pause', // The user agent can render the media data at the current playback position
// for the first time.
// readyState newly increased to HAVE_CURRENT_DATA or greater for the first time.
'loadeddata', // Playback has stopped because the next frame is not available, but the user
// agent expects that frame to become available in due course.
// readyState is newly equal to or less than HAVE_CURRENT_DATA,
// and paused is false. Either seeking is true, or the current playback
// position is not contained in any of the ranges in buffered.
// It is possible for playback to stop for two other reasons without
// paused being false, but those two reasons do not fire this event:
// maybe playback ended, or playback stopped due to errors.
'waiting', // Playback has started. readyState is newly equal to or greater than
// HAVE_FUTURE_DATA, paused is false, seeking is false,
// or the current playback position is contained in one of the ranges in buffered.
'playing', // The user agent can resume playback of the media data,
// but estimates that if playback were to be started now, the media resource
// could not be rendered at the current playback rate up to its end without
// having to stop for further buffering of content.
// readyState newly increased to HAVE_FUTURE_DATA or greater.
'canplay', // The user agent estimates that if playback were to be started now,
// the media resource could be rendered at the current playback rate
// all the way to its end without having to stop for further buffering.
// readyState is newly equal to HAVE_ENOUGH_DATA.
'canplaythrough', // The seeking IDL attribute changed to true and the seek operation is
// taking long enough that the user agent has time to fire the event.
'seeking', // The seeking IDL attribute changed to false.
'seeked', // Playback has stopped because the end of the media resource was reached.
// currentTime equals the end of the media resource; ended is true.
'ended', // Either the defaultPlaybackRate or the playbackRate attribute
// has just been updated.
'ratechange', // The duration attribute has just been updated.
'durationchange', // Either the volume attribute or the muted attribute has changed.
// Fired after the relevant attribute's setter has returned.
'volumechange' // commented out, happen too often
// The current playback position changed as part of normal playback or in
// an especially interesting way, for example discontinuously.
// 'timeupdate'
];
exports.default = _default;

},{}],99:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _safeJsonStringify = _interopRequireDefault(_dereq_("safe-json-stringify"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var DASH = '- ';
var SEPARATOR = '<br/>' + DASH;

function arrayToString(array) {
  if (array.length > 0) {
    var lines = [];
    array.forEach(function (element) {
      if (element) {
        lines.push((0, _safeJsonStringify.default)(element));
      }
    });
    return DASH + lines.join(SEPARATOR);
  }
}

function objectToString(object, options) {
  var propertyNames = Object.getOwnPropertyNames(object);
  var excludes = options && options.excludes || [];
  var lines = [];
  var sLines; // always ignore these

  excludes.push('stack');

  if (propertyNames.length > 0) {
    var exclude = false;
    propertyNames.forEach(function (name) {
      if (excludes) {
        exclude = excludes.indexOf(name) >= 0;
      }

      if (!exclude && object[name]) {
        // this to cover this problem:
        // https://github.com/binarykitchen/videomail-client/issues/157
        lines.push((0, _safeJsonStringify.default)(object[name]));
      }
    });
  }

  if (lines.length === 1) {
    sLines = lines.join();
  } else if (lines.length > 1) {
    sLines = DASH + lines.join(SEPARATOR);
  }

  return sLines;
}

function _default(anything, options) {
  if (anything === null) {
    return 'null';
  } else if (typeof anything === 'undefined') {
    return 'undefined';
  } else if (typeof anything === 'string') {
    return anything;
  } else if (Array.isArray(anything)) {
    return arrayToString(anything);
  } else if (_typeof(anything) === 'object') {
    return objectToString(anything, options);
  } else {
    return anything.toString();
  }
}

},{"safe-json-stringify":67}],100:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

_dereq_("classlist.js");

_dereq_("element-closest");

var _requestFrame = _interopRequireDefault(_dereq_("request-frame"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// needed for IE 11
// https://github.com/julienetie/request-frame
// use those default params for unit tests
function _default() {
  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var navigator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // https://github.com/julienetie/request-frame/issues/6
  if (!window.screen) {
    window.screen = {};
  }

  (0, _requestFrame.default)('native'); // avoids warning "navigator.mozGetUserMedia has been replaced by navigator.mediaDevices.getUserMedia",
  // see https://github.com/binarykitchen/videomail-client/issues/79

  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {// do not shim
  } else {
    navigator.getUserMedia_ = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
  }

  if (!window.AudioContext && window.webkitAudioContext) {
    window.AudioContext = window.webkitAudioContext;
  }

  if (!window.URL) {
    window.URL = window.webkitURL || window.mozURL || window.msURL;
  }

  var methods = ['debug', 'groupCollapsed', 'groupEnd', 'error', 'exception', 'info', 'log', 'trace', 'warn'];
  var console = {};

  if (window.console) {
    console = window.console;
  } else {
    window.console = function () {};
  }

  var method;
  var length = methods.length;

  while (length--) {
    method = methods[length];

    if (!console[method]) {
      console[method] = function () {};
    }
  }
}

},{"classlist.js":11,"element-closest":21,"request-frame":65}],101:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _createError = _interopRequireDefault(_dereq_("create-error"));

var _util = _interopRequireDefault(_dereq_("util"));

var _pretty = _interopRequireDefault(_dereq_("./pretty"));

var _resource = _interopRequireDefault(_dereq_("./../resource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var VIDEOMAIL_ERR_NAME = 'Videomail Error';
var VideomailError = (0, _createError.default)(Error, VIDEOMAIL_ERR_NAME, {
  'explanation': undefined,
  'logLines': undefined,
  'useragent': undefined,
  'url': undefined,
  'stack': undefined
}); // shim pretty to exclude stack always

var pretty = function pretty(anything) {
  return (0, _pretty.default)(anything, {
    excludes: ['stack']
  });
}; // static and public attribute of this class


VideomailError.PERMISSION_DENIED = 'PERMISSION_DENIED';
VideomailError.NOT_ALLOWED_ERROR = 'NotAllowedError';
VideomailError.NOT_CONNECTED = 'Not connected';
VideomailError.DOM_EXCEPTION = 'DOMException';
VideomailError.STARTING_FAILED = 'Starting video failed';
VideomailError.MEDIA_DEVICE_NOT_SUPPORTED = 'MediaDeviceNotSupported';
VideomailError.BROWSER_PROBLEM = 'browser-problem';
VideomailError.WEBCAM_PROBLEM = 'webcam-problem';
VideomailError.IOS_PROBLEM = 'ios-problem';
VideomailError.OVERCONSTRAINED = 'OverconstrainedError';
VideomailError.NOT_FOUND_ERROR = 'NotFoundError';
VideomailError.NOT_READABLE_ERROR = 'NotReadableError';
VideomailError.SECURITY_ERROR = 'SecurityError';
VideomailError.TRACK_START_ERROR = 'TrackStartError';
VideomailError.INVALID_STATE_ERROR = 'InvalidStateError'; // static function to convert an error into a videomail error

VideomailError.create = function (err, explanation, options, parameters) {
  if (err && err.name === VIDEOMAIL_ERR_NAME) {
    return err;
  }

  if (!options && explanation) {
    options = explanation;
    explanation = undefined;
  }

  options = options || {};
  parameters = parameters || {}; // be super robust

  var debug = options && options.debug || console.log;
  var audioEnabled = options && options.isAudioEnabled && options.isAudioEnabled();
  debug('VideomailError: create()', err, explanation || '(no explanation set)');
  var classList = parameters.classList || []; // Require Browser here, not at the top of the file to avoid
  // recursion. Because the Browser class is requiring this file as well.

  var Browser = _dereq_('./browser');

  var browser = new Browser(options);
  var errType;
  var message;
  var stack; // whole code is ugly because all browsers behave so differently :(

  if (_typeof(err) === 'object') {
    if (err.name === VideomailError.TRACK_START_ERROR) {
      errType = VideomailError.TRACK_START_ERROR;
    } else if (err.name === VideomailError.SECURITY_ERROR) {
      errType = VideomailError.SECURITY_ERROR;
    } else if (err.code === 8 && err.name === VideomailError.NotFoundError) {
      errType = VideomailError.NotFoundError;
    } else if (err.code === 35 || err.name === VideomailError.NOT_ALLOWED_ERROR) {
      // https://github.com/binarykitchen/videomail.io/issues/411
      errType = VideomailError.NOT_ALLOWED_ERROR;
    } else if (err.code === 1 && err.PERMISSION_DENIED === 1) {
      errType = VideomailError.PERMISSION_DENIED;
    } else if (err.constructor && err.constructor.name === VideomailError.DOM_EXCEPTION) {
      if (err.name === VideomailError.NOT_READABLE_ERROR) {
        errType = VideomailError.NOT_READABLE_ERROR;
      } else {
        errType = VideomailError.DOM_EXCEPTION;
      }
    } else if (err.constructor && err.constructor.name === VideomailError.OVERCONSTRAINED) {
      errType = VideomailError.OVERCONSTRAINED;
    } else if (err.message === VideomailError.STARTING_FAILED) {
      errType = err.message;
    } else if (err.name) {
      errType = err.name;
    } else if (err.type === 'error' && err.target.bufferedAmount === 0) {
      errType = VideomailError.NOT_CONNECTED;
    }
  } else if (err === VideomailError.NOT_CONNECTED) {
    errType = VideomailError.NOT_CONNECTED;
  } else {
    errType = err;
  }

  if (err && err.stack) {
    stack = err.stack;
  } else {
    stack = new Error().stack;
  }

  switch (errType) {
    case VideomailError.SECURITY_ERROR:
      message = 'The operation was insecure';
      explanation = 'Probably you have disallowed Cookies for this page?';
      classList.push(VideomailError.BROWSER_PROBLEM);
      break;

    case VideomailError.OVERCONSTRAINED:
      message = 'Invalid webcam constraints';

      if (err.constraint) {
        if (err.constraint === 'width') {
          explanation = 'Your webcam does not meet the width requirement.';
        } else {
          explanation = 'Unmet constraint: ' + err.constraint;
        }
      } else {
        explanation = ' Details: ' + err.toString();
      }

      break;

    case 'MediaDeviceFailedDueToShutdown':
      message = 'Webcam is shutting down';
      explanation = 'This happens your webcam is already switching off and not giving you permission to use it.';
      break;

    case 'SourceUnavailableError':
      message = 'Source of your webcam cannot be accessed';
      explanation = 'Probably it is locked from another process or has a hardware error.';

      if (err.message) {
        err.message += ' Details: ' + err.message;
      }

      break;

    case VideomailError.NOT_FOUND_ERROR:
    case 'NO_DEVICES_FOUND':
      if (audioEnabled) {
        message = 'No webcam nor microphone found';
        explanation = 'Your browser cannot find a webcam with microphone attached to your machine.';
      } else {
        message = 'No webcam found';
        explanation = 'Your browser cannot find a webcam attached to your machine.';
      }

      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case 'PermissionDismissedError':
      message = 'Ooops, you didn\'t give me any permissions?';
      explanation = 'Looks like you skipped the webcam permission dialogue.<br/>' + 'Please grant access next time the dialogue appears.';
      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case VideomailError.NOT_ALLOWED_ERROR:
    case VideomailError.PERMISSION_DENIED:
    case 'PermissionDeniedError':
      message = 'Permission denied';
      explanation = 'Cannot access your webcam. This can have two reasons:<br/>' + 'a) you blocked access to webcam; or<br/>' + 'b) your webcam is already in use.';
      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case 'HARDWARE_UNAVAILABLE':
      message = 'Webcam is unavailable';
      explanation = 'Maybe it is already busy in another window?';

      if (browser.isChromeBased()) {
        explanation += ' Or you have to allow access above?';
      }

      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case VideomailError.NOT_CONNECTED:
      message = 'Unable to connect';
      explanation = 'Either the videomail server or your connection is down. ' + 'Trying to reconnect every few seconds ';
      break;

    case 'NO_VIDEO_FEED':
      message = 'No video feed found!';
      explanation = 'Your webcam is already used in another browser.';
      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case VideomailError.STARTING_FAILED:
      message = 'Starting video failed';
      explanation = 'Most likely this happens when the webam is already active in another browser.';
      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case 'DevicesNotFoundError':
      message = 'No available webcam could be found';
      explanation = 'Looks like you do not have any webcam attached to your machine; or ' + 'the one you plugged in is already used.';
      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case VideomailError.NOT_READABLE_ERROR:
    case VideomailError.TRACK_START_ERROR:
      message = 'No access to webcam';
      explanation = 'A hardware error occurred which prevented access to your webcam.';
      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case VideomailError.INVALID_STATE_ERROR:
      message = 'Invalid state';
      explanation = 'Video recording stream from your webcam already has finished.';
      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case VideomailError.DOM_EXCEPTION:
      switch (err.code) {
        case 8:
          message = 'Requested webcam not found';
          explanation = 'A webcam is needed but could not be found.';
          classList.push(VideomailError.WEBCAM_PROBLEM);
          break;

        case 9:
          var newUrl = 'https:' + window.location.href.substring(window.location.protocol.length);
          message = 'Security upgrade needed';
          explanation = 'Click <a href="' + newUrl + '">here</a> to switch to HTTPs which is more safe ' + ' and enables encrypted videomail transfers.';
          classList.push(VideomailError.BROWSER_PROBLEM);
          break;

        case 11:
          message = 'Invalid State';
          explanation = 'The object is in an invalid, unusable state.';
          classList.push(VideomailError.BROWSER_PROBLEM);
          break;

        default:
          message = 'DOM Exception';
          explanation = pretty(err);
          classList.push(VideomailError.BROWSER_PROBLEM);
          break;
      }

      break;
    // Chrome has a weird problem where if you try to do a getUserMedia request too early, it
    // can return a MediaDeviceNotSupported error (even though nothing is wrong and permission
    // has been granted). Look at userMediaErrorCallback() in recorder, there we do not
    // emit those kind of errors further and just retry.
    //
    // but for whatever reasons, if it happens to reach this code, then investigate this further.

    case VideomailError.MEDIA_DEVICE_NOT_SUPPORTED:
      message = 'Media device not supported';
      explanation = pretty(err);
      break;

    default:
      var originalExplanation = explanation;

      if (explanation && _typeof(explanation) === 'object') {
        explanation = pretty(explanation);
      } // it can be that explanation itself is an error object
      // error objects can be prettified to undefined sometimes


      if (!explanation && originalExplanation) {
        if (originalExplanation.message) {
          explanation = originalExplanation.message;
        } else {
          // tried toString before but nah
          explanation = 'Inspected: ' + _util.default.inspect(originalExplanation, {
            showHidden: true
          });
        }
      }

      if (err && typeof err === 'string') {
        message = err;
      } else {
        if (err && err.message) {
          message = pretty(err.message);
        }

        if (err && err.explanation) {
          if (!explanation) {
            explanation = pretty(err.explanation);
          } else {
            explanation += ';<br/>' + pretty(err.explanation);
          }
        }

        if (err && err.details) {
          var details = pretty(err.details);

          if (!explanation) {
            explanation = details;
          } else {
            explanation += ';<br/>' + details;
          }
        }
      } // for weird, undefined cases


      if (!message) {
        if (errType) {
          message = errType;
        }

        if (!explanation && err) {
          explanation = pretty(err, {
            excludes: ['stack']
          });
        } // avoid dupes


        if (pretty(message) === explanation) {
          explanation = undefined;
        }
      }

      break;
  }

  var logLines = null;

  if (options.logger && options.logger.getLines) {
    logLines = options.logger.getLines();
  }

  if (stack) {
    message = new Error(message);
    message.stack = stack;
  }

  var errCode = 'none';

  if (err) {
    errCode = 'code=' + (err.code ? err.code : 'undefined');
    errCode += ', type=' + (err.type ? err.type : 'undefined');
    errCode += ', name=' + (err.name ? err.name : 'undefined');
    errCode += ', message=' + (err.message ? err.message : 'undefined');
  }

  var videomailError = new VideomailError(message, {
    explanation: explanation,
    logLines: logLines,
    client: browser.getUsefulData(),
    url: window.location.href,
    siteName: options.siteName,
    code: errCode,
    stack: stack // have to assign it manually again because it is kinda protected

  });
  var resource;
  var reportErrors = false;

  if (options.reportErrors) {
    if (typeof options.reportErrors === 'function') {
      reportErrors = options.reportErrors(videomailError);
    } else {
      reportErrors = options.reportErrors;
    }
  }

  if (reportErrors) {
    resource = new _resource.default(options);
  }

  if (resource) {
    resource.reportError(videomailError, function (err2) {
      if (err2) {
        console.error('Unable to report error', err2);
      }
    });
  }

  function hasClass(name) {
    return classList.indexOf(name) >= 0;
  }

  function isBrowserProblem() {
    return hasClass(VideomailError.BROWSER_PROBLEM) || parameters.browserProblem;
  } // add some public functions
  // this one is useful so that the notifier can have different css classes


  videomailError.getClassList = function () {
    return classList;
  };

  videomailError.removeDimensions = function () {
    return hasClass(VideomailError.IOS_PROBLEM) || browser.isMobile();
  };

  videomailError.hideButtons = function () {
    return isBrowserProblem() || hasClass(VideomailError.IOS_PROBLEM);
  };

  videomailError.hideForm = function () {
    return hasClass(VideomailError.IOS_PROBLEM);
  };

  return videomailError;
};

var _default = VideomailError;
exports.default = _default;

},{"./../resource":91,"./browser":94,"./pretty":99,"create-error":14,"util":81}],102:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = _interopRequireDefault(_dereq_("util"));

var _hyperscript = _interopRequireDefault(_dereq_("hyperscript"));

var _hidden = _interopRequireDefault(_dereq_("hidden"));

var _contains = _interopRequireDefault(_dereq_("contains"));

var _events = _interopRequireDefault(_dereq_("./../events"));

var _eventEmitter = _interopRequireDefault(_dereq_("./../util/eventEmitter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Buttons = function Buttons(container, options) {
  _eventEmitter.default.call(this, options, 'Buttons');

  var self = this;
  var debug = options.debug;
  var buttonsElement;
  var recordButton;
  var pauseButton;
  var resumeButton;
  var previewButton;
  var recordAgainButton;
  var submitButton;
  var audioOnRadioPair;
  var audioOffRadioPair;
  var built;

  function hide(elements) {
    if (elements && !Array.isArray(elements)) {
      elements = [elements];
    }

    elements && elements.forEach(function (element) {
      (0, _hidden.default)(element, true);
    });
  }

  function show(elements) {
    if (elements && !Array.isArray(elements)) {
      elements = [elements];
    }

    elements && elements.forEach(function (element) {
      (0, _hidden.default)(element, false);
    });
  }

  function isShown(elements) {
    var isShown = elements && true;

    if (elements && !Array.isArray(elements)) {
      elements = [elements];
    }

    elements && elements.forEach(function (element) {
      isShown = isShown && element && !(0, _hidden.default)(element);
    });
    return isShown;
  }

  function disable(elements) {
    if (elements && !Array.isArray(elements)) {
      elements = [elements];
    }

    elements && elements.forEach(function (element) {
      // https://github.com/binarykitchen/videomail-client/issues/148
      if (element) {
        if (element.tagName === 'INPUT' || element.tagName === 'BUTTON') {
          element.disabled = true;
        } else {
          element.classList.add('disabled');
        }
      }
    });
  }

  function enable(elements) {
    if (elements && !Array.isArray(elements)) {
      elements = [elements];
    }

    elements && elements.forEach(function (element) {
      // https://github.com/binarykitchen/videomail-client/issues/148
      if (element) {
        if (element.tagName === 'INPUT' || element.tagName === 'BUTTON') {
          element.disabled = false;
        } else {
          element.classList.remove('disabled');
        }
      }
    });
  }

  function adjustButton(buttonElement, show, type, disabled) {
    if (disabled) {
      disable(buttonElement);
    }

    if (type) {
      buttonElement.type = type;
    } else if (!buttonElement.type) {
      buttonElement.type = 'button';
    }

    !show && hide(buttonElement);
    return buttonElement;
  }

  function replaceClickHandler(element, clickHandler) {
    var wrappedClickHandler = function wrappedClickHandler(e) {
      e && e.preventDefault();

      try {
        clickHandler({
          event: e
        });
      } catch (exc) {
        self.emit(_events.default.ERROR, exc);
      }
    };

    element.onclick = wrappedClickHandler;
  }

  function makeRadioButtonPair(options) {
    var radioButtonElement;
    var radioButtonGroup;

    if (options.id) {
      radioButtonElement = document.getElementById(options.id);
    }

    if (!radioButtonElement) {
      radioButtonElement = (0, _hyperscript.default)('input#' + options.id, {
        type: 'radio',
        name: options.name,
        value: options.value,
        checked: options.checked
      });
      radioButtonGroup = (0, _hyperscript.default)('span.radioGroup', radioButtonElement, (0, _hyperscript.default)('label', {
        'htmlFor': options.id
      }, options.label)); // double check that submit button is already in the buttonsElement container as a child?

      if (submitButton && (0, _contains.default)(buttonsElement, submitButton)) {
        buttonsElement.insertBefore(radioButtonGroup, submitButton);
      } else {
        buttonsElement.appendChild(radioButtonGroup);
      }
    }

    if (options.changeHandler) {
      radioButtonElement.onchange = options.changeHandler;
    }

    disable(radioButtonElement);
    return [radioButtonElement, radioButtonGroup];
  }

  function makeButton(buttonClass, text, clickHandler, show, id, type, selector) {
    var disabled = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;
    var buttonElement;

    if (id) {
      buttonElement = document.getElementById(id);
    } else if (selector) {
      buttonElement = document.querySelector(selector);
    } else {
      buttonElement = buttonsElement.querySelector('.' + buttonClass);
    }

    if (!buttonElement) {
      if (options.selectors.buttonClass) {
        buttonClass += '.' + options.selectors.buttonClass;
      }

      buttonElement = (0, _hyperscript.default)('button.' + buttonClass);
      buttonElement = adjustButton(buttonElement, show, type, disabled);
      buttonElement.innerHTML = text; // double check that submit button is already in the buttonsElement container

      if (submitButton && (0, _contains.default)(buttonsElement, submitButton)) {
        buttonsElement.insertBefore(buttonElement, submitButton);
      } else {
        buttonsElement.appendChild(buttonElement);
      }
    } else {
      buttonElement = adjustButton(buttonElement, show, type, disabled);
    }

    if (clickHandler) {
      replaceClickHandler(buttonElement, clickHandler);
    }

    return buttonElement;
  }

  function buildButtons() {
    if (!options.disableSubmit) {
      if (!submitButton) {
        submitButton = makeButton(options.selectors.submitButtonClass, 'Submit', null, true, options.selectors.submitButtonId, 'submit', options.selectors.submitButtonSelector, options.enableAutoValidation);
      } else {
        disable(submitButton);
      } // no need to listen to the submit event when it's already listened
      // within the form element class


      if (!container.hasForm() && submitButton) {
        replaceClickHandler(submitButton, submit);
      }
    }

    recordButton = makeButton(options.selectors.recordButtonClass, options.text.buttons.record, record, false);

    if (options.enablePause) {
      pauseButton = makeButton(options.selectors.pauseButtonClass, options.text.buttons.pause, container.pause, false);
    }

    if (options.enablePause) {
      resumeButton = makeButton(options.selectors.resumeButtonClass, options.text.buttons.resume, container.resume, false);
    } // show stop only when pause is enabled - looks better that way otherwise button
    // move left and right between record and stop (preview)


    previewButton = makeButton(options.selectors.previewButtonClass, options.text.buttons.preview, container.stop, false);
    recordAgainButton = makeButton(options.selectors.recordAgainButtonClass, options.text.buttons.recordAgain, recordAgain, false);

    if (options.audio && options.audio.switch) {
      audioOffRadioPair = makeRadioButtonPair({
        id: 'audioOffOption',
        name: 'audio',
        value: 'off',
        label: 'Audio Off',
        checked: !options.isAudioEnabled(),
        changeHandler: function changeHandler() {
          container.disableAudio();
        }
      });
      audioOnRadioPair = makeRadioButtonPair({
        id: 'audioOnOption',
        name: 'audio',
        value: 'on',
        label: 'Audio On (Beta)',
        checked: options.isAudioEnabled(),
        changeHandler: function changeHandler() {
          container.enableAudio();
        }
      });
    }
  }

  function onFormReady(params) {
    // no need to show record button when doing a record again
    if (!isShown(recordAgainButton)) {
      if (!params.paused) {
        show(recordButton);
      }
    }

    if (!params.paused) {
      disable(previewButton);
      hide(previewButton);
    }

    if (!options.enableAutoValidation) {
      enable(submitButton);
    }
  }

  function onGoingBack() {
    hide(recordAgainButton);
    show(recordButton);
    show(submitButton);
  }

  function onReplayShown() {
    self.hide();
  }

  function onUserMediaReady(params) {
    onFormReady(params);

    if (isShown(recordButton)) {
      enable(recordButton);
    }

    if (isShown(audioOnRadioPair)) {
      enable(audioOnRadioPair);
    }

    if (isShown(audioOffRadioPair)) {
      enable(audioOffRadioPair);
    }

    if (options.enableAutoValidation) {
      disable(submitButton);
    }
  }

  function onResetting() {
    disable(submitButton);
    self.reset();
  }

  function onPreview() {
    hide(recordButton);
    hide(previewButton);
    disable(audioOnRadioPair);
    disable(audioOffRadioPair);
    show(recordAgainButton);
    enable(recordAgainButton);

    if (!options.enableAutoValidation) {
      enable(submitButton);
    }
  }

  this.enableSubmit = function () {
    enable(submitButton);
  };

  this.adjustButtonsForPause = function () {
    if (!self.isCountingDown()) {
      pauseButton && hide(pauseButton);
      show(resumeButton);
      enable(resumeButton);
      hide(recordButton);
      show(previewButton);
      enable(previewButton);
    }
  };

  function onFirstFrameSent() {
    hide(recordButton);
    hide(recordAgainButton);

    if (pauseButton) {
      show(pauseButton);
      enable(pauseButton);
    }

    enable(previewButton);
    show(previewButton);
  }

  function onRecording(framesCount) {
    // it is possible to hide while recording, hence
    // check framesCount first (coming from recorder)
    if (framesCount > 1) {
      onFirstFrameSent();
    } else {
      disable(audioOffRadioPair);
      disable(audioOnRadioPair);
      disable(recordAgainButton);
      disable(recordButton);
    }
  }

  function onResuming() {
    hide(resumeButton);
    hide(recordButton);

    if (pauseButton) {
      enable(pauseButton);
      show(pauseButton);
    }
  }

  function onStopping() {
    disable(previewButton);
    hide(pauseButton);
    hide(resumeButton);
  }

  function onCountdown() {
    disable(recordButton);
    disable(audioOffRadioPair);
    disable(audioOnRadioPair);
  }

  function onSubmitting() {
    disable(submitButton);
    disable(recordAgainButton);
  }

  function onSubmitted() {
    disable(previewButton);
    disable(recordAgainButton);
    disable(recordButton);
    disable(submitButton);
  }

  function onInvalid() {
    if (options.enableAutoValidation) {
      disable(submitButton);
    }
  }

  function onValid() {
    if (options.enableAutoValidation) {
      enable(submitButton);
    }
  }

  function onHidden() {
    hide(recordButton);
    hide(previewButton);
    hide(recordAgainButton);
    hide(resumeButton);
  }

  function onEnablingAudio() {
    disable(recordButton);
    disable(audioOnRadioPair);
    disable(audioOffRadioPair);
  }

  function onDisablingAudio() {
    disable(recordButton);
    disable(audioOnRadioPair);
    disable(audioOffRadioPair);
  }

  function recordAgain() {
    disable(recordAgainButton);
    container.beginWaiting();
    container.recordAgain();
  }

  function onStartingOver() {
    show(submitButton);
  }

  function submit() {
    container.submit();
  }

  function record(params) {
    disable(recordButton);
    container.record(params);
  }

  function initEvents() {
    debug('Buttons: initEvents()');
    self.on(_events.default.USER_MEDIA_READY, function (params) {
      if (!params.switchingFacingMode) {
        onUserMediaReady(params);
      }
    }).on(_events.default.PREVIEW, function () {
      onPreview();
    }).on(_events.default.PAUSED, function () {
      self.adjustButtonsForPause();
    }).on(_events.default.RECORDING, function (framesCount) {
      onRecording(framesCount);
    }).on(_events.default.FIRST_FRAME_SENT, function () {
      onFirstFrameSent();
    }).on(_events.default.RESUMING, function () {
      onResuming();
    }).on(_events.default.STOPPING, function () {
      onStopping();
    }).on(_events.default.COUNTDOWN, function () {
      onCountdown();
    }).on(_events.default.SUBMITTING, function () {
      onSubmitting();
    }).on(_events.default.RESETTING, function () {
      onResetting();
    }).on(_events.default.INVALID, function () {
      onInvalid();
    }).on(_events.default.VALID, function () {
      onValid();
    }).on(_events.default.SUBMITTED, function () {
      onSubmitted();
    }).on(_events.default.HIDE, function () {
      onHidden();
    }).on(_events.default.FORM_READY, function (params) {
      onFormReady(params);
    }).on(_events.default.REPLAY_SHOWN, function () {
      onReplayShown();
    }).on(_events.default.GOING_BACK, function () {
      onGoingBack();
    }).on(_events.default.ENABLING_AUDIO, function () {
      onEnablingAudio();
    }).on(_events.default.DISABLING_AUDIO, function () {
      onDisablingAudio();
    }).on(_events.default.STARTING_OVER, function () {
      onStartingOver();
    }).on(_events.default.ERROR, function (err) {
      // since https://github.com/binarykitchen/videomail-client/issues/60
      // we hide areas to make it easier for the user
      if (err.hideButtons && err.hideButtons() && options.adjustFormOnBrowserError) {
        self.hide();
      }
    });
  }

  this.reset = function () {
    options.debug('Buttons: reset()');
    disable(pauseButton);
    disable(resumeButton);
    disable(recordButton);
    disable(previewButton);
    disable(recordAgainButton);
  };

  this.isRecordAgainButtonEnabled = function () {
    return !recordAgainButton.disabled;
  };

  this.isRecordButtonEnabled = function () {
    return !recordButton.disabled;
  };

  this.setSubmitButton = function (newSubmitButton) {
    submitButton = newSubmitButton;
  };

  this.getSubmitButton = function () {
    return submitButton;
  };

  this.build = function () {
    buttonsElement = container.querySelector('.' + options.selectors.buttonsClass);

    if (!buttonsElement) {
      buttonsElement = (0, _hyperscript.default)('div.' + options.selectors.buttonsClass);
      container.appendChild(buttonsElement);
    }

    buildButtons();
    !built && initEvents();
    built = true;
  };

  this.unload = function () {
    built = false;
  };

  this.hide = function (params) {
    hide(buttonsElement);

    if (params && params.deep) {
      hide(recordButton);
      hide(pauseButton);
      hide(resumeButton);
      hide(previewButton);
      hide(recordAgainButton);
      hide(submitButton);
    }
  };

  this.show = function () {
    show(buttonsElement);
  };

  this.isCountingDown = function () {
    return container.isCountingDown();
  };
};

_util.default.inherits(Buttons, _eventEmitter.default);

var _default = Buttons;
exports.default = _default;

},{"./../events":89,"./../util/eventEmitter":96,"contains":12,"hidden":31,"hyperscript":33,"util":81}],103:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _insertCss = _interopRequireDefault(_dereq_("insert-css"));

var _hidden = _interopRequireDefault(_dereq_("hidden"));

var _util = _interopRequireDefault(_dereq_("util"));

var _documentVisibility = _interopRequireDefault(_dereq_("document-visibility"));

var _dimension = _interopRequireDefault(_dereq_("./dimension"));

var _visuals = _interopRequireDefault(_dereq_("./visuals"));

var _buttons = _interopRequireDefault(_dereq_("./buttons"));

var _form = _interopRequireDefault(_dereq_("./form"));

var _optionsWrapper = _interopRequireDefault(_dereq_("./optionsWrapper"));

var _resource = _interopRequireDefault(_dereq_("./../resource"));

var _events = _interopRequireDefault(_dereq_("./../events"));

var _eventEmitter = _interopRequireDefault(_dereq_("./../util/eventEmitter"));

var _videomailError = _interopRequireDefault(_dereq_("./../util/videomailError"));

var _mainMinCss = _interopRequireDefault(_dereq_("./../styles/css/main.min.css.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Container = function Container(options) {
  _eventEmitter.default.call(this, options, 'Container');

  var self = this;
  var visibility = (0, _documentVisibility.default)();
  var visuals = new _visuals.default(this, options);
  var buttons = new _buttons.default(this, options);
  var resource = new _resource.default(options);
  var htmlElement = document && document.querySelector && document.querySelector('html');
  var debug = options.debug;
  var hasError = false;
  var submitted = false;
  var lastValidation = false;
  var containerElement;
  var built;
  var form;

  function prependDefaultCss() {
    (0, _insertCss.default)(_mainMinCss.default, {
      prepend: true
    });
  } // since https://github.com/binarykitchen/videomail-client/issues/87


  function findParentFormElement() {
    return containerElement.closest('form');
  }

  function getFormElement() {
    var formElement;

    if (containerElement.tagName === 'FORM') {
      formElement = containerElement;
    } else if (options.selectors.formId) {
      formElement = document.getElementById(options.selectors.formId);
    } else {
      formElement = findParentFormElement();
    }

    return formElement;
  }

  function buildForm() {
    var formElement = getFormElement();

    if (formElement) {
      debug('Container: buildForm()');
      form = new _form.default(self, formElement, options);
      var submitButton = form.findSubmitButton();
      submitButton && buttons.setSubmitButton(submitButton);
      form.build();
    }
  }

  function buildChildren() {
    debug('Container: buildChildren()');

    if (!containerElement.classList) {
      self.emit(_events.default.ERROR, _videomailError.default.create('Sorry, your browser is too old!', options));
    } else {
      containerElement.classList.add('videomail');

      if (!options.playerOnly) {
        buttons.build();
      }

      visuals.build();
    }
  }

  function processError(err) {
    hasError = true;

    if (err.stack) {
      options.logger.error(err.stack);
    } else {
      options.logger.error(err);
    }

    if (options.displayErrors) {
      visuals.error(err);
    } else {
      visuals.reset();
    }
  }

  function initEvents() {
    debug('Container: initEvents()');
    window.addEventListener('beforeunload', function (e) {
      self.unload(e);
    });

    if (!options.playerOnly) {
      visibility.onChange(function (visible) {
        // built? see https://github.com/binarykitchen/videomail.io/issues/326
        if (built) {
          if (visible) {
            if (options.isAutoPauseEnabled() && self.isCountingDown()) {
              self.resume();
            }

            self.emit(_events.default.VISIBLE);
          } else {
            if (options.isAutoPauseEnabled() && (self.isCountingDown() || self.isRecording())) {
              self.pause('document invisible');
            }

            self.emit(_events.default.INVISIBLE);
          }
        }
      });
    }

    if (options.enableSpace) {
      if (!options.playerOnly) {
        window.addEventListener('keypress', function (e) {
          var tagName = e.target.tagName;
          var isEditable = e.target.isContentEditable || e.target.contentEditable === 'true' || e.target.contentEditable === true; // beware of rich text editors, hence the isEditable check (wordpress plugin issue)

          if (!isEditable && tagName !== 'INPUT' && tagName !== 'TEXTAREA') {
            var code = e.keyCode ? e.keyCode : e.which;

            if (code === 32) {
              e.preventDefault();

              if (options.enablePause) {
                visuals.pauseOrResume();
              } else {
                visuals.recordOrStop();
              }
            }
          }
        });
      }
    } // better to keep the one and only error listeners
    // at one spot, here, because unload() will do a removeAllListeners()


    self.on(_events.default.ERROR, function (err) {
      processError(err);
      unloadChildren(err);

      if (err.removeDimensions && err.removeDimensions()) {
        removeDimensions();
      }
    });

    if (!options.playerOnly) {
      self.on(_events.default.LOADED_META_DATA, function () {
        correctDimensions();
      });
    }
  }

  function validateOptions() {
    if (options.hasDefinedWidth() && options.video.width % 2 !== 0) {
      throw _videomailError.default.create('Width must be divisible by two.', options);
    }

    if (options.hasDefinedHeight() && options.video.height % 2 !== 0) {
      throw _videomailError.default.create('Height must be divisible by two.', options);
    }
  } // this will just set the width but not the height because
  // it can be a form with more inputs elements


  function correctDimensions() {
    var width = visuals.getRecorderWidth(true);

    if (width < 1) {
      throw _videomailError.default.create('Recorder width cannot be less than 1!', options);
    } else {
      containerElement.style.width = width + 'px';
    }
  }

  function removeDimensions() {
    containerElement.style.width = 'auto';
  }

  function unloadChildren(e) {
    visuals.unload(e);
    buttons.unload();
    self.endWaiting();
  }

  function hideMySelf() {
    (0, _hidden.default)(containerElement, true);
  } // fixes https://github.com/binarykitchen/videomail-client/issues/71


  function trimEmail(email) {
    return email.replace(/(^[,\s]+)|([,\s]+$)/g, '');
  }

  function submitVideomail(formData, method, cb) {
    var FORM_FIELDS = {
      'subject': options.selectors.subjectInputName,
      'from': options.selectors.fromInputName,
      'to': options.selectors.toInputName,
      'body': options.selectors.bodyInputName,
      'key': options.selectors.keyInputName,
      'parentKey': options.selectors.parentKeyInputName,
      'sendCopy': options.selectors.sendCopyInputName
    };
    var videomailFormData = {};
    Object.keys(FORM_FIELDS).forEach(function (key) {
      if (formData.hasOwnProperty(FORM_FIELDS[key])) {
        videomailFormData[key] = formData[FORM_FIELDS[key]];
      }
    });

    if (videomailFormData.from) {
      videomailFormData.from = trimEmail(videomailFormData.from);
    }

    if (videomailFormData.to) {
      videomailFormData.to = trimEmail(videomailFormData.to);
    } // when method is undefined, treat it as a post


    if (isPost(method) || !method) {
      videomailFormData.recordingStats = visuals.getRecordingStats();
      videomailFormData.width = visuals.getRecorderWidth(true);
      videomailFormData.height = visuals.getRecorderHeight(true);
      resource.post(videomailFormData, cb);
    } else if (isPut(method)) {
      resource.put(videomailFormData, cb);
    }
  }

  function submitForm(formData, videomailResponse, url, cb) {
    // for now, accept POSTs only which have an URL unlike null and
    // treat all other submissions as direct submissions
    if (!url || url === '') {
      // figure out URL automatically then
      url = document.baseURI;
    } // can be missing when no videomail was recorded and is not required


    if (videomailResponse) {
      formData[options.selectors.aliasInputName] = videomailResponse.videomail.alias; // this in case if user wants all videomail metadata to be posted
      // altogether with the remaining form

      if (options.submitWithVideomail) {
        formData.videomail = videomailResponse.videomail;
      }
    }

    resource.form(formData, url, cb);
  }

  function finalizeSubmissions(err, method, videomail, response, formResponse) {
    self.endWaiting();

    if (err) {
      self.emit(_events.default.ERROR, err);
    } else {
      submitted = true; // merge two json response bodies to fake as if it were only one request

      if (response && formResponse && formResponse.body) {
        Object.keys(formResponse.body).forEach(function (key) {
          response[key] = formResponse.body[key];
        });
      }

      self.emit(_events.default.SUBMITTED, videomail, response || formResponse);

      if (formResponse && formResponse.type === 'text/html' && formResponse.text) {
        // server replied with HTML contents - display these
        document.body.innerHTML = formResponse.text; // todo: figure out how to fire dom's onload event again
        // todo: or how to run all the scripts over again
      }
    }
  }

  this.addPlayerDimensions = function (videomail, element) {
    try {
      videomail.playerHeight = this.calculateHeight({
        responsive: true,
        videoWidth: videomail.width,
        ratio: videomail.height / videomail.width
      }, element);
      videomail.playerWidth = this.calculateWidth({
        responsive: true,
        videoHeight: videomail.playerHeight,
        ratio: videomail.height / videomail.width
      });
      return videomail;
    } catch (exc) {
      self.emit(_events.default.ERROR, exc);
    }
  };

  this.limitWidth = function (width) {
    return _dimension.default.limitWidth(containerElement, width, options);
  };

  this.limitHeight = function (height) {
    return _dimension.default.limitHeight(height, options);
  };

  this.calculateWidth = function (fnOptions) {
    return _dimension.default.calculateWidth(_optionsWrapper.default.merge(options, fnOptions, true));
  };

  this.calculateHeight = function (fnOptions, element) {
    if (!element) {
      if (containerElement) {
        element = containerElement;
      } else {
        // better than nothing
        element = document.body;
      }
    }

    return _dimension.default.calculateHeight(element, _optionsWrapper.default.merge(options, fnOptions, true));
  };

  this.areVisualsHidden = function () {
    return visuals.isHidden();
  };

  this.hasElement = function () {
    return !!containerElement;
  };

  this.build = function () {
    try {
      containerElement = document.getElementById(options.selectors.containerId); // only build when a container element hast been found, otherwise
      // be silent and do nothing

      if (containerElement) {
        options.insertCss && prependDefaultCss();
        !built && initEvents();
        validateOptions();
        correctDimensions();

        if (!options.playerOnly) {
          buildForm();
        }

        buildChildren();

        if (!hasError) {
          debug('Container: built.');
          built = true;
          self.emit(_events.default.BUILT);
        } else {
          debug('Container: building failed due to an error.');
        }
      } else {// commented out since it does too much noise on videomail's view page which is fine
        // debug('Container: no container element with ID ' + options.selectors.containerId + ' found. Do nothing.')
      }
    } catch (exc) {
      if (visuals.isNotifierBuilt()) {
        self.emit(_events.default.ERROR, exc);
      } else {
        throw exc;
      }
    }
  };

  this.getSubmitButton = function () {
    return buttons.getSubmitButton();
  };

  this.querySelector = function (selector) {
    return containerElement.querySelector(selector);
  };

  this.beginWaiting = function () {
    htmlElement.classList && htmlElement.classList.add('wait');
  };

  this.endWaiting = function () {
    htmlElement.classList && htmlElement.classList.remove('wait');
  };

  this.appendChild = function (child) {
    containerElement.appendChild(child);
  };

  this.insertBefore = function (child, reference) {
    containerElement.insertBefore(child, reference);
  };

  this.unload = function (e) {
    debug('Container: unload()', e);

    try {
      unloadChildren(e);
      this.removeAllListeners();
      built = submitted = false;
    } catch (exc) {
      self.emit(_events.default.ERROR, exc);
    }
  };

  this.show = function () {
    if (containerElement) {
      (0, _hidden.default)(containerElement, false);
      visuals.show();

      if (!hasError) {
        var paused = self.isPaused();

        if (paused) {
          buttons.adjustButtonsForPause();
        } // since https://github.com/binarykitchen/videomail-client/issues/60
        // we hide areas to make it easier for the user


        buttons.show();

        if (self.isReplayShown()) {
          self.emit(_events.default.PREVIEW);
        } else {
          self.emit(_events.default.FORM_READY, {
            paused: paused
          });
        }
      }
    }
  };

  this.hide = function () {
    debug('Container: hide()');
    hasError = false;
    this.isRecording() && this.pause();
    visuals.hide();

    if (submitted) {
      buttons.hide();
      hideMySelf();
    }
  };

  this.startOver = function (params) {
    try {
      self.emit(_events.default.STARTING_OVER);
      submitted = false;
      form.show();
      visuals.back(params, function () {
        if (params.keepHidden) {
          // just enable form, do nothing else.
          // see example contact_form.html when you submit without videomil
          // and go back
          self.enableForm();
        } else {
          self.show(params);
        }
      });
    } catch (exc) {
      self.emit(_events.default.ERROR, exc);
    }
  };

  this.showReplayOnly = function () {
    hasError = false;
    this.isRecording() && this.pause();
    visuals.showReplayOnly();
    submitted && buttons.hide();
  };

  this.isNotifying = function () {
    return visuals.isNotifying();
  };

  this.isPaused = function () {
    return visuals.isPaused();
  };

  this.pause = function (params) {
    visuals.pause(params);
  }; // this code needs a good rewrite :(


  this.validate = function (force) {
    var runValidation = true;
    var valid;

    if (!options.enableAutoValidation) {
      runValidation = false;
      lastValidation = true; // needed so that it can be submitted anyway, see submit()
    } else if (force) {
      runValidation = force;
    } else if (self.isNotifying()) {
      runValidation = false;
    } else if (visuals.isConnected()) {
      runValidation = visuals.isUserMediaLoaded() || visuals.isReplayShown();
    } else if (visuals.isConnecting()) {
      runValidation = false;
    }

    if (runValidation) {
      this.emit(_events.default.VALIDATING);
      var visualsValid = visuals.validate() && buttons.isRecordAgainButtonEnabled();
      var whyInvalid;

      if (form) {
        valid = form.validate();

        if (valid) {
          if (!this.areVisualsHidden() && !visualsValid) {
            if (submitted || this.isReady() || this.isRecording() || this.isPaused() || this.isCountingDown()) {
              valid = false;
            }

            if (!valid) {
              whyInvalid = 'Video is not recorded';
            }
          }
        } else {
          var invalidInput = form.getInvalidElement();

          if (invalidInput) {
            whyInvalid = 'Form input named ' + invalidInput.name + ' is invalid';
          } else {
            whyInvalid = 'Form input(s() are invalid';
          }
        }
      } else {
        valid = visualsValid;
      }

      if (valid) {
        this.emit(_events.default.VALID);
      } else {
        this.emit(_events.default.INVALID, whyInvalid);
      }

      lastValidation = valid;
    }

    return valid;
  };

  this.disableForm = function (buttonsToo) {
    form && form.disable(buttonsToo);
  };

  this.enableForm = function (buttonsToo) {
    form && form.enable(buttonsToo);
  };

  this.hasForm = function () {
    return !!form;
  };

  this.isReady = function () {
    return buttons.isRecordButtonEnabled();
  };

  function isPost(method) {
    return method && method.toUpperCase() === 'POST';
  }

  function isPut(method) {
    return method && method.toUpperCase() === 'PUT';
  }

  this.submitAll = function (formData, method, url) {
    var post = isPost(method);
    var hasVideomailKey = !!formData[options.selectors.keyInputName];

    function startSubmission() {
      self.beginWaiting();
      self.disableForm(true);
      self.emit(_events.default.SUBMITTING);
    } // a closure so that we can access method


    var submitVideomailCallback = function submitVideomailCallback(err1, videomail, videomailResponse) {
      if (err1) {
        finalizeSubmissions(err1, method, videomail, videomailResponse);
      } else if (post) {
        submitForm(formData, videomailResponse, url, function (err2, formResponse) {
          finalizeSubmissions(err2, method, videomail, videomailResponse, formResponse);
        });
      } else {
        // it's a direct submission
        finalizeSubmissions(null, method, videomail, videomailResponse);
      }
    }; // !hasVideomailKey makes it possible to submit form when videomail itself
    // is not optional.


    if (!hasVideomailKey) {
      if (options.enableAutoSubmission) {
        startSubmission();
        submitForm(formData, null, url, function (err2, formResponse) {
          finalizeSubmissions(err2, method, null, null, formResponse);
        });
      } // ... and when the enableAutoSubmission option is false,
      // then that can mean, leave it to the framework to process with the form
      // validation/handling/submission itself. for example the ninja form
      // will want to highlight which one input are wrong.

    } else {
      startSubmission();
      submitVideomail(formData, method, submitVideomailCallback);
    }
  };

  this.isBuilt = function () {
    return built;
  };

  this.isReplayShown = function () {
    return visuals.isReplayShown();
  };

  this.isDirty = function () {
    var isDirty = false;

    if (form) {
      if (visuals.isRecorderUnloaded()) {
        isDirty = false;
      } else if (this.isReplayShown() || this.isPaused()) {
        isDirty = true;
      }
    }

    return isDirty;
  };

  this.getReplay = function () {
    return visuals.getReplay();
  };

  this.isOutsideElementOf = function (element) {
    return element.parentNode !== containerElement && element !== containerElement;
  };

  this.hideForm = function (params) {
    // form check needed, see https://github.com/binarykitchen/videomail-client/issues/127
    form && form.hide();
    buttons && buttons.hide(params);
  };

  this.loadForm = function (videomail) {
    if (form) {
      form.loadVideomail(videomail);
      this.validate();
    }
  };

  this.enableAudio = function () {
    options.setAudioEnabled(true);
    this.emit(_events.default.ENABLING_AUDIO);
  };

  this.disableAudio = function () {
    options.setAudioEnabled(false);
    this.emit(_events.default.DISABLING_AUDIO);
  };

  this.submit = function () {
    lastValidation && form && form.doTheSubmit();
  };

  this.isCountingDown = visuals.isCountingDown.bind(visuals);
  this.isRecording = visuals.isRecording.bind(visuals);
  this.record = visuals.record.bind(visuals);
  this.resume = visuals.resume.bind(visuals);
  this.stop = visuals.stop.bind(visuals);
  this.recordAgain = visuals.recordAgain.bind(visuals);
};

_util.default.inherits(Container, _eventEmitter.default);

var _default = Container;
exports.default = _default;

},{"./../events":89,"./../resource":91,"./../styles/css/main.min.css.js":92,"./../util/eventEmitter":96,"./../util/videomailError":101,"./buttons":102,"./dimension":104,"./form":105,"./optionsWrapper":106,"./visuals":107,"document-visibility":18,"hidden":31,"insert-css":37,"util":81}],104:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _numberIsInteger = _interopRequireDefault(_dereq_("number-is-integer"));

var _videomailError = _interopRequireDefault(_dereq_("./../util/videomailError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getOuterWidth(element) {
  var outerWidth = 0;
  var rect = element.getBoundingClientRect();

  if (rect) {
    outerWidth = rect.right - rect.left;
  }

  if (outerWidth < 1) {
    // last effort, can happen when replaying only
    rect = document.body.getBoundingClientRect();
    outerWidth = rect.right - rect.left;
  }

  return outerWidth;
}

function figureMinHeight(height, options) {
  if (options.hasDefinedHeight()) {
    if (!height) {
      height = options.video.height;
    } else {
      height = Math.min(options.video.height, height);
    }
  }

  if ((0, _numberIsInteger.default)(height) && height < 1) {
    throw _videomailError.default.create('Got a video height less than 1 (' + height + ') while figuring out the minimum!', options);
  } // just return it, can be "auto"


  return height;
}

var _default = {
  limitWidth: function limitWidth(element, width, options) {
    var limitedWidth;
    var outerWidth = getOuterWidth(element);

    if (width) {
      // only when that element has a defined width, apply this logic
      limitedWidth = outerWidth > 0 && outerWidth < width ? outerWidth : width;
    } else {
      // else apply the outer width when the element has no defined width yet
      limitedWidth = outerWidth;
    }

    if ((0, _numberIsInteger.default)(limitedWidth) && limitedWidth < 1) {
      throw _videomailError.default.create('Limited width cannot be less than 1!', options);
    } else {
      return limitedWidth;
    }
  },
  // this is difficult to compute and is not entirely correct.
  // but good enough for now to ensure some stability.
  limitHeight: function limitHeight(height, options) {
    if ((0, _numberIsInteger.default)(height) && height < 1) {
      throw _videomailError.default.create('Passed limit-height argument cannot be less than 1!', options);
    } else {
      var limitedHeight = Math.min(height, // document.body.scrollHeight,
      document.documentElement.clientHeight);

      if (limitedHeight < 1) {
        throw _videomailError.default.create('Limited height cannot be less than 1!', options);
      } else {
        return limitedHeight;
      }
    }
  },
  calculateWidth: function calculateWidth(options) {
    var height = options.videoHeight || null;
    var ratio = options.ratio || options.getRatio();
    height = figureMinHeight(height, options);

    if (options.responsive) {
      height = this.limitHeight(height, options);
    }

    if ((0, _numberIsInteger.default)(height) && height < 1) {
      throw _videomailError.default.create('Height cannot be smaller than 1 when calculating width.', options);
    } else {
      var calculatedWidth = parseInt(height / ratio);

      if (calculatedWidth < 1) {
        throw _videomailError.default.create('Calculated width cannot be smaller than 1!', options);
      } else {
        return calculatedWidth;
      }
    }
  },
  calculateHeight: function calculateHeight(element, options) {
    var width = options.videoWidth || null;
    var height;
    var ratio = options.ratio || options.getRatio();

    if (options.hasDefinedWidth()) {
      width = options.video.width;
    }

    if ((0, _numberIsInteger.default)(width) && width < 1) {
      throw _videomailError.default.create('Unable to calculate height when width is less than 1.', options);
    } else if (options.responsive) {
      width = this.limitWidth(element, width, options);
    }

    if (width) {
      height = parseInt(width * ratio);
    }

    if ((0, _numberIsInteger.default)(height) && height < 1) {
      throw _videomailError.default.create('Just calculated a height less than 1 which is wrong.', options);
    } else {
      return figureMinHeight(height, options);
    }
  }
};
exports.default = _default;

},{"./../util/videomailError":101,"number-is-integer":45}],105:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _hyperscript = _interopRequireDefault(_dereq_("hyperscript"));

var _util = _interopRequireDefault(_dereq_("util"));

var _hidden = _interopRequireDefault(_dereq_("hidden"));

var _getFormData = _interopRequireDefault(_dereq_("get-form-data"));

var _events = _interopRequireDefault(_dereq_("./../events"));

var _eventEmitter = _interopRequireDefault(_dereq_("./../util/eventEmitter"));

var _videomailError = _interopRequireDefault(_dereq_("./../util/videomailError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Form = function Form(container, formElement, options) {
  _eventEmitter.default.call(this, options, 'Form');

  var self = this;
  var disableContainerValidation;
  var keyInput;

  function getData() {
    return (0, _getFormData.default)(formElement);
  }

  this.loadVideomail = function (videomail) {
    var limit = formElement.elements.length;
    var input;
    var name;

    for (var i = 0; i < limit; i++) {
      input = formElement.elements[i];
      name = input.name;

      if (videomail[name]) {
        input.value = videomail[name];
      }

      if (name === options.selectors.subjectInputName || name === options.selectors.bodyInputName) {
        input.disabled = true;
      }
    }

    formElement.setAttribute('method', 'put');
  };

  function isNotButton(element) {
    return element.tagName !== 'BUTTON' && element.type !== 'submit';
  }

  function setDisabled(disabled, buttonsToo) {
    var limit = formElement.elements.length;

    for (var i = 0; i < limit; i++) {
      if (buttonsToo || !buttonsToo && isNotButton(formElement.elements[i])) {
        formElement.elements[i].disabled = disabled;
      }
    }
  }

  function hideAll() {
    var limit = formElement.elements.length;

    for (var i = 0; i < limit; i++) {
      (0, _hidden.default)(formElement.elements[i], true);
    }

    (0, _hidden.default)(formElement, true);
  }

  function getInputElements() {
    return formElement.querySelectorAll('input, textarea');
  }

  function getSelectElements() {
    return formElement.querySelectorAll('select');
  }

  this.disable = function (buttonsToo) {
    setDisabled(true, buttonsToo);
  };

  this.enable = function (buttonsToo) {
    setDisabled(false, buttonsToo);
  };

  this.build = function () {
    if (options.enableAutoValidation) {
      var inputElements = getInputElements();
      var inputElement;

      for (var i = 0, len = inputElements.length; i < len; i++) {
        inputElement = inputElements[i];

        if (inputElement.type === 'radio') {
          inputElement.addEventListener('change', function () {
            container.validate();
          });
        } else {
          inputElement.addEventListener('input', function () {
            container.validate();
          });
        } // because of angular's digest cycle, validate again when it became invalid


        inputElement.addEventListener('invalid', function () {
          if (!disableContainerValidation) {
            container.validate();
          }
        });
      }

      var selectElements = getSelectElements();

      for (var j = 0, len2 = selectElements.length; j < len2; j++) {
        selectElements[j].addEventListener('change', function () {
          container.validate();
        });
      }
    }

    keyInput = formElement.querySelector('input[name="' + options.selectors.keyInputName + '"]');

    if (!keyInput) {
      keyInput = (0, _hyperscript.default)('input', {
        name: options.selectors.keyInputName,
        type: 'hidden'
      });
      formElement.appendChild(keyInput);
    }

    this.on(_events.default.PREVIEW, function (videomailKey) {
      // beware that preview doesn't always come with a key, i.E.
      // container.show() can emit PREVIEW without a key when a replay already exists
      // (can happen when showing - hiding - showing videomail over again)
      // only emit error if key is missing AND the input has no key (value) yet
      if (!videomailKey && !keyInput.value) {
        self.emit(_events.default.ERROR, _videomailError.default.create('Videomail key for preview is missing!', options));
      } else if (videomailKey) {
        keyInput.value = videomailKey;
      } // else
      // leave as it and use existing keyInput.value

    }); // fixes https://github.com/binarykitchen/videomail-client/issues/91

    this.on(_events.default.GOING_BACK, function () {
      keyInput.value = null;
    });
    this.on(_events.default.ERROR, function (err) {
      // since https://github.com/binarykitchen/videomail-client/issues/60
      // we hide areas to make it easier for the user to process an error
      // (= less distractions)
      if (err.hideForm && err.hideForm() && options.adjustFormOnBrowserError) {
        hideAll();
      } else if (err.hideButtons && err.hideButtons() && options.adjustFormOnBrowserError) {
        hideSubmitButton();
      }
    });
    this.on(_events.default.BUILT, function () {
      startListeningToSubmitEvents();
    });
  };

  function hideSubmitButton() {
    var submitButton = self.findSubmitButton();
    (0, _hidden.default)(submitButton, true);
  }

  function startListeningToSubmitEvents() {
    var submitButton = container.getSubmitButton();
    submitButton.addEventListener('click', self.doTheSubmit.bind(self));
  }

  this.doTheSubmit = function (e) {
    if (e) {
      e.preventDefault();
    } // only submit when there is a container,
    // otherwise do nothing and leave as it


    if (container.hasElement()) {
      container.submitAll(getData(), formElement.getAttribute('method'), formElement.getAttribute('action'));
    }

    return false; // important to stop submission
  };

  this.getInvalidElement = function () {
    var inputElements = getInputElements();

    for (var i = 0, len = inputElements.length; i < len; i++) {
      if (!inputElements[i].validity.valid) {
        return inputElements[i];
      }
    }

    var selectElements = getSelectElements();

    for (var j = 0, len2 = selectElements.length; j < len2; j++) {
      if (!selectElements[i].validity.valid) {
        return selectElements[j];
      }
    }

    return null;
  };

  this.validate = function () {
    // prevents endless validation loop
    disableContainerValidation = true;
    var formIsValid = formElement.checkValidity();
    disableContainerValidation = false;
    return formIsValid;
  };

  this.findSubmitButton = function () {
    return formElement.querySelector("[type='submit']");
  };

  this.hide = function () {
    formElement && (0, _hidden.default)(formElement, true);
  };

  this.show = function () {
    formElement && (0, _hidden.default)(formElement, false);
  };
};

_util.default.inherits(Form, _eventEmitter.default);

var _default = Form;
exports.default = _default;

},{"./../events":89,"./../util/eventEmitter":96,"./../util/videomailError":101,"get-form-data":26,"hidden":31,"hyperscript":33,"util":81}],106:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _deepmerge = _interopRequireDefault(_dereq_("deepmerge"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// enhances options with useful functions we can reuse everywhere
var _default = {
  addFunctions: function addFunctions(options) {
    var audioEnabled = options.audio && options.audio.enabled;

    options.hasDefinedHeight = function () {
      return this.video.height && this.video.height !== 'auto';
    };

    options.hasDefinedWidth = function () {
      return this.video.width && this.video.width !== 'auto';
    };

    options.hasDefinedDimension = function () {
      return this.hasDefinedWidth() || this.hasDefinedHeight();
    };

    options.hasDefinedDimensions = function () {
      return this.hasDefinedWidth() && this.hasDefinedHeight();
    };

    options.getRatio = function () {
      var ratio = 1; // just a default one when no computations are possible
      // todo fix this, it's not really an option

      var hasVideoDimensions = this.videoHeight && this.videoWidth;

      if (this.hasDefinedDimensions()) {
        if (hasVideoDimensions) {
          // figure out first which one to pick
          if (this.videoHeight < this.video.height || this.videoWidth < this.video.width) {
            ratio = this.videoHeight / this.videoWidth;
          } else {
            ratio = this.video.height / this.video.width;
          }
        } else {
          ratio = this.video.height / this.video.width;
        }
      } else if (hasVideoDimensions) {
        ratio = this.videoHeight / this.videoWidth;
      }

      return ratio;
    };

    options.isAudioEnabled = function () {
      return audioEnabled;
    };

    options.setAudioEnabled = function (enabled) {
      audioEnabled = enabled;
    };

    options.isAutoPauseEnabled = function () {
      return this.enableAutoPause && this.enablePause;
    };
  },
  // not very elegant but works! and if you here are reading this, and
  // start to doubt, rest assured, it's solid and run thousand times over
  // and over again each day. and other large sites out there have their own
  // tech debts. hope i have shattered your illusion on perfection?
  merge: function merge(defaultOptions, newOptions) {
    var options = (0, _deepmerge.default)(defaultOptions, newOptions, {
      arrayMerge: function arrayMerge(destination, source) {
        return source;
      }
    });
    this.addFunctions(options);
    return options;
  }
};
exports.default = _default;

},{"deepmerge":15}],107:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = _interopRequireDefault(_dereq_("util"));

var _hyperscript = _interopRequireDefault(_dereq_("hyperscript"));

var _hidden = _interopRequireDefault(_dereq_("hidden"));

var _replay = _interopRequireDefault(_dereq_("./visuals/replay"));

var _recorder = _interopRequireDefault(_dereq_("./visuals/recorder"));

var _notifier = _interopRequireDefault(_dereq_("./visuals/notifier"));

var _recorderInsides = _interopRequireDefault(_dereq_("./visuals/inside/recorderInsides"));

var _eventEmitter = _interopRequireDefault(_dereq_("./../util/eventEmitter"));

var _events = _interopRequireDefault(_dereq_("./../events"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Visuals = function Visuals(container, options) {
  _eventEmitter.default.call(this, options, 'Visuals');

  var self = this; // can be overwritten with setter fn

  var replay = new _replay.default(this, options);
  var recorder = new _recorder.default(this, replay, options);
  var recorderInsides = new _recorderInsides.default(this, options);
  var notifier = new _notifier.default(this, options);
  var debug = options.debug;
  var visualsElement;
  var built;

  function buildNoScriptTag() {
    var noScriptElement = container.querySelector('noscript');

    if (!noScriptElement) {
      noScriptElement = (0, _hyperscript.default)('noscript');
      noScriptElement.innerHTML = 'Please enable Javascript';
      visualsElement.appendChild(noScriptElement);
    }
  }

  function buildChildren() {
    debug('Visuals: buildChildren()');
    buildNoScriptTag();

    if (!options.playerOnly) {
      notifier.build();
      recorderInsides.build();
    }

    replay.build();
    debug('Visuals: built.');
  }

  function initEvents() {
    if (!options.playerOnly) {
      debug('Visuals: initEvents()');
      self.on(_events.default.USER_MEDIA_READY, function () {
        built = true;
        self.endWaiting();
        container.enableForm(false);
      }).on(_events.default.PREVIEW, function () {
        self.endWaiting();
      }).on(_events.default.BLOCKING, function (blockingOptions) {
        if (!blockingOptions.hideForm && !options.adjustFormOnBrowserError) {// do nothing, user still can enter form inputs
          // can be useful when you are on i.E. seeflow's contact page and
          // still want to tick off the webcam option
        } else {
          container.disableForm(true);
        }
      }).on(_events.default.PREVIEW_SHOWN, function () {
        container.validate(true);
      }).on(_events.default.LOADED_META_DATA, function () {
        correctDimensions();
      }).on(_events.default.ERROR, function (err) {
        if (err.removeDimensions && err.removeDimensions()) {
          removeDimensions();
        }
      });
    }
  }

  function correctDimensions() {
    visualsElement.style.width = self.getRecorderWidth(true) + 'px';
    visualsElement.style.height = self.getRecorderHeight(true) + 'px';
  }

  function removeDimensions() {
    visualsElement.style.width = 'auto';
    visualsElement.style.height = 'auto';
  }

  this.getRatio = function () {
    if (visualsElement.clientWidth) {
      // special case for safari, see getRatio() in recorder
      return visualsElement.clientHeight / visualsElement.clientWidth;
    } else {
      return 0;
    }
  };

  function isRecordable() {
    return !self.isNotifying() && !replay.isShown() && !self.isCountingDown();
  }

  this.isCountingDown = function () {
    return recorderInsides.isCountingDown();
  };

  this.build = function () {
    visualsElement = container.querySelector('.' + options.selectors.visualsClass);

    if (!visualsElement) {
      visualsElement = (0, _hyperscript.default)('div.' + options.selectors.visualsClass);
      var buttonsElement = container.querySelector('.' + options.selectors.buttonsClass); // make sure it's placed before the buttons, but only if it's a child
      // element of the container = inside the container

      if (buttonsElement && !container.isOutsideElementOf(buttonsElement)) {
        container.insertBefore(visualsElement, buttonsElement);
      } else {
        container.appendChild(visualsElement);
      }
    } // do not hide visuals element so that apps can give it a predefined
    // width or height through css but hide all children


    visualsElement.classList.add('visuals');
    correctDimensions();
    !built && initEvents();
    buildChildren(); // needed for replay handling and container.isOutsideElementOf()

    self.parentNode = visualsElement.parentNode;
    built = true;
  };

  this.querySelector = function (selector) {
    return visualsElement && visualsElement.querySelector(selector);
  };

  this.appendChild = function (child) {
    visualsElement && visualsElement.appendChild(child);
  };

  this.removeChild = function (child) {
    visualsElement.removeChild(child);
  };

  this.reset = function () {
    this.endWaiting();
    recorder.reset();
  };

  this.beginWaiting = function () {
    container.beginWaiting();
  };

  this.endWaiting = function () {
    container.endWaiting();
  };

  this.stop = function (params) {
    recorder.stop(params);
    recorderInsides.hidePause();
  };

  this.back = function (params, cb) {
    if (!cb && params) {
      cb = params;
      params = {};
    }

    replay.hide();
    notifier.hide();

    if (params.keepHidden) {
      recorder.hide();
      cb && cb();
    } else {
      recorder.back(cb);
    }
  };

  this.recordAgain = function () {
    this.back(function () {
      self.once(_events.default.USER_MEDIA_READY, function () {
        self.record();
      });
    });
  };

  this.unload = function (e) {
    try {
      recorder.unload(e);
      recorderInsides.unload(e);
      replay.unload(e);
      built = false;
    } catch (exc) {
      this.emit(_events.default.ERROR, exc);
    }
  };

  this.isNotifying = function () {
    return notifier.isVisible();
  };

  this.isReplayShown = function () {
    return replay.isShown();
  };

  this.pause = function (params) {
    recorder.pause(params);
    recorderInsides.showPause();
  };

  this.resume = function () {
    if (recorderInsides.isCountingDown()) {
      recorderInsides.resumeCountdown();
    } else {
      recorder.resume();
    }

    recorderInsides.hidePause();
  };

  this.pauseOrResume = function () {
    if (isRecordable.call(this)) {
      if (this.isRecording()) {
        this.pause();
      } else if (recorder.isPaused()) {
        this.resume();
      } else if (recorder.isReady()) {
        this.record();
      }
    }
  };

  this.recordOrStop = function () {
    if (isRecordable()) {
      if (this.isRecording()) {
        this.stop();
      } else if (recorder.isReady()) {
        this.record();
      }
    }
  };

  this.record = function () {
    if (options.video.countdown) {
      this.emit(_events.default.COUNTDOWN);
      recorderInsides.startCountdown(recorder.record.bind(recorder));
    } else {
      recorder.record();
    }
  };

  this.getRecorder = function () {
    return recorder;
  };

  this.getReplay = function () {
    return replay;
  };

  this.validate = function () {
    return recorder.validate() && this.isReplayShown();
  };

  this.getRecordingStats = function () {
    return recorder.getRecordingStats();
  };

  this.getAudioSampleRate = function () {
    return recorder.getAudioSampleRate();
  };

  this.isPaused = function () {
    return recorder.isPaused();
  };

  this.error = function (err) {
    notifier.error(err);
  };

  this.hide = function () {
    if (visualsElement) {
      (0, _hidden.default)(visualsElement, true);
      this.emit(_events.default.HIDE);
    }
  };

  this.isHidden = function () {
    if (!built) {
      return true;
    } else if (visualsElement) {
      return (0, _hidden.default)(visualsElement);
    }
  };

  this.showVisuals = function () {
    visualsElement && (0, _hidden.default)(visualsElement, false);
  };

  this.show = function () {
    !this.isReplayShown() && visualsElement && recorder.build();
    this.showVisuals();
  };

  this.showReplayOnly = function () {
    !this.isReplayShown() && replay.show();
    this.show();
    recorder.hide();
    notifier.hide();
  };

  this.isRecorderUnloaded = function () {
    return recorder.isUnloaded();
  };

  this.isConnecting = function () {
    return recorder.isConnecting();
  };

  this.getRecorderWidth = function (responsive) {
    return recorder.getRecorderWidth(responsive);
  };

  this.getRecorderHeight = function (responsive) {
    return recorder.getRecorderHeight(responsive);
  };

  this.limitWidth = function (width) {
    return container.limitWidth(width, options);
  };

  this.limitHeight = function (height) {
    return container.limitHeight(height);
  };

  this.calculateWidth = function (options) {
    return container.calculateWidth(options);
  };

  this.calculateHeight = function (options) {
    return container.calculateHeight(options);
  };

  this.getReplay = function () {
    return replay;
  };

  this.getBoundingClientRect = function () {
    // fixes https://github.com/binarykitchen/videomail-client/issues/126
    return visualsElement && visualsElement.getBoundingClientRect();
  };

  this.checkTimer = function (intervalSum) {
    recorderInsides.checkTimer(intervalSum);
  };

  this.isNotifierBuilt = function () {
    return notifier && notifier.isBuilt();
  };

  this.isReplayShown = replay.isShown.bind(replay);
  this.hideReplay = replay.hide.bind(replay);
  this.hideRecorder = recorder.hide.bind(recorder);
  this.isRecording = recorder.isRecording.bind(recorder);
  this.isUserMediaLoaded = recorder.isUserMediaLoaded.bind(recorder);
  this.isConnected = recorder.isConnected.bind(recorder);
};

_util.default.inherits(Visuals, _eventEmitter.default);

var _default = Visuals;
exports.default = _default;

},{"./../events":89,"./../util/eventEmitter":96,"./visuals/inside/recorderInsides":113,"./visuals/notifier":114,"./visuals/recorder":115,"./visuals/replay":116,"hidden":31,"hyperscript":33,"util":81}],108:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _hyperscript = _interopRequireDefault(_dereq_("hyperscript"));

var _hidden = _interopRequireDefault(_dereq_("hidden"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(visuals, options) {
  var self = this;
  var countdownElement;
  var intervalId;
  var countdown;
  var paused;

  function fire(cb) {
    self.unload();
    self.hide(); // keep all callbacks async

    setTimeout(function () {
      cb();
    }, 0);
  }

  function countBackward(cb) {
    if (!paused) {
      options.debug('Countdown', countdown);
      countdown--;

      if (countdown < 1) {
        fire(cb);
      } else {
        countdownElement.innerHTML = countdown;
      }
    }
  }

  this.start = function (cb) {
    countdownElement.innerHTML = countdown = options.video.countdown;
    this.show();
    intervalId = setInterval(countBackward.bind(this, cb), 950);
  };

  this.pause = function () {
    paused = true;
  };

  this.resume = function () {
    paused = false;
  };

  this.build = function () {
    countdownElement = visuals.querySelector('.countdown');

    if (!countdownElement) {
      countdownElement = (0, _hyperscript.default)('p.countdown');
      this.hide();
      visuals.appendChild(countdownElement);
    } else {
      this.hide();
    }
  };

  this.show = function () {
    (0, _hidden.default)(countdownElement, false);
  };

  this.isCountingDown = function () {
    return !!intervalId;
  };

  this.unload = function () {
    clearInterval(intervalId);
    paused = false;
    intervalId = null;
  };

  this.hide = function () {
    (0, _hidden.default)(countdownElement, true);
    this.unload();
  };
}

},{"hidden":31,"hyperscript":33}],109:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _hyperscript = _interopRequireDefault(_dereq_("hyperscript"));

var _hidden = _interopRequireDefault(_dereq_("hidden"));

var _events = _interopRequireDefault(_dereq_("./../../../../events"));

var _eventEmitter = _interopRequireDefault(_dereq_("./../../../../util/eventEmitter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(visuals, options) {
  _eventEmitter.default.call(this, options, 'Facing Mode');

  var self = this;
  var facingModeElement;

  function initEvents() {
    self.on(_events.default.ERROR, function () {
      self.hide();
    });
  }

  this.build = function () {
    facingModeElement = visuals.querySelector('.facingMode');

    if (!facingModeElement) {
      facingModeElement = (0, _hyperscript.default)('button.facingMode');
      facingModeElement.innerHTML = '';

      facingModeElement.onclick = function (e) {
        e && e.preventDefault();

        try {
          self.emit(_events.default.SWITCH_FACING_MODE);
        } catch (exc) {
          self.emit(_events.default.ERROR, exc);
        }
      };

      this.hide();
      visuals.appendChild(facingModeElement);
    } else {
      this.hide();
    }

    initEvents();
  };

  this.hide = function () {
    (0, _hidden.default)(facingModeElement, true);
  };

  this.show = function () {
    (0, _hidden.default)(facingModeElement, false);
  };
}

},{"./../../../../events":89,"./../../../../util/eventEmitter":96,"hidden":31,"hyperscript":33}],110:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _hyperscript = _interopRequireDefault(_dereq_("hyperscript"));

var _hidden = _interopRequireDefault(_dereq_("hidden"));

var _videomailError = _interopRequireDefault(_dereq_("./../../../../util/videomailError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(visuals, options) {
  if (!options.text.pausedHeader) {
    throw _videomailError.default.create('Paused header cannot be empty', options);
  }

  var pausedBlockElement;
  var pausedHeaderElement;
  var pausedHintElement;

  function hasPausedHint() {
    return options.text.pausedHint;
  }

  this.build = function () {
    pausedBlockElement = visuals.querySelector('.paused');
    pausedHeaderElement = visuals.querySelector('.pausedHeader');

    if (!pausedHeaderElement) {
      pausedBlockElement = (0, _hyperscript.default)('div.paused');
      pausedHeaderElement = (0, _hyperscript.default)('p.pausedHeader');
      this.hide();
      pausedHeaderElement.innerHTML = options.text.pausedHeader;
      pausedBlockElement.appendChild(pausedHeaderElement);

      if (hasPausedHint()) {
        pausedHintElement = visuals.querySelector('.pausedHint');
        pausedHintElement = (0, _hyperscript.default)('p.pausedHint');
        pausedHintElement.innerHTML = options.text.pausedHint;
        pausedBlockElement.appendChild(pausedHintElement);
      }

      visuals.appendChild(pausedBlockElement);
    } else {
      this.hide();
      pausedHeaderElement.innerHTML = options.text.pausedHeader;

      if (hasPausedHint()) {
        pausedHintElement.innerHTML = options.text.pausedHint;
      }
    }
  };

  this.hide = function () {
    (0, _hidden.default)(pausedBlockElement, true);
  };

  this.show = function () {
    (0, _hidden.default)(pausedBlockElement, false);
  };
}

},{"./../../../../util/videomailError":101,"hidden":31,"hyperscript":33}],111:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _hyperscript = _interopRequireDefault(_dereq_("hyperscript"));

var _hidden = _interopRequireDefault(_dereq_("hidden"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(visuals) {
  var recordNoteElement;

  this.build = function () {
    recordNoteElement = visuals.querySelector('.recordNote');

    if (!recordNoteElement) {
      recordNoteElement = (0, _hyperscript.default)('p.recordNote');
      this.hide();
      visuals.appendChild(recordNoteElement);
    } else {
      this.hide();
    }
  };

  this.stop = function () {
    this.hide();
    recordNoteElement.classList.remove('near');
    recordNoteElement.classList.remove('nigh');
  };

  this.setNear = function () {
    recordNoteElement.classList.add('near');
  };

  this.setNigh = function () {
    recordNoteElement.classList.add('nigh');
  };

  this.hide = function () {
    (0, _hidden.default)(recordNoteElement, true);
  };

  this.show = function () {
    (0, _hidden.default)(recordNoteElement, false);
  };
}

},{"hidden":31,"hyperscript":33}],112:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _hyperscript = _interopRequireDefault(_dereq_("hyperscript"));

var _hidden = _interopRequireDefault(_dereq_("hidden"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(visuals, recordNote, options) {
  var recordTimerElement;
  var nearComputed = false;
  var endNighComputed = false;
  var started;
  var countdown;

  function pad(n) {
    return n < 10 ? '0' + n : n;
  }

  function thresholdReached(secs, threshold) {
    return secs >= options.video.limitSeconds * threshold;
  }

  function isNear(secs) {
    if (!nearComputed && thresholdReached(secs, 0.6)) {
      nearComputed = true;
      return true;
    } else {
      return false;
    }
  }

  function endIsNigh(secs) {
    if (!endNighComputed && thresholdReached(secs, 0.8)) {
      endNighComputed = true;
      return true;
    } else {
      return false;
    }
  }

  function setNear() {
    recordTimerElement.classList.add('near');
  }

  function setNigh() {
    recordTimerElement.classList.add('nigh');
  }

  this.check = function (opts) {
    var newCountdown = getStartSeconds() - Math.floor(opts.intervalSum / 1e3); // performance optimisation (another reason we need react here!)

    if (newCountdown !== countdown) {
      countdown = newCountdown;
      update();
      countdown < 1 && visuals.stop(true);
    }
  };

  function update() {
    var mins = parseInt(countdown / 60, 10);
    var secs = countdown - mins * 60;

    if (!nearComputed || !endNighComputed) {
      var remainingSeconds = options.video.limitSeconds - countdown;

      if (isNear(remainingSeconds)) {
        recordNote.setNear();
        setNear();
        options.debug('End is near, ' + countdown + ' seconds to go');
      } else if (endIsNigh(remainingSeconds)) {
        recordNote.setNigh();
        setNigh();
        options.debug('End is nigh, ' + countdown + ' seconds to go');
      }
    }

    recordTimerElement.innerHTML = mins + ':' + pad(secs);
  }

  function hide() {
    (0, _hidden.default)(recordTimerElement, true);
  }

  function show() {
    recordTimerElement.classList.remove('near');
    recordTimerElement.classList.remove('nigh');
    (0, _hidden.default)(recordTimerElement, false);
  }

  function getSecondsRecorded() {
    return getStartSeconds() - countdown;
  }

  function getStartSeconds() {
    return options.video.limitSeconds;
  }

  this.start = function () {
    countdown = getStartSeconds();
    nearComputed = endNighComputed = false;
    started = true;
    update();
    show();
  };

  this.pause = function () {
    recordNote.hide();
  };

  this.resume = function () {
    recordNote.show();
  };

  function isStopped() {
    return countdown === null;
  }

  this.stop = function () {
    if (!isStopped() && started) {
      options.debug('Stopping record timer. Was recording for about ~' + getSecondsRecorded() + ' seconds.');
      hide();
      recordNote.stop();
      countdown = null;
      started = false;
    }
  };

  this.build = function () {
    recordTimerElement = visuals.querySelector('.recordTimer');

    if (!recordTimerElement) {
      recordTimerElement = (0, _hyperscript.default)('p.recordTimer');
      hide();
      visuals.appendChild(recordTimerElement);
    } else {
      hide();
    }
  };
}

},{"hidden":31,"hyperscript":33}],113:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = _interopRequireDefault(_dereq_("util"));

var _events = _interopRequireDefault(_dereq_("./../../../events"));

var _eventEmitter = _interopRequireDefault(_dereq_("./../../../util/eventEmitter"));

var _browser = _interopRequireDefault(_dereq_("./../../../util/browser"));

var _countdown = _interopRequireDefault(_dereq_("./recorder/countdown"));

var _pausedNote = _interopRequireDefault(_dereq_("./recorder/pausedNote"));

var _recordNote = _interopRequireDefault(_dereq_("./recorder/recordNote"));

var _recordTimer = _interopRequireDefault(_dereq_("./recorder/recordTimer"));

var _facingMode = _interopRequireDefault(_dereq_("./recorder/facingMode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RecorderInsides = function RecorderInsides(visuals, options) {
  _eventEmitter.default.call(this, options, 'RecorderInsides');

  var self = this;
  var debug = options.debug;
  var recordNote = new _recordNote.default(visuals);
  var recordTimer = new _recordTimer.default(visuals, recordNote, options);
  var browser = new _browser.default(options);
  var countdown;
  var pausedNote;
  var built;
  var facingMode;

  if (options.video.countdown) {
    countdown = new _countdown.default(visuals, options);
  }

  if (options.video.facingModeButton && browser.isMobile()) {
    facingMode = new _facingMode.default(visuals, options);
  }

  if (options.enablePause) {
    pausedNote = new _pausedNote.default(visuals, options);
  }

  function startRecording() {
    recordTimer.start();
  }

  function resumeRecording() {
    recordTimer.resume();
  }

  function stopRecording() {
    recordTimer.stop();
  }

  function pauseRecording() {
    if (self.isCountingDown()) {
      countdown.pause();
    } else {
      recordTimer.pause();
    }
  }

  function onResetting() {
    self.hidePause();
    self.hideCountdown();
    recordTimer.stop();
    facingMode && facingMode.hide();
  }

  function initEvents() {
    debug('RecorderInsides: initEvents()');
    self.on(_events.default.USER_MEDIA_READY, function () {
      facingMode && facingMode.show();
    }).on(_events.default.RECORDING, function () {
      startRecording();
    }).on(_events.default.RESUMING, function () {
      resumeRecording();
    }).on(_events.default.STOPPING, function () {
      stopRecording();
    }).on(_events.default.PAUSED, function () {
      pauseRecording();
    }).on(_events.default.RESETTING, onResetting).on(_events.default.HIDE, function () {
      self.hideCountdown();
    });
  }

  this.build = function () {
    debug('RecorderInsides: build()');
    countdown && countdown.build();
    pausedNote && pausedNote.build();
    facingMode && facingMode.build();
    recordNote.build();
    recordTimer.build();
    !built && initEvents();
    built = true;
  };

  this.unload = function () {
    countdown && countdown.unload();
    built = false;
  };

  this.showPause = function () {
    pausedNote && pausedNote.show();
  };

  this.hidePause = function () {
    pausedNote && pausedNote.hide();
  };

  this.hideCountdown = function () {
    countdown && countdown.hide();
  };

  this.startCountdown = function (cb) {
    countdown && countdown.start(cb);
  };

  this.resumeCountdown = function () {
    countdown && countdown.resume();
  };

  this.isCountingDown = function () {
    return countdown && countdown.isCountingDown();
  };

  this.checkTimer = function (intervalSum) {
    recordTimer.check(intervalSum);
  };
};

_util.default.inherits(RecorderInsides, _eventEmitter.default);

var _default = RecorderInsides;
exports.default = _default;

},{"./../../../events":89,"./../../../util/browser":94,"./../../../util/eventEmitter":96,"./recorder/countdown":108,"./recorder/facingMode":109,"./recorder/pausedNote":110,"./recorder/recordNote":111,"./recorder/recordTimer":112,"util":81}],114:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = _interopRequireDefault(_dereq_("util"));

var _hyperscript = _interopRequireDefault(_dereq_("hyperscript"));

var _hidden = _interopRequireDefault(_dereq_("hidden"));

var _eventEmitter = _interopRequireDefault(_dereq_("./../../util/eventEmitter"));

var _events = _interopRequireDefault(_dereq_("./../../events"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Notifier = function Notifier(visuals, options) {
  _eventEmitter.default.call(this, options, 'Notifier');

  var self = this;
  var debug = options && options.debug;
  var notifyElement;
  var messageElement;
  var explanationElement;
  var entertainTimeoutId;
  var entertaining;
  var built;

  function onStopping(limitReached) {
    var lead = '';
    visuals.beginWaiting();

    if (limitReached) {
      debug('Limit reached');
      lead += options.text.limitReached + '.<br/>';
    }

    lead += options.text.sending + ' ';
    self.notify(lead, null, {
      stillWait: true,
      entertain: options.notifier.entertain
    });
  }

  function onConnecting() {
    self.notify('Connecting ');
  }

  function onLoadingUserMedia() {
    self.notify('Loading webcam ');
  }

  function onProgress(frameProgress, sampleProgress) {
    var overallProgress;

    if (options.isAudioEnabled()) {
      overallProgress = 'Video: ' + frameProgress;

      if (sampleProgress) {
        overallProgress += ', Audio: ' + sampleProgress;
      }
    } else {
      overallProgress = frameProgress;
    }

    self.setExplanation(overallProgress);
  }

  function onBeginVideoEncoding() {
    visuals.beginWaiting();
    var lead = options.text.encoding + ' ';
    self.notify(lead, null, {
      stillWait: true,
      entertain: options.notifier.entertain
    });
    hideExplanation();
  }

  function initEvents() {
    debug('Notifier: initEvents()');
    self.on(_events.default.CONNECTING, function () {
      onConnecting();
    }).on(_events.default.LOADING_USER_MEDIA, function () {
      onLoadingUserMedia();
    }).on(_events.default.USER_MEDIA_READY, function () {
      self.hide();
    }).on(_events.default.LOADED_META_DATA, function () {
      correctDimensions();
    }).on(_events.default.PREVIEW, function () {
      self.hide();
    }).on(_events.default.STOPPING, function (limitReached) {
      onStopping(limitReached);
    }).on(_events.default.PROGRESS, function (frameProgress, sampleProgress) {
      onProgress(frameProgress, sampleProgress);
    }).on(_events.default.BEGIN_VIDEO_ENCODING, function () {
      onBeginVideoEncoding();
    });
  }

  function correctDimensions() {
    notifyElement.style.width = visuals.getRecorderWidth(true) + 'px';
    notifyElement.style.height = visuals.getRecorderHeight(true) + 'px';
  }

  function show() {
    notifyElement && (0, _hidden.default)(notifyElement, false);
  }

  function runEntertainment() {
    if (options.notifier.entertain) {
      if (!entertaining) {
        var randomBackgroundClass = Math.floor(Math.random() * options.notifier.entertainLimit + 1);
        notifyElement.className = 'notifier entertain ' + options.notifier.entertainClass + randomBackgroundClass;
        entertainTimeoutId = setTimeout(runEntertainment, options.notifier.entertainInterval);
        entertaining = true;
      }
    } else {
      cancelEntertainment();
    }
  }

  function cancelEntertainment() {
    if (notifyElement) {
      notifyElement.classList.remove('entertain');
    }

    clearTimeout(entertainTimeoutId);
    entertainTimeoutId = null;
    entertaining = false;
  }

  function setMessage(message, messageOptions) {
    var problem = messageOptions.problem ? messageOptions.problem : false;

    if (messageElement) {
      messageElement.innerHTML = (problem ? '&#x2639; ' : '') + message;
    } else {
      options.logger.warn('Unable to show following because messageElement is empty:', message);
    }
  }

  this.error = function (err) {
    var message = err.message ? err.message.toString() : err.toString();
    var explanation = err.explanation ? err.explanation.toString() : null;

    if (!message) {
      options.debug('Weird empty message generated for error', err);
    }

    self.notify(message, explanation, {
      blocking: true,
      problem: true,
      hideForm: err.hideForm && err.hideForm(),
      classList: err.getClassList && err.getClassList(),
      removeDimensions: err.removeDimensions && err.removeDimensions()
    });
  };

  this.setExplanation = function (explanation) {
    if (!explanationElement) {
      explanationElement = (0, _hyperscript.default)('p');

      if (notifyElement) {
        notifyElement.appendChild(explanationElement);
      } else {
        options.logger.warn('Unable to show explanation because notifyElement is empty:', explanation);
      }
    }

    explanationElement.innerHTML = explanation;
    (0, _hidden.default)(explanationElement, false);
  };

  this.build = function () {
    options.debug('Notifier: build()');
    notifyElement = visuals.querySelector('.notifier');

    if (!notifyElement) {
      notifyElement = (0, _hyperscript.default)('.notifier'); // defaults to div

      this.hide();
      visuals.appendChild(notifyElement);
    } else {
      this.hide();
    }

    !built && initEvents();
    built = true;
  };

  function hideExplanation() {
    if (explanationElement) {
      explanationElement.innerHTML = null;
      (0, _hidden.default)(explanationElement, true);
    }
  }

  this.hide = function () {
    cancelEntertainment();

    if (notifyElement) {
      (0, _hidden.default)(notifyElement, true);
      notifyElement.classList.remove('blocking');
    }

    if (messageElement) {
      messageElement.innerHTML = null;
    }

    hideExplanation();
  };

  this.isVisible = function () {
    if (!built) {
      return false;
    } else {
      return notifyElement && !(0, _hidden.default)(notifyElement);
    }
  };

  this.isBuilt = function () {
    return built;
  };

  this.notify = function (message, explanation, notifyOptions) {
    options.debug('Notifier: notify()');

    if (!notifyOptions) {
      notifyOptions = {};
    }

    var stillWait = notifyOptions.stillWait ? notifyOptions.stillWait : false;
    var entertain = notifyOptions.entertain ? notifyOptions.entertain : false;
    var blocking = notifyOptions.blocking ? notifyOptions.blocking : false;
    var hideForm = notifyOptions.hideForm ? notifyOptions.hideForm : false;
    var classList = notifyOptions.classList ? notifyOptions.classList : false;
    var removeDimensions = notifyOptions.removeDimensions ? notifyOptions.removeDimensions : false;

    if (!messageElement && notifyElement) {
      messageElement = (0, _hyperscript.default)('h2');

      if (explanationElement) {
        notifyElement.insertBefore(messageElement, explanationElement);
      } else {
        notifyElement.appendChild(messageElement);
      }
    }

    if (notifyElement) {
      // reset
      if (!entertain) {
        notifyElement.className = 'notifier';
      }

      if (classList) {
        classList.forEach(function (className) {
          notifyElement.classList.add(className);
        });
      }

      if (removeDimensions) {
        notifyElement.style.width = 'auto';
        notifyElement.style.height = 'auto';
      }
    }

    if (blocking) {
      notifyElement && notifyElement.classList.add('blocking');
      this.emit(_events.default.BLOCKING, {
        hideForm: hideForm
      });
    } else {
      this.emit(_events.default.NOTIFYING);
    }

    visuals.hideReplay();
    visuals.hideRecorder();
    setMessage(message, notifyOptions);

    if (explanation && explanation.length > 0) {
      this.setExplanation(explanation);
    }

    if (entertain) {
      runEntertainment();
    } else {
      cancelEntertainment();
    } // just as a safety in case if an error is thrown in the middle of the build process
    // and visuals aren't built/shown yet.


    visuals.showVisuals();
    show();
    !stillWait && visuals.endWaiting();
  };
};

_util.default.inherits(Notifier, _eventEmitter.default);

var _default = Notifier;
exports.default = _default;

},{"./../../events":89,"./../../util/eventEmitter":96,"hidden":31,"hyperscript":33,"util":81}],115:[function(_dereq_,module,exports){
(function (Buffer){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _websocketStream = _interopRequireDefault(_dereq_("websocket-stream"));

var _canvasToBuffer = _interopRequireDefault(_dereq_("canvas-to-buffer"));

var _util = _interopRequireDefault(_dereq_("util"));

var _hyperscript = _interopRequireDefault(_dereq_("hyperscript"));

var _hidden = _interopRequireDefault(_dereq_("hidden"));

var _animitter = _interopRequireDefault(_dereq_("animitter"));

var _safeJsonStringify = _interopRequireDefault(_dereq_("safe-json-stringify"));

var _userMedia = _interopRequireDefault(_dereq_("./userMedia"));

var _events = _interopRequireDefault(_dereq_("./../../events"));

var _constants = _interopRequireDefault(_dereq_("./../../constants"));

var _eventEmitter = _interopRequireDefault(_dereq_("./../../util/eventEmitter"));

var _browser = _interopRequireDefault(_dereq_("./../../util/browser"));

var _humanize = _interopRequireDefault(_dereq_("./../../util/humanize"));

var _pretty = _interopRequireDefault(_dereq_("./../../util/pretty"));

var _videomailError = _interopRequireDefault(_dereq_("./../../util/videomailError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// credits http://1lineart.kulaone.com/#/
var PIPE_SYMBOL = ',,`,,,,`, ';

var Recorder = function Recorder(visuals, replay, options) {
  _eventEmitter.default.call(this, options, 'Recorder'); // validate some options this class needs


  if (!options || !options.video || !options.video.fps) {
    throw _videomailError.default.create('FPS must be defined', options);
  }

  var self = this;
  var browser = new _browser.default(options);
  var debug = options.debug;
  var loop = null;
  var originalAnimationFrameObject;
  var samplesCount = 0;
  var framesCount = 0;
  var facingMode = options.video.facingMode; // default is 'user'

  var recordingStats = {};
  var confirmedFrameNumber = 0;
  var confirmedSampleNumber = 0;
  var recorderElement;
  var userMedia;
  var userMediaTimeout;
  var retryTimeout;
  var bytesSum;
  var frameProgress;
  var sampleProgress;
  var canvas;
  var ctx;
  var userMediaLoaded;
  var userMediaLoading;
  var submitting;
  var unloaded;
  var stopTime;
  var stream;
  var connecting;
  var connected;
  var blocking;
  var built;
  var key;
  var waitingTime;
  var pingInterval;
  var frame;
  var recordingBufferLength;
  var recordingBuffer;

  function writeStream(buffer, opts) {
    if (stream) {
      if (stream.destroyed) {
        // prevents https://github.com/binarykitchen/videomail.io/issues/393
        stopPings();
        self.emit(_events.default.ERROR, _videomailError.default.create('Already disconnected', 'Sorry, connection to the server has been destroyed. Please reload.', options));
      } else {
        var onFlushedCallback = opts && opts.onFlushedCallback;

        try {
          stream.write(buffer, function () {
            onFlushedCallback && onFlushedCallback(opts);
          });
        } catch (exc) {
          self.emit(_events.default.ERROR, _videomailError.default.create('Failed writing to server', 'stream.write() failed because of ' + (0, _pretty.default)(exc), options));
        }
      }
    }
  }

  function sendPings() {
    pingInterval = window.setInterval(function () {
      debug('Recorder: pinging...');
      writeStream(Buffer.from(''));
    }, options.timeouts.pingInterval);
  }

  function stopPings() {
    clearInterval(pingInterval);
  }

  function onAudioSample(audioSample) {
    samplesCount++;
    var audioBuffer = audioSample.toBuffer(); // if (options.verbose) {
    //     debug(
    //         'Sample #' + samplesCount + ' (' + audioBuffer.length + ' bytes):'
    //     )
    // }

    writeStream(audioBuffer);
  }

  function show() {
    recorderElement && (0, _hidden.default)(recorderElement, false);
  }

  function onUserMediaReady() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    try {
      debug('Recorder: onUserMediaReady()', params);
      var switchingFacingMode = params.switchingFacingMode;
      userMediaLoading = blocking = unloaded = submitting = false;
      userMediaLoaded = true;

      if (!switchingFacingMode) {
        loop = createLoop();
      }

      show();
      self.emit(_events.default.USER_MEDIA_READY, {
        switchingFacingMode: params.switchingFacingMode,
        paused: self.isPaused()
      });
    } catch (exc) {
      self.emit(_events.default.ERROR, exc);
    }
  }

  function clearRetryTimeout() {
    debug('Recorder: clearRetryTimeout()');
    retryTimeout && clearTimeout(retryTimeout);
    retryTimeout = null;
  }

  function clearUserMediaTimeout() {
    if (userMediaTimeout) {
      debug('Recorder: clearUserMediaTimeout()');
      userMediaTimeout && clearTimeout(userMediaTimeout);
      userMediaTimeout = null;
    }
  }

  function calculateFrameProgress() {
    return (confirmedFrameNumber / (framesCount || 1) * 100).toFixed(2) + '%';
  }

  function calculateSampleProgress() {
    return (confirmedSampleNumber / (samplesCount || 1) * 100).toFixed(2) + '%';
  }

  function updateOverallProgress() {
    // when progresses aren't initialized,
    // then do a first calculation to avoid `infinite` or `null` displays
    if (!frameProgress) {
      frameProgress = calculateFrameProgress();
    }

    if (!sampleProgress) {
      sampleProgress = calculateSampleProgress();
    }

    self.emit(_events.default.PROGRESS, frameProgress, sampleProgress);
  }

  function updateFrameProgress(args) {
    confirmedFrameNumber = args.frame ? args.frame : confirmedFrameNumber;
    frameProgress = calculateFrameProgress();
    updateOverallProgress();
  }

  function updateSampleProgress(args) {
    confirmedSampleNumber = args.sample ? args.sample : confirmedSampleNumber;
    sampleProgress = calculateSampleProgress();
    updateOverallProgress();
  }

  function preview(args) {
    confirmedFrameNumber = confirmedSampleNumber = samplesCount = framesCount = 0;
    sampleProgress = frameProgress = null;
    key = args.key;

    if (args.mp4) {
      replay.setMp4Source(args.mp4 + _constants.default.SITE_NAME_LABEL + '/' + options.siteName + '/videomail.mp4', true);
    }

    if (args.webm) {
      replay.setWebMSource(args.webm + _constants.default.SITE_NAME_LABEL + '/' + options.siteName + '/videomail.webm', true);
    }

    self.hide();
    var width = self.getRecorderWidth(true);
    var height = self.getRecorderHeight(true);
    self.emit(_events.default.PREVIEW, key, width, height); // keep it for recording stats

    waitingTime = Date.now() - stopTime;
    recordingStats.waitingTime = waitingTime;

    if (options.debug) {
      debug('While recording, %s have been transferred and waiting time was %s', _humanize.default.filesize(bytesSum, 2), _humanize.default.toTime(waitingTime));
    }
  }

  function initSocket(cb) {
    if (!connected) {
      connecting = true;
      debug('Recorder: initialising web socket to %s', options.socketUrl);
      self.emit(_events.default.CONNECTING); // https://github.com/maxogden/websocket-stream#binary-sockets
      // we use query parameters here because we cannot set custom headers in web sockets,
      // see https://github.com/websockets/ws/issues/467

      var url2Connect = options.socketUrl + '?' + encodeURIComponent(_constants.default.SITE_NAME_LABEL) + '=' + encodeURIComponent(options.siteName);

      try {
        // websocket options cannot be set on client side, only on server, see
        // https://github.com/maxogden/websocket-stream/issues/116#issuecomment-296421077
        stream = (0, _websocketStream.default)(url2Connect, {
          perMessageDeflate: false,
          // see https://github.com/maxogden/websocket-stream/issues/117#issuecomment-298826011
          objectMode: true
        });
      } catch (exc) {
        connecting = connected = false;
        var err;

        if (typeof _websocketStream.default === 'undefined') {
          err = _videomailError.default.create('There is no websocket', 'Cause: ' + (0, _pretty.default)(exc), options);
        } else {
          err = _videomailError.default.create('Failed to connect to server', 'Please upgrade your browser. Your current version does not seem to support websockets.', options, {
            browserProblem: true
          });
        }

        self.emit(_events.default.ERROR, err);
      }

      if (stream) {
        // // useful for debugging streams
        //
        // if (!stream.originalEmit) {
        //   stream.originalEmit = stream.emit
        // }
        //
        // stream.emit = function (type) {
        //   if (stream) {
        //     debug(PIPE_SYMBOL + 'Debugging stream event:', type)
        //     var args = Array.prototype.slice.call(arguments, 0)
        //     return stream.originalEmit.apply(stream, args)
        //   }
        // }
        stream.on('close', function (err) {
          debug(PIPE_SYMBOL + 'Stream has closed');
          connecting = connected = false;

          if (err) {
            self.emit(_events.default.ERROR, err || 'Unhandled websocket error');
          } else {
            self.emit(_events.default.DISCONNECTED); // prevents from https://github.com/binarykitchen/videomail.io/issues/297 happening

            cancelAnimationFrame();
          }
        });
        stream.on('connect', function () {
          debug(PIPE_SYMBOL + 'Stream *connect* event emitted');

          if (!connected) {
            connected = true;
            connecting = unloaded = false;
            self.emit(_events.default.CONNECTED);
            debug('Going to ask for webcam permissons now ...');
            cb && cb();
          }
        });
        stream.on('data', function (data) {
          debug(PIPE_SYMBOL + 'Stream *data* event emitted');
          var command;

          try {
            command = JSON.parse(data.toString());
          } catch (exc) {
            debug('Failed to parse command:', exc);
            self.emit(_events.default.ERROR, _videomailError.default.create('Invalid server command', // toString() since https://github.com/binarykitchen/videomail.io/issues/288
            'Contact us asap. Bad commmand was ' + data.toString() + '. ', options));
          } finally {
            executeCommand.call(self, command);
          }
        });
        stream.on('error', function (err) {
          debug(PIPE_SYMBOL + 'Stream *error* event emitted', err);
          connecting = connected = false; // setting custom text since that err object isn't really an error
          // on iphones when locked, and unlocked, this err is actually
          // an event object with stuff we can't use at all (an external bug)

          self.emit(_events.default.ERROR, _videomailError.default.create('Connection error', 'Data exchange has been interrupted. Please reload.', options));
        }); // just experimental

        stream.on('drain', function () {
          debug(PIPE_SYMBOL + 'Stream *drain* event emitted (should not happen!)');
        });
        stream.on('preend', function () {
          debug(PIPE_SYMBOL + 'Stream *preend* event emitted');
        });
        stream.on('end', function () {
          debug(PIPE_SYMBOL + 'Stream *end* event emitted');
        });
        stream.on('drain', function () {
          debug(PIPE_SYMBOL + 'Stream *drain* event emitted');
        });
        stream.on('pipe', function () {
          debug(PIPE_SYMBOL + 'Stream *pipe* event emitted');
        });
        stream.on('unpipe', function () {
          debug(PIPE_SYMBOL + 'Stream *unpipe* event emitted');
        });
        stream.on('resume', function () {
          debug(PIPE_SYMBOL + 'Stream *resume* event emitted');
        });
        stream.on('uncork', function () {
          debug(PIPE_SYMBOL + 'Stream *uncork* event emitted');
        });
        stream.on('readable', function () {
          debug(PIPE_SYMBOL + 'Stream *preend* event emitted');
        });
        stream.on('prefinish', function () {
          debug(PIPE_SYMBOL + 'Stream *preend* event emitted');
        });
        stream.on('finish', function () {
          debug(PIPE_SYMBOL + 'Stream *preend* event emitted');
        });
      }
    }
  }

  function showUserMedia() {
    // use connected flag to prevent this from happening
    // https://github.com/binarykitchen/videomail.io/issues/323
    return connected && (isNotifying() || !isHidden() || blocking);
  }

  function userMediaErrorCallback(err) {
    userMediaLoading = false;
    clearUserMediaTimeout();
    debug('Recorder: userMediaErrorCallback()', ', Webcam characteristics:', userMedia.getCharacteristics());
    var errorListeners = self.listeners(_events.default.ERROR);

    if (errorListeners.length) {
      if (err.name !== _videomailError.default.MEDIA_DEVICE_NOT_SUPPORTED) {
        self.emit(_events.default.ERROR, _videomailError.default.create(err, options));
      } else {
        // do not emit but retry since MEDIA_DEVICE_NOT_SUPPORTED can be a race condition
        debug('Recorder: ignore user media error', err);
      } // retry after a while


      retryTimeout = setTimeout(initSocket, options.timeouts.userMedia);
    } else {
      if (unloaded) {
        // can happen that container is unloaded but some user media related callbacks
        // are still in process. in that case ignore error.
        debug('Recorder: already unloaded. Not going to throw error', err);
      } else {
        debug('Recorder: no error listeners attached but throwing error', err); // weird situation, throw it instead of emitting since there are no error listeners

        throw _videomailError.default.create(err, 'Unable to process this error since there are no error listeners anymore.', options);
      }
    }
  }

  function getUserMediaCallback(localStream, params) {
    debug('Recorder: getUserMediaCallback()', params);

    if (showUserMedia()) {
      try {
        clearUserMediaTimeout();
        userMedia.init(localStream, function () {
          onUserMediaReady(params);
        }, onAudioSample.bind(self), function (err) {
          self.emit(_events.default.ERROR, err);
        }, params);
      } catch (exc) {
        self.emit(_events.default.ERROR, exc);
      }
    }
  }

  function loadGenuineUserMedia(params) {
    if (!navigator) {
      throw new Error('Navigator is missing!');
    }

    debug('Recorder: loadGenuineUserMedia()');
    self.emit(_events.default.ASKING_WEBCAM_PERMISSION); // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia

    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      // prefer the front camera (if one is available) over the rear one
      var constraints = {
        video: {
          facingMode: facingMode,
          frameRate: {
            ideal: options.video.fps
          }
        },
        audio: options.isAudioEnabled()
      };

      if (browser.isOkSafari()) {// do not use those width/height constraints yet,
        // current safari would throw an error
        // todo in https://github.com/binarykitchen/videomail-client/issues/142
      } else {
        if (options.hasDefinedWidth()) {
          constraints.video.width = {
            ideal: options.video.width
          };
        } else {
          // otherwise try to apply the same width as the element is having
          // but there is no 100% guarantee that this will happen. not
          // all webcam drivers behave the same way
          constraints.video.width = {
            ideal: self.limitWidth()
          };
        }

        if (options.hasDefinedHeight()) {
          constraints.video.height = {
            ideal: options.video.height
          };
        }
      }

      debug('Recorder: navigator.mediaDevices.getUserMedia()', constraints);

      if (navigator.mediaDevices.getSupportedConstraints) {
        debug('Recorder: navigator.mediaDevices.getSupportedConstraints()', navigator.mediaDevices.getSupportedConstraints());
      }

      var genuineUserMediaRequest = navigator.mediaDevices.getUserMedia(constraints);

      if (genuineUserMediaRequest) {
        genuineUserMediaRequest.then(function (localStream) {
          getUserMediaCallback(localStream, params);
        }).catch(userMediaErrorCallback);
      } else {
        // this to trap errors like these
        // Cannot read property 'then' of undefined
        // todo retry with navigator.getUserMedia_() maybe?
        throw _videomailError.default.create('Sorry, your browser is unable to use cameras.', 'Try a different browser with better user media functionalities.', options);
      }
    } else {
      debug('Recorder: navigator.getUserMedia()');
      navigator.getUserMedia_({
        video: true,
        audio: options.isAudioEnabled()
      }, getUserMediaCallback, userMediaErrorCallback);
    }
  }

  function loadUserMedia() {
    if (userMediaLoaded) {
      debug('Recorder: skipping loadUserMedia() because it is already loaded');
      onUserMediaReady();
      return false;
    } else if (userMediaLoading) {
      debug('Recorder: skipping loadUserMedia() because it is already asking for permission');
      return false;
    }

    debug('Recorder: loadUserMedia()');
    self.emit(_events.default.LOADING_USER_MEDIA);

    try {
      userMediaTimeout = setTimeout(function () {
        if (!self.isReady()) {
          self.emit(_events.default.ERROR, browser.getNoAccessIssue());
        }
      }, options.timeouts.userMedia);
      userMediaLoading = true;
      loadGenuineUserMedia();
    } catch (exc) {
      debug('Recorder: failed to load genuine user media');
      userMediaLoading = false;
      var errorListeners = self.listeners(_events.default.ERROR);

      if (errorListeners.length) {
        self.emit(_events.default.ERROR, exc);
      } else {
        debug('Recorder: no error listeners attached but throwing exception', exc);
        throw exc; // throw it further
      }
    }
  }

  function executeCommand(command) {
    try {
      debug('Server commanded: %s', command.command, command.args ? ', ' + (0, _safeJsonStringify.default)(command.args) : '');

      switch (command.command) {
        case 'ready':
          if (!userMediaTimeout) {
            loadUserMedia();
          }

          break;

        case 'preview':
          preview(command.args);
          break;

        case 'error':
          this.emit(_events.default.ERROR, _videomailError.default.create('Oh no, server error!', command.args.err.toString() || '(No explanation given)', options));
          break;

        case 'confirmFrame':
          updateFrameProgress(command.args);
          break;

        case 'confirmSample':
          updateSampleProgress(command.args);
          break;

        case 'beginAudioEncoding':
          this.emit(_events.default.BEGIN_AUDIO_ENCODING);
          break;

        case 'beginVideoEncoding':
          this.emit(_events.default.BEGIN_VIDEO_ENCODING);
          break;

        default:
          this.emit(_events.default.ERROR, 'Unknown server command: ' + command.command);
          break;
      }
    } catch (exc) {
      self.emit(_events.default.ERROR, exc);
    }
  }

  function isNotifying() {
    return visuals.isNotifying();
  }

  function isHidden() {
    return !recorderElement || (0, _hidden.default)(recorderElement);
  }

  function writeCommand(command, args, cb) {
    if (!cb && args && args.constructor === Function) {
      cb = args;
      args = null;
    }

    if (!connected) {
      debug('Reconnecting for the command', command, '');
      initSocket(function () {
        writeCommand(command, args);
        cb && cb();
      });
    } else if (stream) {
      debug('$ %s', command, args ? (0, _safeJsonStringify.default)(args) : '');
      var commandObj = {
        command: command,
        args: args // todo commented out because for some reasons server does not accept such a long
        // array of many log lines. to examine later.
        //
        // add some useful debug info to examine weird stuff like this one
        // UnprocessableError: Unable to encode a video with FPS near zero.
        // todo consider removing this later or have it for debug=1 only?
        //
        // if (options.logger && options.logger.getLines) {
        //   commandObj.logLines = options.logger.getLines()
        // }

      };
      writeStream(Buffer.from((0, _safeJsonStringify.default)(commandObj)));

      if (cb) {
        // keep all callbacks async
        setTimeout(function () {
          cb();
        }, 0);
      }
    }
  }

  function disconnect() {
    if (connected) {
      debug('Recorder: disconnect()');

      if (userMedia) {
        // prevents https://github.com/binarykitchen/videomail-client/issues/114
        userMedia.unloadRemainingEventListeners();
      }

      if (submitting) {
        // server will disconnect socket automatically after submitting
        connecting = connected = false;
      } else if (stream) {
        // force to disconnect socket right now to clean temp files on server
        // event listeners will do the rest
        stream.end();
        stream = undefined;
      }
    }
  }

  function cancelAnimationFrame() {
    loop && loop.dispose();
  }

  function getIntervalSum() {
    return loop.getElapsedTime();
  }

  function getAvgInterval() {
    return getIntervalSum() / framesCount;
  }

  this.getRecordingStats = function () {
    return recordingStats;
  };

  this.getAudioSampleRate = function () {
    return userMedia.getAudioSampleRate();
  };

  this.stop = function (params) {
    debug('stop()', params);
    var limitReached = params.limitReached;
    this.emit(_events.default.STOPPING, limitReached);
    loop.complete();
    stopTime = Date.now();
    recordingStats = {
      avgFps: loop.getFPS(),
      wantedFps: options.video.fps,
      avgInterval: getAvgInterval(),
      wantedInterval: 1e3 / options.video.fps,
      intervalSum: getIntervalSum(),
      framesCount: framesCount,
      videoType: replay.getVideoType()
    };

    if (options.isAudioEnabled()) {
      recordingStats.samplesCount = samplesCount;
      recordingStats.sampleRate = userMedia.getAudioSampleRate();
    }

    writeCommand('stop', recordingStats); // beware, resetting will set framesCount to zero, so leave this here

    this.reset();
  };

  this.back = function (cb) {
    this.emit(_events.default.GOING_BACK);
    show();
    this.reset();
    writeCommand('back', cb);
  };

  function reInitialiseAudio() {
    debug('Recorder: reInitialiseAudio()');
    clearUserMediaTimeout(); // important to free memory

    userMedia && userMedia.stop();
    userMediaLoaded = key = canvas = ctx = null;
    loadUserMedia();
  }

  this.unload = function (e) {
    if (!unloaded) {
      var cause;

      if (e) {
        cause = e.name || e.statusText || e.toString();
      }

      debug('Recorder: unload()' + (cause ? ', cause: ' + cause : ''));
      this.reset();
      clearUserMediaTimeout();
      disconnect();
      unloaded = true;
      built = false;
    }
  };

  this.reset = function () {
    // no need to reset when already unloaded
    if (!unloaded) {
      debug('Recorder: reset()');
      this.emit(_events.default.RESETTING);
      cancelAnimationFrame(); // important to free memory

      userMedia && userMedia.stop();
      replay.reset();
      userMediaLoaded = key = canvas = ctx = waitingTime = null;
    }
  };

  this.validate = function () {
    return connected && framesCount > 0 && canvas === null;
  };

  this.isReady = function () {
    return userMedia.isReady();
  };

  this.pause = function (params) {
    var e = params && params.event;

    if (e instanceof window.Event) {
      params.eventType = e.type;
    }

    debug('pause()', params);
    userMedia.pause();
    loop.stop();
    this.emit(_events.default.PAUSED);
    sendPings();
  };

  this.isPaused = function () {
    return userMedia && userMedia.isPaused();
  };

  this.resume = function () {
    debug('Recorder: resume()');
    stopPings();
    this.emit(_events.default.RESUMING);
    userMedia.resume();
    loop.start();
  };

  function onFlushed(opts) {
    var frameNumber = opts && opts.frameNumber;

    if (frameNumber === 1) {
      self.emit(_events.default.FIRST_FRAME_SENT);
    }
  }

  function createLoop() {
    var newLoop = (0, _animitter.default)({
      fps: options.video.fps
    }, draw); // remember it first

    originalAnimationFrameObject = newLoop.getRequestAnimationFrameObject();
    return newLoop;
  }

  function draw(deltaTime, elapsedTime) {
    try {
      // ctx and stream might become null while unloading
      if (!self.isPaused() && stream && ctx) {
        if (framesCount === 0) {
          self.emit(_events.default.SENDING_FIRST_FRAME);
        }

        framesCount++;
        ctx.drawImage(userMedia.getRawVisuals(), 0, 0, canvas.width, canvas.height);
        recordingBuffer = frame.toBuffer();
        recordingBufferLength = recordingBuffer.length;

        if (recordingBufferLength < 1) {
          throw _videomailError.default.create('Failed to extract webcam data.', options);
        }

        bytesSum += recordingBufferLength;
        writeStream(recordingBuffer, {
          frameNumber: framesCount,
          onFlushedCallback: onFlushed
        }); // if (options.verbose) {
        //   debug(
        //     'Frame #' + framesCount + ' (' + recordingBufferLength + ' bytes):',
        //     ' delta=' + deltaTime + 'ms, ' +
        //     ' elapsed=' + elapsedTime + 'ms'
        //   )
        // }

        visuals.checkTimer({
          intervalSum: elapsedTime
        });
      }
    } catch (exc) {
      self.emit(_events.default.ERROR, exc);
    }
  }

  this.record = function () {
    if (unloaded) {
      return false;
    } // reconnect when needed


    if (!connected) {
      debug('Recorder: reconnecting before recording ...');
      initSocket(function () {
        self.once(_events.default.USER_MEDIA_READY, self.record);
      });
      return false;
    }

    try {
      canvas = userMedia.createCanvas();
    } catch (exc) {
      self.emit(_events.default.ERROR, _videomailError.default.create(exc, options));
      return false;
    }

    ctx = canvas.getContext('2d');

    if (!canvas.width) {
      self.emit(_events.default.ERROR, _videomailError.default.create('Canvas has an invalid width.', options));
      return false;
    }

    if (!canvas.height) {
      self.emit(_events.default.ERROR, _videomailError.default.create('Canvas has an invalid height.', options));
      return false;
    }

    bytesSum = 0;
    frame = new _canvasToBuffer.default(canvas, options);
    debug('Recorder: record()');
    userMedia.record();
    self.emit(_events.default.RECORDING, framesCount);
    loop.start();
  };

  function setAnimationFrameObject(newObj) {
    // must stop and then start to make it become effective, see
    // https://github.com/hapticdata/animitter/issues/5#issuecomment-292019168
    if (loop) {
      var isRecording = self.isRecording();
      loop.stop();
      loop.setRequestAnimationFrameObject(newObj);

      if (isRecording) {
        loop.start();
      }
    }
  }

  function restoreAnimationFrameObject() {
    debug('Recorder: restoreAnimationFrameObject()');
    setAnimationFrameObject(originalAnimationFrameObject);
  }

  function loopWithTimeouts() {
    debug('Recorder: loopWithTimeouts()');
    var wantedInterval = 1e3 / options.video.fps;
    var processingTime = 0;
    var start;

    function raf(fn) {
      return setTimeout(function () {
        start = Date.now();
        fn();
        processingTime = Date.now() - start;
      }, // reducing wanted interval by respecting the time it takes to
      // compute internally since this is not multi-threaded like
      // requestAnimationFrame
      wantedInterval - processingTime);
    }

    function cancel(id) {
      clearTimeout(id);
    }

    setAnimationFrameObject({
      requestAnimationFrame: raf,
      cancelAnimationFrame: cancel
    });
  }

  function buildElement() {
    recorderElement = (0, _hyperscript.default)('video.' + options.selectors.userMediaClass);
    visuals.appendChild(recorderElement);
  }

  function correctDimensions() {
    if (options.hasDefinedWidth()) {
      recorderElement.width = self.getRecorderWidth(true);
    }

    if (options.hasDefinedHeight()) {
      recorderElement.height = self.getRecorderHeight(true);
    }
  }

  function switchFacingMode() {
    if (!browser.isMobile()) {
      return false;
    }

    if (facingMode === 'user') {
      facingMode = 'environment';
    } else if (facingMode === 'environment') {
      facingMode = 'user';
    } else {
      debug('Recorder: unspported facing mode', facingMode);
    }

    loadGenuineUserMedia({
      switchingFacingMode: true
    });
  }

  function initEvents() {
    debug('Recorder: initEvents()');
    self.on(_events.default.SUBMITTING, function () {
      submitting = true;
    }).on(_events.default.SUBMITTED, function () {
      submitting = false;
      self.unload();
    }).on(_events.default.BLOCKING, function () {
      blocking = true;
      clearUserMediaTimeout();
    }).on(_events.default.HIDE, function () {
      self.hide();
    }).on(_events.default.LOADED_META_DATA, function () {
      correctDimensions();
    }).on(_events.default.DISABLING_AUDIO, function () {
      reInitialiseAudio();
    }).on(_events.default.ENABLING_AUDIO, function () {
      reInitialiseAudio();
    }).on(_events.default.INVISIBLE, function () {
      loopWithTimeouts();
    }).on(_events.default.VISIBLE, function () {
      restoreAnimationFrameObject();
    }).on(_events.default.SWITCH_FACING_MODE, function () {
      switchFacingMode();
    });
  }

  this.build = function () {
    var err = browser.checkRecordingCapabilities();

    if (!err) {
      err = browser.checkBufferTypes();
    }

    if (err) {
      this.emit(_events.default.ERROR, err);
    } else {
      recorderElement = visuals.querySelector('video.' + options.selectors.userMediaClass);

      if (!recorderElement) {
        buildElement();
      }

      correctDimensions(); // prevent audio feedback, see
      // https://github.com/binarykitchen/videomail-client/issues/35

      recorderElement.muted = true; // for iphones, see https://github.com/webrtc/samples/issues/929

      recorderElement.setAttribute('playsinline', true);
      recorderElement.setAttribute('webkit-playsinline', 'webkit-playsinline');

      if (!userMedia) {
        userMedia = new _userMedia.default(this, options);
      }

      show();

      if (!built) {
        initEvents();

        if (!connected) {
          initSocket();
        } else {
          loadUserMedia();
        }
      } else {
        loadUserMedia();
      }

      built = true;
    }
  };

  this.isPaused = function () {
    return userMedia && userMedia.isPaused() && !loop.isRunning();
  };

  this.isRecording = function () {
    // checking for stream.destroyed needed since
    // https://github.com/binarykitchen/videomail.io/issues/296
    return loop && loop.isRunning() && !this.isPaused() && !isNotifying() && stream && !stream.destroyed;
  };

  this.hide = function () {
    if (!isHidden()) {
      recorderElement && (0, _hidden.default)(recorderElement, true);
      clearUserMediaTimeout();
      clearRetryTimeout();
    }
  };

  this.isUnloaded = function () {
    return unloaded;
  }; // these two return the true dimensions of the webcam area.
  // needed because on mobiles they might be different.


  this.getRecorderWidth = function (responsive) {
    if (userMedia && userMedia.hasVideoWidth()) {
      return userMedia.getRawWidth(responsive);
    } else if (responsive && options.hasDefinedWidth()) {
      return this.limitWidth(options.video.width);
    }
  };

  this.getRecorderHeight = function (responsive) {
    if (userMedia) {
      return userMedia.getRawHeight(responsive);
    } else if (responsive && options.hasDefinedHeight()) {
      return this.calculateHeight(responsive);
    }
  };

  function getRatio() {
    var ratio;

    if (userMedia) {
      var userMediaVideoWidth = userMedia.getVideoWidth(); // avoid division by zero

      if (userMediaVideoWidth < 1) {
        // use as a last resort fallback computation (needed for safari 11)
        ratio = visuals.getRatio();
      } else {
        ratio = userMedia.getVideoHeight() / userMediaVideoWidth;
      }
    } else {
      ratio = options.getRatio();
    }

    return ratio;
  }

  this.calculateWidth = function (responsive) {
    var videoHeight;

    if (userMedia) {
      videoHeight = userMedia.getVideoHeight();
    } else if (recorderElement) {
      videoHeight = recorderElement.videoHeight || recorderElement.height;
    }

    return visuals.calculateWidth({
      responsive: responsive,
      ratio: getRatio(),
      videoHeight: videoHeight
    });
  };

  this.calculateHeight = function (responsive) {
    var videoWidth;

    if (userMedia) {
      videoWidth = userMedia.getVideoWidth();
    } else if (recorderElement) {
      videoWidth = recorderElement.videoWidth || recorderElement.width;
    }

    return visuals.calculateHeight({
      responsive: responsive,
      ratio: getRatio(),
      videoWidth: videoWidth
    });
  };

  this.getRawVisualUserMedia = function () {
    return recorderElement;
  };

  this.isConnected = function () {
    return connected;
  };

  this.isConnecting = function () {
    return connecting;
  };

  this.limitWidth = function (width) {
    return visuals.limitWidth(width);
  };

  this.limitHeight = function (height) {
    return visuals.limitHeight(height);
  };

  this.isUserMediaLoaded = function () {
    return userMediaLoaded;
  };
};

_util.default.inherits(Recorder, _eventEmitter.default);

var _default = Recorder;
exports.default = _default;

}).call(this,_dereq_("buffer").Buffer)

},{"./../../constants":88,"./../../events":89,"./../../util/browser":94,"./../../util/eventEmitter":96,"./../../util/humanize":97,"./../../util/pretty":99,"./../../util/videomailError":101,"./userMedia":117,"animitter":2,"buffer":8,"canvas-to-buffer":9,"hidden":31,"hyperscript":33,"safe-json-stringify":67,"util":81,"websocket-stream":83}],116:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = _interopRequireDefault(_dereq_("util"));

var _hyperscript = _interopRequireDefault(_dereq_("hyperscript"));

var _hidden = _interopRequireDefault(_dereq_("hidden"));

var _addEventlistenerWithOptions = _interopRequireDefault(_dereq_("add-eventlistener-with-options"));

var _events = _interopRequireDefault(_dereq_("./../../events"));

var _browser = _interopRequireDefault(_dereq_("./../../util/browser"));

var _eventEmitter = _interopRequireDefault(_dereq_("./../../util/eventEmitter"));

var _videomailError = _interopRequireDefault(_dereq_("./../../util/videomailError"));

var _iphoneInlineVideo = _interopRequireDefault(_dereq_("iphone-inline-video"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Replay = function Replay(parentElement, options) {
  _eventEmitter.default.call(this, options, 'Replay');

  var self = this;
  var browser = new _browser.default(options);
  var debug = options.debug;
  var built;
  var replayElement;
  var videomail;

  function buildElement() {
    debug('Replay: buildElement()');
    replayElement = (0, _hyperscript.default)('video.' + options.selectors.replayClass);

    if (!replayElement.setAttribute) {
      throw _videomailError.default.create('Please upgrade browser', options);
    }

    parentElement.appendChild(replayElement);
  }

  function isStandalone() {
    return parentElement.constructor.name === 'HTMLDivElement';
  }

  function copyAttributes(newVideomail) {
    var attributeContainer;
    Object.keys(newVideomail).forEach(function (attribute) {
      attributeContainer = parentElement.querySelector('.' + attribute);

      if (attributeContainer) {
        attributeContainer.innerHTML = newVideomail[attribute];
      }
    });
  }

  function correctDimensions(options) {
    var width, height;

    if (videomail && videomail.playerWidth) {
      width = videomail.playerWidth;
    } else if (parentElement.calculateWidth) {
      width = parentElement.calculateWidth(options);
    }

    if (videomail && videomail.playerHeight) {
      height = videomail.playerHeight;
    } else if (parentElement.calculateHeight) {
      height = parentElement.calculateHeight(options);
    }

    if (width > 0) {
      replayElement.style.width = width + 'px';
    } else {
      replayElement.style.width = 'auto';
    }

    if (height > 0) {
      replayElement.style.height = height + 'px';
    } else {
      replayElement.style.height = 'auto';
    }
  }

  this.setVideomail = function (newVideomail) {
    videomail = newVideomail;

    if (videomail) {
      if (videomail.webm) {
        this.setWebMSource(videomail.webm);
      }

      if (videomail.mp4) {
        this.setMp4Source(videomail.mp4);
      }

      if (videomail.poster) {
        replayElement.setAttribute('poster', videomail.poster);
      }

      copyAttributes(videomail);
    }

    var hasAudio = videomail && videomail.recordingStats && videomail.recordingStats.sampleRate > 0;
    this.show(videomail && videomail.width, videomail && videomail.height, hasAudio);
  };

  this.show = function (recorderWidth, recorderHeight, hasAudio) {
    if (videomail) {
      correctDimensions({
        responsive: true,
        // beware that recorderWidth and recorderHeight can be null sometimes
        videoWidth: recorderWidth || replayElement.videoWidth,
        videoHeight: recorderHeight || replayElement.videoHeight
      });
    }

    (0, _hidden.default)(replayElement, false); // parent element can be any object, be careful!

    if (parentElement) {
      if (parentElement.style) {
        (0, _hidden.default)(parentElement, false);
      } else if (parentElement.show) {
        parentElement.show();
      }
    }

    if (hasAudio) {
      // https://github.com/binarykitchen/videomail-client/issues/115
      // do not set mute to false as this will mess up. just do not mention this attribute at all
      replayElement.setAttribute('volume', 1);
    } else if (!options.isAudioEnabled()) {
      replayElement.setAttribute('muted', true);
    } // this must be called after setting the sources and when becoming visible
    // see https://github.com/bfred-it/iphone-inline-video/issues/16


    _iphoneInlineVideo.default && (0, _iphoneInlineVideo.default)(replayElement, {
      iPad: true
    }); // this forces to actually fetch the videos from the server

    replayElement.load();

    if (!videomail) {
      self.emit(_events.default.PREVIEW_SHOWN);
    } else {
      self.emit(_events.default.REPLAY_SHOWN);
    }
  };

  this.build = function () {
    debug('Replay: build()');
    replayElement = parentElement.querySelector('video.' + options.selectors.replayClass);

    if (!replayElement) {
      buildElement();
    }

    this.hide();
    replayElement.setAttribute('autoplay', true);
    replayElement.setAttribute('autostart', true);
    replayElement.setAttribute('autobuffer', true);
    replayElement.setAttribute('playsinline', true);
    replayElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
    replayElement.setAttribute('controls', 'controls');
    replayElement.setAttribute('preload', 'auto');

    if (!built) {
      if (!isStandalone()) {
        this.on(_events.default.PREVIEW, function (key, recorderWidth, recorderHeight) {
          self.show(recorderWidth, recorderHeight);
        });
      } // makes use of passive option automatically for better performance
      // https://www.npmjs.com/package/add-eventlistener-with-options


      (0, _addEventlistenerWithOptions.default)(replayElement, 'touchstart', function (e) {
        try {
          e && e.preventDefault();
        } catch (exc) {// ignore errors like
          // Unable to preventDefault inside passive event listener invocation.
        }

        if (this.paused) {
          play();
        } else {
          pause();
        }
      });

      replayElement.onclick = function (e) {
        e && e.preventDefault();

        if (this.paused) {
          play();
        } else {
          pause();
        }
      };
    }

    built = true;
    debug('Replay: built.');
  };

  this.unload = function () {
    built = false;
  };

  this.getVideoSource = function (type) {
    var sources = replayElement.getElementsByTagName('source');
    var l = sources.length;
    var videoType = 'video/' + type;
    var source;

    if (l) {
      var i;

      for (i = 0; i < l && !source; i++) {
        if (sources[i].getAttribute('type') === videoType) {
          source = sources[i];
        }
      }
    }

    return source;
  };

  function setVideoSource(type, src, bustCache) {
    var source = self.getVideoSource(type);

    if (src && bustCache) {
      src += '?' + Date.now();
    }

    if (!source) {
      if (src) {
        source = (0, _hyperscript.default)('source', {
          src: src,
          type: 'video/' + type
        });
        replayElement.appendChild(source);
      }
    } else {
      if (src) {
        source.setAttribute('src', src);
      } else {
        replayElement.removeChild(source);
      }
    }
  }

  this.setMp4Source = function (src, bustCache) {
    setVideoSource('mp4', src, bustCache);
  };

  this.setWebMSource = function (src, bustCache) {
    setVideoSource('webm', src, bustCache);
  };

  this.getVideoType = function () {
    return browser.getVideoType(replayElement);
  };

  function pause(cb) {
    // avoids race condition, inspired by
    // http://stackoverflow.com/questions/36803176/how-to-prevent-the-play-request-was-interrupted-by-a-call-to-pause-error
    setTimeout(function () {
      try {
        replayElement.pause();
      } catch (exc) {
        // just ignore, see https://github.com/binarykitchen/videomail.io/issues/386
        options.logger.warn(exc);
      }

      cb && cb();
    }, 15);
  }

  function play() {
    if (replayElement && replayElement.play) {
      var p;

      try {
        p = replayElement.play();
      } catch (exc) {
        // this in the hope to catch InvalidStateError, see
        // https://github.com/binarykitchen/videomail-client/issues/149
        options.logger.warn('Caught replay exception:', exc);
      }

      if (p && typeof Promise !== 'undefined' && p instanceof Promise) {
        p.catch(function (reason) {
          options.logger.warn('Caught pending replay promise exception: %s', reason);
        });
      }
    }
  }

  this.reset = function (cb) {
    // pause video to make sure it won't consume any memory
    pause(function () {
      if (replayElement) {
        self.setMp4Source(null);
        self.setWebMSource(null);
      }

      cb && cb();
    });
  };

  this.hide = function () {
    if (isStandalone()) {
      (0, _hidden.default)(parentElement, true);
    } else {
      replayElement && (0, _hidden.default)(replayElement, true);
    }
  };

  this.isShown = function () {
    return replayElement && !(0, _hidden.default)(replayElement);
  };

  this.getParentElement = function () {
    return parentElement;
  };
};

_util.default.inherits(Replay, _eventEmitter.default);

var _default = Replay;
exports.default = _default;

},{"./../../events":89,"./../../util/browser":94,"./../../util/eventEmitter":96,"./../../util/videomailError":101,"add-eventlistener-with-options":1,"hidden":31,"hyperscript":33,"iphone-inline-video":39,"util":81}],117:[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _hyperscript = _interopRequireDefault(_dereq_("hyperscript"));

var _safeJsonStringify = _interopRequireDefault(_dereq_("safe-json-stringify"));

var _audioRecorder = _interopRequireDefault(_dereq_("./../../util/audioRecorder"));

var _videomailError = _interopRequireDefault(_dereq_("./../../util/videomailError"));

var _eventEmitter = _interopRequireDefault(_dereq_("./../../util/eventEmitter"));

var _mediaEvents = _interopRequireDefault(_dereq_("./../../util/mediaEvents"));

var _pretty = _interopRequireDefault(_dereq_("./../../util/pretty"));

var _browser = _interopRequireDefault(_dereq_("./../../util/browser"));

var _events = _interopRequireDefault(_dereq_("./../../events"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EVENT_ASCII = '|O|';

function _default(recorder, options) {
  _eventEmitter.default.call(this, options, 'UserMedia');

  var rawVisualUserMedia = recorder && recorder.getRawVisualUserMedia();
  var browser = new _browser.default(options);
  var self = this;
  var paused = false;
  var record = false;
  var audioRecorder;
  var currentVisualStream;

  function attachMediaStream(stream) {
    currentVisualStream = stream;

    if (typeof rawVisualUserMedia.srcObject !== 'undefined') {
      rawVisualUserMedia.srcObject = stream;
    } else if (typeof rawVisualUserMedia.src !== 'undefined') {
      var URL = window.URL || window.webkitURL;
      rawVisualUserMedia.src = URL.createObjectURL(stream) || stream;
    } else {
      throw _videomailError.default.create('Error attaching stream to element.', 'Contact the developer about this', options);
    }
  }

  function setVisualStream(localMediaStream) {
    if (localMediaStream) {
      attachMediaStream(localMediaStream);
    } else {
      rawVisualUserMedia.removeAttribute('srcObject');
      rawVisualUserMedia.removeAttribute('src');
      currentVisualStream = null;
    }
  }

  function getVisualStream() {
    if (rawVisualUserMedia.mozSrcObject) {
      return rawVisualUserMedia.mozSrcObject;
    } else if (rawVisualUserMedia.srcObject) {
      return rawVisualUserMedia.srcObject;
    } else {
      return currentVisualStream;
    }
  }

  function hasEnded() {
    if (rawVisualUserMedia.ended) {
      return rawVisualUserMedia.ended;
    } else {
      var visualStream = getVisualStream();
      return visualStream && visualStream.ended;
    }
  }

  function hasInvalidDimensions() {
    if (rawVisualUserMedia.videoWidth && rawVisualUserMedia.videoWidth < 3 || rawVisualUserMedia.height && rawVisualUserMedia.height < 3) {
      return true;
    }
  }

  function getTracks(localMediaStream) {
    var tracks;

    if (localMediaStream && localMediaStream.getTracks) {
      tracks = localMediaStream.getTracks();
    }

    return tracks;
  }

  function getVideoTracks(localMediaStream) {
    var videoTracks;

    if (localMediaStream && localMediaStream.getVideoTracks) {
      videoTracks = localMediaStream.getVideoTracks();
    }

    return videoTracks;
  }

  function getFirstVideoTrack(localMediaStream) {
    var videoTracks = getVideoTracks(localMediaStream);
    var videoTrack;

    if (videoTracks && videoTracks[0]) {
      videoTrack = videoTracks[0];
    }

    return videoTrack;
  }

  function logEvent(event, params) {
    options.debug('UserMedia: ...', EVENT_ASCII, 'event', event, (0, _safeJsonStringify.default)(params));
  }

  function isPromise(anything) {
    return anything && typeof Promise !== 'undefined' && anything instanceof Promise;
  }

  function outputEvent(e) {
    logEvent(e.type, {
      readyState: rawVisualUserMedia.readyState
    }); // remove myself

    rawVisualUserMedia.removeEventListener && rawVisualUserMedia.removeEventListener(e.type, outputEvent);
  }

  this.unloadRemainingEventListeners = function () {
    options.debug('UserMedia: unloadRemainingEventListeners()');

    _mediaEvents.default.forEach(function (eventName) {
      rawVisualUserMedia.removeEventListener(eventName, outputEvent);
    });
  };

  this.init = function (localMediaStream, videoCallback, audioCallback, endedEarlyCallback) {
    var params = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    this.stop(localMediaStream, {
      aboutToInitialize: true,
      switchingFacingMode: params.switchingFacingMode
    });
    var onPlayReached = false;
    var onLoadedMetaDataReached = false;
    var playingPromiseReached = false;

    if (options && options.isAudioEnabled()) {
      audioRecorder = audioRecorder || new _audioRecorder.default(this, options);
    }

    function audioRecord() {
      self.removeListener(_events.default.SENDING_FIRST_FRAME, audioRecord);
      audioRecorder && audioRecorder.record(audioCallback);
    }

    function unloadAllEventListeners() {
      options.debug('UserMedia: unloadAllEventListeners()');
      self.removeListener(_events.default.SENDING_FIRST_FRAME, audioRecord);
      rawVisualUserMedia.removeEventListener && rawVisualUserMedia.removeEventListener('play', onPlay);
      rawVisualUserMedia.removeEventListener && rawVisualUserMedia.removeEventListener('loadedmetadata', onLoadedMetaData);
      self.unloadRemainingEventListeners();
    }

    function play() {
      // Resets the media element and restarts the media resource. Any pending events are discarded.
      try {
        rawVisualUserMedia.load(); // fixes https://github.com/binarykitchen/videomail.io/issues/401
        // see https://github.com/MicrosoftEdge/Demos/blob/master/photocapture/scripts/demo.js#L27

        if (rawVisualUserMedia.paused) {
          options.debug('UserMedia: play()', 'media.readyState=' + rawVisualUserMedia.readyState, 'media.paused=' + rawVisualUserMedia.paused, 'media.ended=' + rawVisualUserMedia.ended, 'media.played=' + (0, _pretty.default)(rawVisualUserMedia.played));
          var p;

          try {
            p = rawVisualUserMedia.play();
          } catch (exc) {
            // this in the hope to catch InvalidStateError, see
            // https://github.com/binarykitchen/videomail-client/issues/149
            options.logger.warn('Caught raw usermedia play exception:', exc);
          } // using the promise here just experimental for now
          // and this to catch any weird errors early if possible


          if (isPromise(p)) {
            p.then(function () {
              if (!playingPromiseReached) {
                options.debug('UserMedia: play promise successful. Playing now.');
                playingPromiseReached = true;
              }
            }).catch(function (reason) {
              // promise can be interrupted, i.E. when switching tabs
              // and promise can get resumed when switching back to tab, hence
              // do not treat this like an error
              options.logger.warn('Caught pending usermedia promise exception: %s', reason.toString());
            });
          }
        }
      } catch (exc) {
        unloadAllEventListeners();
        endedEarlyCallback(exc);
      }
    }

    function fireCallbacks() {
      var readyState = rawVisualUserMedia.readyState; // ready state, see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState

      options.debug('UserMedia: fireCallbacks(' + 'readyState=' + readyState + ', ' + 'onPlayReached=' + onPlayReached + ', ' + 'onLoadedMetaDataReached=' + onLoadedMetaDataReached + ')');

      if (onPlayReached && onLoadedMetaDataReached) {
        videoCallback();

        if (audioRecorder && audioCallback) {
          try {
            audioRecorder.init(localMediaStream);
            self.on(_events.default.SENDING_FIRST_FRAME, audioRecord);
          } catch (exc) {
            unloadAllEventListeners();
            endedEarlyCallback(exc);
          }
        }
      }
    }

    function onPlay() {
      try {
        logEvent('play', {
          readyState: rawVisualUserMedia.readyState,
          audio: options.isAudioEnabled(),
          width: rawVisualUserMedia.width,
          height: rawVisualUserMedia.height,
          videoWidth: rawVisualUserMedia.videoWidth,
          videoHeight: rawVisualUserMedia.videoHeight
        });
        rawVisualUserMedia.removeEventListener && rawVisualUserMedia.removeEventListener('play', onPlay);

        if (hasEnded() || hasInvalidDimensions()) {
          endedEarlyCallback(_videomailError.default.create('Already busy', 'Probably another browser window is using your webcam?', options));
        } else {
          onPlayReached = true;
          fireCallbacks();
        }
      } catch (exc) {
        unloadAllEventListeners();
        endedEarlyCallback(exc);
      }
    } // player modifications to perform that must wait until `loadedmetadata` has been triggered


    function onLoadedMetaData() {
      logEvent('loadedmetadata', {
        readyState: rawVisualUserMedia.readyState,
        paused: rawVisualUserMedia.paused,
        width: rawVisualUserMedia.width,
        height: rawVisualUserMedia.height,
        videoWidth: rawVisualUserMedia.videoWidth,
        videoHeight: rawVisualUserMedia.videoHeight
      });
      rawVisualUserMedia.removeEventListener && rawVisualUserMedia.removeEventListener('loadedmetadata', onLoadedMetaData);

      if (!hasEnded() && !hasInvalidDimensions()) {
        self.emit(_events.default.LOADED_META_DATA); // for android devices, we cannot call play() unless meta data has been loaded!
        // todo consider removing that if it's not the case anymore (for better performance)

        if (browser.isAndroid()) {
          play();
        }

        onLoadedMetaDataReached = true;
        fireCallbacks();
      }
    }

    try {
      var videoTrack = getFirstVideoTrack(localMediaStream);

      if (!videoTrack) {
        options.debug('UserMedia: detected (but no video tracks exist');
      } else if (!videoTrack.enabled) {
        throw _videomailError.default.create('Webcam is disabled', 'The video track seems to be disabled. Enable it in your system.', options);
      } else {
        var description;

        if (videoTrack.label && videoTrack.label.length > 0) {
          description = videoTrack.label;
        }

        description += ' with enabled=' + videoTrack.enabled;
        description += ', muted=' + videoTrack.muted;
        description += ', remote=' + videoTrack.remote;
        description += ', readyState=' + videoTrack.readyState;
        description += ', error=' + videoTrack.error;
        options.debug('UserMedia: ' + videoTrack.kind + ' detected.', description || '');
      } // very useful i think, so leave this and just use options.debug()


      var heavyDebugging = true;

      if (heavyDebugging) {
        _mediaEvents.default.forEach(function (eventName) {
          rawVisualUserMedia.addEventListener(eventName, outputEvent, false);
        });
      }

      rawVisualUserMedia.addEventListener('loadedmetadata', onLoadedMetaData);
      rawVisualUserMedia.addEventListener('play', onPlay); // experimental, not sure if this is ever needed/called? since 2 apr 2017
      // An error occurs while fetching the media data.
      // Error can be an object with the code MEDIA_ERR_NETWORK or higher.
      // networkState equals either NETWORK_EMPTY or NETWORK_IDLE, depending on when the download was aborted.

      rawVisualUserMedia.addEventListener('error', function (err) {
        options.logger.warn('Caught video element error event: %s', (0, _pretty.default)(err));
      });
      setVisualStream(localMediaStream);
      play();
    } catch (exc) {
      self.emit(_events.default.ERROR, exc);
    }
  };

  this.isReady = function () {
    return !!rawVisualUserMedia.src;
  };

  this.stop = function (visualStream) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    try {
      // do not stop "too much" when going to initialize anyway
      var aboutToInitialize = params.aboutToInitialize;
      var switchingFacingMode = params.switchingFacingMode;

      if (!aboutToInitialize) {
        if (!visualStream) {
          visualStream = getVisualStream();
        }

        var tracks = getTracks(visualStream);
        var newStopApiFound = false;

        if (tracks) {
          tracks.forEach(function (track) {
            if (track.stop) {
              newStopApiFound = true;
              track.stop();
            }
          });
        } // will probably become obsolete in one year (after june 2017)


        !newStopApiFound && visualStream && visualStream.stop && visualStream.stop();
        setVisualStream(null);
        audioRecorder && audioRecorder.stop();
        audioRecorder = null;
      } // dont have to reset these states when just switching camera
      // while still recording or pausing


      if (!switchingFacingMode) {
        paused = record = false;
      }
    } catch (exc) {
      self.emit(_events.default.ERROR, exc);
    }
  };

  this.createCanvas = function () {
    return (0, _hyperscript.default)('canvas', {
      width: this.getRawWidth(true),
      height: this.getRawHeight(true)
    });
  };

  this.getVideoHeight = function () {
    return rawVisualUserMedia.videoHeight;
  };

  this.getVideoWidth = function () {
    return rawVisualUserMedia.videoWidth;
  };

  this.hasVideoWidth = function () {
    return this.getVideoWidth() > 0;
  };

  this.getRawWidth = function (responsive) {
    var rawWidth = this.getVideoWidth();
    var widthDefined = options.hasDefinedWidth();

    if (widthDefined || options.hasDefinedHeight()) {
      if (!responsive && widthDefined) {
        rawWidth = options.video.width;
      } else {
        rawWidth = recorder.calculateWidth(responsive);
      }
    }

    if (responsive) {
      rawWidth = recorder.limitWidth(rawWidth);
    }

    return rawWidth;
  };

  this.getRawHeight = function (responsive) {
    var rawHeight;

    if (options.hasDefinedDimension()) {
      rawHeight = recorder.calculateHeight(responsive);

      if (rawHeight < 1) {
        throw _videomailError.default.create('Bad dimensions', 'Calculated raw height cannot be less than 1!', options);
      }
    } else {
      rawHeight = this.getVideoHeight();

      if (rawHeight < 1) {
        throw _videomailError.default.create('Bad dimensions', 'Raw video height from DOM element cannot be less than 1!', options);
      }
    }

    if (responsive) {
      rawHeight = recorder.limitHeight(rawHeight);
    }

    return rawHeight;
  };

  this.getRawVisuals = function () {
    return rawVisualUserMedia;
  };

  this.pause = function () {
    paused = true;
  };

  this.isPaused = function () {
    return paused;
  };

  this.resume = function () {
    paused = false;
  };

  this.record = function () {
    record = true;
  };

  this.isRecording = function () {
    return record;
  };

  this.getAudioSampleRate = function () {
    if (audioRecorder) {
      return audioRecorder.getSampleRate();
    } else {
      return -1;
    }
  };

  this.getCharacteristics = function () {
    return {
      audioSampleRate: this.getAudioSampleRate(),
      muted: rawVisualUserMedia && rawVisualUserMedia.muted,
      width: rawVisualUserMedia && rawVisualUserMedia.width,
      height: rawVisualUserMedia && rawVisualUserMedia.height,
      videoWidth: rawVisualUserMedia && rawVisualUserMedia.videoWidth,
      videoHeight: rawVisualUserMedia && rawVisualUserMedia.videoHeight
    };
  };
}

},{"./../../events":89,"./../../util/audioRecorder":93,"./../../util/browser":94,"./../../util/eventEmitter":96,"./../../util/mediaEvents":98,"./../../util/pretty":99,"./../../util/videomailError":101,"hyperscript":33,"safe-json-stringify":67}],"videomail-client":[function(_dereq_,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _standardize = _interopRequireDefault(_dereq_("./util/standardize"));

var _client = _interopRequireDefault(_dereq_("./client"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!navigator) {
  throw new Error('Navigator is missing!');
} else {
  // Ensures Videomail functionality is not broken on exotic browsers with shims.
  (0, _standardize.default)(window, navigator);
}

var _default = _client.default; // also add that so that we can require() it the normal ES5 way

exports.default = _default;
module.exports = _client.default;

},{"./client":87,"./util/standardize":100}]},{},["videomail-client"])("videomail-client")
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYWRkLWV2ZW50bGlzdGVuZXItd2l0aC1vcHRpb25zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FuaW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hdG9iL2Jyb3dzZXItYXRvYi5qcyIsIm5vZGVfbW9kdWxlcy9hdWRpby1zYW1wbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXNwbGl0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtdG8tYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzLWxpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2xhc3NsaXN0LmpzL2NsYXNzTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9jb250YWlucy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY3JlYXRlLWVycm9yL2NyZWF0ZS1lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC91bWQuanMiLCJub2RlX21vZHVsZXMvZGVmaW5lZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZXNwb3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZG9jdW1lbnQtdmlzaWJpbGl0eS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kb2N1bWVudC12aXNpYmlsaXR5L2tleXMuanMiLCJub2RlX21vZHVsZXMvZHVwbGV4aWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VsZW1lbnQtY2xvc2VzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbmQtb2Ytc3RyZWFtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9maWxlc2l6ZS9saWIvZmlsZXNpemUuanMiLCJub2RlX21vZHVsZXMvZ2V0LWZvcm0tZGF0YS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V2YWwvZXZlbnQuanMiLCJub2RlX21vZHVsZXMvZ2V2YWwvc291cmNlLmpzIiwibm9kZV9tb2R1bGVzL2dsb2JhbC9kb2N1bWVudC5qcyIsIm5vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzIiwibm9kZV9tb2R1bGVzL2hpZGRlbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9odW1hbml6ZS1kdXJhdGlvbi9odW1hbml6ZS1kdXJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9oeXBlcnNjcmlwdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pbnNlcnQtY3NzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ludGVydmFsb21ldGVyL2Rpc3QvaW50ZXJ2YWxvbWV0ZXIuY29tbW9uLWpzLmpzIiwibm9kZV9tb2R1bGVzL2lwaG9uZS1pbmxpbmUtdmlkZW8vZGlzdC9pcGhvbmUtaW5saW5lLXZpZGVvLmNvbW1vbi1qcy5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZmluaXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXBvd2VyLW9mLXR3by9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy10eXBlZGFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2tleW1pcnJvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9udW1iZXItaXMtaW50ZWdlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9udW1iZXItaXMtbmFuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29uY2Uvb25jZS5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmFmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWR5c3RhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkeXN0YXRlL3JlYWR5c3RhdGUuanMiLCJub2RlX21vZHVsZXMvcmVxdWVzdC1mcmFtZS9kaXN0L3JlcXVlc3QtZnJhbWUuanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2FmZS1qc29uLXN0cmluZ2lmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tc2hpZnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvYWdlbnQtYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9jbGllbnQuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvaXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3JlcXVlc3QtYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXNwb25zZS1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdHlwZWRhcnJheS10by1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdWEtcGFyc2VyLWpzL3NyYy91YS1wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy92YWxpZGF0ZS5pby1mbG9hdDMyYXJyYXkvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYnNvY2tldC1zdHJlYW0vc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3dlYnNvY2tldC1zdHJlYW0vd3MtZmFsbGJhY2suanMiLCJub2RlX21vZHVsZXMvd3JhcHB5L3dyYXBweS5qcyIsInBhY2thZ2UuanNvbiIsInNyYy9jbGllbnQuanMiLCJzcmMvY29uc3RhbnRzLmpzIiwic3JjL2V2ZW50cy5qcyIsInNyYy9vcHRpb25zLmpzIiwic3JjL3Jlc291cmNlLmpzIiwic3JjL3N0eWxlcy9jc3MvbWFpbi5taW4uY3NzLmpzIiwic3JjL3V0aWwvYXVkaW9SZWNvcmRlci5qcyIsInNyYy91dGlsL2Jyb3dzZXIuanMiLCJzcmMvdXRpbC9jb2xsZWN0TG9nZ2VyLmpzIiwic3JjL3V0aWwvZXZlbnRFbWl0dGVyLmpzIiwic3JjL3V0aWwvaHVtYW5pemUuanMiLCJzcmMvdXRpbC9tZWRpYUV2ZW50cy5qcyIsInNyYy91dGlsL3ByZXR0eS5qcyIsInNyYy91dGlsL3N0YW5kYXJkaXplLmpzIiwic3JjL3V0aWwvdmlkZW9tYWlsRXJyb3IuanMiLCJzcmMvd3JhcHBlcnMvYnV0dG9ucy5qcyIsInNyYy93cmFwcGVycy9jb250YWluZXIuanMiLCJzcmMvd3JhcHBlcnMvZGltZW5zaW9uLmpzIiwic3JjL3dyYXBwZXJzL2Zvcm0uanMiLCJzcmMvd3JhcHBlcnMvb3B0aW9uc1dyYXBwZXIuanMiLCJzcmMvd3JhcHBlcnMvdmlzdWFscy5qcyIsInNyYy93cmFwcGVycy92aXN1YWxzL2luc2lkZS9yZWNvcmRlci9jb3VudGRvd24uanMiLCJzcmMvd3JhcHBlcnMvdmlzdWFscy9pbnNpZGUvcmVjb3JkZXIvZmFjaW5nTW9kZS5qcyIsInNyYy93cmFwcGVycy92aXN1YWxzL2luc2lkZS9yZWNvcmRlci9wYXVzZWROb3RlLmpzIiwic3JjL3dyYXBwZXJzL3Zpc3VhbHMvaW5zaWRlL3JlY29yZGVyL3JlY29yZE5vdGUuanMiLCJzcmMvd3JhcHBlcnMvdmlzdWFscy9pbnNpZGUvcmVjb3JkZXIvcmVjb3JkVGltZXIuanMiLCJzcmMvd3JhcHBlcnMvdmlzdWFscy9pbnNpZGUvcmVjb3JkZXJJbnNpZGVzLmpzIiwic3JjL3dyYXBwZXJzL3Zpc3VhbHMvbm90aWZpZXIuanMiLCJzcmMvd3JhcHBlcnMvdmlzdWFscy9yZWNvcmRlci5qcyIsInNyYy93cmFwcGVycy92aXN1YWxzL3JlcGxheS5qcyIsInNyYy93cmFwcGVycy92aXN1YWxzL3VzZXJNZWRpYS5qcyIsInNyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzEvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3p1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUEsTUFBTSxHQUFHLEtBQVQ7QUFDRCxHQUZEOztBQUlBLE9BQUssTUFBTCxHQUFjLFlBQVk7QUFDeEIsSUFBQSxNQUFNLEdBQUcsSUFBVDtBQUNELEdBRkQ7O0FBSUEsT0FBSyxXQUFMLEdBQW1CLFlBQVk7QUFDN0IsV0FBTyxNQUFQO0FBQ0QsR0FGRDs7QUFJQSxPQUFLLGtCQUFMLEdBQTBCLFlBQVk7QUFDcEMsUUFBSSxhQUFKLEVBQW1CO0FBQ2pCLGFBQU8sYUFBYSxDQUFDLGFBQWQsRUFBUDtBQUNELEtBRkQsTUFFTztBQUNMLGFBQU8sQ0FBQyxDQUFSO0FBQ0Q7QUFDRixHQU5EOztBQVFBLE9BQUssa0JBQUwsR0FBMEIsWUFBWTtBQUNwQyxXQUFPO0FBQ0wsTUFBQSxlQUFlLEVBQUUsS0FBSyxrQkFBTCxFQURaO0FBRUwsTUFBQSxLQUFLLEVBQUUsa0JBQWtCLElBQUksa0JBQWtCLENBQUMsS0FGM0M7QUFHTCxNQUFBLEtBQUssRUFBRSxrQkFBa0IsSUFBSSxrQkFBa0IsQ0FBQyxLQUgzQztBQUlMLE1BQUEsTUFBTSxFQUFFLGtCQUFrQixJQUFJLGtCQUFrQixDQUFDLE1BSjVDO0FBS0wsTUFBQSxVQUFVLEVBQUUsa0JBQWtCLElBQUksa0JBQWtCLENBQUMsVUFMaEQ7QUFNTCxNQUFBLFdBQVcsRUFBRSxrQkFBa0IsSUFBSSxrQkFBa0IsQ0FBQztBQU5qRCxLQUFQO0FBUUQsR0FURDtBQVVEOzs7Ozs7Ozs7O0FDL2dCRDs7QUFDQTs7OztBQUVBLElBQUksQ0FBQyxTQUFMLEVBQWdCO0FBQ2QsUUFBTSxJQUFJLEtBQUosQ0FBVSx1QkFBVixDQUFOO0FBQ0QsQ0FGRCxNQUVPO0FBQ0w7QUFDQSw0QkFBWSxNQUFaLEVBQW9CLFNBQXBCO0FBQ0Q7O2VBRWMsZSxFQUVmOzs7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixlQUFqQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImFkZC1ldmVudGxpc3RlbmVyLXdpdGgtb3B0aW9uc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJhZGQtZXZlbnRsaXN0ZW5lci13aXRoLW9wdGlvbnNcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgICAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGFkZEV2ZW50TGlzdGVuZXJXaXRoT3B0aW9ucztcblxuXHR2YXIgX2NoZWNrU3VwcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblx0ZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuXHQvKipcblx0ICogQWRkIGV2ZW50IGxpc3RlbmVyIHdpdGggYWRkaXRpb25hbCBvcHRpb25zXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldCAtIFRoZSBFdmVudFRhcmdldCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGV2ZW50IGxpc3RlbmVyIGNhbGxiYWNrXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZXhwbGljaXRseSBwYXNzZWQgZnJvbSBjYWxsZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbk5hbWUgLSBUaGUgYWRkaXRpb2FubCBvcHRpb24gdG8gYWRkIHRvIHRoZSBldmVudCBsaXN0ZW5lciBcblx0ICovXG5cdGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJXaXRoT3B0aW9ucyh0YXJnZXQsIG5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG5cdCAgICB2YXIgb3B0aW9uTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogJ3Bhc3NpdmUnO1xuXG5cdCAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHZhciBsaXN0ZW5lck9wdGlvbnMgPSBfY2hlY2tTdXBwb3J0LlN1cHBvcnRNYXBbb3B0aW9uTmFtZV0gPyBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBfZGVmaW5lUHJvcGVydHkoe30sIG9wdGlvbk5hbWUsIHRydWUpKSA6IG9wdGlvbnM7XG5cdCAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIsIGxpc3RlbmVyT3B0aW9ucyk7XG5cdCAgICB9XG5cdH1cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgICAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuU3VwcG9ydE1hcCA9IHVuZGVmaW5lZDtcblxuXHR2YXIgX09wdGlvbnNNYXA7XG5cblx0dmFyIF9jb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cdGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblx0dmFyIE9wdGlvbnNNYXAgPSAoX09wdGlvbnNNYXAgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PcHRpb25zTWFwLCBfY29uc3RhbnRzLlBBU1NJVkUsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9PcHRpb25zTWFwLCBfY29uc3RhbnRzLkNBUFRVUkUsIGZhbHNlKSwgX2RlZmluZVByb3BlcnR5KF9PcHRpb25zTWFwLCBfY29uc3RhbnRzLk9OQ0UsIGZhbHNlKSwgX09wdGlvbnNNYXApO1xuXG5cdHZhciBnZXRPcHRpb25zTWFwID0gZnVuY3Rpb24gZ2V0T3B0aW9uc01hcCgpIHtcblx0ICAgIE9iamVjdC5rZXlzKE9wdGlvbnNNYXApLmZvckVhY2goZnVuY3Rpb24gKGssIGkpIHtcblx0ICAgICAgICBPcHRpb25zTWFwW2tdID0gY2hlY2tTdXBwb3J0Rm9yUHJvcGVydHkoayk7XG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIE9wdGlvbnNNYXA7XG5cdH07XG5cblx0ZnVuY3Rpb24gY2hlY2tTdXBwb3J0Rm9yUHJvcGVydHkocHJvcGVydHkpIHtcblx0ICAgIGlmICghIU9wdGlvbnNNYXBbcHJvcGVydHldKSB7XG5cdCAgICAgICAgcmV0dXJuIE9wdGlvbnNNYXBbcHJvcGVydHldO1xuXHQgICAgfVxuXG5cdCAgICB0cnkge1xuXHQgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBwcm9wZXJ0eSwge1xuXHQgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgICAgICAgICAgIE9wdGlvbnNNYXBbcHJvcGVydHldID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBvcHRzKTtcblx0ICAgICAgICB3aW5kb3cucmVtb3ZlTGlzdGVuZXIoXCJ0ZXN0XCIsIG51bGwpO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblxuXHQgICAgcmV0dXJuIE9wdGlvbnNNYXBbcHJvcGVydHldO1xuXHR9XG5cblx0dmFyIFN1cHBvcnRNYXAgPSBleHBvcnRzLlN1cHBvcnRNYXAgPSBnZXRPcHRpb25zTWFwKCk7XG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdHZhciBQQVNTSVZFID0gZXhwb3J0cy5QQVNTSVZFID0gJ3Bhc3NpdmUnO1xuXHR2YXIgQ0FQVFVSRSA9IGV4cG9ydHMuQ0FQVFVSRSA9ICdjYXB0dXJlJztcblx0dmFyIE9OQ0UgPSBleHBvcnRzLk9OQ0UgPSAnb25jZSc7XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjsiLCJ2YXIgRXZlbnRFbWl0dGVyICAgICAgICAgID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLFxuICAgIGluaGVyaXRzICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2luaGVyaXRzJyksXG4gICAgcmFmICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgncmFmJyksXG4gICAgbWV0aG9kcztcblxuXG4vL3RoZSBzYW1lIGFzIG9mZiB3aW5kb3cgdW5sZXNzIHBvbHlmaWxsZWQgb3IgaW4gbm9kZVxudmFyIGRlZmF1bHRSQUZPYmplY3QgPSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiByYWYsXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWU6IHJhZi5jYW5jZWxcbn07XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKXsgcmV0dXJuIHRydWU7IH1cblxuLy9tYW5hZ2UgRlBTIGlmIDwgNjAsIGVsc2UgcmV0dXJuIHRydWU7XG5mdW5jdGlvbiBtYWtlVGhyb3R0bGUoZnBzKXtcbiAgICB2YXIgZGVsYXkgPSAxMDAwL2ZwcztcbiAgICB2YXIgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xuXG5cbiAgICBpZiggZnBzPD0wIHx8IGZwcyA9PT0gSW5maW5pdHkgKXtcbiAgICAgICAgcmV0dXJuIHJldHVyblRydWU7XG4gICAgfVxuXG4gICAgLy9pZiBhbiBmcHMgdGhyb3R0bGUgaGFzIGJlZW4gc2V0IHRoZW4gd2UnbGwgYXNzdW1lXG4gICAgLy9pdCBuYXRpdmVseSBydW5zIGF0IDYwZnBzLFxuICAgIHZhciBoYWxmID0gTWF0aC5jZWlsKDEwMDAgLyA2MCkgLyAyO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vaWYgYSBjdXN0b20gZnBzIGlzIHJlcXVlc3RlZFxuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgLy9pcyB0aGlzIGZyYW1lIHdpdGhpbiA4LjVtcyBvZiB0aGUgdGFyZ2V0P1xuICAgICAgICAvL2lmIHNvIHRoZW4gbmV4dCBmcmFtZSBpcyBnb25uYSBiZSB0b28gbGF0ZVxuICAgICAgICBpZihub3cgLSBsYXN0VGltZSA8IGRlbGF5IC0gaGFsZil7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFRpbWUgPSBub3c7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5cblxuLyoqXG4gKiBBbmltaXR0ZXIgcHJvdmlkZXMgZXZlbnQtYmFzZWQgbG9vcHMgZm9yIHRoZSBicm93c2VyIGFuZCBub2RlLFxuICogdXNpbmcgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy5mcHM9SW5maW5pdHldIHRoZSBmcmFtZXJhdGUgcmVxdWVzdGVkLCBkZWZhdWx0cyB0byBhcyBmYXN0IGFzIGl0IGNhbiAoNjBmcHMgb24gd2luZG93KVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLmRlbGF5PTBdIG1pbGxpc2Vjb25kcyBkZWxheSBiZXR3ZWVuIGludm9raW5nIGBzdGFydGAgYW5kIGluaXRpYWxpemluZyB0aGUgbG9vcFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnJlcXVlc3RBbmltYXRpb25GcmFtZU9iamVjdD1nbG9iYWxdIHRoZSBvYmplY3Qgb24gd2hpY2ggdG8gZmluZCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhbmQgYGNhbmNlbEFuaW1hdGlvbkZyYW1lYCBtZXRob2RzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRzLmZpeGVkRGVsdGE9ZmFsc2VdIGlmIHRydWUsIHRpbWVzdGFtcHMgd2lsbCBwcmV0ZW5kIHRvIGJlIGV4ZWN1dGVkIGF0IGZpeGVkIGludGVydmFscyBhbHdheXNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBbmltaXR0ZXIoIG9wdHMgKXtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHRoaXMuX19kZWxheSA9IG9wdHMuZGVsYXkgfHwgMDtcblxuICAgIC8qKiBAZXhwb3NlICovXG4gICAgdGhpcy5maXhlZERlbHRhID0gISFvcHRzLmZpeGVkRGVsdGE7XG5cbiAgICAvKiogQGV4cG9zZSAqL1xuICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gICAgLyoqIEBleHBvc2UgKi9cbiAgICB0aGlzLmRlbHRhVGltZSA9IDA7XG4gICAgLyoqIEBleHBvc2UgKi9cbiAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuX19ydW5uaW5nID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5fX2NvbXBsZXRlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXRGUFMob3B0cy5mcHMgfHwgSW5maW5pdHkpO1xuICAgIHRoaXMuc2V0UmVxdWVzdEFuaW1hdGlvbkZyYW1lT2JqZWN0KG9wdHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lT2JqZWN0IHx8IGRlZmF1bHRSQUZPYmplY3QpO1xufVxuXG5pbmhlcml0cyhBbmltaXR0ZXIsIEV2ZW50RW1pdHRlcik7XG5cbmZ1bmN0aW9uIG9uU3RhcnQoc2NvcGUpe1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHZhciByQUZJRDtcbiAgICAvL2RvbnQgbGV0IGEgc2Vjb25kIGFuaW1hdGlvbiBzdGFydCBvbiB0aGUgc2FtZSBvYmplY3RcbiAgICAvL3VzZSAqLm9uKCd1cGRhdGUnLGZuKSogaW5zdGVhZFxuICAgIGlmKHNjb3BlLl9fcnVubmluZyl7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnJ1bm5pbmcgKz0gMTtcbiAgICBzY29wZS5fX3J1bm5pbmcgPSB0cnVlO1xuICAgIHNjb3BlLl9fbGFzdFRpbWUgPSBub3c7XG4gICAgc2NvcGUuZGVsdGFUaW1lID0gMDtcblxuICAgIC8vZW1pdCAqKnN0YXJ0Kiogb25jZSBhdCB0aGUgYmVnaW5uaW5nXG4gICAgc2NvcGUuZW1pdCgnc3RhcnQnLCBzY29wZS5kZWx0YVRpbWUsIDAsIHNjb3BlLmZyYW1lQ291bnQpO1xuXG4gICAgdmFyIGxhc3RSQUZPYmplY3QgPSBzY29wZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVPYmplY3Q7XG5cbiAgICB2YXIgZHJhd0ZyYW1lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYobGFzdFJBRk9iamVjdCAhPT0gc2NvcGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lT2JqZWN0KXtcbiAgICAgICAgICAgIC8vaWYgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZU9iamVjdCBzd2l0Y2hlZCBpbi1iZXR3ZWVuLFxuICAgICAgICAgICAgLy90aGVuIHJlLXJlcXVlc3Qgd2l0aCB0aGUgbmV3IG9uZSB0byBlbnN1cmUgcHJvcGVyIHVwZGF0ZSBleGVjdXRpb24gY29udGV4dFxuICAgICAgICAgICAgLy9pLmUuIFZSRGlzcGxheSNzdWJtaXRGcmFtZSgpIG1heSBvbmx5IGJlIHJlcXVlc3RlZCB0aHJvdWdoIFZSRGlzcGxheSNyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhd0ZyYW1lKVxuICAgICAgICAgICAgbGFzdFJBRk9iamVjdCA9IHNjb3BlLnJlcXVlc3RBbmltYXRpb25GcmFtZU9iamVjdDtcbiAgICAgICAgICAgIHNjb3BlLnJlcXVlc3RBbmltYXRpb25GcmFtZU9iamVjdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhd0ZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZihzY29wZS5fX2lzUmVhZHlGb3JVcGRhdGUoKSl7XG4gICAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZihzY29wZS5fX3J1bm5pbmcpe1xuICAgICAgICAgICAgckFGSUQgPSBzY29wZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVPYmplY3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXdGcmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY29wZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVPYmplY3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUockFGSUQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNjb3BlLnJlcXVlc3RBbmltYXRpb25GcmFtZU9iamVjdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhd0ZyYW1lKTtcblxuICAgIHJldHVybiBzY29wZTtcbn1cblxubWV0aG9kcyA9IHtcbiAgICAvL0V2ZW50RW1pdHRlciBBbGlhc2VzXG4gICAgb2ZmICAgICA6IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIsXG4gICAgdHJpZ2dlciA6IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCxcblxuICAgIC8qKlxuICAgICAqIHN0b3BzIHRoZSBhbmltYXRpb24gYW5kIG1hcmtzIGl0IGFzIGNvbXBsZXRlZFxuICAgICAqIEBlbWl0IEFuaW1pdHRlciNjb21wbGV0ZVxuICAgICAqIEByZXR1cm5zIHtBbmltaXR0ZXJ9XG4gICAgICovXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLl9fY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb21wbGV0ZScsIHRoaXMuZnJhbWVDb3VudCwgdGhpcy5kZWx0YVRpbWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcHMgdGhlIGFuaW1hdGlvbiBhbmQgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzXG4gICAgICogQGVtaXQgQW5pbWl0dGVyI3N0b3BcbiAgICAgKiBAcmV0dXJucyB7QW5pbWl0dGVyfVxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHRoZSBsYXN0IDIgdXBkYXRlc1xuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldERlbHRhVGltZTogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsdGFUaW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHRvdGFsIG1pbGxpc2Vjb25kcyB0aGF0IHRoZSBhbmltYXRpb24gaGFzIHJhbi5cbiAgICAgKiBUaGlzIGlzIHRoZSBjdW1sYXRpdmUgdmFsdWUgb2YgdGhlIGRlbHRhVGltZSBiZXR3ZWVuIGZyYW1lc1xuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEVsYXBzZWRUaW1lOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5lbGFwc2VkVGltZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBpbnN0YW5jZXMgZnJhbWVzIHBlciBzZWNvbmQgYXMgY2FsY3VsYXRlZCBieSB0aGUgbGFzdCBkZWx0YVxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEZQUzogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsdGFUaW1lID4gMCA/IDEwMDAgLyB0aGlzLmRlbHRhVGltZSA6IDA7XG4gICAgICAgIGlmKHRoaXMuZGVsdGFUaW1lKXtcbiAgICAgICAgICAgIHJldHVybiAxMDAwIC8gdGhpcy5kZWx0YVRpbWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBleHBsaWNpdCBGUFMgbGltaXQgc2V0IHZpYSBgQW5pbWl0dGVyI3NldEZQUyhmcHMpYCBvclxuICAgICAqIHZpYSB0aGUgaW5pdGlhbCBgb3B0aW9ucy5mcHNgIHByb3BlcnR5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBlaXRoZXIgYXMgc2V0IG9yIEluZmluaXR5XG4gICAgICovXG4gICAgZ2V0RlBTTGltaXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZnBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG51bWJlciBvZiBmcmFtZXMgdGhhdCBoYXZlIG9jY3VycmVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVDb3VudDtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG9iamVjdCBwcm92aWRpbmcgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKiBhbmQgYGNhbmNlbEFuaW1hdGlvbkZyYW1lYCBtZXRob2RzXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJlcXVlc3RBbmltYXRpb25GcmFtZU9iamVjdDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lT2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpcyB0aGUgYW5pbWF0aW9uIGxvb3AgYWN0aXZlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUnVubmluZzogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19ydW5uaW5nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpcyB0aGUgYW5pbWF0aW9uIG1hcmtlZCBhcyBjb21wbGV0ZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNDb21wbGV0ZWQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29tcGxldGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXNldCB0aGUgYW5pbWF0aW9uIGxvb3AsIG1hcmtzIGFzIGluY29tcGxldGUsXG4gICAgICogbGVhdmVzIGxpc3RlbmVycyBpbnRhY3RcbiAgICAgKlxuICAgICAqIEBlbWl0IEFuaW1pdHRlciNyZXNldFxuICAgICAqIEByZXR1cm4ge0FuaW1pdHRlcn1cbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuX19jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX2xhc3RUaW1lID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YVRpbWUgPSAwO1xuICAgICAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcblxuICAgICAgICB0aGlzLmVtaXQoJ3Jlc2V0JywgMCwgMCwgdGhpcy5mcmFtZUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgZnJhbWVyYXRlIGZvciB0aGUgYW5pbWF0aW9uIGxvb3BcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcHNcbiAgICAgKiBAcmV0dXJuIHtBbmltaXR0ZXJ9XG4gICAgICovXG4gICAgc2V0RlBTOiBmdW5jdGlvbihmcHMpe1xuICAgICAgICB0aGlzLl9fZnBzID0gZnBzO1xuICAgICAgICB0aGlzLl9faXNSZWFkeUZvclVwZGF0ZSA9IG1ha2VUaHJvdHRsZShmcHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBvYmplY3QgdGhhdCB3aWxsIHByb3ZpZGUgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKiBhbmQgYGNhbmNlbEFuaW1hdGlvbkZyYW1lYCBtZXRob2RzIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7QW5pbWl0dGVyfVxuICAgICAqL1xuICAgIHNldFJlcXVlc3RBbmltYXRpb25GcmFtZU9iamVjdDogZnVuY3Rpb24ob2JqZWN0KXtcbiAgICAgICAgaWYodHlwZW9mIG9iamVjdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iamVjdC5jYW5jZWxBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9iamVjdCBwcm92aWRlIHRvIGBzZXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVPYmplY3RgXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lT2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RhcnQgYW4gYW5pbWF0aW9uIGxvb3BcbiAgICAgKiBAZW1pdCBBbmltaXR0ZXIjc3RhcnRcbiAgICAgKiBAcmV0dXJuIHtBbmltaXR0ZXJ9XG4gICAgICovXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYodGhpcy5fX2RlbGF5KXtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBvblN0YXJ0KHNlbGYpO1xuICAgICAgICAgICAgfSwgdGhpcy5fX2RlbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uU3RhcnQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHN0b3BzIHRoZSBhbmltYXRpb24gbG9vcCwgZG9lcyBub3QgbWFyayBhcyBjb21wbGV0ZWRcbiAgICAgKlxuICAgICAqIEBlbWl0IEFuaW1pdHRlciNzdG9wXG4gICAgICogQHJldHVybiB7QW5pbWl0dGVyfVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCB0aGlzLl9fcnVubmluZyApe1xuICAgICAgICAgICAgdGhpcy5fX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGV4cG9ydHMucnVubmluZyAtPSAxO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wJywgdGhpcy5kZWx0YVRpbWUsIHRoaXMuZWxhcHNlZFRpbWUsIHRoaXMuZnJhbWVDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgYW5pbWF0aW9uIGxvb3Agb25jZVxuICAgICAqXG4gICAgICogQGVtaXQgQW5pbWl0dGVyI3VwZGF0ZVxuICAgICAqIEByZXR1cm4ge0FuaW1pdHRlcn1cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuZnJhbWVDb3VudCsrO1xuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuX19sYXN0VGltZSA9IHRoaXMuX19sYXN0VGltZSB8fCBub3c7XG4gICAgICAgIHRoaXMuZGVsdGFUaW1lID0gKHRoaXMuZml4ZWREZWx0YSB8fCBleHBvcnRzLmdsb2JhbEZpeGVkRGVsdGEpID8gMTAwMC9NYXRoLm1pbig2MCwgdGhpcy5fX2ZwcykgOiBub3cgLSB0aGlzLl9fbGFzdFRpbWU7XG4gICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgKz0gdGhpcy5kZWx0YVRpbWU7XG4gICAgICAgIHRoaXMuX19sYXN0VGltZSA9IG5vdztcblxuICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZGVsdGFUaW1lLCB0aGlzLmVsYXBzZWRUaW1lLCB0aGlzLmZyYW1lQ291bnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5cblxuZm9yKHZhciBtZXRob2QgaW4gbWV0aG9kcyl7XG4gICAgQW5pbWl0dGVyLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kc1ttZXRob2RdO1xufVxuXG5cbi8qKlxuICogY3JlYXRlIGFuIGFuaW1pdHRlciBpbnN0YW5jZSxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuKCBkZWx0YVRpbWU6TnVtYmVyLCBlbGFwc2VkVGltZTpOdW1iZXIsIGZyYW1lQ291bnQ6TnVtYmVyIClcbiAqIEByZXR1cm5zIHtBbmltaXR0ZXJ9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFuaW1pdHRlcihvcHRpb25zLCBmbil7XG5cbiAgICBpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgIGZuID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfaW5zdGFuY2UgPSBuZXcgQW5pbWl0dGVyKCBvcHRpb25zICk7XG5cbiAgICBpZiggZm4gKXtcbiAgICAgICAgX2luc3RhbmNlLm9uKCd1cGRhdGUnLCBmbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9pbnN0YW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gY3JlYXRlQW5pbWl0dGVyO1xuXG4vKipcbiAqIGNyZWF0ZSBhbiBhbmltaXR0ZXIgaW5zdGFuY2UsXG4gKiB3aGVyZSB0aGUgc2NvcGUgaXMgYm91bmQgaW4gYWxsIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4oIGRlbHRhVGltZTpOdW1iZXIsIGVsYXBzZWRUaW1lOk51bWJlciwgZnJhbWVDb3VudDpOdW1iZXIgKVxuICogQHJldHVybnMge0FuaW1pdHRlcn1cbiAqL1xuZXhwb3J0cy5ib3VuZCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGZuKXtcblxuICAgIHZhciBsb29wID0gY3JlYXRlQW5pbWl0dGVyKG9wdGlvbnMsIGZuKSxcbiAgICAgICAgZnVuY3Rpb25LZXlzID0gZnVuY3Rpb25zKEFuaW1pdHRlci5wcm90b3R5cGUpLFxuICAgICAgICBoYXNCaW5kID0gISFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCxcbiAgICAgICAgZm5LZXk7XG5cbiAgICBmb3IodmFyIGk9MDsgaTxmdW5jdGlvbktleXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBmbktleSA9IGZ1bmN0aW9uS2V5c1tpXTtcbiAgICAgICAgbG9vcFtmbktleV0gPSBoYXNCaW5kID8gbG9vcFtmbktleV0uYmluZChsb29wKSA6IGJpbmQobG9vcFtmbktleV0sIGxvb3ApO1xuICAgIH1cblxuICAgIHJldHVybiBsb29wO1xufTtcblxuXG5leHBvcnRzLkFuaW1pdHRlciA9IEFuaW1pdHRlcjtcblxuLyoqXG4gKiBpZiB0cnVlLCBhbGwgYEFuaW1pdHRlcmAgaW5zdGFuY2VzIHdpbGwgYmVoYXZlIGFzIGlmIGBvcHRpb25zLmZpeGVkRGVsdGEgPSB0cnVlYFxuICovXG5leHBvcnRzLmdsb2JhbEZpeGVkRGVsdGEgPSBmYWxzZTtcblxuLy9oZWxwZnVsIHRvIGluaGVyaXQgZnJvbSB3aGVuIHVzaW5nIGJ1bmRsZWRcbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuLy9rZWVwIGEgZ2xvYmFsIGNvdW50ZXIgb2YgYWxsIGxvb3BzIHJ1bm5pbmcsIGhlbHBmdWwgdG8gd2F0Y2ggaW4gZGV2IHRvb2xzXG5leHBvcnRzLnJ1bm5pbmcgPSAwO1xuXG5mdW5jdGlvbiBiaW5kKGZuLCBzY29wZSl7XG4gICAgaWYodHlwZW9mIGZuLmJpbmQgPT09ICdmdW5jdGlvbicpe1xuICAgICAgICByZXR1cm4gZm4uYmluZChzY29wZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZnVuY3Rpb25zKG9iail7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTxrZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYodHlwZW9mIG9ialtrZXlzW2ldXSA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgICBhcnIucHVzaChrZXlzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuXG5cblxuLy9wb2x5ZmlsbCBEYXRlLm5vdyBmb3IgcmVhbC1vbGQgYnJvd3NlcnNcbkRhdGUubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn07XG4iLCIoZnVuY3Rpb24gKHcpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZnVuY3Rpb24gZmluZEJlc3QoYXRvYk5hdGl2ZSkge1xuICAgIC8vIG5vcm1hbCB3aW5kb3dcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGF0b2JOYXRpdmUpIHsgcmV0dXJuIGF0b2JOYXRpdmU7IH1cblxuXG4gICAgLy8gYnJvd3NlcmlmeSAod2ViIHdvcmtlcilcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIEJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGF0b2JCcm93c2VyaWZ5KGEpIHtcbiAgICAgICAgLy8hISBEZWxpYmVyYXRlbHkgdXNpbmcgYW4gQVBJIHRoYXQncyBkZXByZWNhdGVkIGluIG5vZGUuanMgYmVjYXVzZVxuICAgICAgICAvLyEhIHRoaXMgZmlsZSBpcyBmb3IgYnJvd3NlcnMgYW5kIHdlIGV4cGVjdCB0aGVtIHRvIGNvcGUgd2l0aCBpdC5cbiAgICAgICAgLy8hISBEaXNjdXNzaW9uOiBnaXRodWIuY29tL25vZGUtYnJvd3Nlci1jb21wYXQvYXRvYi9wdWxsLzlcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaW9zIHdlYiB3b3JrZXIgd2l0aCBiYXNlNjRqc1xuICAgIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIHcuYmFzZTY0anMpIHtcbiAgICAgIC8vIGJ1ZmZlclRvQmluYXJ5U3RyaW5nXG4gICAgICAvLyBodHRwczovL2dpdC5jb29sYWo4Ni5jb20vY29vbGFqODYvdW5pYmFiZWwuanMvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDUwXG4gICAgICByZXR1cm4gZnVuY3Rpb24gYXRvYldlYldvcmtlcl9pT1MoYSkge1xuICAgICAgICB2YXIgYnVmID0gdy5iYXNlNjRqcy5iNjRUb0J5dGVBcnJheShhKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChidWYsIGZ1bmN0aW9uIChjaCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgICB9O1xuICAgIH1cblxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBpb3Mgd2ViIHdvcmtlciB3aXRob3V0IGJhc2U2NGpzXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJZb3UncmUgcHJvYmFibHkgaW4gYW4gb2xkIGJyb3dzZXIgb3IgYW4gaU9TIHdlYndvcmtlci5cIiArXG5cdFx0XHRcdFwiIEl0IG1pZ2h0IGhlbHAgdG8gaW5jbHVkZSBiZWF0Z2FtbWl0J3MgYmFzZTY0LWpzLlwiKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGF0b2JCZXN0ID0gZmluZEJlc3Qody5hdG9iKTtcbiAgdy5hdG9iID0gYXRvYkJlc3Q7XG5cbiAgaWYgKCh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JykgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhdG9iQmVzdDtcbiAgfVxufSh3aW5kb3cpKTtcbiIsInZhciB0b0J1ZmZlciA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktdG8tYnVmZmVyJylcbnZhciBpc0Zsb2F0MzJBcnJheSA9IHJlcXVpcmUoJ3ZhbGlkYXRlLmlvLWZsb2F0MzJhcnJheScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZsb2F0MzJBcnJheSkge1xuICBpZiAoIWZsb2F0MzJBcnJheSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBGbG9hdDMyQXJyYXkgcGFyYW1ldGVyIGlzIG1pc3NpbmcuJylcbiAgfVxuXG4gIGlmICghaXNGbG9hdDMyQXJyYXkoZmxvYXQzMkFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhcmFtZXRlciBpcyBub3QgYSBGbG9hdDMyQXJyYXkuJylcbiAgfVxuXG4gIHRoaXMudG9CdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGwgPSBmbG9hdDMyQXJyYXkubGVuZ3RoXG4gICAgdmFyIGFyciA9IG5ldyBJbnQxNkFycmF5KGwpXG4gICAgdmFyIGlcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGFycltpXSA9IE1hdGgubWluKDEsIGZsb2F0MzJBcnJheVtpXSkgKiAweDdGRkZcbiAgICB9XG5cbiAgICByZXR1cm4gdG9CdWZmZXIoYXJyKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIiIsIi8qIVxuICogQ3Jvc3MtQnJvd3NlciBTcGxpdCAxLjEuMVxuICogQ29weXJpZ2h0IDIwMDctMjAxMiBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT5cbiAqIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIEVDTUFTY3JpcHQgY29tcGxpYW50LCB1bmlmb3JtIGNyb3NzLWJyb3dzZXIgc3BsaXQgbWV0aG9kXG4gKi9cblxuLyoqXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGEgcmVnZXggb3Igc3RyaW5nIHNlcGFyYXRvci4gTWF0Y2hlcyBvZiB0aGVcbiAqIHNlcGFyYXRvciBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSByZXN1bHQgYXJyYXkuIEhvd2V2ZXIsIGlmIGBzZXBhcmF0b3JgIGlzIGEgcmVnZXggdGhhdCBjb250YWluc1xuICogY2FwdHVyaW5nIGdyb3VwcywgYmFja3JlZmVyZW5jZXMgYXJlIHNwbGljZWQgaW50byB0aGUgcmVzdWx0IGVhY2ggdGltZSBgc2VwYXJhdG9yYCBpcyBtYXRjaGVkLlxuICogRml4ZXMgYnJvd3NlciBidWdzIGNvbXBhcmVkIHRvIHRoZSBuYXRpdmUgYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIGFuZCBjYW4gYmUgdXNlZCByZWxpYWJseVxuICogY3Jvc3MtYnJvd3Nlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNwbGl0LlxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBzZXBhcmF0b3IgUmVnZXggb3Igc3RyaW5nIHRvIHVzZSBmb3Igc2VwYXJhdGluZyB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtsaW1pdF0gTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzdWx0IGFycmF5LlxuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBzdWJzdHJpbmdzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBCYXNpYyB1c2VcbiAqIHNwbGl0KCdhIGIgYyBkJywgJyAnKTtcbiAqIC8vIC0+IFsnYScsICdiJywgJ2MnLCAnZCddXG4gKlxuICogLy8gV2l0aCBsaW1pdFxuICogc3BsaXQoJ2EgYiBjIGQnLCAnICcsIDIpO1xuICogLy8gLT4gWydhJywgJ2InXVxuICpcbiAqIC8vIEJhY2tyZWZlcmVuY2VzIGluIHJlc3VsdCBhcnJheVxuICogc3BsaXQoJy4ud29yZDEgd29yZDIuLicsIC8oW2Etel0rKShcXGQrKS9pKTtcbiAqIC8vIC0+IFsnLi4nLCAnd29yZCcsICcxJywgJyAnLCAnd29yZCcsICcyJywgJy4uJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gc3BsaXQodW5kZWYpIHtcblxuICB2YXIgbmF0aXZlU3BsaXQgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0LFxuICAgIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoXCJcIilbMV0gPT09IHVuZGVmLFxuICAgIC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgc2VsZjtcblxuICBzZWxmID0gZnVuY3Rpb24oc3RyLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBgbmF0aXZlU3BsaXRgXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSBcIltvYmplY3QgUmVnRXhwXVwiKSB7XG4gICAgICByZXR1cm4gbmF0aXZlU3BsaXQuY2FsbChzdHIsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAoc2VwYXJhdG9yLm11bHRpbGluZSA/IFwibVwiIDogXCJcIikgKyAoc2VwYXJhdG9yLmV4dGVuZGVkID8gXCJ4XCIgOiBcIlwiKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gXCJ5XCIgOiBcIlwiKSxcbiAgICAgIC8vIEZpcmVmb3ggMytcbiAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyBcImdcIiksXG4gICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgIHN0ciArPSBcIlwiOyAvLyBUeXBlLWNvbnZlcnRcbiAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKFwiXlwiICsgc2VwYXJhdG9yLnNvdXJjZSArIFwiJCg/IVxcXFxzKVwiLCBmbGFncyk7XG4gICAgfVxuICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgKi9cbiAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZiA/IC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgIGxpbWl0ID4+PiAwOyAvLyBUb1VpbnQzMihsaW1pdClcbiAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdHIpKSB7XG4gICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZikge1xuICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdW5kZWY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoXCJcIikpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufSkoKTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHsgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAhPSBudWxsICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJ2YXIgdG9CdWZmZXIgPSByZXF1aXJlKCd0eXBlZGFycmF5LXRvLWJ1ZmZlcicpXG52YXIgYXRvYiA9IHJlcXVpcmUoJ2F0b2InKVxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbidcblxuLy8gY2FjaGVkLCB1c2VkIG9ubHkgb25jZSBmb3IgYnJvd3NlciBlbnZpcm9ubWVudHNcbnZhciB2ZXJpZmllZEltYWdlVHlwZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjYW52YXMsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgb3B0aW9ucy5pbWFnZSA9IG9wdGlvbnMuaW1hZ2UgPyBvcHRpb25zLmltYWdlIDoge31cbiAgb3B0aW9ucy5pbWFnZS50eXBlcyA9IG9wdGlvbnMuaW1hZ2UudHlwZXMgPyBvcHRpb25zLmltYWdlLnR5cGVzIDogW11cblxuICAvLyB2YWxpZGF0ZSBzb21lIG9wdGlvbnMgdGhpcyBjbGFzcyBuZWVkc1xuICBpZiAob3B0aW9ucy5pbWFnZS50eXBlcy5sZW5ndGggPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSBpbWFnZSB0eXBlcyBhcmUgc3BlY2lmaWVkIScpXG4gIH0gZWxzZSBpZiAob3B0aW9ucy5pbWFnZS50eXBlcy5sZW5ndGggPCAxKSB7XG4gICAgLy8gU2V0IGEgZGVmYXVsdCBpbWFnZSB0eXBlLCBqdXN0IHRvIGJlIHJvYnVzdFxuICAgIG9wdGlvbnMuaW1hZ2UudHlwZXMgPSBpc0Jyb3dzZXIgPyBbJ3dlYnAnLCAnanBlZyddIDogWydwbmcnXVxuICB9XG5cbiAgaWYgKCFvcHRpb25zLmltYWdlLnF1YWxpdHkpIHtcbiAgICBvcHRpb25zLmltYWdlLnF1YWxpdHkgPSAwLjUgLy8gZGVmYXVsdFxuICB9XG5cbiAgdmFyIHF1YWxpdHkgPSBwYXJzZUZsb2F0KG9wdGlvbnMuaW1hZ2UucXVhbGl0eSlcblxuICBmdW5jdGlvbiBjb21wb3NlSW1hZ2VUeXBlIChpbmRleCkge1xuICAgIHZhciBpbWFnZVR5cGVcblxuICAgIGlmIChvcHRpb25zLmltYWdlLnR5cGVzW2luZGV4XSkge1xuICAgICAgaW1hZ2VUeXBlID0gJ2ltYWdlLycgKyBvcHRpb25zLmltYWdlLnR5cGVzW2luZGV4XVxuICAgIH1cblxuICAgIHJldHVybiBpbWFnZVR5cGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTWF0Y2ggKHVyaSwgaW1hZ2VUeXBlKSB7XG4gICAgdmFyIG1hdGNoID0gdXJpICYmIHVyaS5tYXRjaChpbWFnZVR5cGUpXG5cbiAgICBtYXRjaCAmJiBvcHRpb25zLmRlYnVnICYmIG9wdGlvbnMuZGVidWcoJ0ltYWdlIHR5cGUgJXMgdmVyaWZpZWQnLCBpbWFnZVR5cGUpXG5cbiAgICByZXR1cm4gbWF0Y2hcbiAgfVxuXG4gIC8vIFBlcmZvcm1hbmNlIHR3ZWFrLCB3ZSBkbyBub3QgbmVlZCBhIGJpZyBjYW52YXMgZm9yIGZpbmRpbmcgb3V0IHRoZSBzdXBwb3J0ZWQgaW1hZ2UgdHlwZVxuICBmdW5jdGlvbiBnZXRUZXN0Q2FudmFzICgpIHtcbiAgICB2YXIgdGVzdENhbnZhc1xuXG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgdGVzdENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICB0ZXN0Q2FudmFzLndpZHRoID0gdGVzdENhbnZhcy5oZWlnaHQgPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHRlc3RDYW52YXMgPSBjYW52YXNcbiAgICB9XG5cbiAgICByZXR1cm4gdGVzdENhbnZhc1xuICB9XG5cbiAgZnVuY3Rpb24gY2FudmFzU3VwcG9ydHNJbWFnZVR5cGVBc3luYyAoaW1hZ2VUeXBlLCBjYikge1xuICAgIHRyeSB7XG4gICAgICBnZXRUZXN0Q2FudmFzKCkudG9EYXRhVVJMKGltYWdlVHlwZSwgZnVuY3Rpb24gKGVyciwgdXJpKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYihlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobnVsbCwgaXNNYXRjaCh1cmksIGltYWdlVHlwZSkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICBjYihudWxsLCBmYWxzZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYW52YXNTdXBwb3J0c0ltYWdlVHlwZVN5bmMgKGltYWdlVHlwZSkge1xuICAgIHZhciBtYXRjaFxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciB0ZXN0Q2FudmFzID0gZ2V0VGVzdENhbnZhcygpXG4gICAgICB2YXIgdXJpID0gdGVzdENhbnZhcy50b0RhdGFVUkwgJiYgdGVzdENhbnZhcy50b0RhdGFVUkwoaW1hZ2VUeXBlKVxuXG4gICAgICBtYXRjaCA9IGlzTWF0Y2godXJpLCBpbWFnZVR5cGUpXG4gICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAvLyBDYW4gaGFwcGVuIHdoZW4gaS5FLiBhIHNwaWRlciBpcyBjb21pbmcuIEp1c3QgYmUgcm9idXN0IGhlcmUgYW5kIGNvbnRpbnVlLlxuICAgICAgb3B0aW9ucy5kZWJ1ZyAmJlxuICAgICAgb3B0aW9ucy5sb2dnZXIuZGVidWcoJ0ZhaWxlZCB0byBjYWxsIHRvRGF0YVVSTCgpIG9uIGNhbnZhcyBmb3IgaW1hZ2UgdHlwZSAlcycsIGltYWdlVHlwZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hcbiAgfVxuXG4gIGZ1bmN0aW9uIHZlcmlmeUltYWdlVHlwZUFzeW5jIChpbWFnZVR5cGUsIGNiKSB7XG4gICAgY2FudmFzU3VwcG9ydHNJbWFnZVR5cGVBc3luYyhpbWFnZVR5cGUsIGZ1bmN0aW9uIChlcnIsIG1hdGNoKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGNiKG51bGwsIGltYWdlVHlwZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbWFnZVR5cGUgPSBjb21wb3NlSW1hZ2VUeXBlKDEpXG5cbiAgICAgICAgICBjYW52YXNTdXBwb3J0c0ltYWdlVHlwZUFzeW5jKGltYWdlVHlwZSwgZnVuY3Rpb24gKGVyciwgbWF0Y2gpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgY2IoZXJyKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2IobnVsbCwgbWF0Y2ggPyBpbWFnZVR5cGUgOiBudWxsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gdmVyaWZ5SW1hZ2VUeXBlU3luYyAoaW1hZ2VUeXBlKSB7XG4gICAgaWYgKCFjYW52YXNTdXBwb3J0c0ltYWdlVHlwZVN5bmMoaW1hZ2VUeXBlKSkge1xuICAgICAgaWYgKG9wdGlvbnMuaW1hZ2UudHlwZXNbMV0pIHtcbiAgICAgICAgaW1hZ2VUeXBlID0gY29tcG9zZUltYWdlVHlwZSgxKVxuXG4gICAgICAgIGlmICghY2FudmFzU3VwcG9ydHNJbWFnZVR5cGVTeW5jKGltYWdlVHlwZSkpIHtcbiAgICAgICAgICBpbWFnZVR5cGUgPSBudWxsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlVHlwZSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhaW1hZ2VUeXBlICYmIG9wdGlvbnMuZGVidWcgJiYgb3B0aW9ucy5sb2dnZXIuZGVidWcoJ1VuYWJsZSB0byB2ZXJpZnkgaW1hZ2UgdHlwZScpXG5cbiAgICByZXR1cm4gaW1hZ2VUeXBlXG4gIH1cblxuICAvLyBjYWxsYmFja3MgYXJlIG5lZWRlZCBmb3Igc2VydmVyIHNpZGUgdGVzdHNcbiAgZnVuY3Rpb24gdmVyaWZ5SW1hZ2VUeXBlIChjYikge1xuICAgIHZhciBpbWFnZVR5cGUgPSBjb21wb3NlSW1hZ2VUeXBlKDApXG5cbiAgICBpZiAoY2IpIHtcbiAgICAgIHZlcmlmeUltYWdlVHlwZUFzeW5jKGltYWdlVHlwZSwgY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2ZXJpZnlJbWFnZVR5cGVTeW5jKGltYWdlVHlwZSlcbiAgICB9XG4gIH1cblxuICAvLyB0aGlzIG1ldGhvZCBpcyBwcm92ZW4gdG8gYmUgZmFzdCwgc2VlXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2RhdGEtdXJpLXRvLWJ1ZmZlci1wZXJmb3JtYW5jZS8zXG4gIGZ1bmN0aW9uIHVyaVRvQnVmZmVyICh1cmkpIHtcbiAgICB2YXIgdXJpU3BsaXR0ZWQgPSB1cmkuc3BsaXQoJywnKVsxXVxuICAgIHZhciBieXRlc1xuXG4gICAgLy8gQmV3YXJlIHRoYXQgdGhlIGF0b2IgZnVuY3Rpb24gbWlnaHQgYmUgYSBzdGF0aWMgb25lIGZvciBzZXJ2ZXIgc2lkZSB0ZXN0c1xuICAgIGlmICh0eXBlb2YgKGF0b2IpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBieXRlcyA9IGF0b2IodXJpU3BsaXR0ZWQpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgKHNlbGYuY29uc3RydWN0b3IuYXRvYikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJ5dGVzID0gc2VsZi5jb25zdHJ1Y3Rvci5hdG9iKHVyaVNwbGl0dGVkKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0b2IgZnVuY3Rpb24gaXMgbWlzc2luZycpXG4gICAgfVxuXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmxlbmd0aClcblxuICAgIC8vIGh0dHA6Ly9tcmFsZS5waC9ibG9nLzIwMTQvMTIvMjQvYXJyYXktbGVuZ3RoLWNhY2hpbmcuaHRtbFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnl0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhcnJbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRvQnVmZmVyKGFycilcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvQnVmZmVyU3luYyAoKSB7XG4gICAgdmFyIGltYWdlVHlwZSA9IHNlbGYuZ2V0SW1hZ2VUeXBlKClcbiAgICB2YXIgYnVmZmVyXG5cbiAgICBpZiAoaW1hZ2VUeXBlKSB7XG4gICAgICB2YXIgdXJpID0gY2FudmFzLnRvRGF0YVVSTChpbWFnZVR5cGUsIHF1YWxpdHkpXG4gICAgICBidWZmZXIgPSB1cmlUb0J1ZmZlcih1cmkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgZnVuY3Rpb24gdG9CdWZmZXJBc3luYyAoY2IpIHtcbiAgICBzZWxmLmdldEltYWdlVHlwZShmdW5jdGlvbiAoZXJyLCBpbWFnZVR5cGUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2IoZXJyKVxuICAgICAgfSBlbHNlIGlmICghaW1hZ2VUeXBlKSB7XG4gICAgICAgIGNiKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy50b0RhdGFVUkwoaW1hZ2VUeXBlLCBmdW5jdGlvbiAoZXJyLCB1cmkpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYihlcnIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNiKG51bGwsIHVyaVRvQnVmZmVyKHVyaSkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB0aGlzLnRvQnVmZmVyID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0b0J1ZmZlckFzeW5jKGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdG9CdWZmZXJTeW5jKClcbiAgICB9XG4gIH1cblxuICAvLyBicm93c2VycyBkbyBub3QgbmVlZCBhIGNhbGxiYWNrLCBidXQgdGVzdHMgZG9cbiAgdGhpcy5nZXRJbWFnZVR5cGUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAvLyBvbmx5IHJ1biBmb3IgdGhlIGZpcnN0IHRpbWUgdGhpcyBjb25zdHJ1Y3RvciBpcyBjYWxsZWQgYW5kXG4gICAgLy8gY2FjaGUgcmVzdWx0IGZvciB0aGUgbmV4dCBjYWxsc1xuICAgIGlmIChjYikge1xuICAgICAgaWYgKCF2ZXJpZmllZEltYWdlVHlwZSB8fCAhaXNCcm93c2VyKSB7XG4gICAgICAgIHZlcmlmeUltYWdlVHlwZShmdW5jdGlvbiAoZXJyLCBuZXdWZXJpZmllZEltYWdlVHlwZSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVyaWZpZWRJbWFnZVR5cGUgPSBuZXdWZXJpZmllZEltYWdlVHlwZVxuICAgICAgICAgICAgY2IobnVsbCwgdmVyaWZpZWRJbWFnZVR5cGUpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbCwgdmVyaWZpZWRJbWFnZVR5cGUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9uIHRoZSBicm93c2VyIHNpZGUgd2UgZG8gY2FjaGUgaXQgZm9yIHNwZWVkXG4gICAgICBpZiAoIXZlcmlmaWVkSW1hZ2VUeXBlIHx8ICFpc0Jyb3dzZXIpIHtcbiAgICAgICAgdmVyaWZpZWRJbWFnZVR5cGUgPSB2ZXJpZnlJbWFnZVR5cGUoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmVyaWZpZWRJbWFnZVR5cGVcbiAgICB9XG4gIH1cbn1cbiIsIi8vIGNvbnRhaW5zLCBhZGQsIHJlbW92ZSwgdG9nZ2xlXG52YXIgaW5kZXhvZiA9IHJlcXVpcmUoJ2luZGV4b2YnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsYXNzTGlzdFxuXG5mdW5jdGlvbiBDbGFzc0xpc3QoZWxlbSkge1xuICAgIHZhciBjbCA9IGVsZW0uY2xhc3NMaXN0XG5cbiAgICBpZiAoY2wpIHtcbiAgICAgICAgcmV0dXJuIGNsXG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTGlzdCA9IHtcbiAgICAgICAgYWRkOiBhZGRcbiAgICAgICAgLCByZW1vdmU6IHJlbW92ZVxuICAgICAgICAsIGNvbnRhaW5zOiBjb250YWluc1xuICAgICAgICAsIHRvZ2dsZTogdG9nZ2xlXG4gICAgICAgICwgdG9TdHJpbmc6ICR0b1N0cmluZ1xuICAgICAgICAsIGxlbmd0aDogMFxuICAgICAgICAsIGl0ZW06IGl0ZW1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NMaXN0XG5cbiAgICBmdW5jdGlvbiBhZGQodG9rZW4pIHtcbiAgICAgICAgdmFyIGxpc3QgPSBnZXRUb2tlbnMoKVxuICAgICAgICBpZiAoaW5kZXhvZihsaXN0LCB0b2tlbikgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5wdXNoKHRva2VuKVxuICAgICAgICBzZXRUb2tlbnMobGlzdClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUodG9rZW4pIHtcbiAgICAgICAgdmFyIGxpc3QgPSBnZXRUb2tlbnMoKVxuICAgICAgICAgICAgLCBpbmRleCA9IGluZGV4b2YobGlzdCwgdG9rZW4pXG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgc2V0VG9rZW5zKGxpc3QpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGFpbnModG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGluZGV4b2YoZ2V0VG9rZW5zKCksIHRva2VuKSA+IC0xXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlKHRva2VuKSB7XG4gICAgICAgIGlmIChjb250YWlucyh0b2tlbikpIHtcbiAgICAgICAgICAgIHJlbW92ZSh0b2tlbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkKHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICR0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NOYW1lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlbShpbmRleCkge1xuICAgICAgICB2YXIgdG9rZW5zID0gZ2V0VG9rZW5zKClcbiAgICAgICAgcmV0dXJuIHRva2Vuc1tpbmRleF0gfHwgbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRva2VucygpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lXG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcihjbGFzc05hbWUuc3BsaXQoXCIgXCIpLCBpc1RydXRoeSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUb2tlbnMobGlzdCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGhcblxuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGxpc3Quam9pbihcIiBcIilcbiAgICAgICAgY2xhc3NMaXN0Lmxlbmd0aCA9IGxlbmd0aFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2xhc3NMaXN0W2ldID0gbGlzdFtpXVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGxpc3RbbGVuZ3RoXVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyIChhcnIsIGZuKSB7XG4gICAgdmFyIHJldCA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZuKGFycltpXSkpIHJldC5wdXNoKGFycltpXSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBpc1RydXRoeSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlXG59XG4iLCIvKlxuICogY2xhc3NMaXN0LmpzOiBDcm9zcy1icm93c2VyIGZ1bGwgZWxlbWVudC5jbGFzc0xpc3QgaW1wbGVtZW50YXRpb24uXG4gKiAxLjEuMjAxNTAzMTJcbiAqXG4gKiBCeSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXG4gKiBMaWNlbnNlOiBEZWRpY2F0ZWQgdG8gdGhlIHB1YmxpYyBkb21haW4uXG4gKiAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9jbGFzc0xpc3QuanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuICovXG5cbi8qZ2xvYmFsIHNlbGYsIGRvY3VtZW50LCBET01FeGNlcHRpb24gKi9cblxuLyohIEBzb3VyY2UgaHR0cDovL3B1cmwuZWxpZ3JleS5jb20vZ2l0aHViL2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9jbGFzc0xpc3QuanMgKi9cblxuaWYgKFwiZG9jdW1lbnRcIiBpbiBzZWxmKSB7XG5cbi8vIEZ1bGwgcG9seWZpbGwgZm9yIGJyb3dzZXJzIHdpdGggbm8gY2xhc3NMaXN0IHN1cHBvcnRcbi8vIEluY2x1ZGluZyBJRSA8IEVkZ2UgbWlzc2luZyBTVkdFbGVtZW50LmNsYXNzTGlzdFxuaWYgKCEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKSkgXG5cdHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiAhKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcImdcIikpKSB7XG5cbihmdW5jdGlvbiAodmlldykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKCEoJ0VsZW1lbnQnIGluIHZpZXcpKSByZXR1cm47XG5cbnZhclxuXHQgIGNsYXNzTGlzdFByb3AgPSBcImNsYXNzTGlzdFwiXG5cdCwgcHJvdG9Qcm9wID0gXCJwcm90b3R5cGVcIlxuXHQsIGVsZW1DdHJQcm90byA9IHZpZXcuRWxlbWVudFtwcm90b1Byb3BdXG5cdCwgb2JqQ3RyID0gT2JqZWN0XG5cdCwgc3RyVHJpbSA9IFN0cmluZ1twcm90b1Byb3BdLnRyaW0gfHwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xuXHR9XG5cdCwgYXJySW5kZXhPZiA9IEFycmF5W3Byb3RvUHJvcF0uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhclxuXHRcdFx0ICBpID0gMFxuXHRcdFx0LCBsZW4gPSB0aGlzLmxlbmd0aFxuXHRcdDtcblx0XHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fVxuXHQvLyBWZW5kb3JzOiBwbGVhc2UgYWxsb3cgY29udGVudCBjb2RlIHRvIGluc3RhbnRpYXRlIERPTUV4Y2VwdGlvbnNcblx0LCBET01FeCA9IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XG5cdFx0dGhpcy5uYW1lID0gdHlwZTtcblx0XHR0aGlzLmNvZGUgPSBET01FeGNlcHRpb25bdHlwZV07XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0fVxuXHQsIGNoZWNrVG9rZW5BbmRHZXRJbmRleCA9IGZ1bmN0aW9uIChjbGFzc0xpc3QsIHRva2VuKSB7XG5cdFx0aWYgKHRva2VuID09PSBcIlwiKSB7XG5cdFx0XHR0aHJvdyBuZXcgRE9NRXgoXG5cdFx0XHRcdCAgXCJTWU5UQVhfRVJSXCJcblx0XHRcdFx0LCBcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZFwiXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRpZiAoL1xccy8udGVzdCh0b2tlbikpIHtcblx0XHRcdHRocm93IG5ldyBET01FeChcblx0XHRcdFx0ICBcIklOVkFMSURfQ0hBUkFDVEVSX0VSUlwiXG5cdFx0XHRcdCwgXCJTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXJcIlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGFyckluZGV4T2YuY2FsbChjbGFzc0xpc3QsIHRva2VuKTtcblx0fVxuXHQsIENsYXNzTGlzdCA9IGZ1bmN0aW9uIChlbGVtKSB7XG5cdFx0dmFyXG5cdFx0XHQgIHRyaW1tZWRDbGFzc2VzID0gc3RyVHJpbS5jYWxsKGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIilcblx0XHRcdCwgY2xhc3NlcyA9IHRyaW1tZWRDbGFzc2VzID8gdHJpbW1lZENsYXNzZXMuc3BsaXQoL1xccysvKSA6IFtdXG5cdFx0XHQsIGkgPSAwXG5cdFx0XHQsIGxlbiA9IGNsYXNzZXMubGVuZ3RoXG5cdFx0O1xuXHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHRoaXMucHVzaChjbGFzc2VzW2ldKTtcblx0XHR9XG5cdFx0dGhpcy5fdXBkYXRlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLnRvU3RyaW5nKCkpO1xuXHRcdH07XG5cdH1cblx0LCBjbGFzc0xpc3RQcm90byA9IENsYXNzTGlzdFtwcm90b1Byb3BdID0gW11cblx0LCBjbGFzc0xpc3RHZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBDbGFzc0xpc3QodGhpcyk7XG5cdH1cbjtcbi8vIE1vc3QgRE9NRXhjZXB0aW9uIGltcGxlbWVudGF0aW9ucyBkb24ndCBhbGxvdyBjYWxsaW5nIERPTUV4Y2VwdGlvbidzIHRvU3RyaW5nKClcbi8vIG9uIG5vbi1ET01FeGNlcHRpb25zLiBFcnJvcidzIHRvU3RyaW5nKCkgaXMgc3VmZmljaWVudCBoZXJlLlxuRE9NRXhbcHJvdG9Qcm9wXSA9IEVycm9yW3Byb3RvUHJvcF07XG5jbGFzc0xpc3RQcm90by5pdGVtID0gZnVuY3Rpb24gKGkpIHtcblx0cmV0dXJuIHRoaXNbaV0gfHwgbnVsbDtcbn07XG5jbGFzc0xpc3RQcm90by5jb250YWlucyA9IGZ1bmN0aW9uICh0b2tlbikge1xuXHR0b2tlbiArPSBcIlwiO1xuXHRyZXR1cm4gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSAhPT0gLTE7XG59O1xuY2xhc3NMaXN0UHJvdG8uYWRkID0gZnVuY3Rpb24gKCkge1xuXHR2YXJcblx0XHQgIHRva2VucyA9IGFyZ3VtZW50c1xuXHRcdCwgaSA9IDBcblx0XHQsIGwgPSB0b2tlbnMubGVuZ3RoXG5cdFx0LCB0b2tlblxuXHRcdCwgdXBkYXRlZCA9IGZhbHNlXG5cdDtcblx0ZG8ge1xuXHRcdHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcblx0XHRpZiAoY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSA9PT0gLTEpIHtcblx0XHRcdHRoaXMucHVzaCh0b2tlbik7XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0d2hpbGUgKCsraSA8IGwpO1xuXG5cdGlmICh1cGRhdGVkKSB7XG5cdFx0dGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XG5cdH1cbn07XG5jbGFzc0xpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdHZhclxuXHRcdCAgdG9rZW5zID0gYXJndW1lbnRzXG5cdFx0LCBpID0gMFxuXHRcdCwgbCA9IHRva2Vucy5sZW5ndGhcblx0XHQsIHRva2VuXG5cdFx0LCB1cGRhdGVkID0gZmFsc2Vcblx0XHQsIGluZGV4XG5cdDtcblx0ZG8ge1xuXHRcdHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcblx0XHRpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XG5cdFx0d2hpbGUgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0dGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cdFx0XHRpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XG5cdFx0fVxuXHR9XG5cdHdoaWxlICgrK2kgPCBsKTtcblxuXHRpZiAodXBkYXRlZCkge1xuXHRcdHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xuXHR9XG59O1xuY2xhc3NMaXN0UHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gKHRva2VuLCBmb3JjZSkge1xuXHR0b2tlbiArPSBcIlwiO1xuXG5cdHZhclxuXHRcdCAgcmVzdWx0ID0gdGhpcy5jb250YWlucyh0b2tlbilcblx0XHQsIG1ldGhvZCA9IHJlc3VsdCA/XG5cdFx0XHRmb3JjZSAhPT0gdHJ1ZSAmJiBcInJlbW92ZVwiXG5cdFx0OlxuXHRcdFx0Zm9yY2UgIT09IGZhbHNlICYmIFwiYWRkXCJcblx0O1xuXG5cdGlmIChtZXRob2QpIHtcblx0XHR0aGlzW21ldGhvZF0odG9rZW4pO1xuXHR9XG5cblx0aWYgKGZvcmNlID09PSB0cnVlIHx8IGZvcmNlID09PSBmYWxzZSkge1xuXHRcdHJldHVybiBmb3JjZTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gIXJlc3VsdDtcblx0fVxufTtcbmNsYXNzTGlzdFByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5qb2luKFwiIFwiKTtcbn07XG5cbmlmIChvYmpDdHIuZGVmaW5lUHJvcGVydHkpIHtcblx0dmFyIGNsYXNzTGlzdFByb3BEZXNjID0ge1xuXHRcdCAgZ2V0OiBjbGFzc0xpc3RHZXR0ZXJcblx0XHQsIGVudW1lcmFibGU6IHRydWVcblx0XHQsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHR9O1xuXHR0cnkge1xuXHRcdG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcblx0fSBjYXRjaCAoZXgpIHsgLy8gSUUgOCBkb2Vzbid0IHN1cHBvcnQgZW51bWVyYWJsZTp0cnVlXG5cdFx0aWYgKGV4Lm51bWJlciA9PT0gLTB4N0ZGNUVDNTQpIHtcblx0XHRcdGNsYXNzTGlzdFByb3BEZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcblx0XHRcdG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcblx0XHR9XG5cdH1cbn0gZWxzZSBpZiAob2JqQ3RyW3Byb3RvUHJvcF0uX19kZWZpbmVHZXR0ZXJfXykge1xuXHRlbGVtQ3RyUHJvdG8uX19kZWZpbmVHZXR0ZXJfXyhjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RHZXR0ZXIpO1xufVxuXG59KHNlbGYpKTtcblxufSBlbHNlIHtcbi8vIFRoZXJlIGlzIGZ1bGwgb3IgcGFydGlhbCBuYXRpdmUgY2xhc3NMaXN0IHN1cHBvcnQsIHNvIGp1c3QgY2hlY2sgaWYgd2UgbmVlZFxuLy8gdG8gbm9ybWFsaXplIHRoZSBhZGQvcmVtb3ZlIGFuZCB0b2dnbGUgQVBJcy5cblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIik7XG5cblx0dGVzdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImMxXCIsIFwiYzJcIik7XG5cblx0Ly8gUG9seWZpbGwgZm9yIElFIDEwLzExIGFuZCBGaXJlZm94IDwyNiwgd2hlcmUgY2xhc3NMaXN0LmFkZCBhbmRcblx0Ly8gY2xhc3NMaXN0LnJlbW92ZSBleGlzdCBidXQgc3VwcG9ydCBvbmx5IG9uZSBhcmd1bWVudCBhdCBhIHRpbWUuXG5cdGlmICghdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYzJcIikpIHtcblx0XHR2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWwgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlW21ldGhvZF07XG5cblx0XHRcdERPTVRva2VuTGlzdC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHRva2VuKSB7XG5cdFx0XHRcdHZhciBpLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdHRva2VuID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdG9yaWdpbmFsLmNhbGwodGhpcywgdG9rZW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0Y3JlYXRlTWV0aG9kKCdhZGQnKTtcblx0XHRjcmVhdGVNZXRob2QoJ3JlbW92ZScpO1xuXHR9XG5cblx0dGVzdEVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcImMzXCIsIGZhbHNlKTtcblxuXHQvLyBQb2x5ZmlsbCBmb3IgSUUgMTAgYW5kIEZpcmVmb3ggPDI0LCB3aGVyZSBjbGFzc0xpc3QudG9nZ2xlIGRvZXMgbm90XG5cdC8vIHN1cHBvcnQgdGhlIHNlY29uZCBhcmd1bWVudC5cblx0aWYgKHRlc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImMzXCIpKSB7XG5cdFx0dmFyIF90b2dnbGUgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZTtcblxuXHRcdERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24odG9rZW4sIGZvcmNlKSB7XG5cdFx0XHRpZiAoMSBpbiBhcmd1bWVudHMgJiYgIXRoaXMuY29udGFpbnModG9rZW4pID09PSAhZm9yY2UpIHtcblx0XHRcdFx0cmV0dXJuIGZvcmNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIF90b2dnbGUuY2FsbCh0aGlzLCB0b2tlbik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHR9XG5cblx0dGVzdEVsZW1lbnQgPSBudWxsO1xufSgpKTtcblxufVxuXG59XG5cbiIsInZhciBET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkgPSAxNlxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zXG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGNvbnRhaW5lciwgZWxlbSkge1xuICAgIGlmIChjb250YWluZXIuY29udGFpbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jb250YWlucyhlbGVtKVxuICAgIH1cblxuICAgIHZhciBjb21wYXJpc29uID0gY29udGFpbmVyLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW0pXG5cbiAgICByZXR1cm4gY29tcGFyaXNvbiA9PT0gMCB8fCBjb21wYXJpc29uICYgRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvLyAgICAgY3JlYXRlLWVycm9yLmpzIDAuMy4xXG4vLyAgICAgKGMpIDIwMTMgVGltIEdyaWVzc2VyXG4vLyAgICAgVGhpcyBzb3VyY2UgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gQSBzaW1wbGUgdXRpbGl0eSBmb3Igc3ViY2xhc3NpbmcgdGhlIFwiRXJyb3JcIlxuLy8gb2JqZWN0IGluIG11bHRpcGxlIGVudmlyb25tZW50cywgd2hpbGUgbWFpbnRhaW5pbmdcbi8vIHJlbGV2YW50IHN0YWNrIHRyYWNlcywgbWVzc2FnZXMsIGFuZCBwcm90b3R5cGVzLlxuZmFjdG9yeShmdW5jdGlvbigpIHtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gQ3JlYXRlcyBhbiBuZXcgZXJyb3IgdHlwZSB3aXRoIGEgXCJuYW1lXCIsXG4vLyBhbmQgYW55IGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXRcbi8vIG9uIHRoZSBlcnJvciBpbnN0YW5jZS5cbnJldHVybiBmdW5jdGlvbigpIHtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gIH1cbiAgdmFyIG5hbWUgICAgICAgPSBnZXROYW1lKGFyZ3MpO1xuICB2YXIgdGFyZ2V0ICAgICA9IGdldFRhcmdldChhcmdzKTtcbiAgdmFyIHByb3BlcnRpZXMgPSBnZXRQcm9wcyhhcmdzKTtcbiAgZnVuY3Rpb24gRXJyb3JDdG9yKG1lc3NhZ2UsIG9iaikge1xuICAgIGF0dGFjaFByb3BzKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIGF0dGFjaFByb3BzKHRoaXMsIG9iaik7XG4gICAgdGhpcy5tZXNzYWdlID0gKG1lc3NhZ2UgfHwgdGhpcy5tZXNzYWdlKTtcbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlLm1lc3NhZ2U7XG4gICAgICB0aGlzLnN0YWNrID0gbWVzc2FnZS5zdGFjaztcbiAgICB9IGVsc2UgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gRXJyKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gRXJyb3JDdG9yOyB9XG4gIEVyci5wcm90b3R5cGUgPSB0YXJnZXRbJ3Byb3RvdHlwZSddO1xuICBFcnJvckN0b3IucHJvdG90eXBlID0gbmV3IEVycigpO1xuICBFcnJvckN0b3IucHJvdG90eXBlLm5hbWUgPSAoJycgKyBuYW1lKSB8fCAnQ3VzdG9tRXJyb3InO1xuICByZXR1cm4gRXJyb3JDdG9yO1xufTtcblxuLy8gSnVzdCBhIGZldyBoZWxwZXJzIHRvIGNsZWFuIHVwIHRoZSBmdW5jdGlvbiBhYm92ZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzXG5mdW5jdGlvbiBnZXROYW1lKGFyZ3MpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHJldHVybiBpc0Vycm9yKGFyZ3NbMF0pID8gKGFyZ3NbMV0gfHwgJycpIDogYXJnc1swXTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldChhcmdzKSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEVycm9yO1xuICByZXR1cm4gaXNFcnJvcihhcmdzWzBdKSA/IGFyZ3NbMF0gOiBFcnJvcjtcbn1cbmZ1bmN0aW9uIGdldFByb3BzKGFyZ3MpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGlzRXJyb3IoYXJnc1swXSkgPyBhcmdzWzJdIDogYXJnc1sxXTtcbn1cbmZ1bmN0aW9uIGluaGVyaXRlZEtleXMob2JqKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHJldC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gUmlnaHQgbm93IHdlJ3JlIGp1c3QgYXNzdW1pbmcgdGhhdCBhIGZ1bmN0aW9uIGluIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBlcnJvci5cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiKTtcbn1cblxuLy8gV2UgZG9uJ3QgbmVlZCB0aGUgZnVsbCB1bmRlcnNjb3JlIGNoZWNrIGhlcmUsIHNpbmNlIGl0IHNob3VsZCBlaXRoZXIgYmVcbi8vIGFuIG9iamVjdC1saXRlcmFsLCBvciBub3RoaW5nIGF0IGFsbC5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gKG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIik7XG59XG5cbi8vIFVzZWQgdG8gYXR0YWNoIGF0dHJpYnV0ZXMgdG8gdGhlIGVycm9yIG9iamVjdCBpbiB0aGUgY29uc3RydWN0b3IuXG5mdW5jdGlvbiBhdHRhY2hQcm9wcyhjb250ZXh0LCB0YXJnZXQpIHtcbiAgaWYgKGlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICB2YXIga2V5cyA9IGluaGVyaXRlZEtleXModGFyZ2V0KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICBjb250ZXh0W2tleXNbaV1dID0gY2xvbmUodGFyZ2V0W2tleXNbaV1dKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRG9uJ3QgbmVlZCB0aGUgZnVsbC1vdXQgXCJjbG9uZVwiIG1lY2hhbmlzbSBoZXJlLCBzaW5jZSBpZiB5b3UncmVcbi8vIHRyeWluZyB0byBzZXQgdGhpbmdzIG90aGVyIHRoYW4gZW1wdHkgYXJyYXlzL29iamVjdHMgb24geW91clxuLy8gc3ViLWNsYXNzZWQgYEVycm9yYCBvYmplY3QsIHlvdSdyZSBwcm9iYWJseSBkb2luZyBpdCB3cm9uZy5cbmZ1bmN0aW9uIGNsb25lKHRhcmdldCkge1xuICBpZiAodGFyZ2V0ID09IG51bGwgfHwgdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHRhcmdldDtcbiAgdmFyIGNsb25lZCA9IHRhcmdldC5jb25zdHJ1Y3RvciA/IHRhcmdldC5jb25zdHJ1Y3RvcigpIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yICh2YXIgYXR0ciBpbiB0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICBjbG9uZWRbYXR0cl0gPSB0YXJnZXRbYXR0cl07XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5cbn0pO1xuXG4vLyBCb2lsZXJwbGF0ZSBVTUQgZGVmaW5pdGlvbiBibG9jay4uLlxufSkoZnVuY3Rpb24oY3JlYXRlRXJyb3JMaWIpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGNyZWF0ZUVycm9yTGliKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUVycm9yTGliKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzO1xuICAgIHZhciBsYXN0Y3JlYXRlRXJyb3IgPSByb290LmNyZWF0ZUVycm9yO1xuICAgIHZhciBjcmVhdGVFcnJvciA9IHJvb3QuY3JlYXRlRXJyb3IgPSBjcmVhdGVFcnJvckxpYigpO1xuICAgIGNyZWF0ZUVycm9yLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJvb3QuY3JlYXRlRXJyb3IgPSBsYXN0Y3JlYXRlRXJyb3I7XG4gICAgICByZXR1cm4gY3JlYXRlRXJyb3I7XG4gICAgfTtcbiAgfVxufSk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmRlZXBtZXJnZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdHZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdFx0cmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSlcblx0XHRcdCYmICFpc1NwZWNpYWwodmFsdWUpXG5cdH07XG5cblx0ZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG5cdFx0cmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG5cdFx0dmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuXHRcdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHRcdHx8IHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXSdcblx0XHRcdHx8IGlzUmVhY3RFbGVtZW50KHZhbHVlKVxuXHR9XG5cblx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG5cdHZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG5cdHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cblx0ZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuXHR9XG5cblx0ZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG5cdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge31cblx0fVxuXG5cdGZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIChvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnMpXG5cdFx0XHQ6IHZhbHVlXG5cdH1cblxuXHRmdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zKVxuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucy5jdXN0b21NZXJnZSkge1xuXHRcdFx0cmV0dXJuIGRlZXBtZXJnZVxuXHRcdH1cblx0XHR2YXIgY3VzdG9tTWVyZ2UgPSBvcHRpb25zLmN1c3RvbU1lcmdlKGtleSk7XG5cdFx0cmV0dXJuIHR5cGVvZiBjdXN0b21NZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1lcmdlIDogZGVlcG1lcmdlXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkge1xuXHRcdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdFx0XHQ/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRcdHJldHVybiB0YXJnZXQucHJvcGVydHlJc0VudW1lcmFibGUoc3ltYm9sKVxuXHRcdFx0fSlcblx0XHRcdDogW11cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEtleXModGFyZ2V0KSB7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuY29uY2F0KGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSlcblx0fVxuXG5cdGZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdFx0aWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuXHRcdFx0Z2V0S2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh0YXJnZXRba2V5XSwgb3B0aW9ucyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0Z2V0S2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRpZiAoIW9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3Qoc291cmNlW2tleV0pIHx8ICF0YXJnZXRba2V5XSkge1xuXHRcdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBkZXN0aW5hdGlvblxuXHR9XG5cblx0ZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0b3B0aW9ucy5hcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuXHRcdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXG5cdFx0dmFyIHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG5cdFx0dmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdFx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdFx0aWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG5cdFx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlLCBvcHRpb25zKVxuXHRcdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMuYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHRcdH1cblx0fVxuXG5cdGRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheScpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG5cdFx0XHRyZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnMpXG5cdFx0fSwge30pXG5cdH07XG5cblx0dmFyIGRlZXBtZXJnZV8xID0gZGVlcG1lcmdlO1xuXG5cdHJldHVybiBkZWVwbWVyZ2VfMTtcblxufSkpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJ2dsb2JhbCcpXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJylcblxudmFyIG1ha2VEZXNwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBEZXNwb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGdsb2JhbC5fc2luZ2xldG9uRGVzcG90SW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBnbG9iYWwuX3NpbmdsZXRvbkRlc3BvdEluc3RhbmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsb2JhbC5fc2luZ2xldG9uRGVzcG90SW5zdGFuY2UgPSB0aGlzXG4gICAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHV0aWwuaW5oZXJpdHMoRGVzcG90LCBFdmVudEVtaXR0ZXIpXG5cbiAgcmV0dXJuIG5ldyBEZXNwb3QoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VEZXNwb3QoKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJ2dsb2JhbC9kb2N1bWVudCcpXG52YXIgRXZlbnQgPSByZXF1aXJlKCdnZXZhbCcpXG52YXIgS2V5cyA9IHJlcXVpcmUoJy4va2V5cycpXG5cbm1vZHVsZS5leHBvcnRzID0gVmlzaWJpbGl0eVxuXG5mdW5jdGlvbiBWaXNpYmlsaXR5ICgpIHtcbiAgdmFyIGtleXMgPSBLZXlzKGRvY3VtZW50KVxuICBpZiAoIWtleXMpIHJldHVybiBub29wU2hpbSgpXG5cbiAgcmV0dXJuIHtcbiAgICB2aXNpYmxlOiB2aXNpYmxlLFxuICAgIG9uQ2hhbmdlOiBFdmVudChsaXN0ZW4pXG4gIH1cblxuICBmdW5jdGlvbiB2aXNpYmxlICgpIHtcbiAgICByZXR1cm4gIWRvY3VtZW50W2tleXMuaGlkZGVuXVxuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuIChicm9hZGNhc3QpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGtleXMuZXZlbnQsIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSAoKSB7XG4gICAgICBicm9hZGNhc3QodmlzaWJsZSgpKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gbm9vcFNoaW0gKCkge1xuICByZXR1cm4ge1xuICAgIHZpc2libGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSxcbiAgICBvbkNoYW5nZTogbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNcblxuZnVuY3Rpb24ga2V5cyAoZG9jdW1lbnQpIHtcbiAgdmFyIHByZWZpeCA9IGRldGVjdFByZWZpeChkb2N1bWVudClcbiAgaWYgKHByZWZpeCA9PSBudWxsKSByZXR1cm5cbiAgcmV0dXJuIHtcbiAgICBoaWRkZW46IGxvd2VyY2FzZUZpcnN0KHByZWZpeCArICdIaWRkZW4nKSxcbiAgICBldmVudDogcHJlZml4ICsgJ3Zpc2liaWxpdHljaGFuZ2UnXG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZWN0UHJlZml4IChkb2N1bWVudCkge1xuICBpZiAoZG9jdW1lbnQuaGlkZGVuICE9IG51bGwpIHJldHVybiAnJ1xuICBpZiAoZG9jdW1lbnQubW96SGlkZGVuICE9IG51bGwpIHJldHVybiAnbW96J1xuICBpZiAoZG9jdW1lbnQubXNIaWRkZW4gIT0gbnVsbCkgcmV0dXJuICdtcydcbiAgaWYgKGRvY3VtZW50LndlYmtpdEhpZGRlbiAhPSBudWxsKSByZXR1cm4gJ3dlYmtpdCdcbn1cblxuZnVuY3Rpb24gbG93ZXJjYXNlRmlyc3QgKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZygwLCAxKS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnN1YnN0cmluZygxKVxufVxuIiwidmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgZW9zID0gcmVxdWlyZSgnZW5kLW9mLXN0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc2hpZnQgPSByZXF1aXJlKCdzdHJlYW0tc2hpZnQnKVxuXG52YXIgU0lHTkFMX0ZMVVNIID0gKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20pXG4gID8gQnVmZmVyLmZyb20oWzBdKVxuICA6IG5ldyBCdWZmZXIoWzBdKVxuXG52YXIgb251bmNvcmsgPSBmdW5jdGlvbihzZWxmLCBmbikge1xuICBpZiAoc2VsZi5fY29ya2VkKSBzZWxmLm9uY2UoJ3VuY29yaycsIGZuKVxuICBlbHNlIGZuKClcbn1cblxudmFyIGF1dG9EZXN0cm95ID0gZnVuY3Rpb24gKHNlbGYsIGVycikge1xuICBpZiAoc2VsZi5fYXV0b0Rlc3Ryb3kpIHNlbGYuZGVzdHJveShlcnIpXG59XG5cbnZhciBkZXN0cm95ZXIgPSBmdW5jdGlvbihzZWxmLCBlbmQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIpIGF1dG9EZXN0cm95KHNlbGYsIGVyci5tZXNzYWdlID09PSAncHJlbWF0dXJlIGNsb3NlJyA/IG51bGwgOiBlcnIpXG4gICAgZWxzZSBpZiAoZW5kICYmICFzZWxmLl9lbmRlZCkgc2VsZi5lbmQoKVxuICB9XG59XG5cbnZhciBlbmQgPSBmdW5jdGlvbih3cywgZm4pIHtcbiAgaWYgKCF3cykgcmV0dXJuIGZuKClcbiAgaWYgKHdzLl93cml0YWJsZVN0YXRlICYmIHdzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSByZXR1cm4gZm4oKVxuICBpZiAod3MuX3dyaXRhYmxlU3RhdGUpIHJldHVybiB3cy5lbmQoZm4pXG4gIHdzLmVuZCgpXG4gIGZuKClcbn1cblxudmFyIHRvU3RyZWFtczIgPSBmdW5jdGlvbihycykge1xuICByZXR1cm4gbmV3IChzdHJlYW0uUmVhZGFibGUpKHtvYmplY3RNb2RlOnRydWUsIGhpZ2hXYXRlck1hcms6MTZ9KS53cmFwKHJzKVxufVxuXG52YXIgRHVwbGV4aWZ5ID0gZnVuY3Rpb24od3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXhpZnkpKSByZXR1cm4gbmV3IER1cGxleGlmeSh3cml0YWJsZSwgcmVhZGFibGUsIG9wdHMpXG4gIHN0cmVhbS5EdXBsZXguY2FsbCh0aGlzLCBvcHRzKVxuXG4gIHRoaXMuX3dyaXRhYmxlID0gbnVsbFxuICB0aGlzLl9yZWFkYWJsZSA9IG51bGxcbiAgdGhpcy5fcmVhZGFibGUyID0gbnVsbFxuXG4gIHRoaXMuX2F1dG9EZXN0cm95ID0gIW9wdHMgfHwgb3B0cy5hdXRvRGVzdHJveSAhPT0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZERlc3Ryb3kgPSAhb3B0cyB8fCBvcHRzLmRlc3Ryb3kgIT09IGZhbHNlXG4gIHRoaXMuX2ZvcndhcmRFbmQgPSAhb3B0cyB8fCBvcHRzLmVuZCAhPT0gZmFsc2VcbiAgdGhpcy5fY29ya2VkID0gMSAvLyBzdGFydCBjb3JrZWRcbiAgdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgdGhpcy5fZHJhaW5lZCA9IGZhbHNlXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSBmYWxzZVxuICB0aGlzLl91bndyaXRlID0gbnVsbFxuICB0aGlzLl91bnJlYWQgPSBudWxsXG4gIHRoaXMuX2VuZGVkID0gZmFsc2VcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG5cbiAgaWYgKHdyaXRhYmxlKSB0aGlzLnNldFdyaXRhYmxlKHdyaXRhYmxlKVxuICBpZiAocmVhZGFibGUpIHRoaXMuc2V0UmVhZGFibGUocmVhZGFibGUpXG59XG5cbmluaGVyaXRzKER1cGxleGlmeSwgc3RyZWFtLkR1cGxleClcblxuRHVwbGV4aWZ5Lm9iaiA9IGZ1bmN0aW9uKHdyaXRhYmxlLCByZWFkYWJsZSwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBvcHRzLm9iamVjdE1vZGUgPSB0cnVlXG4gIG9wdHMuaGlnaFdhdGVyTWFyayA9IDE2XG4gIHJldHVybiBuZXcgRHVwbGV4aWZ5KHdyaXRhYmxlLCByZWFkYWJsZSwgb3B0cylcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIGlmICgrK3RoaXMuX2NvcmtlZCA9PT0gMSkgdGhpcy5lbWl0KCdjb3JrJylcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2NvcmtlZCAmJiAtLXRoaXMuX2NvcmtlZCA9PT0gMCkgdGhpcy5lbWl0KCd1bmNvcmsnKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLnNldFdyaXRhYmxlID0gZnVuY3Rpb24od3JpdGFibGUpIHtcbiAgaWYgKHRoaXMuX3Vud3JpdGUpIHRoaXMuX3Vud3JpdGUoKVxuXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgIGlmICh3cml0YWJsZSAmJiB3cml0YWJsZS5kZXN0cm95KSB3cml0YWJsZS5kZXN0cm95KClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh3cml0YWJsZSA9PT0gbnVsbCB8fCB3cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICB0aGlzLmVuZCgpXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHVuZW5kID0gZW9zKHdyaXRhYmxlLCB7d3JpdGFibGU6dHJ1ZSwgcmVhZGFibGU6ZmFsc2V9LCBkZXN0cm95ZXIodGhpcywgdGhpcy5fZm9yd2FyZEVuZCkpXG5cbiAgdmFyIG9uZHJhaW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb25kcmFpbiA9IHNlbGYuX29uZHJhaW5cbiAgICBzZWxmLl9vbmRyYWluID0gbnVsbFxuICAgIGlmIChvbmRyYWluKSBvbmRyYWluKClcbiAgfVxuXG4gIHZhciBjbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3dyaXRhYmxlLnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pXG4gICAgdW5lbmQoKVxuICB9XG5cbiAgaWYgKHRoaXMuX3Vud3JpdGUpIHByb2Nlc3MubmV4dFRpY2sob25kcmFpbikgLy8gZm9yY2UgYSBkcmFpbiBvbiBzdHJlYW0gcmVzZXQgdG8gYXZvaWQgbGl2ZWxvY2tzXG5cbiAgdGhpcy5fd3JpdGFibGUgPSB3cml0YWJsZVxuICB0aGlzLl93cml0YWJsZS5vbignZHJhaW4nLCBvbmRyYWluKVxuICB0aGlzLl91bndyaXRlID0gY2xlYXJcblxuICB0aGlzLnVuY29yaygpIC8vIGFsd2F5cyB1bmNvcmsgc2V0V3JpdGFibGVcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5zZXRSZWFkYWJsZSA9IGZ1bmN0aW9uKHJlYWRhYmxlKSB7XG4gIGlmICh0aGlzLl91bnJlYWQpIHRoaXMuX3VucmVhZCgpXG5cbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgaWYgKHJlYWRhYmxlICYmIHJlYWRhYmxlLmRlc3Ryb3kpIHJlYWRhYmxlLmRlc3Ryb3koKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHJlYWRhYmxlID09PSBudWxsIHx8IHJlYWRhYmxlID09PSBmYWxzZSkge1xuICAgIHRoaXMucHVzaChudWxsKVxuICAgIHRoaXMucmVzdW1lKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgdW5lbmQgPSBlb3MocmVhZGFibGUsIHt3cml0YWJsZTpmYWxzZSwgcmVhZGFibGU6dHJ1ZX0sIGRlc3Ryb3llcih0aGlzKSlcblxuICB2YXIgb25yZWFkYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2ZvcndhcmQoKVxuICB9XG5cbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5wdXNoKG51bGwpXG4gIH1cblxuICB2YXIgY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9yZWFkYWJsZTIucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgb25yZWFkYWJsZSlcbiAgICBzZWxmLl9yZWFkYWJsZTIucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgIHVuZW5kKClcbiAgfVxuXG4gIHRoaXMuX2RyYWluZWQgPSB0cnVlXG4gIHRoaXMuX3JlYWRhYmxlID0gcmVhZGFibGVcbiAgdGhpcy5fcmVhZGFibGUyID0gcmVhZGFibGUuX3JlYWRhYmxlU3RhdGUgPyByZWFkYWJsZSA6IHRvU3RyZWFtczIocmVhZGFibGUpXG4gIHRoaXMuX3JlYWRhYmxlMi5vbigncmVhZGFibGUnLCBvbnJlYWRhYmxlKVxuICB0aGlzLl9yZWFkYWJsZTIub24oJ2VuZCcsIG9uZW5kKVxuICB0aGlzLl91bnJlYWQgPSBjbGVhclxuXG4gIHRoaXMuX2ZvcndhcmQoKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2RyYWluZWQgPSB0cnVlXG4gIHRoaXMuX2ZvcndhcmQoKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLl9mb3J3YXJkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mb3J3YXJkaW5nIHx8ICF0aGlzLl9yZWFkYWJsZTIgfHwgIXRoaXMuX2RyYWluZWQpIHJldHVyblxuICB0aGlzLl9mb3J3YXJkaW5nID0gdHJ1ZVxuXG4gIHZhciBkYXRhXG5cbiAgd2hpbGUgKHRoaXMuX2RyYWluZWQgJiYgKGRhdGEgPSBzaGlmdCh0aGlzLl9yZWFkYWJsZTIpKSAhPT0gbnVsbCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgY29udGludWVcbiAgICB0aGlzLl9kcmFpbmVkID0gdGhpcy5wdXNoKGRhdGEpXG4gIH1cblxuICB0aGlzLl9mb3J3YXJkaW5nID0gZmFsc2Vcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2Rlc3Ryb3koZXJyKVxuICB9KVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmIChlcnIpIHtcbiAgICB2YXIgb25kcmFpbiA9IHRoaXMuX29uZHJhaW5cbiAgICB0aGlzLl9vbmRyYWluID0gbnVsbFxuICAgIGlmIChvbmRyYWluKSBvbmRyYWluKGVycilcbiAgICBlbHNlIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cblxuICBpZiAodGhpcy5fZm9yd2FyZERlc3Ryb3kpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGUgJiYgdGhpcy5fcmVhZGFibGUuZGVzdHJveSkgdGhpcy5fcmVhZGFibGUuZGVzdHJveSgpXG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlICYmIHRoaXMuX3dyaXRhYmxlLmRlc3Ryb3kpIHRoaXMuX3dyaXRhYmxlLmRlc3Ryb3koKVxuICB9XG5cbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZW5jLCBjYikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVybiBjYigpXG4gIGlmICh0aGlzLl9jb3JrZWQpIHJldHVybiBvbnVuY29yayh0aGlzLCB0aGlzLl93cml0ZS5iaW5kKHRoaXMsIGRhdGEsIGVuYywgY2IpKVxuICBpZiAoZGF0YSA9PT0gU0lHTkFMX0ZMVVNIKSByZXR1cm4gdGhpcy5fZmluaXNoKGNiKVxuICBpZiAoIXRoaXMuX3dyaXRhYmxlKSByZXR1cm4gY2IoKVxuXG4gIGlmICh0aGlzLl93cml0YWJsZS53cml0ZShkYXRhKSA9PT0gZmFsc2UpIHRoaXMuX29uZHJhaW4gPSBjYlxuICBlbHNlIGNiKClcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24oY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuZW1pdCgncHJlZW5kJylcbiAgb251bmNvcmsodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgZW5kKHNlbGYuX2ZvcndhcmRFbmQgJiYgc2VsZi5fd3JpdGFibGUsIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaGF4eCB0byBub3QgZW1pdCBwcmVmaW5pc2ggdHdpY2VcbiAgICAgIGlmIChzZWxmLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID09PSBmYWxzZSkgc2VsZi5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWVcbiAgICAgIHNlbGYuZW1pdCgncHJlZmluaXNoJylcbiAgICAgIG9udW5jb3JrKHNlbGYsIGNiKVxuICAgIH0pXG4gIH0pXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZGF0YSwgZW5jLCBjYikge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmVuZChudWxsLCBudWxsLCBkYXRhKVxuICBpZiAodHlwZW9mIGVuYyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZW5kKGRhdGEsIG51bGwsIGVuYylcbiAgdGhpcy5fZW5kZWQgPSB0cnVlXG4gIGlmIChkYXRhKSB0aGlzLndyaXRlKGRhdGEpXG4gIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcpIHRoaXMud3JpdGUoU0lHTkFMX0ZMVVNIKVxuICByZXR1cm4gc3RyZWFtLldyaXRhYmxlLnByb3RvdHlwZS5lbmQuY2FsbCh0aGlzLCBjYilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXhpZnlcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcG9seWZpbGwod2luZG93KSB7XG4gIGNvbnN0IEVsZW1lbnRQcm90b3R5cGUgPSB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGU7XG5cbiAgaWYgKHR5cGVvZiBFbGVtZW50UHJvdG90eXBlLm1hdGNoZXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICBFbGVtZW50UHJvdG90eXBlLm1hdGNoZXMgPSBFbGVtZW50UHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnRQcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnRQcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGZ1bmN0aW9uIG1hdGNoZXMoc2VsZWN0b3IpIHtcbiAgICAgIGxldCBlbGVtZW50ID0gdGhpcztcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gKGVsZW1lbnQuZG9jdW1lbnQgfHwgZWxlbWVudC5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICAgIHdoaWxlIChlbGVtZW50c1tpbmRleF0gJiYgZWxlbWVudHNbaW5kZXhdICE9PSBlbGVtZW50KSB7XG4gICAgICAgICsraW5kZXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBCb29sZWFuKGVsZW1lbnRzW2luZGV4XSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgRWxlbWVudFByb3RvdHlwZS5jbG9zZXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgRWxlbWVudFByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24gY2xvc2VzdChzZWxlY3Rvcikge1xuICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGlmIChlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsInZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbnZhciBpc1JlcXVlc3QgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0cmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBpc0NoaWxkUHJvY2VzcyA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRyZXR1cm4gc3RyZWFtLnN0ZGlvICYmIEFycmF5LmlzQXJyYXkoc3RyZWFtLnN0ZGlvKSAmJiBzdHJlYW0uc3RkaW8ubGVuZ3RoID09PSAzXG59O1xuXG52YXIgZW9zID0gZnVuY3Rpb24oc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuXHRpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcblx0aWYgKCFvcHRzKSBvcHRzID0ge307XG5cblx0Y2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuXG5cdHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblx0dmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXHR2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IChvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGUpO1xuXHR2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IChvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGUpO1xuXG5cdHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuXHR9O1xuXG5cdHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHdyaXRhYmxlID0gZmFsc2U7XG5cdFx0aWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuXHR9O1xuXG5cdHZhciBvbmVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlYWRhYmxlID0gZmFsc2U7XG5cdFx0aWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuXHR9O1xuXG5cdHZhciBvbmV4aXQgPSBmdW5jdGlvbihleGl0Q29kZSkge1xuXHRcdGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBleGl0Q29kZSA/IG5ldyBFcnJvcignZXhpdGVkIHdpdGggZXJyb3IgY29kZTogJyArIGV4aXRDb2RlKSA6IG51bGwpO1xuXHR9O1xuXG5cdHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0Y2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG5cdH07XG5cblx0dmFyIG9uY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAocmVhZGFibGUgJiYgIShycyAmJiBycy5lbmRlZCkpIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgbmV3IEVycm9yKCdwcmVtYXR1cmUgY2xvc2UnKSk7XG5cdFx0aWYgKHdyaXRhYmxlICYmICEod3MgJiYgd3MuZW5kZWQpKSByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIG5ldyBFcnJvcigncHJlbWF0dXJlIGNsb3NlJykpO1xuXHR9O1xuXG5cdHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHRzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdH07XG5cblx0aWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG5cdFx0c3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG5cdFx0aWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO1xuXHRcdGVsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcblx0fSBlbHNlIGlmICh3cml0YWJsZSAmJiAhd3MpIHsgLy8gbGVnYWN5IHN0cmVhbXNcblx0XHRzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuXHR9XG5cblx0aWYgKGlzQ2hpbGRQcm9jZXNzKHN0cmVhbSkpIHN0cmVhbS5vbignZXhpdCcsIG9uZXhpdCk7XG5cblx0c3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG5cdHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuXHRpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcblx0c3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuXHRcdGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBvbmV4aXQpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVvcztcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBvYmplY3RDcmVhdGVQb2x5ZmlsbFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxudmFyIGhhc0RlZmluZVByb3BlcnR5O1xudHJ5IHtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICd4JywgeyB2YWx1ZTogMCB9KTtcbiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7XG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XG5pZiAoaGFzRGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3JcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBhcmcgIT09IGFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xufVxuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHM7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmICghZXZsaXN0ZW5lcilcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90bykge1xuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgIGtleXMucHVzaChrKTtcbiAgfVxuICByZXR1cm4gaztcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpIHtcbiAgdmFyIGZuID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5XG5zdHJpbmdpZnkuZGVmYXVsdCA9IHN0cmluZ2lmeVxuc3RyaW5naWZ5LnN0YWJsZSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnlcbnN0cmluZ2lmeS5zdGFibGVTdHJpbmdpZnkgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5XG5cbnZhciBhcnIgPSBbXVxuXG4vLyBSZWd1bGFyIHN0cmluZ2lmeVxuZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIHJlcGxhY2VyLCBzcGFjZXIpIHtcbiAgZGVjaXJjKG9iaiwgJycsIFtdLCB1bmRlZmluZWQpXG4gIHZhciByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpXG4gIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgdmFyIHBhcnQgPSBhcnIucG9wKClcbiAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXVxuICB9XG4gIHJldHVybiByZXNcbn1cbmZ1bmN0aW9uIGRlY2lyYyAodmFsLCBrLCBzdGFjaywgcGFyZW50KSB7XG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgIHBhcmVudFtrXSA9ICdbQ2lyY3VsYXJdJ1xuICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucHVzaCh2YWwpXG4gICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWNpcmModmFsW2ldLCBpLCBzdGFjaywgdmFsKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbClcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgICAgIGRlY2lyYyh2YWxba2V5XSwga2V5LCBzdGFjaywgdmFsKVxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKVxuICB9XG59XG5cbi8vIFN0YWJsZS1zdHJpbmdpZnlcbmZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvbiAoYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNTdHJpbmdpZnkgKG9iaiwgcmVwbGFjZXIsIHNwYWNlcikge1xuICB2YXIgdG1wID0gZGV0ZXJtaW5pc3RpY0RlY2lyYyhvYmosICcnLCBbXSwgdW5kZWZpbmVkKSB8fCBvYmpcbiAgdmFyIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZXIsIHNwYWNlcilcbiAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjICh2YWwsIGssIHN0YWNrLCBwYXJlbnQpIHtcbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgcGFyZW50W2tdID0gJ1tDaXJjdWxhcl0nXG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbClcbiAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRldGVybWluaXN0aWNEZWNpcmModmFsW2ldLCBpLCBzdGFjaywgdmFsKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgb2JqZWN0IGluIHRoZSByZXF1aXJlZCB3YXlcbiAgICAgIHZhciB0bXAgPSB7fVxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpLnNvcnQoY29tcGFyZUZ1bmN0aW9uKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBzdGFjaywgdmFsKVxuICAgICAgICB0bXBba2V5XSA9IHZhbFtrZXldXG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSlcbiAgICAgICAgcGFyZW50W2tdID0gdG1wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG1wXG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcclxuICogZmlsZXNpemVcclxuICpcclxuICogQGNvcHlyaWdodCAyMDE5IEphc29uIE11bGxpZ2FuIDxqYXNvbi5tdWxsaWdhbkBhdm9pZHdvcmsuY29tPlxyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2VcclxuICogQHZlcnNpb24gNC4xLjJcclxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCkge1xuXHR2YXIgYiA9IC9eKGJ8QikkLyxcblx0ICAgIHN5bWJvbCA9IHtcblx0XHRpZWM6IHtcblx0XHRcdGJpdHM6IFtcImJcIiwgXCJLaWJcIiwgXCJNaWJcIiwgXCJHaWJcIiwgXCJUaWJcIiwgXCJQaWJcIiwgXCJFaWJcIiwgXCJaaWJcIiwgXCJZaWJcIl0sXG5cdFx0XHRieXRlczogW1wiQlwiLCBcIktpQlwiLCBcIk1pQlwiLCBcIkdpQlwiLCBcIlRpQlwiLCBcIlBpQlwiLCBcIkVpQlwiLCBcIlppQlwiLCBcIllpQlwiXVxuXHRcdH0sXG5cdFx0amVkZWM6IHtcblx0XHRcdGJpdHM6IFtcImJcIiwgXCJLYlwiLCBcIk1iXCIsIFwiR2JcIiwgXCJUYlwiLCBcIlBiXCIsIFwiRWJcIiwgXCJaYlwiLCBcIlliXCJdLFxuXHRcdFx0Ynl0ZXM6IFtcIkJcIiwgXCJLQlwiLCBcIk1CXCIsIFwiR0JcIiwgXCJUQlwiLCBcIlBCXCIsIFwiRUJcIiwgXCJaQlwiLCBcIllCXCJdXG5cdFx0fVxuXHR9LFxuXHQgICAgZnVsbGZvcm0gPSB7XG5cdFx0aWVjOiBbXCJcIiwgXCJraWJpXCIsIFwibWViaVwiLCBcImdpYmlcIiwgXCJ0ZWJpXCIsIFwicGViaVwiLCBcImV4YmlcIiwgXCJ6ZWJpXCIsIFwieW9iaVwiXSxcblx0XHRqZWRlYzogW1wiXCIsIFwia2lsb1wiLCBcIm1lZ2FcIiwgXCJnaWdhXCIsIFwidGVyYVwiLCBcInBldGFcIiwgXCJleGFcIiwgXCJ6ZXR0YVwiLCBcInlvdHRhXCJdXG5cdH07XG5cblx0LyoqXHJcbiAgKiBmaWxlc2l6ZVxyXG4gICpcclxuICAqIEBtZXRob2QgZmlsZXNpemVcclxuICAqIEBwYXJhbSAge01peGVkfSAgIGFyZyAgICAgICAgU3RyaW5nLCBJbnQgb3IgRmxvYXQgdG8gdHJhbnNmb3JtXHJcbiAgKiBAcGFyYW0gIHtPYmplY3R9ICBkZXNjcmlwdG9yIFtPcHRpb25hbF0gRmxhZ3NcclxuICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgUmVhZGFibGUgZmlsZSBzaXplIFN0cmluZ1xyXG4gICovXG5cdGZ1bmN0aW9uIGZpbGVzaXplKGFyZykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuXHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHQgICAgdmFsID0gMCxcblx0XHQgICAgZSA9IHZvaWQgMCxcblx0XHQgICAgYmFzZSA9IHZvaWQgMCxcblx0XHQgICAgYml0cyA9IHZvaWQgMCxcblx0XHQgICAgY2VpbCA9IHZvaWQgMCxcblx0XHQgICAgZnVsbCA9IHZvaWQgMCxcblx0XHQgICAgZnVsbGZvcm1zID0gdm9pZCAwLFxuXHRcdCAgICBsb2NhbGUgPSB2b2lkIDAsXG5cdFx0ICAgIG5lZyA9IHZvaWQgMCxcblx0XHQgICAgbnVtID0gdm9pZCAwLFxuXHRcdCAgICBvdXRwdXQgPSB2b2lkIDAsXG5cdFx0ICAgIHJvdW5kID0gdm9pZCAwLFxuXHRcdCAgICB1bml4ID0gdm9pZCAwLFxuXHRcdCAgICBzZXBhcmF0b3IgPSB2b2lkIDAsXG5cdFx0ICAgIHNwYWNlciA9IHZvaWQgMCxcblx0XHQgICAgc3RhbmRhcmQgPSB2b2lkIDAsXG5cdFx0ICAgIHN5bWJvbHMgPSB2b2lkIDA7XG5cblx0XHRpZiAoaXNOYU4oYXJnKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgbnVtYmVyXCIpO1xuXHRcdH1cblxuXHRcdGJpdHMgPSBkZXNjcmlwdG9yLmJpdHMgPT09IHRydWU7XG5cdFx0dW5peCA9IGRlc2NyaXB0b3IudW5peCA9PT0gdHJ1ZTtcblx0XHRiYXNlID0gZGVzY3JpcHRvci5iYXNlIHx8IDI7XG5cdFx0cm91bmQgPSBkZXNjcmlwdG9yLnJvdW5kICE9PSB2b2lkIDAgPyBkZXNjcmlwdG9yLnJvdW5kIDogdW5peCA/IDEgOiAyO1xuXHRcdGxvY2FsZSA9IGRlc2NyaXB0b3IubG9jYWxlICE9PSB2b2lkIDAgPyBkZXNjcmlwdG9yLmxvY2FsZSA6IFwiXCI7XG5cdFx0c2VwYXJhdG9yID0gZGVzY3JpcHRvci5zZXBhcmF0b3IgIT09IHZvaWQgMCA/IGRlc2NyaXB0b3Iuc2VwYXJhdG9yIDogXCJcIjtcblx0XHRzcGFjZXIgPSBkZXNjcmlwdG9yLnNwYWNlciAhPT0gdm9pZCAwID8gZGVzY3JpcHRvci5zcGFjZXIgOiB1bml4ID8gXCJcIiA6IFwiIFwiO1xuXHRcdHN5bWJvbHMgPSBkZXNjcmlwdG9yLnN5bWJvbHMgfHwge307XG5cdFx0c3RhbmRhcmQgPSBiYXNlID09PSAyID8gZGVzY3JpcHRvci5zdGFuZGFyZCB8fCBcImplZGVjXCIgOiBcImplZGVjXCI7XG5cdFx0b3V0cHV0ID0gZGVzY3JpcHRvci5vdXRwdXQgfHwgXCJzdHJpbmdcIjtcblx0XHRmdWxsID0gZGVzY3JpcHRvci5mdWxsZm9ybSA9PT0gdHJ1ZTtcblx0XHRmdWxsZm9ybXMgPSBkZXNjcmlwdG9yLmZ1bGxmb3JtcyBpbnN0YW5jZW9mIEFycmF5ID8gZGVzY3JpcHRvci5mdWxsZm9ybXMgOiBbXTtcblx0XHRlID0gZGVzY3JpcHRvci5leHBvbmVudCAhPT0gdm9pZCAwID8gZGVzY3JpcHRvci5leHBvbmVudCA6IC0xO1xuXHRcdG51bSA9IE51bWJlcihhcmcpO1xuXHRcdG5lZyA9IG51bSA8IDA7XG5cdFx0Y2VpbCA9IGJhc2UgPiAyID8gMTAwMCA6IDEwMjQ7XG5cblx0XHQvLyBGbGlwcGluZyBhIG5lZ2F0aXZlIG51bWJlciB0byBkZXRlcm1pbmUgdGhlIHNpemVcblx0XHRpZiAobmVnKSB7XG5cdFx0XHRudW0gPSAtbnVtO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluaW5nIHRoZSBleHBvbmVudFxuXHRcdGlmIChlID09PSAtMSB8fCBpc05hTihlKSkge1xuXHRcdFx0ZSA9IE1hdGguZmxvb3IoTWF0aC5sb2cobnVtKSAvIE1hdGgubG9nKGNlaWwpKTtcblxuXHRcdFx0aWYgKGUgPCAwKSB7XG5cdFx0XHRcdGUgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEV4Y2VlZGluZyBzdXBwb3J0ZWQgbGVuZ3RoLCB0aW1lIHRvIHJlZHVjZSAmIG11bHRpcGx5XG5cdFx0aWYgKGUgPiA4KSB7XG5cdFx0XHRlID0gODtcblx0XHR9XG5cblx0XHRpZiAob3V0cHV0ID09PSBcImV4cG9uZW50XCIpIHtcblx0XHRcdHJldHVybiBlO1xuXHRcdH1cblxuXHRcdC8vIFplcm8gaXMgbm93IGEgc3BlY2lhbCBjYXNlIGJlY2F1c2UgYnl0ZXMgZGl2aWRlIGJ5IDFcblx0XHRpZiAobnVtID09PSAwKSB7XG5cdFx0XHRyZXN1bHRbMF0gPSAwO1xuXHRcdFx0cmVzdWx0WzFdID0gdW5peCA/IFwiXCIgOiBzeW1ib2xbc3RhbmRhcmRdW2JpdHMgPyBcImJpdHNcIiA6IFwiYnl0ZXNcIl1bZV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbCA9IG51bSAvIChiYXNlID09PSAyID8gTWF0aC5wb3coMiwgZSAqIDEwKSA6IE1hdGgucG93KDEwMDAsIGUpKTtcblxuXHRcdFx0aWYgKGJpdHMpIHtcblx0XHRcdFx0dmFsID0gdmFsICogODtcblxuXHRcdFx0XHRpZiAodmFsID49IGNlaWwgJiYgZSA8IDgpIHtcblx0XHRcdFx0XHR2YWwgPSB2YWwgLyBjZWlsO1xuXHRcdFx0XHRcdGUrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXN1bHRbMF0gPSBOdW1iZXIodmFsLnRvRml4ZWQoZSA+IDAgPyByb3VuZCA6IDApKTtcblx0XHRcdHJlc3VsdFsxXSA9IGJhc2UgPT09IDEwICYmIGUgPT09IDEgPyBiaXRzID8gXCJrYlwiIDogXCJrQlwiIDogc3ltYm9sW3N0YW5kYXJkXVtiaXRzID8gXCJiaXRzXCIgOiBcImJ5dGVzXCJdW2VdO1xuXG5cdFx0XHRpZiAodW5peCkge1xuXHRcdFx0XHRyZXN1bHRbMV0gPSBzdGFuZGFyZCA9PT0gXCJqZWRlY1wiID8gcmVzdWx0WzFdLmNoYXJBdCgwKSA6IGUgPiAwID8gcmVzdWx0WzFdLnJlcGxhY2UoL0IkLywgXCJcIikgOiByZXN1bHRbMV07XG5cblx0XHRcdFx0aWYgKGIudGVzdChyZXN1bHRbMV0pKSB7XG5cdFx0XHRcdFx0cmVzdWx0WzBdID0gTWF0aC5mbG9vcihyZXN1bHRbMF0pO1xuXHRcdFx0XHRcdHJlc3VsdFsxXSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEZWNvcmF0aW5nIGEgJ2RpZmYnXG5cdFx0aWYgKG5lZykge1xuXHRcdFx0cmVzdWx0WzBdID0gLXJlc3VsdFswXTtcblx0XHR9XG5cblx0XHQvLyBBcHBseWluZyBjdXN0b20gc3ltYm9sXG5cdFx0cmVzdWx0WzFdID0gc3ltYm9sc1tyZXN1bHRbMV1dIHx8IHJlc3VsdFsxXTtcblxuXHRcdGlmIChsb2NhbGUgPT09IHRydWUpIHtcblx0XHRcdHJlc3VsdFswXSA9IHJlc3VsdFswXS50b0xvY2FsZVN0cmluZygpO1xuXHRcdH0gZWxzZSBpZiAobG9jYWxlLmxlbmd0aCA+IDApIHtcblx0XHRcdHJlc3VsdFswXSA9IHJlc3VsdFswXS50b0xvY2FsZVN0cmluZyhsb2NhbGUpO1xuXHRcdH0gZWxzZSBpZiAoc2VwYXJhdG9yLmxlbmd0aCA+IDApIHtcblx0XHRcdHJlc3VsdFswXSA9IHJlc3VsdFswXS50b1N0cmluZygpLnJlcGxhY2UoXCIuXCIsIHNlcGFyYXRvcik7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuaW5nIEFycmF5LCBPYmplY3QsIG9yIFN0cmluZyAoZGVmYXVsdClcblx0XHRpZiAob3V0cHV0ID09PSBcImFycmF5XCIpIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0aWYgKGZ1bGwpIHtcblx0XHRcdHJlc3VsdFsxXSA9IGZ1bGxmb3Jtc1tlXSA/IGZ1bGxmb3Jtc1tlXSA6IGZ1bGxmb3JtW3N0YW5kYXJkXVtlXSArIChiaXRzID8gXCJiaXRcIiA6IFwiYnl0ZVwiKSArIChyZXN1bHRbMF0gPT09IDEgPyBcIlwiIDogXCJzXCIpO1xuXHRcdH1cblxuXHRcdGlmIChvdXRwdXQgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdHJldHVybiB7IHZhbHVlOiByZXN1bHRbMF0sIHN5bWJvbDogcmVzdWx0WzFdIH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKHNwYWNlcik7XG5cdH1cblxuXHQvLyBQYXJ0aWFsIGFwcGxpY2F0aW9uIGZvciBmdW5jdGlvbmFsIHByb2dyYW1taW5nXG5cdGZpbGVzaXplLnBhcnRpYWwgPSBmdW5jdGlvbiAob3B0KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcblx0XHRcdHJldHVybiBmaWxlc2l6ZShhcmcsIG9wdCk7XG5cdFx0fTtcblx0fTtcblxuXHQvLyBDb21tb25KUywgQU1ELCBzY3JpcHQgdGFnXG5cdGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmlsZXNpemU7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgIT09IHZvaWQgMCkge1xuXHRcdGRlZmluZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZmlsZXNpemU7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0Z2xvYmFsLmZpbGVzaXplID0gZmlsZXNpemU7XG5cdH1cbn0pKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBnbG9iYWwpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0Rm9ybURhdGE7XG5leHBvcnRzLmdldEZpZWxkRGF0YSA9IGdldEZpZWxkRGF0YTtcbnZhciBOT0RFX0xJU1RfQ0xBU1NFUyA9IHtcbiAgJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJzogdHJ1ZSxcbiAgJ1tvYmplY3QgTm9kZUxpc3RdJzogdHJ1ZSxcbiAgJ1tvYmplY3QgUmFkaW9Ob2RlTGlzdF0nOiB0cnVlXG5cbiAgLy8gLnR5cGUgdmFsdWVzIGZvciBlbGVtZW50cyB3aGljaCBjYW4gYXBwZWFyIGluIC5lbGVtZW50cyBhbmQgc2hvdWxkIGJlIGlnbm9yZWRcbn07dmFyIElHTk9SRURfRUxFTUVOVF9UWVBFUyA9IHtcbiAgJ2J1dHRvbic6IHRydWUsXG4gICdmaWVsZHNldCc6IHRydWUsXG4gICdyZXNldCc6IHRydWUsXG4gICdzdWJtaXQnOiB0cnVlXG59O1xuXG52YXIgQ0hFQ0tFRF9JTlBVVF9UWVBFUyA9IHtcbiAgJ2NoZWNrYm94JzogdHJ1ZSxcbiAgJ3JhZGlvJzogdHJ1ZVxufTtcblxudmFyIFRSSU1fUkUgPSAvXlxccyt8XFxzKyQvZztcblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLChzdHJpbmd8QXJyYXkuPHN0cmluZz4pPn0gYW4gb2JqZWN0IGNvbnRhaW5pbmdcbiAqICAgc3VibWl0dGFibGUgdmFsdWUocykgaGVsZCBpbiB0aGUgZm9ybSdzIC5lbGVtZW50cyBjb2xsZWN0aW9uLCB3aXRoXG4gKiAgIHByb3BlcnRpZXMgbmFtZWQgYXMgcGVyIGVsZW1lbnQgbmFtZXMgb3IgaWRzLlxuICovXG5cbmZ1bmN0aW9uIGdldEZvcm1EYXRhKGZvcm0pIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHsgdHJpbTogZmFsc2UgfTtcblxuICBpZiAoIWZvcm0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgZm9ybSBpcyByZXF1aXJlZCBieSBnZXRGb3JtRGF0YSwgd2FzIGdpdmVuIGZvcm09JyArIGZvcm0pO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIGVsZW1lbnROYW1lID0gdm9pZCAwO1xuICB2YXIgZWxlbWVudE5hbWVzID0gW107XG4gIHZhciBlbGVtZW50TmFtZUxvb2t1cCA9IHt9O1xuXG4gIC8vIEdldCB1bmlxdWUgc3VibWl0dGFibGUgZWxlbWVudCBuYW1lcyBmb3IgdGhlIGZvcm1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBmb3JtLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBlbGVtZW50ID0gZm9ybS5lbGVtZW50c1tpXTtcbiAgICBpZiAoSUdOT1JFRF9FTEVNRU5UX1RZUEVTW2VsZW1lbnQudHlwZV0gfHwgZWxlbWVudC5kaXNhYmxlZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGVsZW1lbnROYW1lID0gZWxlbWVudC5uYW1lIHx8IGVsZW1lbnQuaWQ7XG4gICAgaWYgKGVsZW1lbnROYW1lICYmICFlbGVtZW50TmFtZUxvb2t1cFtlbGVtZW50TmFtZV0pIHtcbiAgICAgIGVsZW1lbnROYW1lcy5wdXNoKGVsZW1lbnROYW1lKTtcbiAgICAgIGVsZW1lbnROYW1lTG9va3VwW2VsZW1lbnROYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRXh0cmFjdCBlbGVtZW50IGRhdGEgbmFtZS1ieS1uYW1lIGZvciBjb25zaXN0ZW50IGhhbmRsaW5nIG9mIHNwZWNpYWwgY2FzZXNcbiAgLy8gYXJvdW5kIGVsZW1lbnRzIHdoaWNoIGNvbnRhaW4gbXVsdGlwbGUgaW5wdXRzLlxuICBmb3IgKHZhciBfaSA9IDAsIF9sID0gZWxlbWVudE5hbWVzLmxlbmd0aDsgX2kgPCBfbDsgX2krKykge1xuICAgIGVsZW1lbnROYW1lID0gZWxlbWVudE5hbWVzW19pXTtcbiAgICB2YXIgdmFsdWUgPSBnZXRGaWVsZERhdGEoZm9ybSwgZWxlbWVudE5hbWUsIG9wdGlvbnMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBkYXRhW2VsZW1lbnROYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGROYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7KHN0cmluZ3xBcnJheS48c3RyaW5nPil9IHN1Ym1pdHRhYmxlIHZhbHVlKHMpIGluIHRoZSBmb3JtIGZvciBhXG4gKiAgIG5hbWVkIGVsZW1lbnQgZnJvbSBpdHMgLmVsZW1lbnRzIGNvbGxlY3Rpb24sIG9yIG51bGwgaWYgdGhlcmUgd2FzIG5vXG4gKiAgIGVsZW1lbnQgd2l0aCB0aGF0IG5hbWUgb3IgdGhlIGVsZW1lbnQgaGFkIG5vIHN1Ym1pdHRhYmxlIHZhbHVlKHMpLlxuICovXG5mdW5jdGlvbiBnZXRGaWVsZERhdGEoZm9ybSwgZmllbGROYW1lKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7IHRyaW06IGZhbHNlIH07XG5cbiAgaWYgKCFmb3JtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGZvcm0gaXMgcmVxdWlyZWQgYnkgZ2V0RmllbGREYXRhLCB3YXMgZ2l2ZW4gZm9ybT0nICsgZm9ybSk7XG4gIH1cbiAgaWYgKCFmaWVsZE5hbWUgJiYgdG9TdHJpbmcuY2FsbChmaWVsZE5hbWUpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBmaWVsZCBuYW1lIGlzIHJlcXVpcmVkIGJ5IGdldEZpZWxkRGF0YSwgd2FzIGdpdmVuIGZpZWxkTmFtZT0nICsgZmllbGROYW1lKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gZm9ybS5lbGVtZW50c1tmaWVsZE5hbWVdO1xuICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudC5kaXNhYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFOT0RFX0xJU1RfQ0xBU1NFU1t0b1N0cmluZy5jYWxsKGVsZW1lbnQpXSkge1xuICAgIHJldHVybiBnZXRGb3JtRWxlbWVudFZhbHVlKGVsZW1lbnQsIG9wdGlvbnMudHJpbSk7XG4gIH1cblxuICAvLyBEZWFsIHdpdGggbXVsdGlwbGUgZm9ybSBjb250cm9scyB3aGljaCBoYXZlIHRoZSBzYW1lIG5hbWVcbiAgdmFyIGRhdGEgPSBbXTtcbiAgdmFyIGFsbFJhZGlvcyA9IHRydWU7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWxlbWVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoZWxlbWVudFtpXS5kaXNhYmxlZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbGxSYWRpb3MgJiYgZWxlbWVudFtpXS50eXBlICE9PSAncmFkaW8nKSB7XG4gICAgICBhbGxSYWRpb3MgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gZ2V0Rm9ybUVsZW1lbnRWYWx1ZShlbGVtZW50W2ldLCBvcHRpb25zLnRyaW0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBkYXRhID0gZGF0YS5jb25jYXQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgYW4gZWxlbWVudCB3aXRoIG11bHRpcGxlIHNhbWUtbmFtZWQgaW5wdXRzIHdoaWNoIHdlcmUgYWxsXG4gIC8vIHJhZGlvIGJ1dHRvbnM6IGlmIHRoZXJlIHdhcyBhIHNlbGVjdGVkIHZhbHVlLCBvbmx5IHJldHVybiB0aGUgdmFsdWUuXG4gIGlmIChhbGxSYWRpb3MgJiYgZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZGF0YVswXTtcbiAgfVxuXG4gIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBkYXRhIDogbnVsbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IGEgZm9ybSBlbGVtZW50LlxuICogQHBhcmFtIHtib29sZWFtfSB0cmltIHNob3VsZCB2YWx1ZXMgZm9yIHRleHQgZW50cnkgaW5wdXRzIGJlIHRyaW1tZWQ/XG4gKiBAcmV0dXJuIHsoc3RyaW5nfEFycmF5LjxzdHJpbmc+fEZpbGV8QXJyYXkuPEZpbGU+KX0gdGhlIGVsZW1lbnQncyBzdWJtaXR0YWJsZVxuICogICB2YWx1ZShzKSwgb3IgbnVsbCBpZiBpdCBoYWQgbm9uZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Rm9ybUVsZW1lbnRWYWx1ZShlbGVtZW50LCB0cmltKSB7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG5cbiAgaWYgKHR5cGUgPT09ICdzZWxlY3Qtb25lJykge1xuICAgIGlmIChlbGVtZW50Lm9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9IGVsZW1lbnQub3B0aW9uc1tlbGVtZW50LnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ3NlbGVjdC1tdWx0aXBsZScpIHtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWxlbWVudC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGVsZW1lbnQub3B0aW9uc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICB2YWx1ZS5wdXNoKGVsZW1lbnQub3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gSWYgYSBmaWxlIGlucHV0IGRvZXNuJ3QgaGF2ZSBhIGZpbGVzIGF0dHJpYnV0ZSwgZmFsbCB0aHJvdWdoIHRvIHVzaW5nIGl0c1xuICAvLyB2YWx1ZSBhdHRyaWJ1dGUuXG4gIGlmICh0eXBlID09PSAnZmlsZScgJiYgJ2ZpbGVzJyBpbiBlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQubXVsdGlwbGUpIHtcbiAgICAgIHZhbHVlID0gc2xpY2UuY2FsbChlbGVtZW50LmZpbGVzKTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaG91bGQgYmUgbnVsbCBpZiBub3QgcHJlc2VudCwgYWNjb3JkaW5nIHRvIHRoZSBzcGVjXG4gICAgICB2YWx1ZSA9IGVsZW1lbnQuZmlsZXNbMF07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICghQ0hFQ0tFRF9JTlBVVF9UWVBFU1t0eXBlXSkge1xuICAgIHZhbHVlID0gdHJpbSA/IGVsZW1lbnQudmFsdWUucmVwbGFjZShUUklNX1JFLCAnJykgOiBlbGVtZW50LnZhbHVlO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQuY2hlY2tlZCkge1xuICAgIHZhbHVlID0gZWxlbWVudC52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gRm9yIFVNRCBidWlsZCBhY2Nlc3MgdG8gZ2V0RmllbGREYXRhXG5nZXRGb3JtRGF0YS5nZXRGaWVsZERhdGEgPSBnZXRGaWVsZERhdGE7IiwibW9kdWxlLmV4cG9ydHMgPSBFdmVudFxuXG5mdW5jdGlvbiBFdmVudCgpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gW11cblxuICAgIHJldHVybiB7IGJyb2FkY2FzdDogYnJvYWRjYXN0LCBsaXN0ZW46IGV2ZW50IH1cblxuICAgIGZ1bmN0aW9uIGJyb2FkY2FzdCh2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2ldKHZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXZlbnQobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpXG5cbiAgICAgICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyXG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcilcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gU291cmNlXG5cbmZ1bmN0aW9uIFNvdXJjZShicm9hZGNhc3Rlcikge1xuICAgIHZhciB0dXBsZSA9IEV2ZW50KClcblxuICAgIGJyb2FkY2FzdGVyKHR1cGxlLmJyb2FkY2FzdClcblxuICAgIHJldHVybiB0dXBsZS5saXN0ZW5cbn1cbiIsInZhciB0b3BMZXZlbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9XG52YXIgbWluRG9jID0gcmVxdWlyZSgnbWluLWRvY3VtZW50Jyk7XG5cbnZhciBkb2NjeTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkb2NjeSA9IGRvY3VtZW50O1xufSBlbHNlIHtcbiAgICBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jY3k7XG4iLCJ2YXIgd2luO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbiA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbiA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgIHdpbiA9IHNlbGY7XG59IGVsc2Uge1xuICAgIHdpbiA9IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbjtcbiIsIm1vZHVsZS5leHBvcnRzID0gc2hpbVxuXG5mdW5jdGlvbiBzaGltIChlbGVtZW50LCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJ1xuICAgIH1cblxuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJ25vbmUnIDogJydcbn1cbiIsIi8vIEh1bWFuaXplRHVyYXRpb24uanMgLSBodHRwczovL2dpdC5pby9qMEhnbVFcblxuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIFRoaXMgaGFzIHRvIGJlIGRlZmluZWQgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGEgYnVnOiB3ZSB3YW50IHRvIGFsaWFzXG4gIC8vIGBncmAgYW5kIGBlbGAgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmxpdHkuIEluIGEgYnJlYWtpbmcgY2hhbmdlLCB3ZSBjYW5cbiAgLy8gcmVtb3ZlIGBncmAgZW50aXJlbHkuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXZhbkhhaG4vSHVtYW5pemVEdXJhdGlvbi5qcy9pc3N1ZXMvMTQzIGZvciBtb3JlLlxuICB2YXIgZ3JlZWsgPSB7XG4gICAgeTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnz4fPgc+Mzr3Ov8+CJyA6ICfPh8+Bz4zOvc65zrEnIH0sXG4gICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ868zq7Ovc6xz4InIDogJ868zq7Ovc61z4InIH0sXG4gICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnzrXOss60zr/OvM6szrTOsScgOiAnzrXOss60zr/OvM6szrTOtc+CJyB9LFxuICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ868zq3Pgc6xJyA6ICfOvM6tz4HOtc+CJyB9LFxuICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ8+Oz4HOsScgOiAnz47Pgc61z4InIH0sXG4gICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnzrvOtc+Az4TPjCcgOiAnzrvOtc+Az4TOrCcgfSxcbiAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICfOtM61z4XPhM61z4HPjM67zrXPgM+Ezr8nIDogJ860zrXPhc+EzrXPgc+MzrvOtc+Az4TOsScgfSxcbiAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnz4fOuc67zrnOv8+Dz4TPjCDPhM6/z4UgzrTOtc+Fz4TOtc+Bzr/Ou86tz4DPhM6/z4UnIDogJ8+HzrnOu865zr/Pg8+Ezqwgz4TOv8+FIM60zrXPhc+EzrXPgc6/zrvOrc+Az4TOv8+FJyB9LFxuICAgIGRlY2ltYWw6ICcsJ1xuICB9XG5cbiAgdmFyIGxhbmd1YWdlcyA9IHtcbiAgICBhcjoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAn2LPZhtipJyA6ICfYs9mG2YjYp9iqJyB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ9i02YfYsScgOiAn2KPYtNmH2LEnIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICfYo9iz2KjZiNi5JyA6ICfYo9iz2KfYqNmK2LknIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICfZitmI2YUnIDogJ9ij2YrYp9mFJyB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAn2LPYp9i52KknIDogJ9iz2KfYudin2KonIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gWyfYr9mC2YrZgtipJywgJ9iv2YLYp9im2YInXVtnZXRBcmFiaWNGb3JtKGMpXVxuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ9ir2KfZhtmK2KknIDogJ9ir2YjYp9mG2YonIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAn2KzYstihINmF2YYg2KfZhNir2KfZhtmK2KknIDogJ9ij2KzYstin2KEg2YXZhiDYp9mE2KvYp9mG2YrYqScgfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgYmc6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9Cz0L7QtNC40L3QuCcsICfQs9C+0LTQuNC90LAnLCAn0LPQvtC00LjQvdC4J11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfQvNC10YHQtdGG0LAnLCAn0LzQtdGB0LXRhicsICfQvNC10YHQtdGG0LAnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0YHQtdC00LzQuNGG0LgnLCAn0YHQtdC00LzQuNGG0LAnLCAn0YHQtdC00LzQuNGG0LgnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0LTQvdC4JywgJ9C00LXQvScsICfQtNC90LgnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0YfQsNGB0LAnLCAn0YfQsNGBJywgJ9GH0LDRgdCwJ11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9C80LjQvdGD0YLQuCcsICfQvNC40L3Rg9GC0LAnLCAn0LzQuNC90YPRgtC4J11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9GB0LXQutGD0L3QtNC4JywgJ9GB0LXQutGD0L3QtNCwJywgJ9GB0LXQutGD0L3QtNC4J11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfQvNC40LvQuNGB0LXQutGD0L3QtNC4JywgJ9C80LjQu9C40YHQtdC60YPQvdC00LAnLCAn0LzQuNC70LjRgdC10LrRg9C90LTQuCddW2dldFNsYXZpY0Zvcm0oYyldIH0sXG4gICAgICBkZWNpbWFsOiAnLCdcbiAgICB9LFxuICAgIGNhOiB7XG4gICAgICB5OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2FueScgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWVzJyArIChjID09PSAxID8gJycgOiAnb3MnKSB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdzZXRtYW4nICsgKGMgPT09IDEgPyAnYScgOiAnZXMnKSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdkaScgKyAoYyA9PT0gMSA/ICdhJyA6ICdlcycpIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2hvcicgKyAoYyA9PT0gMSA/ICdhJyA6ICdlcycpIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbnV0JyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3NlZ29uJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaWxpc2Vnb24nICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgY3M6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ3JvaycsICdyb2t1JywgJ3Jva3knLCAnbGV0J11bZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYyldIH0sXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnbcSbc8OtYycsICdtxJtzw61jZScsICdtxJtzw61jZScsICdtxJtzw61jxa8nXVtnZXRDemVjaE9yU2xvdmFrRm9ybShjKV0gfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ3TDvWRlbicsICd0w71kbmUnLCAndMO9ZG55JywgJ3TDvWRuxa8nXVtnZXRDemVjaE9yU2xvdmFrRm9ybShjKV0gfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ2RlbicsICdkbmUnLCAnZG55JywgJ2Ruw60nXVtnZXRDemVjaE9yU2xvdmFrRm9ybShjKV0gfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ2hvZGluYScsICdob2RpbnknLCAnaG9kaW55JywgJ2hvZGluJ11bZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYyldIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydtaW51dGEnLCAnbWludXR5JywgJ21pbnV0eScsICdtaW51dCddW2dldEN6ZWNoT3JTbG92YWtGb3JtKGMpXSB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnc2VrdW5kYScsICdzZWt1bmR5JywgJ3Nla3VuZHknLCAnc2VrdW5kJ11bZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYyldIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnbWlsaXNla3VuZGEnLCAnbWlsaXNla3VuZHknLCAnbWlsaXNla3VuZHknLCAnbWlsaXNla3VuZCddW2dldEN6ZWNoT3JTbG92YWtGb3JtKGMpXSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBkYToge1xuICAgICAgeTogJ8OlcicsXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtw6VuZWQnICsgKGMgPT09IDEgPyAnJyA6ICdlcicpIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3VnZScgKyAoYyA9PT0gMSA/ICcnIDogJ3InKSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdkYWcnICsgKGMgPT09IDEgPyAnJyA6ICdlJykgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAndGltZScgKyAoYyA9PT0gMSA/ICcnIDogJ3InKSB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaW51dCcgKyAoYyA9PT0gMSA/ICcnIDogJ3RlcicpIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3Nla3VuZCcgKyAoYyA9PT0gMSA/ICcnIDogJ2VyJykgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbGxpc2VrdW5kJyArIChjID09PSAxID8gJycgOiAnZXInKSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBkZToge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdKYWhyJyArIChjID09PSAxID8gJycgOiAnZScpIH0sXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdNb25hdCcgKyAoYyA9PT0gMSA/ICcnIDogJ2UnKSB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdXb2NoZScgKyAoYyA9PT0gMSA/ICcnIDogJ24nKSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdUYWcnICsgKGMgPT09IDEgPyAnJyA6ICdlJykgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnU3R1bmRlJyArIChjID09PSAxID8gJycgOiAnbicpIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ01pbnV0ZScgKyAoYyA9PT0gMSA/ICcnIDogJ24nKSB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdTZWt1bmRlJyArIChjID09PSAxID8gJycgOiAnbicpIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdNaWxsaXNla3VuZGUnICsgKGMgPT09IDEgPyAnJyA6ICduJykgfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgZWw6IGdyZWVrLFxuICAgIGVuOiB7XG4gICAgICB5OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3llYXInICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21vbnRoJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3dlZWsnICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnZGF5JyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2hvdXInICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWludXRlJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3NlY29uZCcgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWlsbGlzZWNvbmQnICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIGRlY2ltYWw6ICcuJ1xuICAgIH0sXG4gICAgZXM6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnYcOxbycgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWVzJyArIChjID09PSAxID8gJycgOiAnZXMnKSB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdzZW1hbmEnICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnZMOtYScgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdob3JhJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbnV0bycgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdzZWd1bmRvJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaWxpc2VndW5kbycgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBmYToge1xuICAgICAgeTogJ9iz2KfZhCcsXG4gICAgICBtbzogJ9mF2KfZhycsXG4gICAgICB3OiAn2YfZgdiq2YcnLFxuICAgICAgZDogJ9ix2YjYsicsXG4gICAgICBoOiAn2LPYp9i52KonLFxuICAgICAgbTogJ9iv2YLbjNmC2YcnLFxuICAgICAgczogJ9ir2KfZhtuM2YcnLFxuICAgICAgbXM6ICfZhduM2YTbjCDYq9in2YbbjNmHJyxcbiAgICAgIGRlY2ltYWw6ICcuJ1xuICAgIH0sXG4gICAgZmk6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ3Z1b3NpJyA6ICd2dW90dGEnIH0sXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAna3V1a2F1c2knIDogJ2t1dWthdXR0YScgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAndmlpa2tvJyArIChjID09PSAxID8gJycgOiAnYScpIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3DDpGl2w6QnICsgKGMgPT09IDEgPyAnJyA6ICfDpCcpIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3R1bnRpJyArIChjID09PSAxID8gJycgOiAnYScpIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbnV1dHRpJyArIChjID09PSAxID8gJycgOiAnYScpIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3Nla3VudGknICsgKGMgPT09IDEgPyAnJyA6ICdhJykgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbGxpc2VrdW50aScgKyAoYyA9PT0gMSA/ICcnIDogJ2EnKSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBmcjoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdhbicgKyAoYyA+PSAyID8gJ3MnIDogJycpIH0sXG4gICAgICBtbzogJ21vaXMnLFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdzZW1haW5lJyArIChjID49IDIgPyAncycgOiAnJykgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnam91cicgKyAoYyA+PSAyID8gJ3MnIDogJycpIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2hldXJlJyArIChjID49IDIgPyAncycgOiAnJykgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWludXRlJyArIChjID49IDIgPyAncycgOiAnJykgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnc2Vjb25kZScgKyAoYyA+PSAyID8gJ3MnIDogJycpIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaWxsaXNlY29uZGUnICsgKGMgPj0gMiA/ICdzJyA6ICcnKSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBncjogZ3JlZWssXG4gICAgaHI6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjICUgMTAgPT09IDIgfHwgYyAlIDEwID09PSAzIHx8IGMgJSAxMCA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiAnZ29kaW5lJ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZ29kaW5hJ1xuICAgICAgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiAnbWplc2VjJ1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09IDIgfHwgYyA9PT0gMyB8fCBjID09PSA0KSB7XG4gICAgICAgICAgcmV0dXJuICdtamVzZWNhJ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnbWplc2VjaSdcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyAlIDEwID09PSAxICYmIGMgIT09IDExKSB7XG4gICAgICAgICAgcmV0dXJuICd0amVkYW4nXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd0amVkbmEnXG4gICAgICB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnZGFuJyA6ICdkYW5hJyB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gJ3NhdCdcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSAyIHx8IGMgPT09IDMgfHwgYyA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiAnc2F0YSdcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3NhdGknXG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIG1vZDEwID0gYyAlIDEwXG4gICAgICAgIGlmICgobW9kMTAgPT09IDIgfHwgbW9kMTAgPT09IDMgfHwgbW9kMTAgPT09IDQpICYmIChjIDwgMTAgfHwgYyA+IDE0KSkge1xuICAgICAgICAgIHJldHVybiAnbWludXRlJ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnbWludXRhJ1xuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICgoYyA9PT0gMTAgfHwgYyA9PT0gMTEgfHwgYyA9PT0gMTIgfHwgYyA9PT0gMTMgfHwgYyA9PT0gMTQgfHwgYyA9PT0gMTYgfHwgYyA9PT0gMTcgfHwgYyA9PT0gMTggfHwgYyA9PT0gMTkpIHx8IChjICUgMTAgPT09IDUpKSB7XG4gICAgICAgICAgcmV0dXJuICdzZWt1bmRpJ1xuICAgICAgICB9IGVsc2UgaWYgKGMgJSAxMCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiAnc2VrdW5kYSdcbiAgICAgICAgfSBlbHNlIGlmIChjICUgMTAgPT09IDIgfHwgYyAlIDEwID09PSAzIHx8IGMgJSAxMCA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiAnc2VrdW5kZSdcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3Nla3VuZGknXG4gICAgICB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuICdtaWxpc2VrdW5kYSdcbiAgICAgICAgfSBlbHNlIGlmIChjICUgMTAgPT09IDIgfHwgYyAlIDEwID09PSAzIHx8IGMgJSAxMCA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiAnbWlsaXNla3VuZGUnXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdtaWxpc2VrdW5kaSdcbiAgICAgIH0sXG4gICAgICBkZWNpbWFsOiAnLCdcbiAgICB9LFxuICAgIGh1OiB7XG4gICAgICB5OiAnw6l2JyxcbiAgICAgIG1vOiAnaMOzbmFwJyxcbiAgICAgIHc6ICdow6l0JyxcbiAgICAgIGQ6ICduYXAnLFxuICAgICAgaDogJ8OzcmEnLFxuICAgICAgbTogJ3BlcmMnLFxuICAgICAgczogJ23DoXNvZHBlcmMnLFxuICAgICAgbXM6ICdlenJlZG3DoXNvZHBlcmMnLFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBpZDoge1xuICAgICAgeTogJ3RhaHVuJyxcbiAgICAgIG1vOiAnYnVsYW4nLFxuICAgICAgdzogJ21pbmdndScsXG4gICAgICBkOiAnaGFyaScsXG4gICAgICBoOiAnamFtJyxcbiAgICAgIG06ICdtZW5pdCcsXG4gICAgICBzOiAnZGV0aWsnLFxuICAgICAgbXM6ICdtaWxpZGV0aWsnLFxuICAgICAgZGVjaW1hbDogJy4nXG4gICAgfSxcbiAgICBpczoge1xuICAgICAgeTogJ8OhcicsXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtw6FudcOwJyArIChjID09PSAxID8gJ3VyJyA6ICdpcicpIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3ZpaycgKyAoYyA9PT0gMSA/ICdhJyA6ICd1cicpIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2RhZycgKyAoYyA9PT0gMSA/ICd1cicgOiAnYXInKSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdrbHVra3V0w61tJyArIChjID09PSAxID8gJ2knIDogJ2FyJykgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbcOtbsO6dCcgKyAoYyA9PT0gMSA/ICdhJyA6ICd1cicpIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3Nla8O6bmQnICsgKGMgPT09IDEgPyAnYScgOiAndXInKSB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWlsbGlzZWvDum5kJyArIChjID09PSAxID8gJ2EnIDogJ3VyJykgfSxcbiAgICAgIGRlY2ltYWw6ICcuJ1xuICAgIH0sXG4gICAgaXQ6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnYW5uJyArIChjID09PSAxID8gJ28nIDogJ2knKSB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWVzJyArIChjID09PSAxID8gJ2UnIDogJ2knKSB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdzZXR0aW1hbicgKyAoYyA9PT0gMSA/ICdhJyA6ICdlJykgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnZ2lvcm4nICsgKGMgPT09IDEgPyAnbycgOiAnaScpIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ29yJyArIChjID09PSAxID8gJ2EnIDogJ2UnKSB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaW51dCcgKyAoYyA9PT0gMSA/ICdvJyA6ICdpJykgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnc2Vjb25kJyArIChjID09PSAxID8gJ28nIDogJ2knKSB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWlsbGlzZWNvbmQnICsgKGMgPT09IDEgPyAnbycgOiAnaScpIH0sXG4gICAgICBkZWNpbWFsOiAnLCdcbiAgICB9LFxuICAgIGphOiB7XG4gICAgICB5OiAn5bm0JyxcbiAgICAgIG1vOiAn5pyIJyxcbiAgICAgIHc6ICfpgLEnLFxuICAgICAgZDogJ+aXpScsXG4gICAgICBoOiAn5pmC6ZaTJyxcbiAgICAgIG06ICfliIYnLFxuICAgICAgczogJ+enkicsXG4gICAgICBtczogJ+ODn+ODquenkicsXG4gICAgICBkZWNpbWFsOiAnLidcbiAgICB9LFxuICAgIGtvOiB7XG4gICAgICB5OiAn64WEJyxcbiAgICAgIG1vOiAn6rCc7JuUJyxcbiAgICAgIHc6ICfso7zsnbwnLFxuICAgICAgZDogJ+ydvCcsXG4gICAgICBoOiAn7Iuc6rCEJyxcbiAgICAgIG06ICfrtoQnLFxuICAgICAgczogJ+y0iCcsXG4gICAgICBtczogJ+uwgOumrCDstIgnLFxuICAgICAgZGVjaW1hbDogJy4nXG4gICAgfSxcbiAgICBsbzoge1xuICAgICAgeTogJ+C6m+C6tScsXG4gICAgICBtbzogJ+C7gOC6lOC6t+C6reC6mScsXG4gICAgICB3OiAn4Lqt4Lqy4LqX4Lq04LqUJyxcbiAgICAgIGQ6ICfguqHgurfgu4knLFxuICAgICAgaDogJ+C6iuC6u+C7iOC6p+C7guC6oeC6hycsXG4gICAgICBtOiAn4LqZ4Lqy4LqX4Lq1JyxcbiAgICAgIHM6ICfguqfgurTgupngurLgupfgurUnLFxuICAgICAgbXM6ICfguqHgurTgupnguqXgurTguqfgurTgupngurLgupfgurUnLFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBsdDoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICgoYyAlIDEwID09PSAwKSB8fCAoYyAlIDEwMCA+PSAxMCAmJiBjICUgMTAwIDw9IDIwKSkgPyAnbWV0xbMnIDogJ21ldGFpJyB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ23El251bycsICdtxJduZXNpYWknLCAnbcSXbmVzacWzJ11bZ2V0TGl0aHVhbmlhbkZvcm0oYyldIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydzYXZhaXTElycsICdzYXZhaXTEl3MnLCAnc2F2YWnEjWnFsyddW2dldExpdGh1YW5pYW5Gb3JtKGMpXSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnZGllbmEnLCAnZGllbm9zJywgJ2RpZW7FsyddW2dldExpdGh1YW5pYW5Gb3JtKGMpXSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsndmFsYW5kYScsICd2YWxhbmRvcycsICd2YWxhbmTFsyddW2dldExpdGh1YW5pYW5Gb3JtKGMpXSB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnbWludXTElycsICdtaW51dMSXcycsICdtaW51xI1pxbMnXVtnZXRMaXRodWFuaWFuRm9ybShjKV0gfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ3Nla3VuZMSXJywgJ3Nla3VuZMSXcycsICdzZWt1bmTFvmnFsyddW2dldExpdGh1YW5pYW5Gb3JtKGMpXSB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ21pbGlzZWt1bmTElycsICdtaWxpc2VrdW5kxJdzJywgJ21pbGlzZWt1bmTFvmnFsyddW2dldExpdGh1YW5pYW5Gb3JtKGMpXSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBtczoge1xuICAgICAgeTogJ3RhaHVuJyxcbiAgICAgIG1vOiAnYnVsYW4nLFxuICAgICAgdzogJ21pbmdndScsXG4gICAgICBkOiAnaGFyaScsXG4gICAgICBoOiAnamFtJyxcbiAgICAgIG06ICdtaW5pdCcsXG4gICAgICBzOiAnc2FhdCcsXG4gICAgICBtczogJ21pbGlzYWF0JyxcbiAgICAgIGRlY2ltYWw6ICcuJ1xuICAgIH0sXG4gICAgbmw6IHtcbiAgICAgIHk6ICdqYWFyJyxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICdtYWFuZCcgOiAnbWFhbmRlbicgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ3dlZWsnIDogJ3dla2VuJyB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnZGFnJyA6ICdkYWdlbicgfSxcbiAgICAgIGg6ICd1dXInLFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnbWludXV0JyA6ICdtaW51dGVuJyB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnc2Vjb25kZScgOiAnc2Vjb25kZW4nIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnbWlsbGlzZWNvbmRlJyA6ICdtaWxsaXNlY29uZGVuJyB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBubzoge1xuICAgICAgeTogJ8OlcicsXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtw6VuZWQnICsgKGMgPT09IDEgPyAnJyA6ICdlcicpIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3VrZScgKyAoYyA9PT0gMSA/ICcnIDogJ3InKSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdkYWcnICsgKGMgPT09IDEgPyAnJyA6ICdlcicpIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3RpbWUnICsgKGMgPT09IDEgPyAnJyA6ICdyJykgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWludXR0JyArIChjID09PSAxID8gJycgOiAnZXInKSB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdzZWt1bmQnICsgKGMgPT09IDEgPyAnJyA6ICdlcicpIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaWxsaXNla3VuZCcgKyAoYyA9PT0gMSA/ICcnIDogJ2VyJykgfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgcGw6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ3JvaycsICdyb2t1JywgJ2xhdGEnLCAnbGF0J11bZ2V0UG9saXNoRm9ybShjKV0gfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydtaWVzacSFYycsICdtaWVzacSFY2EnLCAnbWllc2nEhWNlJywgJ21pZXNpxJljeSddW2dldFBvbGlzaEZvcm0oYyldIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyd0eWR6aWXFhCcsICd0eWdvZG5pYScsICd0eWdvZG5pZScsICd0eWdvZG5pJ11bZ2V0UG9saXNoRm9ybShjKV0gfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ2R6aWXFhCcsICdkbmlhJywgJ2RuaScsICdkbmknXVtnZXRQb2xpc2hGb3JtKGMpXSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnZ29kemluYScsICdnb2R6aW55JywgJ2dvZHppbnknLCAnZ29kemluJ11bZ2V0UG9saXNoRm9ybShjKV0gfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ21pbnV0YScsICdtaW51dHknLCAnbWludXR5JywgJ21pbnV0J11bZ2V0UG9saXNoRm9ybShjKV0gfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ3Nla3VuZGEnLCAnc2VrdW5keScsICdzZWt1bmR5JywgJ3Nla3VuZCddW2dldFBvbGlzaEZvcm0oYyldIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnbWlsaXNla3VuZGEnLCAnbWlsaXNla3VuZHknLCAnbWlsaXNla3VuZHknLCAnbWlsaXNla3VuZCddW2dldFBvbGlzaEZvcm0oYyldIH0sXG4gICAgICBkZWNpbWFsOiAnLCdcbiAgICB9LFxuICAgIHB0OiB7XG4gICAgICB5OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2FubycgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ23DqnMnIDogJ21lc2VzJyB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdzZW1hbmEnICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnZGlhJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2hvcmEnICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWludXRvJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3NlZ3VuZG8nICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbGlzc2VndW5kbycgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBybzoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnYW4nIDogJ2FuaScgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICdsdW7EgycgOiAnbHVuaScgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ3PEg3B0xINtw6JuxIMnIDogJ3PEg3B0xINtw6JuaScgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ3ppJyA6ICd6aWxlJyB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnb3LEgycgOiAnb3JlJyB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnbWludXQnIDogJ21pbnV0ZScgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ3NlY3VuZMSDJyA6ICdzZWN1bmRlJyB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ21pbGlzZWN1bmTEgycgOiAnbWlsaXNlY3VuZGUnIH0sXG4gICAgICBkZWNpbWFsOiAnLCdcbiAgICB9LFxuICAgIHJ1OiB7XG4gICAgICB5OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfQu9C10YInLCAn0LPQvtC0JywgJ9Cz0L7QtNCwJ11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfQvNC10YHRj9GG0LXQsicsICfQvNC10YHRj9GGJywgJ9C80LXRgdGP0YbQsCddW2dldFNsYXZpY0Zvcm0oYyldIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfQvdC10LTQtdC70YwnLCAn0L3QtdC00LXQu9GPJywgJ9C90LXQtNC10LvQuCddW2dldFNsYXZpY0Zvcm0oYyldIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfQtNC90LXQuScsICfQtNC10L3RjCcsICfQtNC90Y8nXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0YfQsNGB0L7QsicsICfRh9Cw0YEnLCAn0YfQsNGB0LAnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0LzQuNC90YPRgicsICfQvNC40L3Rg9GC0LAnLCAn0LzQuNC90YPRgtGLJ11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9GB0LXQutGD0L3QtCcsICfRgdC10LrRg9C90LTQsCcsICfRgdC10LrRg9C90LTRiyddW2dldFNsYXZpY0Zvcm0oYyldIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0LzQuNC70LvQuNGB0LXQutGD0L3QtCcsICfQvNC40LvQu9C40YHQtdC60YPQvdC00LAnLCAn0LzQuNC70LvQuNGB0LXQutGD0L3QtNGLJ11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgdWs6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9GA0L7QutGW0LInLCAn0YDRltC6JywgJ9GA0L7QutC4J11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfQvNGW0YHRj9GG0ZbQsicsICfQvNGW0YHRj9GG0YwnLCAn0LzRltGB0Y/RhtGWJ11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9GC0LjQttC90ZbQsicsICfRgtC40LbQtNC10L3RjCcsICfRgtC40LbQvdGWJ11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9C00L3RltCyJywgJ9C00LXQvdGMJywgJ9C00L3RliddW2dldFNsYXZpY0Zvcm0oYyldIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfQs9C+0LTQuNC9JywgJ9Cz0L7QtNC40L3QsCcsICfQs9C+0LTQuNC90LgnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0YXQstC40LvQuNC9JywgJ9GF0LLQuNC70LjQvdCwJywgJ9GF0LLQuNC70LjQvdC4J11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9GB0LXQutGD0L3QtCcsICfRgdC10LrRg9C90LTQsCcsICfRgdC10LrRg9C90LTQuCddW2dldFNsYXZpY0Zvcm0oYyldIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0LzRltC70ZbRgdC10LrRg9C90LQnLCAn0LzRltC70ZbRgdC10LrRg9C90LTQsCcsICfQvNGW0LvRltGB0LXQutGD0L3QtNC4J11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgdXI6IHtcbiAgICAgIHk6ICfYs9in2YQnLFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ9mF24HbjNmG24EnIDogJ9mF24HbjNmG25InIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICfbgdmB2KrbgScgOiAn24HZgdiq25InIH0sXG4gICAgICBkOiAn2K/ZhicsXG4gICAgICBoOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICfar9q+2YbZuduBJyA6ICfar9q+2YbZuduSJyB9LFxuICAgICAgbTogJ9mF2YbZuScsXG4gICAgICBzOiAn2LPbjNqp2YbaiCcsXG4gICAgICBtczogJ9mF2YTbjCDYs9uM2qnZhtqIJyxcbiAgICAgIGRlY2ltYWw6ICcuJ1xuICAgIH0sXG4gICAgc2s6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ3JvaycsICdyb2t5JywgJ3Jva3knLCAncm9rb3YnXVtnZXRDemVjaE9yU2xvdmFrRm9ybShjKV0gfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydtZXNpYWMnLCAnbWVzaWFjZScsICdtZXNpYWNlJywgJ21lc2lhY292J11bZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYyldIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyd0w73FvmRlxYgnLCAndMO9xb5kbmUnLCAndMO9xb5kbmUnLCAndMO9xb5kxYhvdiddW2dldEN6ZWNoT3JTbG92YWtGb3JtKGMpXSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnZGXFiCcsICdkbmknLCAnZG5pJywgJ2Ruw60nXVtnZXRDemVjaE9yU2xvdmFrRm9ybShjKV0gfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ2hvZGluYScsICdob2RpbnknLCAnaG9kaW55JywgJ2hvZMOtbiddW2dldEN6ZWNoT3JTbG92YWtGb3JtKGMpXSB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnbWluw7p0YScsICdtaW7DunR5JywgJ21pbsO6dHknLCAnbWluw7p0J11bZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYyldIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydzZWt1bmRhJywgJ3Nla3VuZHknLCAnc2VrdW5keScsICdzZWvDum5kJ11bZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYyldIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnbWlsaXNla3VuZGEnLCAnbWlsaXNla3VuZHknLCAnbWlsaXNla3VuZHknLCAnbWlsaXNla8O6bmQnXVtnZXRDemVjaE9yU2xvdmFrRm9ybShjKV0gfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgc3Y6IHtcbiAgICAgIHk6ICfDpXInLFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbcOlbmFkJyArIChjID09PSAxID8gJycgOiAnZXInKSB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICd2ZWNrJyArIChjID09PSAxID8gJ2EnIDogJ29yJykgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnZGFnJyArIChjID09PSAxID8gJycgOiAnYXInKSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICd0aW1tJyArIChjID09PSAxID8gJ2UnIDogJ2FyJykgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWludXQnICsgKGMgPT09IDEgPyAnJyA6ICdlcicpIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3Nla3VuZCcgKyAoYyA9PT0gMSA/ICcnIDogJ2VyJykgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbGxpc2VrdW5kJyArIChjID09PSAxID8gJycgOiAnZXInKSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICB0cjoge1xuICAgICAgeTogJ3nEsWwnLFxuICAgICAgbW86ICdheScsXG4gICAgICB3OiAnaGFmdGEnLFxuICAgICAgZDogJ2fDvG4nLFxuICAgICAgaDogJ3NhYXQnLFxuICAgICAgbTogJ2Rha2lrYScsXG4gICAgICBzOiAnc2FuaXllJyxcbiAgICAgIG1zOiAnbWlsaXNhbml5ZScsXG4gICAgICBkZWNpbWFsOiAnLCdcbiAgICB9LFxuICAgIHRoOiB7XG4gICAgICB5OiAn4Lib4Li1JyxcbiAgICAgIG1vOiAn4LmA4LiU4Li34Lit4LiZJyxcbiAgICAgIHc6ICfguK3guLLguJfguLTguJXguKLguYwnLFxuICAgICAgZDogJ+C4p+C4seC4mScsXG4gICAgICBoOiAn4LiK4Lix4LmI4Lin4LmC4Lih4LiHJyxcbiAgICAgIG06ICfguJnguLLguJfguLUnLFxuICAgICAgczogJ+C4p+C4tOC4meC4suC4l+C4tScsXG4gICAgICBtczogJ+C4oeC4tOC4peC4peC4tOC4p+C4tOC4meC4suC4l+C4tScsXG4gICAgICBkZWNpbWFsOiAnLidcbiAgICB9LFxuICAgIHZpOiB7XG4gICAgICB5OiAnbsSDbScsXG4gICAgICBtbzogJ3Row6FuZycsXG4gICAgICB3OiAndHXhuqduJyxcbiAgICAgIGQ6ICduZ8OgeScsXG4gICAgICBoOiAnZ2nhu50nLFxuICAgICAgbTogJ3Bow7p0JyxcbiAgICAgIHM6ICdnacOieScsXG4gICAgICBtczogJ21pbGkgZ2nDonknLFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICB6aF9DTjoge1xuICAgICAgeTogJ+W5tCcsXG4gICAgICBtbzogJ+S4quaciCcsXG4gICAgICB3OiAn5ZGoJyxcbiAgICAgIGQ6ICflpKknLFxuICAgICAgaDogJ+Wwj+aXticsXG4gICAgICBtOiAn5YiG6ZKfJyxcbiAgICAgIHM6ICfnp5InLFxuICAgICAgbXM6ICfmr6vnp5InLFxuICAgICAgZGVjaW1hbDogJy4nXG4gICAgfSxcbiAgICB6aF9UVzoge1xuICAgICAgeTogJ+W5tCcsXG4gICAgICBtbzogJ+WAi+aciCcsXG4gICAgICB3OiAn5ZGoJyxcbiAgICAgIGQ6ICflpKknLFxuICAgICAgaDogJ+Wwj+aZgicsXG4gICAgICBtOiAn5YiG6ZCYJyxcbiAgICAgIHM6ICfnp5InLFxuICAgICAgbXM6ICfmr6vnp5InLFxuICAgICAgZGVjaW1hbDogJy4nXG4gICAgfVxuICB9XG5cbiAgLy8gWW91IGNhbiBjcmVhdGUgYSBodW1hbml6ZXIsIHdoaWNoIHJldHVybnMgYSBmdW5jdGlvbiB3aXRoIGRlZmF1bHRcbiAgLy8gcGFyYW1ldGVycy5cbiAgZnVuY3Rpb24gaHVtYW5pemVyIChwYXNzZWRPcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uIGh1bWFuaXplciAobXMsIGh1bWFuaXplck9wdGlvbnMpIHtcbiAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kKHt9LCByZXN1bHQsIGh1bWFuaXplck9wdGlvbnMgfHwge30pXG4gICAgICByZXR1cm4gZG9IdW1hbml6YXRpb24obXMsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuZChyZXN1bHQsIHtcbiAgICAgIGxhbmd1YWdlOiAnZW4nLFxuICAgICAgZGVsaW1pdGVyOiAnLCAnLFxuICAgICAgc3BhY2VyOiAnICcsXG4gICAgICBjb25qdW5jdGlvbjogJycsXG4gICAgICBzZXJpYWxDb21tYTogdHJ1ZSxcbiAgICAgIHVuaXRzOiBbJ3knLCAnbW8nLCAndycsICdkJywgJ2gnLCAnbScsICdzJ10sXG4gICAgICBsYW5ndWFnZXM6IHt9LFxuICAgICAgcm91bmQ6IGZhbHNlLFxuICAgICAgdW5pdE1lYXN1cmVzOiB7XG4gICAgICAgIHk6IDMxNTU3NjAwMDAwLFxuICAgICAgICBtbzogMjYyOTgwMDAwMCxcbiAgICAgICAgdzogNjA0ODAwMDAwLFxuICAgICAgICBkOiA4NjQwMDAwMCxcbiAgICAgICAgaDogMzYwMDAwMCxcbiAgICAgICAgbTogNjAwMDAsXG4gICAgICAgIHM6IDEwMDAsXG4gICAgICAgIG1zOiAxXG4gICAgICB9XG4gICAgfSwgcGFzc2VkT3B0aW9ucylcbiAgfVxuXG4gIC8vIFRoZSBtYWluIGZ1bmN0aW9uIGlzIGp1c3QgYSB3cmFwcGVyIGFyb3VuZCBhIGRlZmF1bHQgaHVtYW5pemVyLlxuICB2YXIgaHVtYW5pemVEdXJhdGlvbiA9IGh1bWFuaXplcih7fSlcblxuICAvLyBCdWlsZCBkaWN0aW9uYXJ5IGZyb20gb3B0aW9uc1xuICBmdW5jdGlvbiBnZXREaWN0aW9uYXJ5IChvcHRpb25zKSB7XG4gICAgdmFyIGxhbmd1YWdlc0Zyb21PcHRpb25zID0gW29wdGlvbnMubGFuZ3VhZ2VdXG5cbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZmFsbGJhY2tzJykpIHtcbiAgICAgIGlmIChpc0FycmF5KG9wdGlvbnMuZmFsbGJhY2tzKSAmJiBvcHRpb25zLmZhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgbGFuZ3VhZ2VzRnJvbU9wdGlvbnMgPSBsYW5ndWFnZXNGcm9tT3B0aW9ucy5jb25jYXQob3B0aW9ucy5mYWxsYmFja3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhbGxiYWNrcyBtdXN0IGJlIGFuIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFuZ3VhZ2VzRnJvbU9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsYW5ndWFnZVRvVHJ5ID0gbGFuZ3VhZ2VzRnJvbU9wdGlvbnNbaV1cbiAgICAgIGlmIChvcHRpb25zLmxhbmd1YWdlcy5oYXNPd25Qcm9wZXJ0eShsYW5ndWFnZVRvVHJ5KSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5sYW5ndWFnZXNbbGFuZ3VhZ2VUb1RyeV1cbiAgICAgIH0gZWxzZSBpZiAobGFuZ3VhZ2VzLmhhc093blByb3BlcnR5KGxhbmd1YWdlVG9UcnkpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZXNbbGFuZ3VhZ2VUb1RyeV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGxhbmd1YWdlIGZvdW5kLicpXG4gIH1cblxuICAvLyBkb0h1bWFuaXphdGlvbiBkb2VzIHRoZSBidWxrIG9mIHRoZSB3b3JrLlxuICBmdW5jdGlvbiBkb0h1bWFuaXphdGlvbiAobXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgaSwgbGVuLCBwaWVjZVxuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBwb3NpdGl2ZSBudW1iZXIuXG4gICAgLy8gSGFzIHRoZSBuaWNlIHNpZGVmZmVjdCBvZiB0dXJuaW5nIE51bWJlciBvYmplY3RzIGludG8gcHJpbWl0aXZlcy5cbiAgICBtcyA9IE1hdGguYWJzKG1zKVxuXG4gICAgdmFyIGRpY3Rpb25hcnkgPSBnZXREaWN0aW9uYXJ5KG9wdGlvbnMpXG4gICAgdmFyIHBpZWNlcyA9IFtdXG5cbiAgICAvLyBTdGFydCBhdCB0aGUgdG9wIGFuZCBrZWVwIHJlbW92aW5nIHVuaXRzLCBiaXQgYnkgYml0LlxuICAgIHZhciB1bml0TmFtZSwgdW5pdE1TLCB1bml0Q291bnRcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBvcHRpb25zLnVuaXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB1bml0TmFtZSA9IG9wdGlvbnMudW5pdHNbaV1cbiAgICAgIHVuaXRNUyA9IG9wdGlvbnMudW5pdE1lYXN1cmVzW3VuaXROYW1lXVxuXG4gICAgICAvLyBXaGF0J3MgdGhlIG51bWJlciBvZiBmdWxsIHVuaXRzIHdlIGNhbiBmaXQ/XG4gICAgICBpZiAoaSArIDEgPT09IGxlbikge1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbWF4RGVjaW1hbFBvaW50cycpKSB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byB1c2UgdGhpcyBleHBWYWx1ZSB0byBhdm9pZCByb3VuZGluZyBmdW5jdGlvbmFsaXR5IG9mIHRvRml4ZWQgY2FsbFxuICAgICAgICAgIHZhciBleHBWYWx1ZSA9IE1hdGgucG93KDEwLCBvcHRpb25zLm1heERlY2ltYWxQb2ludHMpXG4gICAgICAgICAgdmFyIHVuaXRDb3VudEZsb2F0ID0gKG1zIC8gdW5pdE1TKVxuICAgICAgICAgIHVuaXRDb3VudCA9IHBhcnNlRmxvYXQoKE1hdGguZmxvb3IoZXhwVmFsdWUgKiB1bml0Q291bnRGbG9hdCkgLyBleHBWYWx1ZSkudG9GaXhlZChvcHRpb25zLm1heERlY2ltYWxQb2ludHMpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaXRDb3VudCA9IG1zIC8gdW5pdE1TXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXRDb3VudCA9IE1hdGguZmxvb3IobXMgLyB1bml0TVMpXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgc3RyaW5nLlxuICAgICAgcGllY2VzLnB1c2goe1xuICAgICAgICB1bml0Q291bnQ6IHVuaXRDb3VudCxcbiAgICAgICAgdW5pdE5hbWU6IHVuaXROYW1lXG4gICAgICB9KVxuXG4gICAgICAvLyBSZW1vdmUgd2hhdCB3ZSBqdXN0IGZpZ3VyZWQgb3V0LlxuICAgICAgbXMgLT0gdW5pdENvdW50ICogdW5pdE1TXG4gICAgfVxuXG4gICAgdmFyIGZpcnN0T2NjdXBpZWRVbml0SW5kZXggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBpZWNlc1tpXS51bml0Q291bnQpIHtcbiAgICAgICAgZmlyc3RPY2N1cGllZFVuaXRJbmRleCA9IGlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yb3VuZCkge1xuICAgICAgdmFyIHJhdGlvVG9MYXJnZXJVbml0LCBwcmV2aW91c1BpZWNlXG4gICAgICBmb3IgKGkgPSBwaWVjZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcGllY2UgPSBwaWVjZXNbaV1cbiAgICAgICAgcGllY2UudW5pdENvdW50ID0gTWF0aC5yb3VuZChwaWVjZS51bml0Q291bnQpXG5cbiAgICAgICAgaWYgKGkgPT09IDApIHsgYnJlYWsgfVxuXG4gICAgICAgIHByZXZpb3VzUGllY2UgPSBwaWVjZXNbaSAtIDFdXG5cbiAgICAgICAgcmF0aW9Ub0xhcmdlclVuaXQgPSBvcHRpb25zLnVuaXRNZWFzdXJlc1twcmV2aW91c1BpZWNlLnVuaXROYW1lXSAvIG9wdGlvbnMudW5pdE1lYXN1cmVzW3BpZWNlLnVuaXROYW1lXVxuICAgICAgICBpZiAoKHBpZWNlLnVuaXRDb3VudCAlIHJhdGlvVG9MYXJnZXJVbml0KSA9PT0gMCB8fCAob3B0aW9ucy5sYXJnZXN0ICYmICgob3B0aW9ucy5sYXJnZXN0IC0gMSkgPCAoaSAtIGZpcnN0T2NjdXBpZWRVbml0SW5kZXgpKSkpIHtcbiAgICAgICAgICBwcmV2aW91c1BpZWNlLnVuaXRDb3VudCArPSBwaWVjZS51bml0Q291bnQgLyByYXRpb1RvTGFyZ2VyVW5pdFxuICAgICAgICAgIHBpZWNlLnVuaXRDb3VudCA9IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbXVxuICAgIGZvciAoaSA9IDAsIHBpZWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcGllY2UgPSBwaWVjZXNbaV1cbiAgICAgIGlmIChwaWVjZS51bml0Q291bnQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocmVuZGVyKHBpZWNlLnVuaXRDb3VudCwgcGllY2UudW5pdE5hbWUsIGRpY3Rpb25hcnksIG9wdGlvbnMpKVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gb3B0aW9ucy5sYXJnZXN0KSB7IGJyZWFrIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgaWYgKCFvcHRpb25zLmNvbmp1bmN0aW9uIHx8IHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKG9wdGlvbnMuZGVsaW1pdGVyKVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihvcHRpb25zLmNvbmp1bmN0aW9uKVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoID4gMikge1xuICAgICAgICByZXR1cm4gcmVzdWx0LnNsaWNlKDAsIC0xKS5qb2luKG9wdGlvbnMuZGVsaW1pdGVyKSArIChvcHRpb25zLnNlcmlhbENvbW1hID8gJywnIDogJycpICsgb3B0aW9ucy5jb25qdW5jdGlvbiArIHJlc3VsdC5zbGljZSgtMSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlbmRlcigwLCBvcHRpb25zLnVuaXRzW29wdGlvbnMudW5pdHMubGVuZ3RoIC0gMV0sIGRpY3Rpb25hcnksIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyIChjb3VudCwgdHlwZSwgZGljdGlvbmFyeSwgb3B0aW9ucykge1xuICAgIHZhciBkZWNpbWFsXG4gICAgaWYgKG9wdGlvbnMuZGVjaW1hbCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWNpbWFsID0gZGljdGlvbmFyeS5kZWNpbWFsXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY2ltYWwgPSBvcHRpb25zLmRlY2ltYWxcbiAgICB9XG5cbiAgICB2YXIgY291bnRTdHIgPSBjb3VudC50b1N0cmluZygpLnJlcGxhY2UoJy4nLCBkZWNpbWFsKVxuXG4gICAgdmFyIGRpY3Rpb25hcnlWYWx1ZSA9IGRpY3Rpb25hcnlbdHlwZV1cbiAgICB2YXIgd29yZFxuICAgIGlmICh0eXBlb2YgZGljdGlvbmFyeVZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JkID0gZGljdGlvbmFyeVZhbHVlKGNvdW50KVxuICAgIH0gZWxzZSB7XG4gICAgICB3b3JkID0gZGljdGlvbmFyeVZhbHVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50U3RyICsgb3B0aW9ucy5zcGFjZXIgKyB3b3JkXG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQgKGRlc3RpbmF0aW9uKSB7XG4gICAgdmFyIHNvdXJjZVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV1cbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wXSA9IHNvdXJjZVtwcm9wXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvblxuICB9XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIGZvciBQb2xpc2ggbGFuZ3VhZ2UuXG4gIGZ1bmN0aW9uIGdldFBvbGlzaEZvcm0gKGMpIHtcbiAgICBpZiAoYyA9PT0gMSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2UgaWYgKE1hdGguZmxvb3IoYykgIT09IGMpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfSBlbHNlIGlmIChjICUgMTAgPj0gMiAmJiBjICUgMTAgPD0gNCAmJiAhKGMgJSAxMDAgPiAxMCAmJiBjICUgMTAwIDwgMjApKSB7XG4gICAgICByZXR1cm4gMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gM1xuICAgIH1cbiAgfVxuXG4gIC8vIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiBmb3IgUnVzc2lhbiBhbmQgVWtyYW5pYW4gbGFuZ3VhZ2VzLlxuICBmdW5jdGlvbiBnZXRTbGF2aWNGb3JtIChjKSB7XG4gICAgaWYgKE1hdGguZmxvb3IoYykgIT09IGMpIHtcbiAgICAgIHJldHVybiAyXG4gICAgfSBlbHNlIGlmICgoYyAlIDEwMCA+PSA1ICYmIGMgJSAxMDAgPD0gMjApIHx8IChjICUgMTAgPj0gNSAmJiBjICUgMTAgPD0gOSkgfHwgYyAlIDEwID09PSAwKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZiAoYyAlIDEwID09PSAxKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoYyA+IDEpIHtcbiAgICAgIHJldHVybiAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICB9XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIGZvciBTbG92YWsgbGFuZ3VhZ2UuXG4gIGZ1bmN0aW9uIGdldEN6ZWNoT3JTbG92YWtGb3JtIChjKSB7XG4gICAgaWYgKGMgPT09IDEpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIGlmIChNYXRoLmZsb29yKGMpICE9PSBjKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoYyAlIDEwID49IDIgJiYgYyAlIDEwIDw9IDQgJiYgYyAlIDEwMCA8IDEwKSB7XG4gICAgICByZXR1cm4gMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gM1xuICAgIH1cbiAgfVxuXG4gIC8vIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiBmb3IgTGl0aHVhbmlhbiBsYW5ndWFnZS5cbiAgZnVuY3Rpb24gZ2V0TGl0aHVhbmlhbkZvcm0gKGMpIHtcbiAgICBpZiAoYyA9PT0gMSB8fCAoYyAlIDEwID09PSAxICYmIGMgJSAxMDAgPiAyMCkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIGlmIChNYXRoLmZsb29yKGMpICE9PSBjIHx8IChjICUgMTAgPj0gMiAmJiBjICUgMTAwID4gMjApIHx8IChjICUgMTAgPj0gMiAmJiBjICUgMTAwIDwgMTApKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMlxuICAgIH1cbiAgfVxuXG4gIC8vIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiBmb3IgQXJhYmljIGxhbmd1YWdlLlxuICBmdW5jdGlvbiBnZXRBcmFiaWNGb3JtIChjKSB7XG4gICAgaWYgKGMgPD0gMikgeyByZXR1cm4gMCB9XG4gICAgaWYgKGMgPiAyICYmIGMgPCAxMSkgeyByZXR1cm4gMSB9XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIHN1cHBvcnQgYnJvd3NlcnMgdGhhdCBkb24ndCBoYXZlXG4gIC8vIGBBcnJheS5pc0FycmF5YCwgc28gd2UgZGVmaW5lIGEgZmFsbGJhY2sgaGVyZS5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfVxuXG4gIGh1bWFuaXplRHVyYXRpb24uZ2V0U3VwcG9ydGVkTGFuZ3VhZ2VzID0gZnVuY3Rpb24gZ2V0U3VwcG9ydGVkTGFuZ3VhZ2VzICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW11cbiAgICBmb3IgKHZhciBsYW5ndWFnZSBpbiBsYW5ndWFnZXMpIHtcbiAgICAgIGlmIChsYW5ndWFnZXMuaGFzT3duUHJvcGVydHkobGFuZ3VhZ2UpICYmIGxhbmd1YWdlICE9PSAnZ3InKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxhbmd1YWdlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBodW1hbml6ZUR1cmF0aW9uLmh1bWFuaXplciA9IGh1bWFuaXplclxuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGh1bWFuaXplRHVyYXRpb25cbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBodW1hbml6ZUR1cmF0aW9uXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5odW1hbml6ZUR1cmF0aW9uID0gaHVtYW5pemVEdXJhdGlvblxuICB9XG59KSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHNlbWlcbiIsInZhciBzcGxpdCA9IHJlcXVpcmUoJ2Jyb3dzZXItc3BsaXQnKVxudmFyIENsYXNzTGlzdCA9IHJlcXVpcmUoJ2NsYXNzLWxpc3QnKVxuXG52YXIgdyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gcmVxdWlyZSgnaHRtbC1lbGVtZW50JykgOiB3aW5kb3dcbnZhciBkb2N1bWVudCA9IHcuZG9jdW1lbnRcbnZhciBUZXh0ID0gdy5UZXh0XG5cbmZ1bmN0aW9uIGNvbnRleHQgKCkge1xuXG4gIHZhciBjbGVhbnVwRnVuY3MgPSBbXVxuXG4gIGZ1bmN0aW9uIGgoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGUgPSBudWxsXG4gICAgZnVuY3Rpb24gaXRlbSAobCkge1xuICAgICAgdmFyIHJcbiAgICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3MgKHN0cmluZykge1xuICAgICAgICAvLyBPdXIgbWluaW1hbCBwYXJzZXIgZG9lc27igJl0IHVuZGVyc3RhbmQgZXNjYXBpbmcgQ1NTIHNwZWNpYWxcbiAgICAgICAgLy8gY2hhcmFjdGVycyBsaWtlIGAjYC4gRG9u4oCZdCB1c2UgdGhlbS4gTW9yZSByZWFkaW5nOlxuICAgICAgICAvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvY3NzLWVzY2FwZXMgLlxuXG4gICAgICAgIHZhciBtID0gc3BsaXQoc3RyaW5nLCAvKFtcXC4jXT9bXlxccyMuXSspLylcbiAgICAgICAgaWYoL15cXC58Iy8udGVzdChtWzFdKSlcbiAgICAgICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgZm9yRWFjaChtLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgIHZhciBzID0gdi5zdWJzdHJpbmcoMSx2Lmxlbmd0aClcbiAgICAgICAgICBpZighdikgcmV0dXJuXG4gICAgICAgICAgaWYoIWUpXG4gICAgICAgICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh2KVxuICAgICAgICAgIGVsc2UgaWYgKHZbMF0gPT09ICcuJylcbiAgICAgICAgICAgIENsYXNzTGlzdChlKS5hZGQocylcbiAgICAgICAgICBlbHNlIGlmICh2WzBdID09PSAnIycpXG4gICAgICAgICAgICBlLnNldEF0dHJpYnV0ZSgnaWQnLCBzKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZihsID09IG51bGwpXG4gICAgICAgIDtcbiAgICAgIGVsc2UgaWYoJ3N0cmluZycgPT09IHR5cGVvZiBsKSB7XG4gICAgICAgIGlmKCFlKVxuICAgICAgICAgIHBhcnNlQ2xhc3MobClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGwpKVxuICAgICAgfVxuICAgICAgZWxzZSBpZignbnVtYmVyJyA9PT0gdHlwZW9mIGxcbiAgICAgICAgfHwgJ2Jvb2xlYW4nID09PSB0eXBlb2YgbFxuICAgICAgICB8fCBsIGluc3RhbmNlb2YgRGF0ZVxuICAgICAgICB8fCBsIGluc3RhbmNlb2YgUmVnRXhwICkge1xuICAgICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGwudG9TdHJpbmcoKSkpXG4gICAgICB9XG4gICAgICAvL3RoZXJlIG1pZ2h0IGJlIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuICAgICAgZWxzZSBpZiAoaXNBcnJheShsKSlcbiAgICAgICAgZm9yRWFjaChsLCBpdGVtKVxuICAgICAgZWxzZSBpZihpc05vZGUobCkpXG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGwpXG4gICAgICBlbHNlIGlmKGwgaW5zdGFuY2VvZiBUZXh0KVxuICAgICAgICBlLmFwcGVuZENoaWxkKHIgPSBsKVxuICAgICAgZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBsKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gbCkge1xuICAgICAgICAgIGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiBsW2tdKSB7XG4gICAgICAgICAgICBpZigvXm9uXFx3Ky8udGVzdChrKSkge1xuICAgICAgICAgICAgICAoZnVuY3Rpb24gKGssIGwpIHsgLy8gY2FwdHVyZSBrLCBsIGluIHRoZSBjbG9zdXJlXG4gICAgICAgICAgICAgICAgaWYgKGUuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgICAgICAgICAgICAgICBlLmFkZEV2ZW50TGlzdGVuZXIoay5zdWJzdHJpbmcoMiksIGxba10sIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVFdmVudExpc3RlbmVyKGsuc3Vic3RyaW5nKDIpLCBsW2tdLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICBlLmF0dGFjaEV2ZW50KGssIGxba10pXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBlLmRldGFjaEV2ZW50KGssIGxba10pXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkoaywgbClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG9ic2VydmFibGVcbiAgICAgICAgICAgICAgZVtrXSA9IGxba10oKVxuICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChsW2tdKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgZVtrXSA9IHZcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoayA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgaWYoJ3N0cmluZycgPT09IHR5cGVvZiBsW2tdKSB7XG4gICAgICAgICAgICAgIGUuc3R5bGUuY3NzVGV4dCA9IGxba11cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBmb3IgKHZhciBzIGluIGxba10pIChmdW5jdGlvbihzLCB2KSB7XG4gICAgICAgICAgICAgICAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG9ic2VydmFibGVcbiAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgdigpKVxuICAgICAgICAgICAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2godihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgdmFsKVxuICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsW2tdW3NdLm1hdGNoKC8oLiopXFxXKyFpbXBvcnRhbnRcXFcqJC8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgbWF0Y2hbMV0sICdpbXBvcnRhbnQnKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCBsW2tdW3NdKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KShzLCBsW2tdW3NdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZihrID09PSAnYXR0cnMnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2IGluIGxba10pIHtcbiAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUodiwgbFtrXVt2XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoay5zdWJzdHIoMCwgNSkgPT09IFwiZGF0YS1cIikge1xuICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoaywgbFtrXSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZVtrXSA9IGxba11cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGwpIHtcbiAgICAgICAgLy9hc3N1bWUgaXQncyBhbiBvYnNlcnZhYmxlIVxuICAgICAgICB2YXIgdiA9IGwoKVxuICAgICAgICBlLmFwcGVuZENoaWxkKHIgPSBpc05vZGUodikgPyB2IDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodikpXG5cbiAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2gobChmdW5jdGlvbiAodikge1xuICAgICAgICAgIGlmKGlzTm9kZSh2KSAmJiByLnBhcmVudEVsZW1lbnQpXG4gICAgICAgICAgICByLnBhcmVudEVsZW1lbnQucmVwbGFjZUNoaWxkKHYsIHIpLCByID0gdlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHIudGV4dENvbnRlbnQgPSB2XG4gICAgICAgIH0pKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gclxuICAgIH1cbiAgICB3aGlsZShhcmdzLmxlbmd0aClcbiAgICAgIGl0ZW0oYXJncy5zaGlmdCgpKVxuXG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIGguY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsZWFudXBGdW5jcy5sZW5ndGg7IGkrKyl7XG4gICAgICBjbGVhbnVwRnVuY3NbaV0oKVxuICAgIH1cbiAgICBjbGVhbnVwRnVuY3MubGVuZ3RoID0gMFxuICB9XG5cbiAgcmV0dXJuIGhcbn1cblxudmFyIGggPSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRleHQoKVxuaC5jb250ZXh0ID0gY29udGV4dFxuXG5mdW5jdGlvbiBpc05vZGUgKGVsKSB7XG4gIHJldHVybiBlbCAmJiBlbC5ub2RlTmFtZSAmJiBlbC5ub2RlVHlwZVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoIChhcnIsIGZuKSB7XG4gIGlmIChhcnIuZm9yRWFjaCkgcmV0dXJuIGFyci5mb3JFYWNoKGZuKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgZm4oYXJyW2ldLCBpKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSdcbn1cblxuXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJ2YXIgY29udGFpbmVycyA9IFtdOyAvLyB3aWxsIHN0b3JlIGNvbnRhaW5lciBIVE1MRWxlbWVudCByZWZlcmVuY2VzXG52YXIgc3R5bGVFbGVtZW50cyA9IFtdOyAvLyB3aWxsIHN0b3JlIHtwcmVwZW5kOiBIVE1MRWxlbWVudCwgYXBwZW5kOiBIVE1MRWxlbWVudH1cblxudmFyIHVzYWdlID0gJ2luc2VydC1jc3M6IFlvdSBuZWVkIHRvIHByb3ZpZGUgYSBDU1Mgc3RyaW5nLiBVc2FnZTogaW5zZXJ0Q3NzKGNzc1N0cmluZ1ssIG9wdGlvbnNdKS4nO1xuXG5mdW5jdGlvbiBpbnNlcnRDc3MoY3NzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoY3NzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVzYWdlKTtcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBvcHRpb25zLnByZXBlbmQgPT09IHRydWUgPyAncHJlcGVuZCcgOiAnYXBwZW5kJztcbiAgICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29udGFpbmVyIDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xuICAgIHZhciBjb250YWluZXJJZCA9IGNvbnRhaW5lcnMuaW5kZXhPZihjb250YWluZXIpO1xuXG4gICAgLy8gZmlyc3QgdGltZSB3ZSBzZWUgdGhpcyBjb250YWluZXIsIGNyZWF0ZSB0aGUgbmVjZXNzYXJ5IGVudHJpZXNcbiAgICBpZiAoY29udGFpbmVySWQgPT09IC0xKSB7XG4gICAgICAgIGNvbnRhaW5lcklkID0gY29udGFpbmVycy5wdXNoKGNvbnRhaW5lcikgLSAxO1xuICAgICAgICBzdHlsZUVsZW1lbnRzW2NvbnRhaW5lcklkXSA9IHt9O1xuICAgIH1cblxuICAgIC8vIHRyeSB0byBnZXQgdGhlIGNvcnJlcG9uZGluZyBjb250YWluZXIgKyBwb3NpdGlvbiBzdHlsZUVsZW1lbnQsIGNyZWF0ZSBpdCBvdGhlcndpc2VcbiAgICB2YXIgc3R5bGVFbGVtZW50O1xuXG4gICAgaWYgKHN0eWxlRWxlbWVudHNbY29udGFpbmVySWRdICE9PSB1bmRlZmluZWQgJiYgc3R5bGVFbGVtZW50c1tjb250YWluZXJJZF1bcG9zaXRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3R5bGVFbGVtZW50ID0gc3R5bGVFbGVtZW50c1tjb250YWluZXJJZF1bcG9zaXRpb25dO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlRWxlbWVudCA9IHN0eWxlRWxlbWVudHNbY29udGFpbmVySWRdW3Bvc2l0aW9uXSA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3ByZXBlbmQnKSB7XG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgY29udGFpbmVyLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdHJpcCBwb3RlbnRpYWwgVVRGLTggQk9NIGlmIGNzcyB3YXMgcmVhZCBmcm9tIGEgZmlsZVxuICAgIGlmIChjc3MuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7IGNzcyA9IGNzcy5zdWJzdHIoMSwgY3NzLmxlbmd0aCk7IH1cblxuICAgIC8vIGFjdHVhbGx5IGFkZCB0aGUgc3R5bGVzaGVldFxuICAgIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ICs9IGNzc1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlRWxlbWVudC50ZXh0Q29udGVudCArPSBjc3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlRWxlbWVudDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCgpIHtcbiAgICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgcmV0dXJuIHN0eWxlRWxlbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRDc3M7XG5tb2R1bGUuZXhwb3J0cy5pbnNlcnRDc3MgPSBpbnNlcnRDc3M7XG4iLCIvKiEgbnBtLmltL2ludGVydmFsb21ldGVyICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIGludGVydmFsb21ldGVyKGNiLCByZXF1ZXN0LCBjYW5jZWwsIHJlcXVlc3RQYXJhbWV0ZXIpIHtcblx0dmFyIHJlcXVlc3RJZDtcblx0dmFyIHByZXZpb3VzTG9vcFRpbWU7XG5cdGZ1bmN0aW9uIGxvb3Aobm93KSB7XG5cdFx0Ly8gbXVzdCBiZSByZXF1ZXN0ZWQgYmVmb3JlIGNiKCkgYmVjYXVzZSB0aGF0IG1pZ2h0IGNhbGwgLnN0b3AoKVxuXHRcdHJlcXVlc3RJZCA9IHJlcXVlc3QobG9vcCwgcmVxdWVzdFBhcmFtZXRlcik7XG5cblx0XHQvLyBjYWxsZWQgd2l0aCBcIm1zIHNpbmNlIGxhc3QgY2FsbFwiLiAwIG9uIHN0YXJ0KClcblx0XHRjYihub3cgLSAocHJldmlvdXNMb29wVGltZSB8fCBub3cpKTtcblxuXHRcdHByZXZpb3VzTG9vcFRpbWUgPSBub3c7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG5cdFx0XHRpZiAoIXJlcXVlc3RJZCkgeyAvLyBwcmV2ZW50IGRvdWJsZSBzdGFydHNcblx0XHRcdFx0bG9vcCgwKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0XHRjYW5jZWwocmVxdWVzdElkKTtcblx0XHRcdHJlcXVlc3RJZCA9IG51bGw7XG5cdFx0XHRwcmV2aW91c0xvb3BUaW1lID0gMDtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGZyYW1lSW50ZXJ2YWxvbWV0ZXIoY2IpIHtcblx0cmV0dXJuIGludGVydmFsb21ldGVyKGNiLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbEFuaW1hdGlvbkZyYW1lKTtcbn1cblxuZnVuY3Rpb24gdGltZXJJbnRlcnZhbG9tZXRlcihjYiwgZGVsYXkpIHtcblx0cmV0dXJuIGludGVydmFsb21ldGVyKGNiLCBzZXRUaW1lb3V0LCBjbGVhclRpbWVvdXQsIGRlbGF5KTtcbn1cblxuZXhwb3J0cy5pbnRlcnZhbG9tZXRlciA9IGludGVydmFsb21ldGVyO1xuZXhwb3J0cy5mcmFtZUludGVydmFsb21ldGVyID0gZnJhbWVJbnRlcnZhbG9tZXRlcjtcbmV4cG9ydHMudGltZXJJbnRlcnZhbG9tZXRlciA9IHRpbWVySW50ZXJ2YWxvbWV0ZXI7IiwiLyohIG5wbS5pbS9pcGhvbmUtaW5saW5lLXZpZGVvIDIuMi4yICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnRlcnZhbG9tZXRlciA9IHJlcXVpcmUoJ2ludGVydmFsb21ldGVyJyk7XG5cbmZ1bmN0aW9uIHByZXZlbnRFdmVudChlbGVtZW50LCBldmVudE5hbWUsIHRlc3QpIHtcblx0ZnVuY3Rpb24gaGFuZGxlcihlKSB7XG5cdFx0aWYgKCF0ZXN0IHx8IHRlc3QoZWxlbWVudCwgZXZlbnROYW1lKSkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdC8vIC8vIGNvbnNvbGUubG9nKGV2ZW50TmFtZSwgJ3ByZXZlbnRlZCBvbicsIGVsZW1lbnQpO1xuXHRcdH1cblx0fVxuXHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcblxuXHQvLyBSZXR1cm4gaGFuZGxlciB0byBhbGxvdyB0byBkaXNhYmxlIHRoZSBwcmV2ZW50aW9uLiBVc2FnZTpcblx0Ly8gY29uc3QgcHJldmVudGlvbkhhbmRsZXIgPSBwcmV2ZW50RXZlbnQoZWwsICdjbGljaycpO1xuXHQvLyBlbC5yZW1vdmVFdmVudEhhbmRsZXIoJ2NsaWNrJywgcHJldmVudGlvbkhhbmRsZXIpO1xuXHRyZXR1cm4gaGFuZGxlcjtcbn1cblxuZnVuY3Rpb24gcHJveHlQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5TmFtZSwgc291cmNlT2JqZWN0LCBjb3B5Rmlyc3QpIHtcblx0ZnVuY3Rpb24gZ2V0KCkge1xuXHRcdHJldHVybiBzb3VyY2VPYmplY3RbcHJvcGVydHlOYW1lXTtcblx0fVxuXHRmdW5jdGlvbiBzZXQodmFsdWUpIHtcblx0XHRzb3VyY2VPYmplY3RbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuXHR9XG5cblx0aWYgKGNvcHlGaXJzdCkge1xuXHRcdHNldChvYmplY3RbcHJvcGVydHlOYW1lXSk7XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHtnZXQ6IGdldCwgc2V0OiBzZXR9KTtcbn1cblxuZnVuY3Rpb24gcHJveHlFdmVudChvYmplY3QsIGV2ZW50TmFtZSwgc291cmNlT2JqZWN0KSB7XG5cdHNvdXJjZU9iamVjdC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqZWN0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KGV2ZW50TmFtZSkpOyB9KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudEFzeW5jKGVsZW1lbnQsIHR5cGUpIHtcblx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0ZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCh0eXBlKSk7XG5cdH0pO1xufVxuXG52YXIgaU9TOG9yOSA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCcgJiYgJ29iamVjdC1maXQnIGluIGRvY3VtZW50LmhlYWQuc3R5bGUgJiYgIW1hdGNoTWVkaWEoJygtd2Via2l0LXZpZGVvLXBsYXlhYmxlLWlubGluZSknKS5tYXRjaGVzO1xuXG52YXIgSUlWID0gJ2JmcmVkLWl0OmlwaG9uZS1pbmxpbmUtdmlkZW8nO1xudmFyIElJVkV2ZW50ID0gJ2JmcmVkLWl0OmlwaG9uZS1pbmxpbmUtdmlkZW86ZXZlbnQnO1xudmFyIElJVlBsYXkgPSAnYmZyZWQtaXQ6aXBob25lLWlubGluZS12aWRlbzpuYXRpdmVwbGF5JztcbnZhciBJSVZQYXVzZSA9ICdiZnJlZC1pdDppcGhvbmUtaW5saW5lLXZpZGVvOm5hdGl2ZXBhdXNlJztcblxuLyoqXG4gKiBVVElMU1xuICovXG5cbmZ1bmN0aW9uIGdldEF1ZGlvRnJvbVZpZGVvKHZpZGVvKSB7XG5cdHZhciBhdWRpbyA9IG5ldyBBdWRpbygpO1xuXHRwcm94eUV2ZW50KHZpZGVvLCAncGxheScsIGF1ZGlvKTtcblx0cHJveHlFdmVudCh2aWRlbywgJ3BsYXlpbmcnLCBhdWRpbyk7XG5cdHByb3h5RXZlbnQodmlkZW8sICdwYXVzZScsIGF1ZGlvKTtcblx0YXVkaW8uY3Jvc3NPcmlnaW4gPSB2aWRlby5jcm9zc09yaWdpbjtcblxuXHQvLyAnZGF0YTonIGNhdXNlcyBhdWRpby5uZXR3b3JrU3RhdGUgPiAwXG5cdC8vIHdoaWNoIHRoZW4gYWxsb3dzIHRvIGtlZXAgPGF1ZGlvPiBpbiBhIHJlc3VtYWJsZSBwbGF5aW5nIHN0YXRlXG5cdC8vIGkuZS4gb25jZSB5b3Ugc2V0IGEgcmVhbCBzcmMgaXQgd2lsbCBrZWVwIHBsYXlpbmcgaWYgaXQgd2FzIGlmIC5wbGF5KCkgd2FzIGNhbGxlZFxuXHRhdWRpby5zcmMgPSB2aWRlby5zcmMgfHwgdmlkZW8uY3VycmVudFNyYyB8fCAnZGF0YTonO1xuXG5cdC8vIC8vIGlmIChhdWRpby5zcmMgPT09ICdkYXRhOicpIHtcblx0Ly8gICBUT0RPOiB3YWl0IGZvciB2aWRlbyB0byBiZSBzZWxlY3RlZFxuXHQvLyAvLyB9XG5cdHJldHVybiBhdWRpbztcbn1cblxudmFyIGxhc3RSZXF1ZXN0cyA9IFtdO1xudmFyIHJlcXVlc3RJbmRleCA9IDA7XG52YXIgbGFzdFRpbWV1cGRhdGVFdmVudDtcblxuZnVuY3Rpb24gc2V0VGltZSh2aWRlbywgdGltZSwgcmVtZW1iZXJPbmx5KSB7XG5cdC8vIEFsbG93IG9uZSB0aW1ldXBkYXRlIGV2ZW50IGV2ZXJ5IDIwMCsgbXNcblx0aWYgKChsYXN0VGltZXVwZGF0ZUV2ZW50IHx8IDApICsgMjAwIDwgRGF0ZS5ub3coKSkge1xuXHRcdHZpZGVvW0lJVkV2ZW50XSA9IHRydWU7XG5cdFx0bGFzdFRpbWV1cGRhdGVFdmVudCA9IERhdGUubm93KCk7XG5cdH1cblx0aWYgKCFyZW1lbWJlck9ubHkpIHtcblx0XHR2aWRlby5jdXJyZW50VGltZSA9IHRpbWU7XG5cdH1cblx0bGFzdFJlcXVlc3RzWysrcmVxdWVzdEluZGV4ICUgM10gPSB0aW1lICogMTAwIHwgMCAvIDEwMDtcbn1cblxuZnVuY3Rpb24gaXNQbGF5ZXJFbmRlZChwbGF5ZXIpIHtcblx0cmV0dXJuIHBsYXllci5kcml2ZXIuY3VycmVudFRpbWUgPj0gcGxheWVyLnZpZGVvLmR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiB1cGRhdGUodGltZURpZmYpIHtcblx0dmFyIHBsYXllciA9IHRoaXM7XG5cdC8vIC8vIGNvbnNvbGUubG9nKCd1cGRhdGUnLCBwbGF5ZXIudmlkZW8ucmVhZHlTdGF0ZSwgcGxheWVyLnZpZGVvLm5ldHdvcmtTdGF0ZSwgcGxheWVyLmRyaXZlci5yZWFkeVN0YXRlLCBwbGF5ZXIuZHJpdmVyLm5ldHdvcmtTdGF0ZSwgcGxheWVyLmRyaXZlci5wYXVzZWQpO1xuXHRpZiAocGxheWVyLnZpZGVvLnJlYWR5U3RhdGUgPj0gcGxheWVyLnZpZGVvLkhBVkVfRlVUVVJFX0RBVEEpIHtcblx0XHRpZiAoIXBsYXllci5oYXNBdWRpbykge1xuXHRcdFx0cGxheWVyLmRyaXZlci5jdXJyZW50VGltZSA9IHBsYXllci52aWRlby5jdXJyZW50VGltZSArICgodGltZURpZmYgKiBwbGF5ZXIudmlkZW8ucGxheWJhY2tSYXRlKSAvIDEwMDApO1xuXHRcdFx0aWYgKHBsYXllci52aWRlby5sb29wICYmIGlzUGxheWVyRW5kZWQocGxheWVyKSkge1xuXHRcdFx0XHRwbGF5ZXIuZHJpdmVyLmN1cnJlbnRUaW1lID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0c2V0VGltZShwbGF5ZXIudmlkZW8sIHBsYXllci5kcml2ZXIuY3VycmVudFRpbWUpO1xuXHR9IGVsc2UgaWYgKHBsYXllci52aWRlby5uZXR3b3JrU3RhdGUgPT09IHBsYXllci52aWRlby5ORVRXT1JLX0lETEUgJiYgcGxheWVyLnZpZGVvLmJ1ZmZlcmVkLmxlbmd0aCA9PT0gMCkge1xuXHRcdC8vIFRoaXMgc2hvdWxkIGhhcHBlbiB3aGVuIHRoZSBzb3VyY2UgaXMgYXZhaWxhYmxlIGJ1dDpcblx0XHQvLyAtIGl0J3MgcG90ZW50aWFsbHkgcGxheWluZyAoLnBhdXNlZCA9PT0gZmFsc2UpXG5cdFx0Ly8gLSBpdCdzIG5vdCByZWFkeSB0byBwbGF5XG5cdFx0Ly8gLSBpdCdzIG5vdCBsb2FkaW5nXG5cdFx0Ly8gSWYgaXQgaGFzQXVkaW8sIHRoYXQgd2lsbCBiZSBsb2FkZWQgaW4gdGhlICdlbXB0aWVkJyBoYW5kbGVyIGJlbG93XG5cdFx0cGxheWVyLnZpZGVvLmxvYWQoKTtcblx0XHQvLyAvLyBjb25zb2xlLmxvZygnV2lsbCBsb2FkJyk7XG5cdH1cblxuXHQvLyAvLyBjb25zb2xlLmFzc2VydChwbGF5ZXIudmlkZW8uY3VycmVudFRpbWUgPT09IHBsYXllci5kcml2ZXIuY3VycmVudFRpbWUsICdWaWRlbyBub3QgdXBkYXRpbmchJyk7XG5cblx0aWYgKHBsYXllci52aWRlby5lbmRlZCkge1xuXHRcdGRlbGV0ZSBwbGF5ZXIudmlkZW9bSUlWRXZlbnRdOyAvLyBBbGxvdyB0aW1ldXBkYXRlIGV2ZW50XG5cdFx0cGxheWVyLnZpZGVvLnBhdXNlKHRydWUpO1xuXHR9XG59XG5cbi8qKlxuICogTUVUSE9EU1xuICovXG5cbmZ1bmN0aW9uIHBsYXkoKSB7XG5cdC8vIC8vIGNvbnNvbGUubG9nKCdwbGF5Jyk7XG5cdHZhciB2aWRlbyA9IHRoaXM7XG5cdHZhciBwbGF5ZXIgPSB2aWRlb1tJSVZdO1xuXG5cdC8vIElmIGl0J3MgZnVsbHNjcmVlbiwgdXNlIHRoZSBuYXRpdmUgcGxheWVyXG5cdGlmICh2aWRlby53ZWJraXREaXNwbGF5aW5nRnVsbHNjcmVlbikge1xuXHRcdHZpZGVvW0lJVlBsYXldKCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKHBsYXllci5kcml2ZXIuc3JjICE9PSAnZGF0YTonICYmIHBsYXllci5kcml2ZXIuc3JjICE9PSB2aWRlby5zcmMpIHtcblx0XHQvLyAvLyBjb25zb2xlLmxvZygnc3JjIGNoYW5nZWQgb24gcGxheScsIHZpZGVvLnNyYyk7XG5cdFx0c2V0VGltZSh2aWRlbywgMCwgdHJ1ZSk7XG5cdFx0cGxheWVyLmRyaXZlci5zcmMgPSB2aWRlby5zcmM7XG5cdH1cblxuXHRpZiAoIXZpZGVvLnBhdXNlZCkge1xuXHRcdHJldHVybjtcblx0fVxuXHRwbGF5ZXIucGF1c2VkID0gZmFsc2U7XG5cblx0aWYgKHZpZGVvLmJ1ZmZlcmVkLmxlbmd0aCA9PT0gMCkge1xuXHRcdC8vIC5sb2FkKCkgY2F1c2VzIHRoZSBlbXB0aWVkIGV2ZW50XG5cdFx0Ly8gdGhlIGFsdGVybmF0aXZlIGlzIC5wbGF5KCkrLnBhdXNlKCkgYnV0IHRoYXQgdHJpZ2dlcnMgcGxheS9wYXVzZSBldmVudHMsIGV2ZW4gd29yc2Vcblx0XHQvLyBwb3NzaWJseSB0aGUgYWx0ZXJuYXRpdmUgaXMgcHJldmVudGluZyB0aGlzIGV2ZW50IG9ubHkgb25jZVxuXHRcdHZpZGVvLmxvYWQoKTtcblx0fVxuXG5cdHBsYXllci5kcml2ZXIucGxheSgpO1xuXHRwbGF5ZXIudXBkYXRlci5zdGFydCgpO1xuXG5cdGlmICghcGxheWVyLmhhc0F1ZGlvKSB7XG5cdFx0ZGlzcGF0Y2hFdmVudEFzeW5jKHZpZGVvLCAncGxheScpO1xuXHRcdGlmIChwbGF5ZXIudmlkZW8ucmVhZHlTdGF0ZSA+PSBwbGF5ZXIudmlkZW8uSEFWRV9FTk9VR0hfREFUQSkge1xuXHRcdFx0Ly8gLy8gY29uc29sZS5sb2coJ29ucGxheScpO1xuXHRcdFx0ZGlzcGF0Y2hFdmVudEFzeW5jKHZpZGVvLCAncGxheWluZycpO1xuXHRcdH1cblx0fVxufVxuZnVuY3Rpb24gcGF1c2UoZm9yY2VFdmVudHMpIHtcblx0Ly8gLy8gY29uc29sZS5sb2coJ3BhdXNlJyk7XG5cdHZhciB2aWRlbyA9IHRoaXM7XG5cdHZhciBwbGF5ZXIgPSB2aWRlb1tJSVZdO1xuXG5cdHBsYXllci5kcml2ZXIucGF1c2UoKTtcblx0cGxheWVyLnVwZGF0ZXIuc3RvcCgpO1xuXG5cdC8vIElmIGl0J3MgZnVsbHNjcmVlbiwgdGhlIGRldmVsb3BlciB0aGUgbmF0aXZlIHBsYXllci5wYXVzZSgpXG5cdC8vIFRoaXMgaXMgYXQgdGhlIGVuZCBvZiBwYXVzZSgpIGJlY2F1c2UgaXQgYWxzb1xuXHQvLyBuZWVkcyB0byBtYWtlIHN1cmUgdGhhdCB0aGUgc2ltdWxhdGlvbiBpcyBwYXVzZWRcblx0aWYgKHZpZGVvLndlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuKSB7XG5cdFx0dmlkZW9bSUlWUGF1c2VdKCk7XG5cdH1cblxuXHRpZiAocGxheWVyLnBhdXNlZCAmJiAhZm9yY2VFdmVudHMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRwbGF5ZXIucGF1c2VkID0gdHJ1ZTtcblx0aWYgKCFwbGF5ZXIuaGFzQXVkaW8pIHtcblx0XHRkaXNwYXRjaEV2ZW50QXN5bmModmlkZW8sICdwYXVzZScpO1xuXHR9XG5cblx0Ly8gSGFuZGxlIHRoZSAnZW5kZWQnIGV2ZW50IG9ubHkgaWYgaXQncyBub3QgZnVsbHNjcmVlblxuXHRpZiAodmlkZW8uZW5kZWQgJiYgIXZpZGVvLndlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuKSB7XG5cdFx0dmlkZW9bSUlWRXZlbnRdID0gdHJ1ZTtcblx0XHRkaXNwYXRjaEV2ZW50QXN5bmModmlkZW8sICdlbmRlZCcpO1xuXHR9XG59XG5cbi8qKlxuICogU0VUVVBcbiAqL1xuXG5mdW5jdGlvbiBhZGRQbGF5ZXIodmlkZW8sIGhhc0F1ZGlvKSB7XG5cdHZhciBwbGF5ZXIgPSB7fTtcblx0dmlkZW9bSUlWXSA9IHBsYXllcjtcblx0cGxheWVyLnBhdXNlZCA9IHRydWU7IC8vIFRyYWNrIHdoZXRoZXIgJ3BhdXNlJyBldmVudHMgaGF2ZSBiZWVuIGZpcmVkXG5cdHBsYXllci5oYXNBdWRpbyA9IGhhc0F1ZGlvO1xuXHRwbGF5ZXIudmlkZW8gPSB2aWRlbztcblx0cGxheWVyLnVwZGF0ZXIgPSBpbnRlcnZhbG9tZXRlci5mcmFtZUludGVydmFsb21ldGVyKHVwZGF0ZS5iaW5kKHBsYXllcikpO1xuXG5cdGlmIChoYXNBdWRpbykge1xuXHRcdHBsYXllci5kcml2ZXIgPSBnZXRBdWRpb0Zyb21WaWRlbyh2aWRlbyk7XG5cdH0gZWxzZSB7XG5cdFx0dmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghdmlkZW8ucGF1c2VkKSB7XG5cdFx0XHRcdC8vIC8vIGNvbnNvbGUubG9nKCdvbmNhbnBsYXknKTtcblx0XHRcdFx0ZGlzcGF0Y2hFdmVudEFzeW5jKHZpZGVvLCAncGxheWluZycpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHBsYXllci5kcml2ZXIgPSB7XG5cdFx0XHRzcmM6IHZpZGVvLnNyYyB8fCB2aWRlby5jdXJyZW50U3JjIHx8ICdkYXRhOicsXG5cdFx0XHRtdXRlZDogdHJ1ZSxcblx0XHRcdHBhdXNlZDogdHJ1ZSxcblx0XHRcdHBhdXNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHBsYXllci5kcml2ZXIucGF1c2VkID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRwbGF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHBsYXllci5kcml2ZXIucGF1c2VkID0gZmFsc2U7XG5cdFx0XHRcdC8vIE1lZGlhIGF1dG9tYXRpY2FsbHkgZ29lcyB0byAwIGlmIC5wbGF5KCkgaXMgY2FsbGVkIHdoZW4gaXQncyBkb25lXG5cdFx0XHRcdGlmIChpc1BsYXllckVuZGVkKHBsYXllcikpIHtcblx0XHRcdFx0XHRzZXRUaW1lKHZpZGVvLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGdldCBlbmRlZCgpIHtcblx0XHRcdFx0cmV0dXJuIGlzUGxheWVyRW5kZWQocGxheWVyKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gLmxvYWQoKSBjYXVzZXMgdGhlIGVtcHRpZWQgZXZlbnRcblx0dmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignZW1wdGllZCcsIGZ1bmN0aW9uICgpIHtcblx0XHQvLyAvLyBjb25zb2xlLmxvZygnZHJpdmVyIHNyYyBpcycsIHBsYXllci5kcml2ZXIuc3JjKTtcblx0XHR2YXIgd2FzRW1wdHkgPSAhcGxheWVyLmRyaXZlci5zcmMgfHwgcGxheWVyLmRyaXZlci5zcmMgPT09ICdkYXRhOic7XG5cdFx0aWYgKHBsYXllci5kcml2ZXIuc3JjICYmIHBsYXllci5kcml2ZXIuc3JjICE9PSB2aWRlby5zcmMpIHtcblx0XHRcdC8vIC8vIGNvbnNvbGUubG9nKCdzcmMgY2hhbmdlZCB0bycsIHZpZGVvLnNyYyk7XG5cdFx0XHRzZXRUaW1lKHZpZGVvLCAwLCB0cnVlKTtcblx0XHRcdHBsYXllci5kcml2ZXIuc3JjID0gdmlkZW8uc3JjO1xuXHRcdFx0Ly8gUGxheWluZyB2aWRlb3Mgd2lsbCBvbmx5IGtlZXAgcGxheWluZyBpZiBubyBzcmMgd2FzIHByZXNlbnQgd2hlbiAucGxheSgp4oCZZWRcblx0XHRcdGlmICh3YXNFbXB0eSB8fCAoIWhhc0F1ZGlvICYmIHZpZGVvLmF1dG9wbGF5KSkge1xuXHRcdFx0XHRwbGF5ZXIuZHJpdmVyLnBsYXkoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBsYXllci51cGRhdGVyLnN0b3AoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sIGZhbHNlKTtcblxuXHQvLyBTdG9wIHByb2dyYW1tYXRpYyBwbGF5ZXIgd2hlbiBPUyB0YWtlcyBvdmVyXG5cdHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGJlZ2luZnVsbHNjcmVlbicsIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXZpZGVvLnBhdXNlZCkge1xuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIDxhdWRpbz4gYW5kIHRoZSBzeW5jZXIvdXBkYXRlciBhcmUgc3RvcHBlZFxuXHRcdFx0dmlkZW8ucGF1c2UoKTtcblxuXHRcdFx0Ly8gUGxheSB2aWRlbyBuYXRpdmVseVxuXHRcdFx0dmlkZW9bSUlWUGxheV0oKTtcblx0XHR9IGVsc2UgaWYgKGhhc0F1ZGlvICYmIHBsYXllci5kcml2ZXIuYnVmZmVyZWQubGVuZ3RoID09PSAwKSB7XG5cdFx0XHQvLyBJZiB0aGUgZmlyc3QgcGxheSBpcyBuYXRpdmUsXG5cdFx0XHQvLyB0aGUgPGF1ZGlvPiBuZWVkcyB0byBiZSBidWZmZXJlZCBtYW51YWxseVxuXHRcdFx0Ly8gc28gd2hlbiB0aGUgZnVsbHNjcmVlbiBlbmRzLCBpdCBjYW4gYmUgc2V0IHRvIHRoZSBzYW1lIGN1cnJlbnQgdGltZVxuXHRcdFx0cGxheWVyLmRyaXZlci5sb2FkKCk7XG5cdFx0fVxuXHR9KTtcblx0aWYgKGhhc0F1ZGlvKSB7XG5cdFx0dmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0ZW5kZnVsbHNjcmVlbicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFN5bmMgYXVkaW8gdG8gbmV3IHZpZGVvIHBvc2l0aW9uXG5cdFx0XHRwbGF5ZXIuZHJpdmVyLmN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG5cdFx0XHQvLyAvLyBjb25zb2xlLmFzc2VydChwbGF5ZXIuZHJpdmVyLmN1cnJlbnRUaW1lID09PSB2aWRlby5jdXJyZW50VGltZSwgJ0F1ZGlvIG5vdCBzeW5jZWQnKTtcblx0XHR9KTtcblxuXHRcdC8vIEFsbG93IHNlZWtpbmdcblx0XHR2aWRlby5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGxhc3RSZXF1ZXN0cy5pbmRleE9mKHZpZGVvLmN1cnJlbnRUaW1lICogMTAwIHwgMCAvIDEwMCkgPCAwKSB7XG5cdFx0XHRcdC8vIC8vIGNvbnNvbGUubG9nKCdVc2VyLXJlcXVlc3RlZCBzZWVraW5nJyk7XG5cdFx0XHRcdHBsYXllci5kcml2ZXIuY3VycmVudFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuXG5mdW5jdGlvbiBwcmV2ZW50V2l0aFByb3BPckZ1bGxzY3JlZW4oZWwpIHtcblx0dmFyIGlzQWxsb3dlZCA9IGVsW0lJVkV2ZW50XTtcblx0ZGVsZXRlIGVsW0lJVkV2ZW50XTtcblx0cmV0dXJuICFlbC53ZWJraXREaXNwbGF5aW5nRnVsbHNjcmVlbiAmJiAhaXNBbGxvd2VkO1xufVxuXG5mdW5jdGlvbiBvdmVybG9hZEFQSSh2aWRlbykge1xuXHR2YXIgcGxheWVyID0gdmlkZW9bSUlWXTtcblx0dmlkZW9bSUlWUGxheV0gPSB2aWRlby5wbGF5O1xuXHR2aWRlb1tJSVZQYXVzZV0gPSB2aWRlby5wYXVzZTtcblx0dmlkZW8ucGxheSA9IHBsYXk7XG5cdHZpZGVvLnBhdXNlID0gcGF1c2U7XG5cdHByb3h5UHJvcGVydHkodmlkZW8sICdwYXVzZWQnLCBwbGF5ZXIuZHJpdmVyKTtcblx0cHJveHlQcm9wZXJ0eSh2aWRlbywgJ211dGVkJywgcGxheWVyLmRyaXZlciwgdHJ1ZSk7XG5cdHByb3h5UHJvcGVydHkodmlkZW8sICdwbGF5YmFja1JhdGUnLCBwbGF5ZXIuZHJpdmVyLCB0cnVlKTtcblx0cHJveHlQcm9wZXJ0eSh2aWRlbywgJ2VuZGVkJywgcGxheWVyLmRyaXZlcik7XG5cdHByb3h5UHJvcGVydHkodmlkZW8sICdsb29wJywgcGxheWVyLmRyaXZlciwgdHJ1ZSk7XG5cblx0Ly8gSUlWIHdvcmtzIGJ5IHNlZWtpbmcgNjAgdGltZXMgcGVyIHNlY29uZC5cblx0Ly8gVGhlc2UgZXZlbnRzIGFyZSBub3cgdXNlbGVzcy5cblx0cHJldmVudEV2ZW50KHZpZGVvLCAnc2Vla2luZycsIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gIWVsLndlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuOyB9KTtcblx0cHJldmVudEV2ZW50KHZpZGVvLCAnc2Vla2VkJywgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhZWwud2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW47IH0pO1xuXG5cdC8vIExpbWl0IHRpbWV1cGRhdGUgZXZlbnRzXG5cdHByZXZlbnRFdmVudCh2aWRlbywgJ3RpbWV1cGRhdGUnLCBwcmV2ZW50V2l0aFByb3BPckZ1bGxzY3JlZW4pO1xuXG5cdC8vIFByZXZlbnQgb2NjYXNpb25hbCBuYXRpdmUgZW5kZWQgZXZlbnRzXG5cdHByZXZlbnRFdmVudCh2aWRlbywgJ2VuZGVkJywgcHJldmVudFdpdGhQcm9wT3JGdWxsc2NyZWVuKTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlSW5saW5lVmlkZW8odmlkZW8sIG9wdHMpIHtcblx0aWYgKCBvcHRzID09PSB2b2lkIDAgKSBvcHRzID0ge307XG5cblx0Ly8gU3RvcCBpZiBhbHJlYWR5IGVuYWJsZWRcblx0aWYgKHZpZGVvW0lJVl0pIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBBbGxvdyB0aGUgdXNlciB0byBza2lwIGRldGVjdGlvblxuXHRpZiAoIW9wdHMuZXZlcnl3aGVyZSkge1xuXHRcdC8vIE9ubHkgaU9TOCBhbmQgOSBhcmUgc3VwcG9ydGVkXG5cdFx0aWYgKCFpT1M4b3I5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcCBpZiBpdCdzIG5vdCBhbiBhbGxvd2VkIGRldmljZVxuXHRcdGlmICghKG9wdHMuaVBhZCB8fCBvcHRzLmlwYWQgPyAvaVBob25lfGlQb2R8aVBhZC8gOiAvaVBob25lfGlQb2QvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0Ly8gVHJ5IHRvIHBhdXNlXG5cdHZpZGVvLnBhdXNlKCk7XG5cblx0Ly8gUHJldmVudCBhdXRvcGxheS5cblx0Ly8gQW4gbm9uLXN0YXJ0ZWQgYXV0b3BsYXlpbmcgdmlkZW8gY2FuJ3QgYmUgLnBhdXNlKCknZFxuXHR2YXIgd2lsbEF1dG9wbGF5ID0gdmlkZW8uYXV0b3BsYXk7XG5cdHZpZGVvLmF1dG9wbGF5ID0gZmFsc2U7XG5cblx0YWRkUGxheWVyKHZpZGVvLCAhdmlkZW8ubXV0ZWQpO1xuXHRvdmVybG9hZEFQSSh2aWRlbyk7XG5cdHZpZGVvLmNsYXNzTGlzdC5hZGQoJ0lJVicpO1xuXG5cdC8vIEF1dG9wbGF5XG5cdGlmICh2aWRlby5tdXRlZCAmJiB3aWxsQXV0b3BsYXkpIHtcblx0XHR2aWRlby5wbGF5KCk7XG5cdFx0dmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIGZ1bmN0aW9uIHJlc3RvcmVBdXRvcGxheSgpIHtcblx0XHRcdHZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcblx0XHRcdHZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCByZXN0b3JlQXV0b3BsYXkpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCEvaVBob25lfGlQb2R8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pKSB7XG5cdFx0Y29uc29sZS53YXJuKCdpcGhvbmUtaW5saW5lLXZpZGVvIGlzIG5vdCBndWFyYW50ZWVkIHRvIHdvcmsgaW4gZW11bGF0ZWQgZW52aXJvbm1lbnRzJyk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbmFibGVJbmxpbmVWaWRlbztcbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG51bWJlcklzTmFuID0gcmVxdWlyZSgnbnVtYmVyLWlzLW5hbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsKSB7XG5cdHJldHVybiAhKHR5cGVvZiB2YWwgIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFuKHZhbCkgfHwgdmFsID09PSBJbmZpbml0eSB8fCB2YWwgPT09IC1JbmZpbml0eSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBpc1Bvd2VyT2ZUd29cblxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKG4pIHtcbiAgcmV0dXJuIG4gIT09IDAgJiYgKG4gJiAobiAtIDEpKSA9PT0gMFxufSIsIm1vZHVsZS5leHBvcnRzICAgICAgPSBpc1R5cGVkQXJyYXlcbmlzVHlwZWRBcnJheS5zdHJpY3QgPSBpc1N0cmljdFR5cGVkQXJyYXlcbmlzVHlwZWRBcnJheS5sb29zZSAgPSBpc0xvb3NlVHlwZWRBcnJheVxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgbmFtZXMgPSB7XG4gICAgJ1tvYmplY3QgSW50OEFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBJbnQxNkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBJbnQzMkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50OEFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDE2QXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQzMkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBGbG9hdDMyQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOiB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheShhcnIpIHtcbiAgcmV0dXJuIChcbiAgICAgICBpc1N0cmljdFR5cGVkQXJyYXkoYXJyKVxuICAgIHx8IGlzTG9vc2VUeXBlZEFycmF5KGFycilcbiAgKVxufVxuXG5mdW5jdGlvbiBpc1N0cmljdFR5cGVkQXJyYXkoYXJyKSB7XG4gIHJldHVybiAoXG4gICAgICAgYXJyIGluc3RhbmNlb2YgSW50OEFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgSW50MTZBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEludDMyQXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50MTZBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQzMkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5XG4gIClcbn1cblxuZnVuY3Rpb24gaXNMb29zZVR5cGVkQXJyYXkoYXJyKSB7XG4gIHJldHVybiBuYW1lc1t0b1N0cmluZy5jYWxsKGFycildXG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBlbnVtZXJhdGlvbiB3aXRoIGtleXMgZXF1YWwgdG8gdGhlaXIgdmFsdWUuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICB2YXIgQ09MT1JTID0ga2V5TWlycm9yKHtibHVlOiBudWxsLCByZWQ6IG51bGx9KTtcbiAqICAgdmFyIG15Q29sb3IgPSBDT0xPUlMuYmx1ZTtcbiAqICAgdmFyIGlzQ29sb3JWYWxpZCA9ICEhQ09MT1JTW215Q29sb3JdO1xuICpcbiAqIFRoZSBsYXN0IGxpbmUgY291bGQgbm90IGJlIHBlcmZvcm1lZCBpZiB0aGUgdmFsdWVzIG9mIHRoZSBnZW5lcmF0ZWQgZW51bSB3ZXJlXG4gKiBub3QgZXF1YWwgdG8gdGhlaXIga2V5cy5cbiAqXG4gKiAgIElucHV0OiAge2tleTE6IHZhbDEsIGtleTI6IHZhbDJ9XG4gKiAgIE91dHB1dDoge2tleTE6IGtleTEsIGtleTI6IGtleTJ9XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG52YXIga2V5TWlycm9yID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICFBcnJheS5pc0FycmF5KG9iaikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdrZXlNaXJyb3IoLi4uKTogQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldFtrZXldID0ga2V5O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBudW1iZXJJc0Zpbml0ZSA9IHJlcXVpcmUoJ2lzLWZpbml0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24gKHgpIHtcblx0cmV0dXJuIG51bWJlcklzRmluaXRlKHgpICYmIE1hdGguZmxvb3IoeCkgPT09IHg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gKHgpIHtcblx0cmV0dXJuIHggIT09IHg7XG59O1xuIiwidmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKVxubW9kdWxlLmV4cG9ydHMuc3RyaWN0ID0gd3JhcHB5KG9uY2VTdHJpY3QpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZVN0cmljdCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2VTdHJpY3QodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gb25jZVN0cmljdCAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGYub25jZUVycm9yKVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCdcbiAgZi5vbmNlRXJyb3IgPSBuYW1lICsgXCIgc2hvdWxkbid0IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVwiXG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi4yXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBnZXROYW5vU2Vjb25kcywgaHJ0aW1lLCBsb2FkVGltZSwgbW9kdWxlTG9hZFRpbWUsIG5vZGVMb2FkVGltZSwgdXBUaW1lO1xuXG4gIGlmICgodHlwZW9mIHBlcmZvcm1hbmNlICE9PSBcInVuZGVmaW5lZFwiICYmIHBlcmZvcm1hbmNlICE9PSBudWxsKSAmJiBwZXJmb3JtYW5jZS5ub3cpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MgIT09IG51bGwpICYmIHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoZ2V0TmFub1NlY29uZHMoKSAtIG5vZGVMb2FkVGltZSkgLyAxZTY7XG4gICAgfTtcbiAgICBocnRpbWUgPSBwcm9jZXNzLmhydGltZTtcbiAgICBnZXROYW5vU2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhyO1xuICAgICAgaHIgPSBocnRpbWUoKTtcbiAgICAgIHJldHVybiBoclswXSAqIDFlOSArIGhyWzFdO1xuICAgIH07XG4gICAgbW9kdWxlTG9hZFRpbWUgPSBnZXROYW5vU2Vjb25kcygpO1xuICAgIHVwVGltZSA9IHByb2Nlc3MudXB0aW1lKCkgKiAxZTk7XG4gICAgbm9kZUxvYWRUaW1lID0gbW9kdWxlTG9hZFRpbWUgLSB1cFRpbWU7XG4gIH0gZWxzZSBpZiAoRGF0ZS5ub3cpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gRGF0ZS5ub3coKTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmZvcm1hbmNlLW5vdy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBub3cgPSByZXF1aXJlKCdwZXJmb3JtYW5jZS1ub3cnKVxuICAsIHJvb3QgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvd1xuICAsIHZlbmRvcnMgPSBbJ21veicsICd3ZWJraXQnXVxuICAsIHN1ZmZpeCA9ICdBbmltYXRpb25GcmFtZSdcbiAgLCByYWYgPSByb290WydyZXF1ZXN0JyArIHN1ZmZpeF1cbiAgLCBjYWYgPSByb290WydjYW5jZWwnICsgc3VmZml4XSB8fCByb290WydjYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cblxuZm9yKHZhciBpID0gMDsgIXJhZiAmJiBpIDwgdmVuZG9ycy5sZW5ndGg7IGkrKykge1xuICByYWYgPSByb290W3ZlbmRvcnNbaV0gKyAnUmVxdWVzdCcgKyBzdWZmaXhdXG4gIGNhZiA9IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWwnICsgc3VmZml4XVxuICAgICAgfHwgcm9vdFt2ZW5kb3JzW2ldICsgJ0NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxufVxuXG4vLyBTb21lIHZlcnNpb25zIG9mIEZGIGhhdmUgckFGIGJ1dCBub3QgY0FGXG5pZighcmFmIHx8ICFjYWYpIHtcbiAgdmFyIGxhc3QgPSAwXG4gICAgLCBpZCA9IDBcbiAgICAsIHF1ZXVlID0gW11cbiAgICAsIGZyYW1lRHVyYXRpb24gPSAxMDAwIC8gNjBcblxuICByYWYgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIF9ub3cgPSBub3coKVxuICAgICAgICAsIG5leHQgPSBNYXRoLm1heCgwLCBmcmFtZUR1cmF0aW9uIC0gKF9ub3cgLSBsYXN0KSlcbiAgICAgIGxhc3QgPSBuZXh0ICsgX25vd1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNwID0gcXVldWUuc2xpY2UoMClcbiAgICAgICAgLy8gQ2xlYXIgcXVldWUgaGVyZSB0byBwcmV2ZW50XG4gICAgICAgIC8vIGNhbGxiYWNrcyBmcm9tIGFwcGVuZGluZyBsaXN0ZW5lcnNcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgZnJhbWUncyBxdWV1ZVxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKCFjcFtpXS5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgY3BbaV0uY2FsbGJhY2sobGFzdClcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0aHJvdyBlIH0sIDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBNYXRoLnJvdW5kKG5leHQpKVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKHtcbiAgICAgIGhhbmRsZTogKytpZCxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGNhbmNlbGxlZDogZmFsc2VcbiAgICB9KVxuICAgIHJldHVybiBpZFxuICB9XG5cbiAgY2FmID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihxdWV1ZVtpXS5oYW5kbGUgPT09IGhhbmRsZSkge1xuICAgICAgICBxdWV1ZVtpXS5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4pIHtcbiAgLy8gV3JhcCBpbiBhIG5ldyBmdW5jdGlvbiB0byBwcmV2ZW50XG4gIC8vIGBjYW5jZWxgIHBvdGVudGlhbGx5IGJlaW5nIGFzc2lnbmVkXG4gIC8vIHRvIHRoZSBuYXRpdmUgckFGIGZ1bmN0aW9uXG4gIHJldHVybiByYWYuY2FsbChyb290LCBmbilcbn1cbm1vZHVsZS5leHBvcnRzLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICBjYWYuYXBwbHkocm9vdCwgYXJndW1lbnRzKVxufVxubW9kdWxlLmV4cG9ydHMucG9seWZpbGwgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICBvYmplY3QgPSByb290O1xuICB9XG4gIG9iamVjdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByYWZcbiAgb2JqZWN0LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2FmXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlYWR5c3RhdGUgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZHlzdGF0ZScpXG4gICwgd2luID0gKG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSkoKVxuICAsIGNvbXBsZXRlID0gJ2NvbXBsZXRlJ1xuICAsIHJvb3QgPSB0cnVlXG4gICwgZG9jID0gd2luID8gd2luLmRvY3VtZW50IDogbnVsbFxuICAsIGh0bWwgPSBkb2MgPyBkb2MuZG9jdW1lbnRFbGVtZW50IDogbnVsbFxuICAsIGRvY1JlYWR5U3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2MgPyBkb2MucmVhZHlTdGF0ZSA6IG51bGw7IH07XG5cbihmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAvL1xuICAvLyBCYWlsIG91dCBlYXJseSBpZiB0aGUgZG9jdW1lbnQgaXMgYWxyZWFkeSBmdWxseSBsb2FkZWQuIFRoaXMgbWVhbnMgdGhhdCB0aGlzXG4gIC8vIHNjcmlwdCBpcyBsb2FkZWQgYWZ0ZXIgdGhlIG9ubG9hZCBldmVudC5cbiAgLy9cblxuICBpZiAoY29tcGxldGUgPT09IGRvY1JlYWR5U3RhdGUoKSkge1xuICAgIHJldHVybiByZWFkeXN0YXRlLmNoYW5nZShjb21wbGV0ZSk7XG4gIH1cblxuICAvL1xuICAvLyBVc2UgZmVhdHVyZSBkZXRlY3Rpb24gdG8gc2VlIHdoYXQga2luZCBvZiBicm93c2VyIGVudmlyb25tZW50IHdlJ3JlIGRlYWxpbmdcbiAgLy8gd2l0aC4gT2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyIGRvIG5vdCBzdXBwb3J0IHRoZSBhZGRFdmVudExpc3RlbmVyXG4gIC8vIGludGVyZmFjZSBzbyB3ZSBjYW4gYWxzbyBzYWZlbHkgYXNzdW1lIHRoYXQgd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gcG9sbGluZy5cbiAgLy9cbiAgdmFyIG1vZGVybiA9IGRvYyAmJiAhIWRvYy5hZGRFdmVudExpc3RlbmVyXG4gICAgLCBwcmVmaXggPSBtb2Rlcm4gPyAnJyA6ICdvbidcbiAgICAsIG9uID0gbW9kZXJuID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ2F0dGFjaEV2ZW50J1xuICAgICwgb2ZmID0gbW9kZXJuID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2RldGFjaEV2ZW50J1xuICAgICwgZG9TY3JvbGwgPSBodG1sID8gaHRtbC5kb1Njcm9sbCA6IG51bGw7XG5cbiAgaWYgKCFtb2Rlcm4gJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRvU2Nyb2xsKSB7XG4gICAgdHJ5IHsgcm9vdCA9ICF3aW4uZnJhbWVFbGVtZW50OyB9XG4gICAgY2F0Y2ggKGUpIHt9XG5cbiAgICBpZiAocm9vdCkgKGZ1bmN0aW9uIHBvbGxpbmcoKSB7XG4gICAgICB0cnkgeyBkb1Njcm9sbCgnbGVmdCcpOyB9XG4gICAgICBjYXRjaCAoZSkgeyByZXR1cm4gc2V0VGltZW91dChwb2xsaW5nLCA1MCk7IH1cblxuICAgICAgcmVhZHlzdGF0ZS5jaGFuZ2UoJ2ludGVyYWN0aXZlJyk7XG4gICAgfSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIHZhcmlvdXMgb2YgZXZlbnQgbGlzdGVuZXIgY2FsbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2dCBTaW1wbGUgRE9NIGV2ZW50LlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNoYW5nZShldnQpIHtcbiAgICBldnQgPSBldnQgfHwgd2luLmV2ZW50O1xuXG4gICAgaWYgKCdyZWFkeXN0YXRlY2hhbmdlJyA9PT0gZXZ0LnR5cGUpIHtcbiAgICAgIHJlYWR5c3RhdGUuY2hhbmdlKGRvY1JlYWR5U3RhdGUoKSk7XG4gICAgICBpZiAoY29tcGxldGUgIT09IGRvY1JlYWR5U3RhdGUoKSkgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgnbG9hZCcgPT09IGV2dC50eXBlKSByZWFkeXN0YXRlLmNoYW5nZSgnY29tcGxldGUnKTtcbiAgICBlbHNlIHJlYWR5c3RhdGUuY2hhbmdlKCdpbnRlcmFjdGl2ZScpO1xuXG4gICAgLy9cbiAgICAvLyBIb3VzZSBrZWVwaW5nLCByZW1vdmUgb3VyIGFzc2lnbmVkIGV2ZW50IGxpc3RlbmVycy5cbiAgICAvL1xuICAgIChldnQudHlwZSA9PT0gJ2xvYWQnID8gd2luIDogZG9jKVtvZmZdKGV2dC50eXBlLCBjaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFzc2lnbiBhIHNoaXQgbG9hZCBvZiBldmVudCBsaXN0ZW5lcnMgc28gd2UgY2FuIHVwZGF0ZSBvdXIgaW50ZXJuYWwgc3RhdGUuXG4gIC8vXG4gIGRvY1tvbl0ocHJlZml4ICsnRE9NQ29udGVudExvYWRlZCcsIGNoYW5nZSwgZmFsc2UpO1xuICBkb2Nbb25dKHByZWZpeCArJ3JlYWR5c3RhdGVjaGFuZ2UnLCBjaGFuZ2UsIGZhbHNlKTtcbiAgd2luW29uXShwcmVmaXggKydsb2FkJywgY2hhbmdlLCBmYWxzZSk7XG59ICgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG5ldyBwcm90b3R5cGUgbWV0aG9kIHdoaWNoIHdpbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIG9uY2UgdGhlXG4gKiBkZXNpcmVkIHN0YXRlIGhhcyBiZWVuIHJlYWNoZWQuIFRoZSByZXR1cm5lZCBmdW5jdGlvbiBhY2NlcHRzIDIgYXJndW1lbnRzOlxuICpcbiAqIC0gZm46IFRoZSBhc3NpZ25lZCBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBiZSBjYWxsZWQuXG4gKiAtIGNvbnRleHQ6IENvbnRleHQvdGhpcyB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gd2UgbmVlZCB0byBleGVjdXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZSBUaGUgc3RhdGUgd2UgbmVlZCB0byBvcGVyYXRlIHVwb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGUoc3RhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb3h5KGZuLCBjb250ZXh0KSB7XG4gICAgdmFyIHJzID0gdGhpcztcblxuICAgIGlmIChycy5pcyhzdGF0ZSkpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBmbi5jYWxsKGNvbnRleHQsIHJzLnJlYWR5U3RhdGUpO1xuICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcnMuX2V2ZW50c1tzdGF0ZV0pIHJzLl9ldmVudHNbc3RhdGVdID0gW107XG4gICAgICBycy5fZXZlbnRzW3N0YXRlXS5wdXNoKHsgZm46IGZuLCBjb250ZXh0OiBjb250ZXh0IH0pO1xuICAgIH1cblxuICAgIHJldHVybiBycztcbiAgfTtcbn1cblxuLyoqXG4gKiBSUyAocmVhZHlTdGF0ZSkgaW5zdGFuY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBSUygpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gUlMuVU5LTk9XTjtcbiAgdGhpcy5fZXZlbnRzID0ge307XG59XG5cbi8qKlxuICogVGhlIGVudmlyb25tZW50IGNhbiBiZSBpbiBkaWZmZXJlbnQgc3RhdGVzLiBUaGUgZm9sbG93aW5nIHN0YXRlcyBhcmVcbiAqIGdlbmVyYXRlZDpcbiAqXG4gKiAtIEFMTDogICAgICAgICBUaGUgSSBkb24ndCByZWFsbHkgZ2l2ZSBhIGZ1Y2sgc3RhdGUuXG4gKiAtIFVOS05PV046ICAgICBXZSBnb3QgYW4gdW5rbm93biByZWFkeVN0YXRlIHdlIHNob3VsZCBzdGFydCBsaXN0ZW5pbmcgZm9yIGV2ZW50cy5cbiAqIC0gTE9BRElORzogICAgIEVudmlyb25tZW50IGlzIGN1cnJlbnRseSBsb2FkaW5nLlxuICogLSBJTlRFUkFDVElWRTogRW52aXJvbm1lbnQgaXMgcmVhZHkgZm9yIG1vZGlmaWNhdGlvbi5cbiAqIC0gQ09NUExFVEU6ICAgIEFsbCByZXNvdXJjZXMgaGF2ZSBiZWVuIGxvYWRlZC5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgYHN0YXRlc2Agc3RyaW5nL2FycmF5IGlzIG9mIHZpdGFsXG4gKiBpbXBvcnRhbmNlIGFzIGl0J3MgdXNlZCBpbiB0aGUgcmVhZHlTdGF0ZSBjaGVjay5cbiAqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuUlMuc3RhdGVzID0gJ0FMTCxVTktOT1dOLExPQURJTkcsSU5URVJBQ1RJVkUsQ09NUExFVEUnLnNwbGl0KCcsJyk7XG5cbmZvciAodmFyIHMgPSAwLCBzdGF0ZTsgcyA8IFJTLnN0YXRlcy5sZW5ndGg7IHMrKykge1xuICBzdGF0ZSA9IFJTLnN0YXRlc1tzXTtcblxuICBSU1tzdGF0ZV0gPSBSUy5wcm90b3R5cGVbc3RhdGVdID0gcztcbiAgUlMucHJvdG90eXBlW3N0YXRlLnRvTG93ZXJDYXNlKCldID0gZ2VuZXJhdGUoc3RhdGUpO1xufVxuXG4vKipcbiAqIEEgY2hhbmdlIGluIHRoZSBlbnZpcm9ubWVudCBoYXMgYmVlbiBkZXRlY3RlZCBzbyB3ZSBuZWVkIHRvIGNoYW5nZSBvdXJcbiAqIHJlYWR5U3RhdGUgYW5kIGNhbGwgYXNzaWduZWQgZXZlbnQgbGlzdGVuZXJzIGFuZCB0aG9zZSBvZiB0aGUgcHJldmlvdXNcbiAqIHN0YXRlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdGUgVGhlIG5ldyByZWFkeVN0YXRlIHRoYXQgd2UgZGV0ZWN0ZWQuXG4gKiBAcmV0dXJucyB7UlN9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUlMucHJvdG90eXBlLmNoYW5nZSA9IGZ1bmN0aW9uIGNoYW5nZShzdGF0ZSkge1xuICBzdGF0ZSA9IHRoaXMuY2xlYW4oc3RhdGUsIHRydWUpO1xuXG4gIHZhciBqXG4gICAgLCBuYW1lXG4gICAgLCBpID0gMFxuICAgICwgbGlzdGVuZXJcbiAgICAsIHJzID0gdGhpc1xuICAgICwgcHJldmlvdXNseSA9IHJzLnJlYWR5U3RhdGU7XG5cbiAgaWYgKHByZXZpb3VzbHkgPj0gc3RhdGUpIHJldHVybiBycztcblxuICBycy5yZWFkeVN0YXRlID0gc3RhdGU7XG5cbiAgZm9yICg7IGkgPCBSUy5zdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA+IHN0YXRlKSBicmVhaztcbiAgICBuYW1lID0gUlMuc3RhdGVzW2ldO1xuXG4gICAgaWYgKG5hbWUgaW4gcnMuX2V2ZW50cykge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHJzLl9ldmVudHNbbmFtZV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGlzdGVuZXIgPSBycy5fZXZlbnRzW25hbWVdW2pdO1xuICAgICAgICBsaXN0ZW5lci5mbi5jYWxsKGxpc3RlbmVyLmNvbnRleHQgfHwgcnMsIHByZXZpb3VzbHkpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgcnMuX2V2ZW50c1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIGN1cnJlbnRseSBpbiBhIGdpdmVuIHJlYWR5U3RhdGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBzdGF0ZSBUaGUgcmVxdWlyZWQgcmVhZHlTdGF0ZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJbmRpY2F0aW9uIGlmIHRoaXMgc3RhdGUgaGFzIGJlZW4gcmVhY2hlZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblJTLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uIGlzKHN0YXRlKSB7XG4gIHJldHVybiB0aGlzLnJlYWR5U3RhdGUgPj0gdGhpcy5jbGVhbihzdGF0ZSwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHN0YXRlIHRvIGEgbnVtYmVyIG9yIHRvVXBwZXJDYXNlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHN0YXRlIFN0YXRlIHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbnIgQ2hhbmdlIHRvIG51bWJlci5cbiAqIEByZXR1cm5zIHtNaXhlZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblJTLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uIHRyYW5zZm9ybShzdGF0ZSwgbnIpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3RhdGU7XG5cbiAgaWYgKG5yKSByZXR1cm4gJ251bWJlcicgIT09IHR5cGVcbiAgPyArUlNbc3RhdGUudG9VcHBlckNhc2UoKV0gfHwgMFxuICA6IHN0YXRlO1xuXG4gIHJldHVybiAoJ251bWJlcicgPT09IHR5cGUgPyBSUy5zdGF0ZXNbc3RhdGVdIDogc3RhdGUpLnRvVXBwZXJDYXNlKCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycy4gVXNlZnVsIHdoZW4geW91IHdhbnQgdG8gdW5sb2FkIHJlYWR5c3RhdGVjaGFuZ2VcbiAqIGNvbXBsZXRlbHkgc28gdGhhdCBpdCB3b24ndCByZWFjdCB0byBhbnkgZXZlbnRzIGFueW1vcmUuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3Vuc2hpZnRpby9yZWFkeXN0YXRlL2lzc3Vlcy84XG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBycyBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuUlMucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgdGhpcy5fZXZlbnRzID0ge307XG4gIHJldHVybiB0aGlzO1xufVxuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgUlMoKTtcbiIsIi8qKlxuICogcmVxdWVzdC1mcmFtZSAtIHJlcXVlc3RBbmltYXRpb25GcmFtZSAmIGNhbmNlbEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGZvciBvcHRpbWFsIGNyb3NzLWJyb3dzZXIgZGV2ZWxvcG1lbnQuXG4gKiBAdmVyc2lvbiB2MS41LjNcbiAqIEBsaWNlbnNlIE1JVFxuICogQ29weXJpZ2h0IEp1bGllbiBFdGllbm5lIDIwMTUgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsLnJlcXVlc3RGcmFtZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgLSByZXF1ZXN0IHwgY2FuY2VsIHwgbmF0aXZlLlxuICogQHJldHVybiB7RnVuY3Rpb259IFRpbWluZyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gcmVxdWVzdEZyYW1lKHR5cGUpIHtcbiAgICAvLyBUaGUgb25seSB2ZW5kb3IgcHJlZml4ZXMgcmVxdWlyZWQuXG4gICAgdmFyIHZlbmRvcnMgPSBbJ21veicsICd3ZWJraXQnXTtcblxuICAgIC8vIERpc2Fzc2VtYmxlZCB0aW1pbmcgZnVuY3Rpb24gYWJicmV2aWF0aW9ucy5cbiAgICB2YXIgYUYgPSAnQW5pbWF0aW9uRnJhbWUnO1xuICAgIHZhciBycUFGID0gJ1JlcXVlc3QnICsgYUY7XG5cbiAgICAvLyBDaGVja3MgZm9yIGZpcmVmb3ggNCAtIDEwIGZ1bmN0aW9uIHBhaXIgbWlzbWF0Y2guXG4gICAgdmFyIG1velJBRiA9IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgdmFyIG1vekNBRiA9IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZTtcbiAgICB2YXIgaGFzTW96TWlzbWF0Y2ggPSBtb3pSQUYgJiYgIW1vekNBRjtcblxuICAgIC8vIEZpbmFsIGFzc2lnbmVkIGZ1bmN0aW9ucy5cbiAgICB2YXIgYXNzaWduZWRSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgdmFyIGFzc2lnbmVkQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cbiAgICAvLyBJbml0aWFsIHRpbWUgb2YgdGhlIHRpbWluZyBsYXBzZS5cbiAgICB2YXIgcHJldmlvdXNUaW1lID0gMDtcblxuICAgIHZhciByZXF1ZXN0RnJhbWVNYWluO1xuXG4gICAgLy8gRGF0ZS5ub3cgcG9seWZpbGwsIG1haW5seSBmb3IgbGVnYWN5IElFIHZlcnNpb25zLlxuICAgIGlmICghRGF0ZS5ub3cpIHtcbiAgICAgICAgRGF0ZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFzSU9TNlJlcXVlc3RBbmltYXRpb25GcmFtZUJ1Zy5cbiAgICAgKiBAU2VlIHtATGluayBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qdWxpZW5ldGllLzg2YWMzOTRlYzQxZjEyNzFmZjBhfVxuICAgICAqIC0gZm9yIENvbW1lbnRhcnkuXG4gICAgICogQENvcHlyaWdodCAyMDE1IC0gSnVsaWVuIEV0aWVubmUuIFxuICAgICAqIEBMaWNlbnNlOiBNSVQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzSU9TNlJlcXVlc3RBbmltYXRpb25GcmFtZUJ1ZygpIHtcbiAgICAgICAgdmFyIHdlYmtpdFJBRiA9IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgICAgIHZhciByQUYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4gICAgICAgIC8vIENTUy8gRGV2aWNlIHdpdGggbWF4IGZvciBpT1M2IERldmljZXMuXG4gICAgICAgIHZhciBoYXNNb2JpbGVEZXZpY2VXaWR0aCA9IHNjcmVlbi53aWR0aCA8PSA3NjggPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgLy8gT25seSBzdXBwb3J0cyB3ZWJraXQgcHJlZml4ZWQgcmVxdWVzdEFuaW10aW9uRnJhbmUuXG4gICAgICAgIHZhciByZXF1aXJlc1dlYmtpdHByZWZpeCA9ICEod2Via2l0UkFGICYmIHJBRik7XG5cbiAgICAgICAgLy8gaU9TNiB3ZWJraXQgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBwZXJmb3JtYW5jZSBub3cuXG4gICAgICAgIHZhciBoYXNOb05hdmlnYXRpb25UaW1pbmcgPSB3aW5kb3cucGVyZm9ybWFuY2UgPyBmYWxzZSA6IHRydWU7XG5cbiAgICAgICAgdmFyIGlPUzZOb3RpY2UgPSAnc2V0VGltZW91dCBpcyBiZWluZyB1c2VkIGFzIGEgc3Vic3RpdGl1ZSBmb3IgXFxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGR1ZSB0byBhIGJ1ZyB3aXRoaW4gaU9TIDYgYnVpbGRzJztcblxuICAgICAgICB2YXIgaGFzSU9TNkJ1ZyA9IHJlcXVpcmVzV2Via2l0cHJlZml4ICYmIGhhc01vYmlsZURldmljZVdpZHRoICYmIGhhc05vTmF2aWdhdGlvblRpbWluZztcblxuICAgICAgICB2YXIgYnVnQ2hlY2tyZXN1bHRzID0gZnVuY3Rpb24gYnVnQ2hlY2tyZXN1bHRzKHRpbWluZ0ZuQSwgdGltaW5nRm5CLCBub3RpY2UpIHtcbiAgICAgICAgICAgIGlmICh0aW1pbmdGbkEgfHwgdGltaW5nRm5CKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG5vdGljZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGlzcGxheVJlc3VsdHMgPSBmdW5jdGlvbiBkaXNwbGF5UmVzdWx0cyhoYXNCdWcsIGhhc0J1Z05vdGljZSwgd2Via2l0Rm4sIG5hdGl2ZUZuKSB7XG4gICAgICAgICAgICBpZiAoaGFzQnVnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1Z0NoZWNrcmVzdWx0cyh3ZWJraXRGbiwgbmF0aXZlRm4sIGhhc0J1Z05vdGljZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZGlzcGxheVJlc3VsdHMoaGFzSU9TNkJ1ZywgaU9TNk5vdGljZSwgd2Via2l0UkFGLCByQUYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5hdGl2ZSBjbGVhclRpbWVvdXQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xlYXJUaW1lb3V0V2l0aElkKGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gYSBwb2x5ZmlsbCBieSBFcmlrLCBpbnRyb2R1Y2VkIGJ5IFBhdWwgSXJpc2ggJiBcbiAgICAgKiBmdXJ0aGVyIGltcHJvdmVkIGJ5IERhcml1cyBCYWNvbi5cbiAgICAgKiBAc2VlICB7QGxpbmsgaHR0cDovL3d3dy5wYXVsaXJpc2guY29tLzIwMTEvXG4gICAgICogcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmd9XG4gICAgICogQHNlZSAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJpdXMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lL2Jsb2IvXG4gICAgICogbWFzdGVyL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qc31cbiAgICAgKiBAY2FsbGJhY2sge051bWJlcn0gVGltZXN0YW1wLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBzZXRUaW1lb3V0IEZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFRpbWVvdXRXaXRoVGltZXN0YW1wKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpbW1lZGlhdGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGxhcHNlZFRpbWUgPSBNYXRoLm1heChwcmV2aW91c1RpbWUgKyAxNiwgaW1tZWRpYXRlVGltZSk7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHByZXZpb3VzVGltZSA9IGxhcHNlZFRpbWUpO1xuICAgICAgICB9LCBsYXBzZWRUaW1lIC0gaW1tZWRpYXRlVGltZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVlcmllcyB0aGUgbmF0aXZlIGZ1bmN0aW9uLCBwcmVmaXhlZCBmdW5jdGlvbiBcbiAgICAgKiBvciB1c2UgdGhlIHNldFRpbWVvdXRXaXRoVGltZXN0YW1wIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1ZXJ5UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkge1xuICAgICAgICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbHRlcikge1xuICAgICAgICAgICAgYXNzaWduZWRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbJ3JlcXVlc3QnICsgYUZdIHx8IHdpbmRvd1t2ZW5kb3JzLmZpbHRlcihmdW5jdGlvbiAodmVuZG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvd1t2ZW5kb3IgKyBycUFGXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdmVuZG9yO1xuICAgICAgICAgICAgfSkgKyBycUFGXSB8fCBzZXRUaW1lb3V0V2l0aFRpbWVzdGFtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0V2l0aFRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0lPUzZSZXF1ZXN0QW5pbWF0aW9uRnJhbWVCdWcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFzc2lnbmVkUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXRXaXRoVGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVlcmllcyB0aGUgbmF0aXZlIGZ1bmN0aW9uLCBwcmVmaXhlZCBmdW5jdGlvbiBcbiAgICAgKiBvciB1c2UgdGhlIGNsZWFyVGltZW91dFdpdGhJZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWVyeUNhbmNlbEFuaW1hdGlvbkZyYW1lKCkge1xuICAgICAgICB2YXIgY2FuY2VsbGF0aW9uTmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LnByb3RvdHlwZS5tYXApIHtcbiAgICAgICAgICAgIHZlbmRvcnMubWFwKGZ1bmN0aW9uICh2ZW5kb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydDYW5jZWwnLCAnQ2FuY2VsUmVxdWVzdCddLm1hcChmdW5jdGlvbiAoY2FuY2VsbGF0aW9uTmFtZVByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25OYW1lcy5wdXNoKHZlbmRvciArIGNhbmNlbGxhdGlvbk5hbWVQcmVmaXggKyBhRik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXRXaXRoSWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGZvciB0aGUgcHJlZml4ZWQgY2FuY2VsQW5pbWF0aW9uRnJhbWUgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAqIEBwYXJhbSAge0FycmF5fSBwcmVmaXhlZE5hbWVzIC0gQW4gYXJyYXkgb2YgdGhlIHByZWZpeGVkIG5hbWVzLiBcbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBpIC0gSXRlcmF0aW9uIHN0YXJ0IHBvaW50LlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJlZml4ZWQgY2FuY2VsQW5pbWF0aW9uRnJhbWUgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBwcmVmaXhlZENhbmNlbEFuaW1hdGlvbkZyYW1lKHByZWZpeGVkTmFtZXMsIGkpIHtcbiAgICAgICAgICAgIHZhciBjYW5jZWxsYXRpb25GdW5jdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcHJlZml4ZWROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3dbcHJlZml4ZWROYW1lc1tpXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uRnVuY3Rpb24gPSB3aW5kb3dbcHJlZml4ZWROYW1lc1tpXV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW5jZWxsYXRpb25GdW5jdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSB0cnV0aGx5IGZ1bmN0aW9uXG4gICAgICAgIGFzc2lnbmVkQ2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbJ2NhbmNlbCcgKyBhRl0gfHwgcHJlZml4ZWRDYW5jZWxBbmltYXRpb25GcmFtZShjYW5jZWxsYXRpb25OYW1lcywgMCkgfHwgY2xlYXJUaW1lb3V0V2l0aElkO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBpT1MgNiBidWdcbiAgICAgICAgaWYgKCFoYXNJT1M2UmVxdWVzdEFuaW1hdGlvbkZyYW1lQnVnKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3NpZ25lZENhbmNlbEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dFdpdGhJZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlcXVlc3RGbigpIHtcbiAgICAgICAgaWYgKGhhc01vek1pc21hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dFdpdGhUaW1lc3RhbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnlSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENhbmNlbEZuKCkge1xuICAgICAgICByZXR1cm4gcXVlcnlDYW5jZWxBbmltYXRpb25GcmFtZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE5hdGl2ZUZuKCkge1xuICAgICAgICBpZiAoaGFzTW96TWlzbWF0Y2gpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBzZXRUaW1lb3V0V2l0aFRpbWVzdGFtcDtcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNsZWFyVGltZW91dFdpdGhJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBxdWVyeVJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gcXVlcnlDYW5jZWxBbmltYXRpb25GcmFtZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgdmFsdWUgXCJyZXF1ZXN0XCIgc2luZ2xlcyBvdXQgZmlyZWZveCA0IC0gMTAgYW5kIFxuICAgICAqIGFzc2lnbnMgdGhlIHNldFRpbWVvdXQgZnVuY3Rpb24gaWYgcGxhdXNpYmxlLlxuICAgICAqL1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3JlcXVlc3QnOlxuICAgICAgICBjYXNlICcnOlxuICAgICAgICAgICAgcmVxdWVzdEZyYW1lTWFpbiA9IGdldFJlcXVlc3RGbigpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2FuY2VsJzpcbiAgICAgICAgICAgIHJlcXVlc3RGcmFtZU1haW4gPSBnZXRDYW5jZWxGbigpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbmF0aXZlJzpcbiAgICAgICAgICAgIHNldE5hdGl2ZUZuKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdEZyYW1lIHBhcmFtZXRlciBpcyBub3QgYSB0eXBlLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdEZyYW1lTWFpbjtcbn1cblxucmV0dXJuIHJlcXVlc3RGcmFtZTtcblxufSkpKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCJ2YXIgaGFzUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHRocm93c01lc3NhZ2UoZXJyKSB7XG5cdHJldHVybiAnW1Rocm93czogJyArIChlcnIgPyBlcnIubWVzc2FnZSA6ICc/JykgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHNhZmVHZXRWYWx1ZUZyb21Qcm9wZXJ0eU9uT2JqZWN0KG9iaiwgcHJvcGVydHkpIHtcblx0aWYgKGhhc1Byb3AuY2FsbChvYmosIHByb3BlcnR5KSkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gb2JqW3Byb3BlcnR5XTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0cmV0dXJuIHRocm93c01lc3NhZ2UoZXJyKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb2JqW3Byb3BlcnR5XTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlUHJvcGVydGllcyhvYmopIHtcblx0dmFyIHNlZW4gPSBbIF07IC8vIHN0b3JlIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyB3ZSBoYXZlIHNlZW4gYmVmb3JlXG5cblx0ZnVuY3Rpb24gdmlzaXQob2JqKSB7XG5cdFx0aWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9XG5cblx0XHRpZiAoc2Vlbi5pbmRleE9mKG9iaikgIT09IC0xKSB7XG5cdFx0XHRyZXR1cm4gJ1tDaXJjdWxhcl0nO1xuXHRcdH1cblx0XHRzZWVuLnB1c2gob2JqKTtcblxuXHRcdGlmICh0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIGZSZXN1bHQgPSB2aXNpdChvYmoudG9KU09OKCkpO1xuXHRcdFx0XHRzZWVuLnBvcCgpO1xuXHRcdFx0XHRyZXR1cm4gZlJlc3VsdDtcblx0XHRcdH0gY2F0Y2goZXJyKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd3NNZXNzYWdlKGVycik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuXHRcdFx0dmFyIGFSZXN1bHQgPSBvYmoubWFwKHZpc2l0KTtcblx0XHRcdHNlZW4ucG9wKCk7XG5cdFx0XHRyZXR1cm4gYVJlc3VsdDtcblx0XHR9XG5cblx0XHR2YXIgcmVzdWx0ID0gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24ocmVzdWx0LCBwcm9wKSB7XG5cdFx0XHQvLyBwcmV2ZW50IGZhdWx0eSBkZWZpbmVkIGdldHRlciBwcm9wZXJ0aWVzXG5cdFx0XHRyZXN1bHRbcHJvcF0gPSB2aXNpdChzYWZlR2V0VmFsdWVGcm9tUHJvcGVydHlPbk9iamVjdChvYmosIHByb3ApKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSwge30pO1xuXHRcdHNlZW4ucG9wKCk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRyZXR1cm4gdmlzaXQob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCByZXBsYWNlciwgc3BhY2UpIHtcblx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGVuc3VyZVByb3BlcnRpZXMoZGF0YSksIHJlcGxhY2VyLCBzcGFjZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmVuc3VyZVByb3BlcnRpZXMgPSBlbnN1cmVQcm9wZXJ0aWVzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBzaGlmdFxuXG5mdW5jdGlvbiBzaGlmdCAoc3RyZWFtKSB7XG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBpZiAoIXJzKSByZXR1cm4gbnVsbFxuICByZXR1cm4gcnMub2JqZWN0TW9kZSA/IHN0cmVhbS5yZWFkKCkgOiBzdHJlYW0ucmVhZChnZXRTdGF0ZUxlbmd0aChycykpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlTGVuZ3RoIChzdGF0ZSkge1xuICBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgIC8vIFNpbmNlIG5vZGUgNi4zLjAgc3RhdGUuYnVmZmVyIGlzIGEgQnVmZmVyTGlzdCBub3QgYW4gYXJyYXlcbiAgICBpZiAoc3RhdGUuYnVmZmVyLmhlYWQpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aFxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IH1cblxuZnVuY3Rpb24gQWdlbnQoKSB7XG4gIHRoaXMuX2RlZmF1bHRzID0gW107XG59XG5cblsndXNlJywgJ29uJywgJ29uY2UnLCAnc2V0JywgJ3F1ZXJ5JywgJ3R5cGUnLCAnYWNjZXB0JywgJ2F1dGgnLCAnd2l0aENyZWRlbnRpYWxzJywgJ3NvcnRRdWVyeScsICdyZXRyeScsICdvaycsICdyZWRpcmVjdHMnLCAndGltZW91dCcsICdidWZmZXInLCAnc2VyaWFsaXplJywgJ3BhcnNlJywgJ2NhJywgJ2tleScsICdwZngnLCAnY2VydCddLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gIC8vIERlZmF1bHQgc2V0dGluZyBmb3IgYWxsIHJlcXVlc3RzIGZyb20gdGhpcyBhZ2VudFxuICBBZ2VudC5wcm90b3R5cGVbZm5dID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZhdWx0cy5wdXNoKHtcbiAgICAgIGZuOiBmbixcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbkFnZW50LnByb3RvdHlwZS5fc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAocmVxKSB7XG4gIHRoaXMuX2RlZmF1bHRzLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xuICAgIHJlcVtkZWYuZm5dLmFwcGx5KHJlcSwgX3RvQ29uc3VtYWJsZUFycmF5KGRlZi5hcmdzKSk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBSb290IHJlZmVyZW5jZSBmb3IgaWZyYW1lcy5cbiAqL1xudmFyIHJvb3Q7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBCcm93c2VyIHdpbmRvd1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gT3RoZXIgZW52aXJvbm1lbnRzXG4gIGNvbnNvbGUud2FybignVXNpbmcgYnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudCcpO1xuICByb290ID0gdm9pZCAwO1xufSBlbHNlIHtcbiAgLy8gV2ViIFdvcmtlclxuICByb290ID0gc2VsZjtcbn1cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG52YXIgc2FmZVN0cmluZ2lmeSA9IHJlcXVpcmUoJ2Zhc3Qtc2FmZS1zdHJpbmdpZnknKTtcblxudmFyIFJlcXVlc3RCYXNlID0gcmVxdWlyZSgnLi9yZXF1ZXN0LWJhc2UnKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcblxudmFyIFJlc3BvbnNlQmFzZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UtYmFzZScpO1xuXG52YXIgQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50LWJhc2UnKTtcbi8qKlxuICogTm9vcC5cbiAqL1xuXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuLyoqXG4gKiBFeHBvc2UgYHJlcXVlc3RgLlxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwpIHtcbiAgLy8gY2FsbGJhY2tcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcbiAgfSAvLyB1cmwgZmlyc3RcblxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdChtZXRob2QsIHVybCk7XG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHM7XG52YXIgcmVxdWVzdCA9IGV4cG9ydHM7XG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuLyoqXG4gKiBEZXRlcm1pbmUgWEhSLlxuICovXG5cbnJlcXVlc3QuZ2V0WEhSID0gZnVuY3Rpb24gKCkge1xuICBpZiAocm9vdC5YTUxIdHRwUmVxdWVzdCAmJiAoIXJvb3QubG9jYXRpb24gfHwgcm9vdC5sb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2ZpbGU6JyB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjYuMCcpO1xuICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjMuMCcpO1xuICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7XG4gIH0gY2F0Y2ggKGVycikge31cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSJyk7XG59O1xuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxudmFyIHRyaW0gPSAnJy50cmltID8gZnVuY3Rpb24gKHMpIHtcbiAgcmV0dXJuIHMudHJpbSgpO1xufSA6IGZ1bmN0aW9uIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoLyheXFxzKnxcXHMqJCkvZywgJycpO1xufTtcbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgdmFyIHBhaXJzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCBvYmpba2V5XSk7XG4gIH1cblxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuLyoqXG4gKiBIZWxwcyAnc2VyaWFsaXplJyB3aXRoIHNlcmlhbGl6aW5nIGFycmF5cy5cbiAqIE11dGF0ZXMgdGhlIHBhaXJzIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqL1xuXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgZm9yICh2YXIgc3Via2V5IGluIHZhbCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIHN1YmtleSkpIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBcIlwiLmNvbmNhdChrZXksIFwiW1wiKS5jb25jYXQoc3Via2V5LCBcIl1cIiksIHZhbFtzdWJrZXldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpKTtcbiAgfVxufVxuLyoqXG4gKiBFeHBvc2Ugc2VyaWFsaXphdGlvbiBtZXRob2QuXG4gKi9cblxuXG5yZXF1ZXN0LnNlcmlhbGl6ZU9iamVjdCA9IHNlcmlhbGl6ZTtcbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICB2YXIgcGFpcnMgPSBzdHIuc3BsaXQoJyYnKTtcbiAgdmFyIHBhaXI7XG4gIHZhciBwb3M7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBvcyA9IHBhaXIuaW5kZXhPZignPScpO1xuXG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpcildID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZSgwLCBwb3MpKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZShwb3MgKyAxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbi8qKlxuICogRXhwb3NlIHBhcnNlci5cbiAqL1xuXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcbi8qKlxuICogRGVmYXVsdCBNSU1FIHR5cGUgbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqL1xuXG5yZXF1ZXN0LnR5cGVzID0ge1xuICBodG1sOiAndGV4dC9odG1sJyxcbiAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB4bWw6ICd0ZXh0L3htbCcsXG4gIHVybGVuY29kZWQ6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICBmb3JtOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0tZGF0YSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAnYXBwbGljYXRpb24vanNvbic6IHNhZmVTdHJpbmdpZnlcbn07XG4vKipcbiAqIERlZmF1bHQgcGFyc2Vycy5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICogICAgICAgcmV0dXJuIHsgb2JqZWN0IHBhcnNlZCBmcm9tIHN0ciB9O1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3QucGFyc2UgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBwYXJzZVN0cmluZyxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnBhcnNlXG59O1xuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICB2YXIgaW5kZXg7XG4gIHZhciBsaW5lO1xuICB2YXIgZmllbGQ7XG4gIHZhciB2YWw7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAvLyBjb3VsZCBiZSBlbXB0eSBsaW5lLCBqdXN0IHNraXAgaXRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZpZWxkID0gbGluZS5zbGljZSgwLCBpbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB0cmltKGxpbmUuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgZmllbGRzW2ZpZWxkXSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiBmaWVsZHM7XG59XG4vKipcbiAqIENoZWNrIGlmIGBtaW1lYCBpcyBqc29uIG9yIGhhcyAranNvbiBzdHJ1Y3R1cmVkIHN5bnRheCBzdWZmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzSlNPTihtaW1lKSB7XG4gIC8vIHNob3VsZCBtYXRjaCAvanNvbiBvciAranNvblxuICAvLyBidXQgbm90IC9qc29uLXNlcVxuICByZXR1cm4gL1svK11qc29uKCR8W14tXFx3XSkvLnRlc3QobWltZSk7XG59XG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSkge1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7IC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcblxuICB0aGlzLnRleHQgPSB0aGlzLnJlcS5tZXRob2QgIT09ICdIRUFEJyAmJiAodGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAnJyB8fCB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JykgfHwgdHlwZW9mIHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnhoci5yZXNwb25zZVRleHQgOiBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSB0aGlzLnJlcS54aHIuc3RhdHVzVGV4dDtcbiAgdmFyIHN0YXR1cyA9IHRoaXMueGhyLnN0YXR1czsgLy8gaGFuZGxlIElFOSBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAwNDY5NzIvbXNpZS1yZXR1cm5zLXN0YXR1cy1jb2RlLW9mLTEyMjMtZm9yLWFqYXgtcmVxdWVzdFxuXG4gIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICBzdGF0dXMgPSAyMDQ7XG4gIH1cblxuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHN0YXR1cyk7XG5cbiAgdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICB0aGlzLmhlYWRlciA9IHRoaXMuaGVhZGVyczsgLy8gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIHNvbWV0aW1lcyBmYWxzZWx5IHJldHVybnMgXCJcIiBmb3IgQ09SUyByZXF1ZXN0cywgYnV0XG4gIC8vIGdldFJlc3BvbnNlSGVhZGVyIHN0aWxsIHdvcmtzLiBzbyB3ZSBnZXQgY29udGVudC10eXBlIGV2ZW4gaWYgZ2V0dGluZ1xuICAvLyBvdGhlciBoZWFkZXJzIGZhaWxzLlxuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcblxuICB0aGlzLl9zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcblxuICBpZiAodGhpcy50ZXh0ID09PSBudWxsICYmIHJlcS5fcmVzcG9uc2VUeXBlKSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy54aHIucmVzcG9uc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kID09PSAnSEVBRCcgPyBudWxsIDogdGhpcy5fcGFyc2VCb2R5KHRoaXMudGV4dCA/IHRoaXMudGV4dCA6IHRoaXMueGhyLnJlc3BvbnNlKTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuXG5cblJlc3BvbnNlQmFzZShSZXNwb25zZS5wcm90b3R5cGUpO1xuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYm9keSBgc3RyYC5cbiAqXG4gKiBVc2VkIGZvciBhdXRvLXBhcnNpbmcgb2YgYm9kaWVzLiBQYXJzZXJzXG4gKiBhcmUgZGVmaW5lZCBvbiB0aGUgYHN1cGVyYWdlbnQucGFyc2VgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fcGFyc2VCb2R5ID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG5cbiAgaWYgKHRoaXMucmVxLl9wYXJzZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZXEuX3BhcnNlcih0aGlzLCBzdHIpO1xuICB9XG5cbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCA+IDAgfHwgc3RyIGluc3RhbmNlb2YgT2JqZWN0KSA/IHBhcnNlKHN0cikgOiBudWxsO1xufTtcbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlcSA9IHRoaXMucmVxO1xuICB2YXIgbWV0aG9kID0gcmVxLm1ldGhvZDtcbiAgdmFyIHVybCA9IHJlcS51cmw7XG4gIHZhciBtc2cgPSBcImNhbm5vdCBcIi5jb25jYXQobWV0aG9kLCBcIiBcIikuY29uY2F0KHVybCwgXCIgKFwiKS5jb25jYXQodGhpcy5zdGF0dXMsIFwiKVwiKTtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSBtZXRob2Q7XG4gIGVyci51cmwgPSB1cmw7XG4gIHJldHVybiBlcnI7XG59O1xuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5cbnJlcXVlc3QuUmVzcG9uc2UgPSBSZXNwb25zZTtcbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTsgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcblxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG5cbiAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlcnIgPSBudWxsO1xuICAgIHZhciByZXMgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IG5ldyBSZXNwb25zZShzZWxmKTtcbiAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICBlcnIgPSBuZXcgRXJyb3IoJ1BhcnNlciBpcyB1bmFibGUgdG8gcGFyc2UgdGhlIHJlc3BvbnNlJyk7XG4gICAgICBlcnIucGFyc2UgPSB0cnVlO1xuICAgICAgZXJyLm9yaWdpbmFsID0gZXJyMjsgLy8gaXNzdWUgIzY3NTogcmV0dXJuIHRoZSByYXcgcmVzcG9uc2UgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcblxuICAgICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICAgIC8vIGllOSBkb2Vzbid0IGhhdmUgJ3Jlc3BvbnNlJyBwcm9wZXJ0eVxuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSB0eXBlb2Ygc2VsZi54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJyA/IHNlbGYueGhyLnJlc3BvbnNlVGV4dCA6IHNlbGYueGhyLnJlc3BvbnNlOyAvLyBpc3N1ZSAjODc2OiByZXR1cm4gdGhlIGh0dHAgc3RhdHVzIGNvZGUgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcblxuICAgICAgICBlcnIuc3RhdHVzID0gc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1c0NvZGUgPSBlcnIuc3RhdHVzOyAvLyBiYWNrd2FyZHMtY29tcGF0IG9ubHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5jYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuICAgIHZhciBuZXdfZXJyO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VsZi5faXNSZXNwb25zZU9LKHJlcykpIHtcbiAgICAgICAgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICBuZXdfZXJyID0gZXJyMjsgLy8gb2soKSBjYWxsYmFjayBjYW4gdGhyb3dcbiAgICB9IC8vICMxMDAwIGRvbid0IGNhdGNoIGVycm9ycyBmcm9tIHRoZSBjYWxsYmFjayB0byBhdm9pZCBkb3VibGUgY2FsbGluZyBpdFxuXG5cbiAgICBpZiAobmV3X2Vycikge1xuICAgICAgbmV3X2Vyci5vcmlnaW5hbCA9IGVycjtcbiAgICAgIG5ld19lcnIucmVzcG9uc2UgPSByZXM7XG4gICAgICBuZXdfZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICBzZWxmLmNhbGxiYWNrKG5ld19lcnIsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBNaXhpbiBgRW1pdHRlcmAgYW5kIGBSZXF1ZXN0QmFzZWAuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG5cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG5cblJlcXVlc3RCYXNlKFJlcXVlc3QucHJvdG90eXBlKTtcbi8qKlxuICogU2V0IENvbnRlbnQtVHlwZSB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgnYXBwbGljYXRpb24veG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdGhpcy5zZXQoJ0NvbnRlbnQtVHlwZScsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogU2V0IEFjY2VwdCB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy5qc29uID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXB0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5SZXF1ZXN0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodHlwZSkge1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBTZXQgQXV0aG9yaXphdGlvbiBmaWVsZCB2YWx1ZSB3aXRoIGB1c2VyYCBhbmQgYHBhc3NgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Bhc3NdIG9wdGlvbmFsIGluIGNhc2Ugb2YgdXNpbmcgJ2JlYXJlcicgYXMgdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgd2l0aCAndHlwZScgcHJvcGVydHkgJ2F1dG8nLCAnYmFzaWMnIG9yICdiZWFyZXInIChkZWZhdWx0ICdiYXNpYycpXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24gKHVzZXIsIHBhc3MsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHBhc3MgPSAnJztcblxuICBpZiAoX3R5cGVvZihwYXNzKSA9PT0gJ29iamVjdCcgJiYgcGFzcyAhPT0gbnVsbCkge1xuICAgIC8vIHBhc3MgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZXBsYWNlZCB3aXRoIG9wdGlvbnNcbiAgICBvcHRpb25zID0gcGFzcztcbiAgICBwYXNzID0gJyc7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgdHlwZTogdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicgPyAnYmFzaWMnIDogJ2F1dG8nXG4gICAgfTtcbiAgfVxuXG4gIHZhciBlbmNvZGVyID0gZnVuY3Rpb24gZW5jb2RlcihzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBidG9hKHN0cmluZyk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGJhc2ljIGF1dGgsIGJ0b2EgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcy5fYXV0aCh1c2VyLCBwYXNzLCBvcHRpb25zLCBlbmNvZGVyKTtcbn07XG4vKipcbiAqIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICByZXF1ZXN0LmdldCgnL3Nob2VzJylcbiAqICAgICAucXVlcnkoJ3NpemU9MTAnKVxuICogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAodmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykgdmFsID0gc2VyaWFsaXplKHZhbCk7XG4gIGlmICh2YWwpIHRoaXMuX3F1ZXJ5LnB1c2godmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBRdWV1ZSB0aGUgZ2l2ZW4gYGZpbGVgIGFzIGFuIGF0dGFjaG1lbnQgdG8gdGhlIHNwZWNpZmllZCBgZmllbGRgLFxuICogd2l0aCBvcHRpb25hbCBgb3B0aW9uc2AgKG9yIGZpbGVuYW1lKS5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5hdHRhY2goJ2NvbnRlbnQnLCBuZXcgQmxvYihbJzxhIGlkPVwiYVwiPjxiIGlkPVwiYlwiPmhleSE8L2I+PC9hPiddLCB7IHR5cGU6IFwidGV4dC9odG1sXCJ9KSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChmaWVsZCwgZmlsZSwgb3B0aW9ucykge1xuICBpZiAoZmlsZSkge1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdXBlcmFnZW50IGNhbid0IG1peCAuc2VuZCgpIGFuZCAuYXR0YWNoKClcIik7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIG9wdGlvbnMgfHwgZmlsZS5uYW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2dldEZvcm1EYXRhID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhpcy5fZm9ybURhdGEgPSBuZXcgcm9vdC5Gb3JtRGF0YSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2Zvcm1EYXRhO1xufTtcbi8qKlxuICogSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGBlcnJgIGFuZCBgcmVzYFxuICogYW5kIGhhbmRsZSBhcml0eSBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICBpZiAodGhpcy5fc2hvdWxkUmV0cnkoZXJyLCByZXMpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJ5KCk7XG4gIH1cblxuICB2YXIgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuX21heFJldHJpZXMpIGVyci5yZXRyaWVzID0gdGhpcy5fcmV0cmllcyAtIDE7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBmbihlcnIsIHJlcyk7XG59O1xuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB4LWRvbWFpbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZFxcblBvc3NpYmxlIGNhdXNlczogdGhlIG5ldHdvcmsgaXMgb2ZmbGluZSwgT3JpZ2luIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiwgdGhlIHBhZ2UgaXMgYmVpbmcgdW5sb2FkZWQsIGV0Yy4nKTtcbiAgZXJyLmNyb3NzRG9tYWluID0gdHJ1ZTtcbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gIGVyci51cmwgPSB0aGlzLnVybDtcbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTsgLy8gVGhpcyBvbmx5IHdhcm5zLCBiZWNhdXNlIHRoZSByZXF1ZXN0IGlzIHN0aWxsIGxpa2VseSB0byB3b3JrXG5cblxuUmVxdWVzdC5wcm90b3R5cGUuYWdlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnNvbGUud2FybignVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50Jyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuYnVmZmVyID0gUmVxdWVzdC5wcm90b3R5cGUuY2E7XG5SZXF1ZXN0LnByb3RvdHlwZS5jYSA9IFJlcXVlc3QucHJvdG90eXBlLmFnZW50OyAvLyBUaGlzIHRocm93cywgYmVjYXVzZSBpdCBjYW4ndCBzZW5kL3JlY2VpdmUgZGF0YSBhcyBleHBlY3RlZFxuXG5SZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTdHJlYW1pbmcgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudCcpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUucGlwZSA9IFJlcXVlc3QucHJvdG90eXBlLndyaXRlO1xuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIGhvc3Qgb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSBpcyBhIGhvc3Qgb2JqZWN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5faXNIb3N0ID0gZnVuY3Rpb24gKG9iaikge1xuICAvLyBOYXRpdmUgb2JqZWN0cyBzdHJpbmdpZnkgdG8gW29iamVjdCBGaWxlXSwgW29iamVjdCBCbG9iXSwgW29iamVjdCBGb3JtRGF0YV0sIGV0Yy5cbiAgcmV0dXJuIG9iaiAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9iaikgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgIT09ICdbb2JqZWN0IE9iamVjdF0nO1xufTtcbi8qKlxuICogSW5pdGlhdGUgcmVxdWVzdCwgaW52b2tpbmcgY2FsbGJhY2sgYGZuKHJlcylgXG4gKiB3aXRoIGFuIGluc3RhbmNlb2YgYFJlc3BvbnNlYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGZuKSB7XG4gIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IC5lbmQoKSB3YXMgY2FsbGVkIHR3aWNlLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gc3VwZXJhZ2VudCcpO1xuICB9XG5cbiAgdGhpcy5fZW5kQ2FsbGVkID0gdHJ1ZTsgLy8gc3RvcmUgY2FsbGJhY2tcblxuICB0aGlzLl9jYWxsYmFjayA9IGZuIHx8IG5vb3A7IC8vIHF1ZXJ5c3RyaW5nXG5cbiAgdGhpcy5fZmluYWxpemVRdWVyeVN0cmluZygpO1xuXG4gIHRoaXMuX2VuZCgpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX3NldFVwbG9hZFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpczsgLy8gdXBsb2FkIHRpbWVvdXQgaXQncyB3b2tycyBvbmx5IGlmIGRlYWRsaW5lIHRpbWVvdXQgaXMgb2ZmXG5cbiAgaWYgKHRoaXMuX3VwbG9hZFRpbWVvdXQgJiYgIXRoaXMuX3VwbG9hZFRpbWVvdXRUaW1lcikge1xuICAgIHRoaXMuX3VwbG9hZFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdVcGxvYWQgdGltZW91dCBvZiAnLCBzZWxmLl91cGxvYWRUaW1lb3V0LCAnRVRJTUVET1VUJyk7XG4gICAgfSwgdGhpcy5fdXBsb2FkVGltZW91dCk7XG4gIH1cbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cblxuUmVxdWVzdC5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHJldHVybiB0aGlzLmNhbGxiYWNrKG5ldyBFcnJvcignVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCBldmVuIGJlZm9yZSAuZW5kKCkgd2FzIGNhbGxlZCcpKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCk7XG4gIHZhciB4aHIgPSB0aGlzLnhocjtcbiAgdmFyIGRhdGEgPSB0aGlzLl9mb3JtRGF0YSB8fCB0aGlzLl9kYXRhO1xuXG4gIHRoaXMuX3NldFRpbWVvdXRzKCk7IC8vIHN0YXRlIGNoYW5nZVxuXG5cbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuXG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMiAmJiBzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgICB9XG5cbiAgICBpZiAocmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSW4gSUU5LCByZWFkcyB0byBhbnkgcHJvcGVydHkgKGUuZy4gc3RhdHVzKSBvZmYgb2YgYW4gYWJvcnRlZCBYSFIgd2lsbFxuICAgIC8vIHJlc3VsdCBpbiB0aGUgZXJyb3IgXCJDb3VsZCBub3QgY29tcGxldGUgdGhlIG9wZXJhdGlvbiBkdWUgdG8gZXJyb3IgYzAwYzAyM2ZcIlxuXG5cbiAgICB2YXIgc3RhdHVzO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzdGF0dXMgPSAwO1xuICAgIH1cblxuICAgIGlmICghc3RhdHVzKSB7XG4gICAgICBpZiAoc2VsZi50aW1lZG91dCB8fCBzZWxmLl9hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdlbmQnKTtcbiAgfTsgLy8gcHJvZ3Jlc3NcblxuXG4gIHZhciBoYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKGRpcmVjdGlvbiwgZSkge1xuICAgIGlmIChlLnRvdGFsID4gMCkge1xuICAgICAgZS5wZXJjZW50ID0gZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwO1xuXG4gICAgICBpZiAoZS5wZXJjZW50ID09PSAxMDApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3VwbG9hZFRpbWVvdXRUaW1lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIGUpO1xuICB9O1xuXG4gIGlmICh0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgIHRyeSB7XG4gICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICdkb3dubG9hZCcpKTtcblxuICAgICAgaWYgKHhoci51cGxvYWQpIHtcbiAgICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ3VwbG9hZCcpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHsvLyBBY2Nlc3NpbmcgeGhyLnVwbG9hZCBmYWlscyBpbiBJRSBmcm9tIGEgd2ViIHdvcmtlciwgc28ganVzdCBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBSZXBvcnRlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MzcyNDUveG1saHR0cHJlcXVlc3QtdXBsb2FkLXRocm93cy1pbnZhbGlkLWFyZ3VtZW50LXdoZW4tdXNlZC1mcm9tLXdlYi13b3JrZXItY29udGV4dFxuICAgIH1cbiAgfVxuXG4gIGlmICh4aHIudXBsb2FkKSB7XG4gICAgdGhpcy5fc2V0VXBsb2FkVGltZW91dCgpO1xuICB9IC8vIGluaXRpYXRlIHJlcXVlc3RcblxuXG4gIHRyeSB7XG4gICAgaWYgKHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHNlZSAjMTE0OVxuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGVycik7XG4gIH0gLy8gQ09SU1xuXG5cbiAgaWYgKHRoaXMuX3dpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7IC8vIGJvZHlcblxuICBpZiAoIXRoaXMuX2Zvcm1EYXRhICYmIHRoaXMubWV0aG9kICE9PSAnR0VUJyAmJiB0aGlzLm1ldGhvZCAhPT0gJ0hFQUQnICYmIHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiAhdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgLy8gc2VyaWFsaXplIHN0dWZmXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcblxuICAgIHZhciBfc2VyaWFsaXplID0gdGhpcy5fc2VyaWFsaXplciB8fCByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG5cbiAgICBpZiAoIV9zZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkge1xuICAgICAgX3NlcmlhbGl6ZSA9IHJlcXVlc3Quc2VyaWFsaXplWydhcHBsaWNhdGlvbi9qc29uJ107XG4gICAgfVxuXG4gICAgaWYgKF9zZXJpYWxpemUpIGRhdGEgPSBfc2VyaWFsaXplKGRhdGEpO1xuICB9IC8vIHNldCBoZWFkZXIgZmllbGRzXG5cblxuICBmb3IgKHZhciBmaWVsZCBpbiB0aGlzLmhlYWRlcikge1xuICAgIGlmICh0aGlzLmhlYWRlcltmaWVsZF0gPT09IG51bGwpIGNvbnRpbnVlO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5oZWFkZXIsIGZpZWxkKSkgeGhyLnNldFJlcXVlc3RIZWFkZXIoZmllbGQsIHRoaXMuaGVhZGVyW2ZpZWxkXSk7XG4gIH1cblxuICBpZiAodGhpcy5fcmVzcG9uc2VUeXBlKSB7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IHRoaXMuX3Jlc3BvbnNlVHlwZTtcbiAgfSAvLyBzZW5kIHN0dWZmXG5cblxuICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCB0aGlzKTsgLy8gSUUxMSB4aHIuc2VuZCh1bmRlZmluZWQpIHNlbmRzICd1bmRlZmluZWQnIHN0cmluZyBhcyBQT1NUIHBheWxvYWQgKGluc3RlYWQgb2Ygbm90aGluZylcbiAgLy8gV2UgbmVlZCBudWxsIGhlcmUgaWYgZGF0YSBpcyB1bmRlZmluZWRcblxuICB4aHIuc2VuZCh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogZGF0YSk7XG59O1xuXG5yZXF1ZXN0LmFnZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IEFnZW50KCk7XG59O1xuXG5bJ0dFVCcsICdQT1NUJywgJ09QVElPTlMnLCAnUEFUQ0gnLCAnUFVUJywgJ0RFTEVURSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICBBZ2VudC5wcm90b3R5cGVbbWV0aG9kLnRvTG93ZXJDYXNlKCldID0gZnVuY3Rpb24gKHVybCwgZm4pIHtcbiAgICB2YXIgcmVxID0gbmV3IHJlcXVlc3QuUmVxdWVzdChtZXRob2QsIHVybCk7XG5cbiAgICB0aGlzLl9zZXREZWZhdWx0cyhyZXEpO1xuXG4gICAgaWYgKGZuKSB7XG4gICAgICByZXEuZW5kKGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxO1xuICB9O1xufSk7XG5BZ2VudC5wcm90b3R5cGUuZGVsID0gQWdlbnQucHJvdG90eXBlLmRlbGV0ZTtcbi8qKlxuICogR0VUIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5nZXQgPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcblxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IGRhdGE7XG4gICAgZGF0YSA9IG51bGw7XG4gIH1cblxuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcbi8qKlxuICogSEVBRCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxucmVxdWVzdC5oZWFkID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0hFQUQnLCB1cmwpO1xuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuLyoqXG4gKiBPUFRJT05TIHF1ZXJ5IHRvIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5yZXF1ZXN0Lm9wdGlvbnMgPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnT1BUSU9OUycsIHVybCk7XG5cbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSBudWxsO1xuICB9XG5cbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGRlbCh1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdERUxFVEUnLCB1cmwpO1xuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn1cblxucmVxdWVzdC5kZWwgPSBkZWw7XG5yZXF1ZXN0LmRlbGV0ZSA9IGRlbDtcbi8qKlxuICogUEFUQ0ggYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucGF0Y2ggPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUEFUQ0gnLCB1cmwpO1xuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG4vKipcbiAqIFBPU1QgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxucmVxdWVzdC5wb3N0ID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG4vKipcbiAqIFBVVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5yZXF1ZXN0LnB1dCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQVVQnLCB1cmwpO1xuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgX3R5cGVvZihvYmopID09PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBNb2R1bGUgb2YgbWl4ZWQtaW4gZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIG5vZGUgYW5kIGNsaWVudCBjb2RlXG4gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdEJhc2VgLlxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0QmFzZTtcbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdEJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdEJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIFJlcXVlc3RCYXNlLnByb3RvdHlwZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoUmVxdWVzdEJhc2UucHJvdG90eXBlLCBrZXkpKSBvYmpba2V5XSA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbi8qKlxuICogQ2xlYXIgcHJldmlvdXMgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fdXBsb2FkVGltZW91dFRpbWVyKTtcbiAgZGVsZXRlIHRoaXMuX3RpbWVyO1xuICBkZWxldGUgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXI7XG4gIGRlbGV0ZSB0aGlzLl91cGxvYWRUaW1lb3V0VGltZXI7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXNwb25zZSBib2R5IHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBpbmNvbWluZyBkYXRhIGludG8gcmVxdWVzdC5ib2R5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5fcGFyc2VyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogU2V0IGZvcm1hdCBvZiBiaW5hcnkgcmVzcG9uc2UgYm9keS5cbiAqIEluIGJyb3dzZXIgdmFsaWQgZm9ybWF0cyBhcmUgJ2Jsb2InIGFuZCAnYXJyYXlidWZmZXInLFxuICogd2hpY2ggcmV0dXJuIEJsb2IgYW5kIEFycmF5QnVmZmVyLCByZXNwZWN0aXZlbHkuXG4gKlxuICogSW4gTm9kZSBhbGwgdmFsdWVzIHJlc3VsdCBpbiBCdWZmZXIuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAucmVzcG9uc2VUeXBlKCdibG9iJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVzcG9uc2VUeXBlID0gZnVuY3Rpb24gKHZhbCkge1xuICB0aGlzLl9yZXNwb25zZVR5cGUgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXF1ZXN0IGJvZHkgc2VyaWFsaXplclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBkYXRhIHNldCB2aWEgLnNlbmQgb3IgLmF0dGFjaCBpbnRvIHBheWxvYWQgdG8gc2VuZFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChmbikge1xuICB0aGlzLl9zZXJpYWxpemVyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogU2V0IHRpbWVvdXRzLlxuICpcbiAqIC0gcmVzcG9uc2UgdGltZW91dCBpcyB0aW1lIGJldHdlZW4gc2VuZGluZyByZXF1ZXN0IGFuZCByZWNlaXZpbmcgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIHJlc3BvbnNlLiBJbmNsdWRlcyBETlMgYW5kIGNvbm5lY3Rpb24gdGltZS5cbiAqIC0gZGVhZGxpbmUgaXMgdGhlIHRpbWUgZnJvbSBzdGFydCBvZiB0aGUgcmVxdWVzdCB0byByZWNlaXZpbmcgcmVzcG9uc2UgYm9keSBpbiBmdWxsLiBJZiB0aGUgZGVhZGxpbmUgaXMgdG9vIHNob3J0IGxhcmdlIGZpbGVzIG1heSBub3QgbG9hZCBhdCBhbGwgb24gc2xvdyBjb25uZWN0aW9ucy5cbiAqIC0gdXBsb2FkIGlzIHRoZSB0aW1lICBzaW5jZSBsYXN0IGJpdCBvZiBkYXRhIHdhcyBzZW50IG9yIHJlY2VpdmVkLiBUaGlzIHRpbWVvdXQgd29ya3Mgb25seSBpZiBkZWFkbGluZSB0aW1lb3V0IGlzIG9mZlxuICpcbiAqIFZhbHVlIG9mIDAgb3IgZmFsc2UgbWVhbnMgbm8gdGltZW91dC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IG1zIG9yIHtyZXNwb25zZSwgZGVhZGxpbmV9XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCBfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0Jykge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zO1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IDA7XG4gICAgdGhpcy5fdXBsb2FkVGltZW91dCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgb3B0aW9uKSkge1xuICAgICAgc3dpdGNoIChvcHRpb24pIHtcbiAgICAgICAgY2FzZSAnZGVhZGxpbmUnOlxuICAgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLmRlYWRsaW5lO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Jlc3BvbnNlJzpcbiAgICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3VwbG9hZCc6XG4gICAgICAgICAgdGhpcy5fdXBsb2FkVGltZW91dCA9IG9wdGlvbnMudXBsb2FkO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS53YXJuKCdVbmtub3duIHRpbWVvdXQgb3B0aW9uJywgb3B0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNldCBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgb24gZXJyb3IuXG4gKlxuICogRmFpbGVkIHJlcXVlc3RzIHdpbGwgYmUgcmV0cmllZCAnY291bnQnIHRpbWVzIGlmIHRpbWVvdXQgb3IgZXJyLmNvZGUgPj0gNTAwLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24gKGNvdW50LCBmbikge1xuICAvLyBEZWZhdWx0IHRvIDEgaWYgbm8gY291bnQgcGFzc2VkIG9yIHRydWVcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgY291bnQgPT09IHRydWUpIGNvdW50ID0gMTtcbiAgaWYgKGNvdW50IDw9IDApIGNvdW50ID0gMDtcbiAgdGhpcy5fbWF4UmV0cmllcyA9IGNvdW50O1xuICB0aGlzLl9yZXRyaWVzID0gMDtcbiAgdGhpcy5fcmV0cnlDYWxsYmFjayA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBFUlJPUl9DT0RFUyA9IFsnRUNPTk5SRVNFVCcsICdFVElNRURPVVQnLCAnRUFERFJJTkZPJywgJ0VTT0NLRVRUSU1FRE9VVCddO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSByZXF1ZXN0IHNob3VsZCBiZSByZXRyaWVkLlxuICogKEJvcnJvd2VkIGZyb20gc2VnbWVudGlvL3N1cGVyYWdlbnQtcmV0cnkpXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIGFuIGVycm9yXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSBbcmVzXSByZXNwb25zZVxuICogQHJldHVybnMge0Jvb2xlYW59IGlmIHNlZ21lbnQgc2hvdWxkIGJlIHJldHJpZWRcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3Nob3VsZFJldHJ5ID0gZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gIGlmICghdGhpcy5fbWF4UmV0cmllcyB8fCB0aGlzLl9yZXRyaWVzKysgPj0gdGhpcy5fbWF4UmV0cmllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXRyeUNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvdmVycmlkZSA9IHRoaXMuX3JldHJ5Q2FsbGJhY2soZXJyLCByZXMpO1xuXG4gICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlOyAvLyB1bmRlZmluZWQgZmFsbHMgYmFjayB0byBkZWZhdWx0c1xuICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyMik7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlcyAmJiByZXMuc3RhdHVzICYmIHJlcy5zdGF0dXMgPj0gNTAwICYmIHJlcy5zdGF0dXMgIT09IDUwMSkgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGVycikge1xuICAgIGlmIChlcnIuY29kZSAmJiBFUlJPUl9DT0RFUy5pbmRleE9mKGVyci5jb2RlKSAhPT0gLTEpIHJldHVybiB0cnVlOyAvLyBTdXBlcmFnZW50IHRpbWVvdXRcblxuICAgIGlmIChlcnIudGltZW91dCAmJiBlcnIuY29kZSA9PT0gJ0VDT05OQUJPUlRFRCcpIHJldHVybiB0cnVlO1xuICAgIGlmIChlcnIuY3Jvc3NEb21haW4pIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogUmV0cnkgcmVxdWVzdFxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3JldHJ5ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFyVGltZW91dCgpOyAvLyBub2RlXG5cbiAgaWYgKHRoaXMucmVxKSB7XG4gICAgdGhpcy5yZXEgPSBudWxsO1xuICAgIHRoaXMucmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIH1cblxuICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7XG4gIHRoaXMudGltZWRvdXQgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXMuX2VuZCgpO1xufTtcbi8qKlxuICogUHJvbWlzZSBzdXBwb3J0XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAoIXRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBzdXBlcmFnZW50IHJlcXVlc3Qgd2FzIHNlbnQgdHdpY2UsIGJlY2F1c2UgYm90aCAuZW5kKCkgYW5kIC50aGVuKCkgd2VyZSBjYWxsZWQuIE5ldmVyIGNhbGwgLmVuZCgpIGlmIHlvdSB1c2UgcHJvbWlzZXMnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHNlbGYub24oJ2Fib3J0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XG4gICAgICAgIGVyci5jb2RlID0gJ0FCT1JURUQnO1xuICAgICAgICBlcnIuc3RhdHVzID0gX3RoaXMuc3RhdHVzO1xuICAgICAgICBlcnIubWV0aG9kID0gX3RoaXMubWV0aG9kO1xuICAgICAgICBlcnIudXJsID0gX3RoaXMudXJsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5lbmQoZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO2Vsc2UgcmVzb2x2ZShyZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fZnVsbGZpbGxlZFByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKGNiKSB7XG4gIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBjYik7XG59O1xuLyoqXG4gKiBBbGxvdyBmb3IgZXh0ZW5zaW9uXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIGZuKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5vayA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIHJlcXVpcmVkJyk7XG4gIHRoaXMuX29rQ2FsbGJhY2sgPSBjYjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2lzUmVzcG9uc2VPSyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgaWYgKCFyZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fb2tDYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9va0NhbGxiYWNrKHJlcyk7XG4gIH1cblxuICByZXR1cm4gcmVzLnN0YXR1cyA+PSAyMDAgJiYgcmVzLnN0YXR1cyA8IDMwMDtcbn07XG4vKipcbiAqIEdldCByZXF1ZXN0IGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldEhlYWRlciA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQ7XG4vKipcbiAqIFNldCBoZWFkZXIgYGZpZWxkYCB0byBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLnNldCgnWC1BUEktS2V5JywgJ2Zvb2JhcicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsICdYLUFQSS1LZXknOiAnZm9vYmFyJyB9KVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGZpZWxkLCB2YWwpIHtcbiAgaWYgKGlzT2JqZWN0KGZpZWxkKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBmaWVsZCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmaWVsZCwga2V5KSkgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC1qc2RvY1xuXG4vKipcbiAqIFJlbW92ZSBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC51bnNldCgnVXNlci1BZ2VudCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkIGZpZWxkIG5hbWVcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0XG4gKiBmb3IgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoeyBmb286ICdiYXInLCBiYXo6ICdxdXgnIH0pXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lIG5hbWUgb2YgZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8RmlsZXxCdWZmZXJ8ZnMuUmVhZFN0cmVhbX0gdmFsIHZhbHVlIG9mIGZpZWxkXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZmllbGQgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XG4gIC8vIG5hbWUgc2hvdWxkIGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBvYmplY3QuXG4gIGlmIChuYW1lID09PSBudWxsIHx8IHVuZGVmaW5lZCA9PT0gbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgbmFtZSBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIi5maWVsZCgpIGNhbid0IGJlIHVzZWQgaWYgLnNlbmQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmFtZSwga2V5KSkgdGhpcy5maWVsZChrZXksIG5hbWVba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgZm9yICh2YXIgaSBpbiB2YWwpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsLCBpKSkgdGhpcy5maWVsZChuYW1lLCB2YWxbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHZhbCBzaG91bGQgYmUgZGVmaW5lZCBub3dcblxuXG4gIGlmICh2YWwgPT09IG51bGwgfHwgdW5kZWZpbmVkID09PSB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIHZhbCBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gU3RyaW5nKHZhbCk7XG4gIH1cblxuICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChuYW1lLCB2YWwpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fYWJvcnRlZCA9IHRydWU7XG4gIGlmICh0aGlzLnhocikgdGhpcy54aHIuYWJvcnQoKTsgLy8gYnJvd3NlclxuXG4gIGlmICh0aGlzLnJlcSkgdGhpcy5yZXEuYWJvcnQoKTsgLy8gbm9kZVxuXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2F1dGggPSBmdW5jdGlvbiAodXNlciwgcGFzcywgb3B0aW9ucywgYmFzZTY0RW5jb2Rlcikge1xuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgXCJCYXNpYyBcIi5jb25jYXQoYmFzZTY0RW5jb2RlcihcIlwiLmNvbmNhdCh1c2VyLCBcIjpcIikuY29uY2F0KHBhc3MpKSkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRvJzpcbiAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VyO1xuICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JlYXJlcic6XG4gICAgICAvLyB1c2FnZSB3b3VsZCBiZSAuYXV0aChhY2Nlc3NUb2tlbiwgeyB0eXBlOiAnYmVhcmVyJyB9KVxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCBcIkJlYXJlciBcIi5jb25jYXQodXNlcikpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uIChvbikge1xuICAvLyBUaGlzIGlzIGJyb3dzZXItb25seSBmdW5jdGlvbmFsaXR5LiBOb2RlIHNpZGUgaXMgbm8tb3AuXG4gIGlmIChvbiA9PT0gdW5kZWZpbmVkKSBvbiA9IHRydWU7XG4gIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IG9uO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNldCB0aGUgbWF4IHJlZGlyZWN0cyB0byBgbmAuIERvZXMgbm90aGluZyBpbiBicm93c2VyIFhIUiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlZGlyZWN0cyA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuX21heFJlZGlyZWN0cyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogTWF4aW11bSBzaXplIG9mIGJ1ZmZlcmVkIHJlc3BvbnNlIGJvZHksIGluIGJ5dGVzLiBDb3VudHMgdW5jb21wcmVzc2VkIHNpemUuXG4gKiBEZWZhdWx0IDIwME1CLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIG51bWJlciBvZiBieXRlc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUubWF4UmVzcG9uc2VTaXplID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIHRoaXMuX21heFJlc3BvbnNlU2l6ZSA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogQ29udmVydCB0byBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IChub3QgSlNPTiBzdHJpbmcpIG9mIHNjYWxhciBwcm9wZXJ0aWVzLlxuICogTm90ZSBhcyB0aGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byByZXR1cm4gYSB1c2VmdWwgbm9uLXRoaXMgdmFsdWUsXG4gKiBpdCBjYW5ub3QgYmUgY2hhaW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc2NyaWJpbmcgbWV0aG9kLCB1cmwsIGFuZCBkYXRhIG9mIHRoaXMgcmVxdWVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgaGVhZGVyczogdGhpcy5faGVhZGVyXG4gIH07XG59O1xuLyoqXG4gKiBTZW5kIGBkYXRhYCBhcyB0aGUgcmVxdWVzdCBib2R5LCBkZWZhdWx0aW5nIHRoZSBgLnR5cGUoKWAgdG8gXCJqc29uXCIgd2hlblxuICogYW4gb2JqZWN0IGlzIGdpdmVuLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIG1hbnVhbCBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgICAuc2VuZCgne1wibmFtZVwiOlwidGpcIn0nKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8ganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKCduYW1lPXRqJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gZGVmYXVsdHMgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKCduYW1lPXRvYmknKVxuICogICAgICAgIC5zZW5kKCdzcGVjaWVzPWZlcnJldCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBpc09iaiA9IGlzT2JqZWN0KGRhdGEpO1xuICB2YXIgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgaWYgKHRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiLnNlbmQoKSBjYW4ndCBiZSB1c2VkIGlmIC5hdHRhY2goKSBvciAuZmllbGQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpO1xuICB9XG5cbiAgaWYgKGlzT2JqICYmICF0aGlzLl9kYXRhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YSAmJiB0aGlzLl9kYXRhICYmIHRoaXMuX2lzSG9zdCh0aGlzLl9kYXRhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IG1lcmdlIHRoZXNlIHNlbmQgY2FsbHNcIik7XG4gIH0gLy8gbWVyZ2VcblxuXG4gIGlmIChpc09iaiAmJiBpc09iamVjdCh0aGlzLl9kYXRhKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkpIHRoaXMuX2RhdGFba2V5XSA9IGRhdGFba2V5XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZGVmYXVsdCB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xuICAgIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gICAgaWYgKHR5cGUgPT09ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YSA/IFwiXCIuY29uY2F0KHRoaXMuX2RhdGEsIFwiJlwiKS5jb25jYXQoZGF0YSkgOiBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRhID0gKHRoaXMuX2RhdGEgfHwgJycpICsgZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICBpZiAoIWlzT2JqIHx8IHRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIGRlZmF1bHQgdG8ganNvblxuXG5cbiAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2pzb24nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBTb3J0IGBxdWVyeXN0cmluZ2AgYnkgdGhlIHNvcnQgZnVuY3Rpb25cbiAqXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gZGVmYXVsdCBvcmRlclxuICogICAgICAgcmVxdWVzdC5nZXQoJy91c2VyJylcbiAqICAgICAgICAgLnF1ZXJ5KCduYW1lPU5pY2snKVxuICogICAgICAgICAucXVlcnkoJ3NlYXJjaD1NYW5ueScpXG4gKiAgICAgICAgIC5zb3J0UXVlcnkoKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGN1c3RvbWl6ZWQgc29ydCBmdW5jdGlvblxuICogICAgICAgcmVxdWVzdC5nZXQoJy91c2VyJylcbiAqICAgICAgICAgLnF1ZXJ5KCduYW1lPU5pY2snKVxuICogICAgICAgICAucXVlcnkoJ3NlYXJjaD1NYW5ueScpXG4gKiAgICAgICAgIC5zb3J0UXVlcnkoZnVuY3Rpb24oYSwgYil7XG4gKiAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zb3J0UXVlcnkgPSBmdW5jdGlvbiAoc29ydCkge1xuICAvLyBfc29ydCBkZWZhdWx0IHRvIHRydWUgYnV0IG90aGVyd2lzZSBjYW4gYmUgYSBmdW5jdGlvbiBvciBib29sZWFuXG4gIHRoaXMuX3NvcnQgPSB0eXBlb2Ygc29ydCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogc29ydDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBDb21wb3NlIHF1ZXJ5c3RyaW5nIHRvIGFwcGVuZCB0byByZXEudXJsXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2ZpbmFsaXplUXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcblxuICBpZiAocXVlcnkpIHtcbiAgICB0aGlzLnVybCArPSAodGhpcy51cmwuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPycpICsgcXVlcnk7XG4gIH1cblxuICB0aGlzLl9xdWVyeS5sZW5ndGggPSAwOyAvLyBNYWtlcyB0aGUgY2FsbCBpZGVtcG90ZW50XG5cbiAgaWYgKHRoaXMuX3NvcnQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnVybC5pbmRleE9mKCc/Jyk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIHF1ZXJ5QXJyID0gdGhpcy51cmwuc3Vic3RyaW5nKGluZGV4ICsgMSkuc3BsaXQoJyYnKTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQodGhpcy5fc29ydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeUFyci5zb3J0KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXJsID0gdGhpcy51cmwuc3Vic3RyaW5nKDAsIGluZGV4KSArICc/JyArIHF1ZXJ5QXJyLmpvaW4oJyYnKTtcbiAgICB9XG4gIH1cbn07IC8vIEZvciBiYWNrd2FyZHMgY29tcGF0IG9ubHlcblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2FwcGVuZFF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkJyk7XG59O1xuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbiAocmVhc29uLCB0aW1lb3V0LCBlcnJubykge1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJcIi5jb25jYXQocmVhc29uICsgdGltZW91dCwgXCJtcyBleGNlZWRlZFwiKSk7XG4gIGVyci50aW1lb3V0ID0gdGltZW91dDtcbiAgZXJyLmNvZGUgPSAnRUNPTk5BQk9SVEVEJztcbiAgZXJyLmVycm5vID0gZXJybm87XG4gIHRoaXMudGltZWRvdXQgPSB0cnVlO1xuICB0aGlzLmFib3J0KCk7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2V0VGltZW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpczsgLy8gZGVhZGxpbmVcblxuICBpZiAodGhpcy5fdGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdUaW1lb3V0IG9mICcsIHNlbGYuX3RpbWVvdXQsICdFVElNRScpO1xuICAgIH0sIHRoaXMuX3RpbWVvdXQpO1xuICB9IC8vIHJlc3BvbnNlIHRpbWVvdXRcblxuXG4gIGlmICh0aGlzLl9yZXNwb25zZVRpbWVvdXQgJiYgIXRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignUmVzcG9uc2UgdGltZW91dCBvZiAnLCBzZWxmLl9yZXNwb25zZVRpbWVvdXQsICdFVElNRURPVVQnKTtcbiAgICB9LCB0aGlzLl9yZXNwb25zZVRpbWVvdXQpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZUJhc2VgLlxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZXNwb25zZUJhc2U7XG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlQmFzZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZUJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIFJlc3BvbnNlQmFzZS5wcm90b3R5cGUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFJlc3BvbnNlQmFzZS5wcm90b3R5cGUsIGtleSkpIG9ialtrZXldID0gUmVzcG9uc2VCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICByZXR1cm4gdGhpcy5oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuLyoqXG4gKiBTZXQgaGVhZGVyIHJlbGF0ZWQgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYC50eXBlYCB0aGUgY29udGVudCB0eXBlIHdpdGhvdXQgcGFyYW1zXG4gKlxuICogQSByZXNwb25zZSBvZiBcIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gKiB3aWxsIHByb3ZpZGUgeW91IHdpdGggYSBgLnR5cGVgIG9mIFwidGV4dC9wbGFpblwiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgLy8gVE9ETzogbW9hciFcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGEgdXRpbFxuICAvLyBjb250ZW50LXR5cGVcbiAgdmFyIGN0ID0gaGVhZGVyWydjb250ZW50LXR5cGUnXSB8fCAnJztcbiAgdGhpcy50eXBlID0gdXRpbHMudHlwZShjdCk7IC8vIHBhcmFtc1xuXG4gIHZhciBwYXJhbXMgPSB1dGlscy5wYXJhbXMoY3QpO1xuXG4gIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywga2V5KSkgdGhpc1trZXldID0gcGFyYW1zW2tleV07XG4gIH1cblxuICB0aGlzLmxpbmtzID0ge307IC8vIGxpbmtzXG5cbiAgdHJ5IHtcbiAgICBpZiAoaGVhZGVyLmxpbmspIHtcbiAgICAgIHRoaXMubGlua3MgPSB1dGlscy5wYXJzZUxpbmtzKGhlYWRlci5saW5rKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikgey8vIGlnbm9yZVxuICB9XG59O1xuLyoqXG4gKiBTZXQgZmxhZ3Mgc3VjaCBhcyBgLm9rYCBiYXNlZCBvbiBgc3RhdHVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cbiAqIHdoZXJlYXMgNXh4IHdpbGwgYmUgX19mYWxzZV9fIGFuZCBgLmVycm9yYCB3aWxsIGJlIF9fdHJ1ZV9fLiBUaGVcbiAqIGAuY2xpZW50RXJyb3JgIGFuZCBgLnNlcnZlckVycm9yYCBhcmUgYWxzbyBhdmFpbGFibGUgdG8gYmUgbW9yZVxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxuICogc29tZXRpbWVzIHVzZWZ1bCBmb3IgbWFwcGluZyByZXNwb25kIGNvbG9ycyBldGMuXG4gKlxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxuICpcbiAqICAgLSAubm9Db250ZW50XG4gKiAgIC0gLmJhZFJlcXVlc3RcbiAqICAgLSAudW5hdXRob3JpemVkXG4gKiAgIC0gLm5vdEFjY2VwdGFibGVcbiAqICAgLSAubm90Rm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuX3NldFN0YXR1c1Byb3BlcnRpZXMgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIHZhciB0eXBlID0gc3RhdHVzIC8gMTAwIHwgMDsgLy8gc3RhdHVzIC8gY2xhc3NcblxuICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0dXNDb2RlO1xuICB0aGlzLnN0YXR1c1R5cGUgPSB0eXBlOyAvLyBiYXNpY3NcblxuICB0aGlzLmluZm8gPSB0eXBlID09PSAxO1xuICB0aGlzLm9rID0gdHlwZSA9PT0gMjtcbiAgdGhpcy5yZWRpcmVjdCA9IHR5cGUgPT09IDM7XG4gIHRoaXMuY2xpZW50RXJyb3IgPSB0eXBlID09PSA0O1xuICB0aGlzLnNlcnZlckVycm9yID0gdHlwZSA9PT0gNTtcbiAgdGhpcy5lcnJvciA9IHR5cGUgPT09IDQgfHwgdHlwZSA9PT0gNSA/IHRoaXMudG9FcnJvcigpIDogZmFsc2U7IC8vIHN1Z2FyXG5cbiAgdGhpcy5jcmVhdGVkID0gc3RhdHVzID09PSAyMDE7XG4gIHRoaXMuYWNjZXB0ZWQgPSBzdGF0dXMgPT09IDIwMjtcbiAgdGhpcy5ub0NvbnRlbnQgPSBzdGF0dXMgPT09IDIwNDtcbiAgdGhpcy5iYWRSZXF1ZXN0ID0gc3RhdHVzID09PSA0MDA7XG4gIHRoaXMudW5hdXRob3JpemVkID0gc3RhdHVzID09PSA0MDE7XG4gIHRoaXMubm90QWNjZXB0YWJsZSA9IHN0YXR1cyA9PT0gNDA2O1xuICB0aGlzLmZvcmJpZGRlbiA9IHN0YXR1cyA9PT0gNDAzO1xuICB0aGlzLm5vdEZvdW5kID0gc3RhdHVzID09PSA0MDQ7XG4gIHRoaXMudW5wcm9jZXNzYWJsZUVudGl0eSA9IHN0YXR1cyA9PT0gNDIyO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcbn07XG4vKipcbiAqIFJldHVybiBoZWFkZXIgZmllbGQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmV4cG9ydHMucGFyYW1zID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKjsgKi8pLnJlZHVjZShmdW5jdGlvbiAob2JqLCBzdHIpIHtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLyk7XG4gICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgdmFyIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgaWYgKGtleSAmJiB2YWwpIG9ialtrZXldID0gdmFsO1xuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbn07XG4vKipcbiAqIFBhcnNlIExpbmsgaGVhZGVyIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmV4cG9ydHMucGFyc2VMaW5rcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICosICovKS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgc3RyKSB7XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKjsgKi8pO1xuICAgIHZhciB1cmwgPSBwYXJ0c1swXS5zbGljZSgxLCAtMSk7XG4gICAgdmFyIHJlbCA9IHBhcnRzWzFdLnNwbGl0KC8gKj0gKi8pWzFdLnNsaWNlKDEsIC0xKTtcbiAgICBvYmpbcmVsXSA9IHVybDtcbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59O1xuLyoqXG4gKiBTdHJpcCBjb250ZW50IHJlbGF0ZWQgZmllbGRzIGZyb20gYGhlYWRlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZXhwb3J0cy5jbGVhbkhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIsIGNoYW5nZXNPcmlnaW4pIHtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC10eXBlJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ3RyYW5zZmVyLWVuY29kaW5nJ107XG4gIGRlbGV0ZSBoZWFkZXIuaG9zdDsgLy8gc2VjdWlydHlcblxuICBpZiAoY2hhbmdlc09yaWdpbikge1xuICAgIGRlbGV0ZSBoZWFkZXIuYXV0aG9yaXphdGlvbjtcbiAgICBkZWxldGUgaGVhZGVyLmNvb2tpZTtcbiAgfVxuXG4gIHJldHVybiBoZWFkZXI7XG59OyIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGV2ZW50IHNwZWNpZmljIGFycmF5cyBmb3IgZXZlbnQgdHlwZXMgdGhhdCBub1xyXG4gIC8vIG9uZSBpcyBzdWJzY3JpYmVkIGZvciB0byBhdm9pZCBtZW1vcnkgbGVhay5cclxuICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiLyoqXG4gKiBDb252ZXJ0IGEgdHlwZWQgYXJyYXkgdG8gYSBCdWZmZXIgd2l0aG91dCBhIGNvcHlcbiAqXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogTGljZW5zZTogIE1JVFxuICpcbiAqIGBucG0gaW5zdGFsbCB0eXBlZGFycmF5LXRvLWJ1ZmZlcmBcbiAqL1xuXG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWRhcnJheScpLnN0cmljdFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHR5cGVkYXJyYXlUb0J1ZmZlciAoYXJyKSB7XG4gIGlmIChpc1R5cGVkQXJyYXkoYXJyKSkge1xuICAgIC8vIFRvIGF2b2lkIGEgY29weSwgdXNlIHRoZSB0eXBlZCBhcnJheSdzIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIgdG8gYmFjayBuZXcgQnVmZmVyXG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5mcm9tKGFyci5idWZmZXIpXG4gICAgaWYgKGFyci5ieXRlTGVuZ3RoICE9PSBhcnIuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIC8vIFJlc3BlY3QgdGhlIFwidmlld1wiLCBpLmUuIGJ5dGVPZmZzZXQgYW5kIGJ5dGVMZW5ndGgsIHdpdGhvdXQgZG9pbmcgYSBjb3B5XG4gICAgICBidWYgPSBidWYuc2xpY2UoYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlT2Zmc2V0ICsgYXJyLmJ5dGVMZW5ndGgpXG4gICAgfVxuICAgIHJldHVybiBidWZcbiAgfSBlbHNlIHtcbiAgICAvLyBQYXNzIHRocm91Z2ggYWxsIG90aGVyIHR5cGVzIHRvIGBCdWZmZXIuZnJvbWBcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKVxuICB9XG59XG4iLCIvKiFcbiAqIFVBUGFyc2VyLmpzIHYwLjcuMjBcbiAqIExpZ2h0d2VpZ2h0IEphdmFTY3JpcHQtYmFzZWQgVXNlci1BZ2VudCBzdHJpbmcgcGFyc2VyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFpc2FsbWFuL3VhLXBhcnNlci1qc1xuICpcbiAqIENvcHlyaWdodCDCqSAyMDEyLTIwMTkgRmFpc2FsIFNhbG1hbiA8ZkBmYWlzYWxtYW4uY29tPlxuICogTGljZW5zZWQgdW5kZXIgTUlUIExpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24gKHdpbmRvdywgdW5kZWZpbmVkKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLy8vLy8vLy8vLy8vL1xuICAgIC8vIENvbnN0YW50c1xuICAgIC8vLy8vLy8vLy8vLy9cblxuXG4gICAgdmFyIExJQlZFUlNJT04gID0gJzAuNy4yMCcsXG4gICAgICAgIEVNUFRZICAgICAgID0gJycsXG4gICAgICAgIFVOS05PV04gICAgID0gJz8nLFxuICAgICAgICBGVU5DX1RZUEUgICA9ICdmdW5jdGlvbicsXG4gICAgICAgIFVOREVGX1RZUEUgID0gJ3VuZGVmaW5lZCcsXG4gICAgICAgIE9CSl9UWVBFICAgID0gJ29iamVjdCcsXG4gICAgICAgIFNUUl9UWVBFICAgID0gJ3N0cmluZycsXG4gICAgICAgIE1BSk9SICAgICAgID0gJ21ham9yJywgLy8gZGVwcmVjYXRlZFxuICAgICAgICBNT0RFTCAgICAgICA9ICdtb2RlbCcsXG4gICAgICAgIE5BTUUgICAgICAgID0gJ25hbWUnLFxuICAgICAgICBUWVBFICAgICAgICA9ICd0eXBlJyxcbiAgICAgICAgVkVORE9SICAgICAgPSAndmVuZG9yJyxcbiAgICAgICAgVkVSU0lPTiAgICAgPSAndmVyc2lvbicsXG4gICAgICAgIEFSQ0hJVEVDVFVSRT0gJ2FyY2hpdGVjdHVyZScsXG4gICAgICAgIENPTlNPTEUgICAgID0gJ2NvbnNvbGUnLFxuICAgICAgICBNT0JJTEUgICAgICA9ICdtb2JpbGUnLFxuICAgICAgICBUQUJMRVQgICAgICA9ICd0YWJsZXQnLFxuICAgICAgICBTTUFSVFRWICAgICA9ICdzbWFydHR2JyxcbiAgICAgICAgV0VBUkFCTEUgICAgPSAnd2VhcmFibGUnLFxuICAgICAgICBFTUJFRERFRCAgICA9ICdlbWJlZGRlZCc7XG5cblxuICAgIC8vLy8vLy8vLy8vXG4gICAgLy8gSGVscGVyXG4gICAgLy8vLy8vLy8vL1xuXG5cbiAgICB2YXIgdXRpbCA9IHtcbiAgICAgICAgZXh0ZW5kIDogZnVuY3Rpb24gKHJlZ2V4ZXMsIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIHZhciBtZXJnZWRSZWdleGVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHJlZ2V4ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uc1tpXSAmJiBleHRlbnNpb25zW2ldLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkUmVnZXhlc1tpXSA9IGV4dGVuc2lvbnNbaV0uY29uY2F0KHJlZ2V4ZXNbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFJlZ2V4ZXNbaV0gPSByZWdleGVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXJnZWRSZWdleGVzO1xuICAgICAgICB9LFxuICAgICAgICBoYXMgOiBmdW5jdGlvbiAoc3RyMSwgc3RyMikge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RyMSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjIudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cjEudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb3dlcml6ZSA6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFqb3IgOiBmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZih2ZXJzaW9uKSA9PT0gU1RSX1RZUEUgPyB2ZXJzaW9uLnJlcGxhY2UoL1teXFxkXFwuXS9nLCcnKS5zcGxpdChcIi5cIilbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaW0gOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gTWFwIGhlbHBlclxuICAgIC8vLy8vLy8vLy8vLy8vXG5cblxuICAgIHZhciBtYXBwZXIgPSB7XG5cbiAgICAgICAgcmd4IDogZnVuY3Rpb24gKHVhLCBhcnJheXMpIHtcblxuICAgICAgICAgICAgdmFyIGkgPSAwLCBqLCBrLCBwLCBxLCBtYXRjaGVzLCBtYXRjaDtcblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCByZWdleGVzIG1hcHNcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYXJyYXlzLmxlbmd0aCAmJiAhbWF0Y2hlcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gYXJyYXlzW2ldLCAgICAgICAvLyBldmVuIHNlcXVlbmNlICgwLDIsNCwuLilcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBhcnJheXNbaSArIDFdOyAgIC8vIG9kZCBzZXF1ZW5jZSAoMSwzLDUsLi4pXG4gICAgICAgICAgICAgICAgaiA9IGsgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IG1hdGNoaW5nIHVhc3RyaW5nIHdpdGggcmVnZXhlc1xuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgcmVnZXgubGVuZ3RoICYmICFtYXRjaGVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHJlZ2V4W2orK10uZXhlYyh1YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwID0gMDsgcCA8IHByb3BzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzWysra107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHByb3BzW3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGdpdmVuIHByb3BlcnR5IGlzIGFjdHVhbGx5IGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxID09PSBPQkpfVFlQRSAmJiBxLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcVsxXSA9PSBGVU5DX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gbW9kaWZpZWQgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gcVsxXS5jYWxsKHRoaXMsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzaWduIGdpdmVuIHZhbHVlLCBpZ25vcmUgcmVnZXggbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gcVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGZ1bmN0aW9uIG9yIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHFbMV0gPT09IEZVTkNfVFlQRSAmJiAhKHFbMV0uZXhlYyAmJiBxWzFdLnRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBmdW5jdGlvbiAodXN1YWxseSBzdHJpbmcgbWFwcGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBtYXRjaCA/IHFbMV0uY2FsbCh0aGlzLCBtYXRjaCwgcVsyXSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbml0aXplIG1hdGNoIHVzaW5nIGdpdmVuIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1txWzBdXSA9IG1hdGNoID8gbWF0Y2gucmVwbGFjZShxWzFdLCBxWzJdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1txWzBdXSA9IG1hdGNoID8gcVszXS5jYWxsKHRoaXMsIG1hdGNoLnJlcGxhY2UocVsxXSwgcVsyXSkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1txXSA9IG1hdGNoID8gbWF0Y2ggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdHIgOiBmdW5jdGlvbiAoc3RyLCBtYXApIHtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBhcnJheVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFwW2ldID09PSBPQkpfVFlQRSAmJiBtYXBbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcFtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWwuaGFzKG1hcFtpXVtqXSwgc3RyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaSA9PT0gVU5LTk9XTikgPyB1bmRlZmluZWQgOiBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmhhcyhtYXBbaV0sIHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpID09PSBVTktOT1dOKSA/IHVuZGVmaW5lZCA6IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN0cmluZyBtYXBcbiAgICAvLy8vLy8vLy8vLy8vL1xuXG5cbiAgICB2YXIgbWFwcyA9IHtcblxuICAgICAgICBicm93c2VyIDoge1xuICAgICAgICAgICAgb2xkc2FmYXJpIDoge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gOiB7XG4gICAgICAgICAgICAgICAgICAgICcxLjAnICAgOiAnLzgnLFxuICAgICAgICAgICAgICAgICAgICAnMS4yJyAgIDogJy8xJyxcbiAgICAgICAgICAgICAgICAgICAgJzEuMycgICA6ICcvMycsXG4gICAgICAgICAgICAgICAgICAgICcyLjAnICAgOiAnLzQxMicsXG4gICAgICAgICAgICAgICAgICAgICcyLjAuMicgOiAnLzQxNicsXG4gICAgICAgICAgICAgICAgICAgICcyLjAuMycgOiAnLzQxNycsXG4gICAgICAgICAgICAgICAgICAgICcyLjAuNCcgOiAnLzQxOScsXG4gICAgICAgICAgICAgICAgICAgICc/JyAgICAgOiAnLydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV2aWNlIDoge1xuICAgICAgICAgICAgYW1hem9uIDoge1xuICAgICAgICAgICAgICAgIG1vZGVsIDoge1xuICAgICAgICAgICAgICAgICAgICAnRmlyZSBQaG9uZScgOiBbJ1NEJywgJ0tGJ11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3ByaW50IDoge1xuICAgICAgICAgICAgICAgIG1vZGVsIDoge1xuICAgICAgICAgICAgICAgICAgICAnRXZvIFNoaWZ0IDRHJyA6ICc3MzczS1QnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2ZW5kb3IgOiB7XG4gICAgICAgICAgICAgICAgICAgICdIVEMnICAgICAgIDogJ0FQQScsXG4gICAgICAgICAgICAgICAgICAgICdTcHJpbnQnICAgIDogJ1NwcmludCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3MgOiB7XG4gICAgICAgICAgICB3aW5kb3dzIDoge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gOiB7XG4gICAgICAgICAgICAgICAgICAgICdNRScgICAgICAgIDogJzQuOTAnLFxuICAgICAgICAgICAgICAgICAgICAnTlQgMy4xMScgICA6ICdOVDMuNTEnLFxuICAgICAgICAgICAgICAgICAgICAnTlQgNC4wJyAgICA6ICdOVDQuMCcsXG4gICAgICAgICAgICAgICAgICAgICcyMDAwJyAgICAgIDogJ05UIDUuMCcsXG4gICAgICAgICAgICAgICAgICAgICdYUCcgICAgICAgIDogWydOVCA1LjEnLCAnTlQgNS4yJ10sXG4gICAgICAgICAgICAgICAgICAgICdWaXN0YScgICAgIDogJ05UIDYuMCcsXG4gICAgICAgICAgICAgICAgICAgICc3JyAgICAgICAgIDogJ05UIDYuMScsXG4gICAgICAgICAgICAgICAgICAgICc4JyAgICAgICAgIDogJ05UIDYuMicsXG4gICAgICAgICAgICAgICAgICAgICc4LjEnICAgICAgIDogJ05UIDYuMycsXG4gICAgICAgICAgICAgICAgICAgICcxMCcgICAgICAgIDogWydOVCA2LjQnLCAnTlQgMTAuMCddLFxuICAgICAgICAgICAgICAgICAgICAnUlQnICAgICAgICA6ICdBUk0nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBSZWdleCBtYXBcbiAgICAvLy8vLy8vLy8vLy8vXG5cblxuICAgIHZhciByZWdleGVzID0ge1xuXG4gICAgICAgIGJyb3dzZXIgOiBbW1xuXG4gICAgICAgICAgICAvLyBQcmVzdG8gYmFzZWRcbiAgICAgICAgICAgIC8ob3BlcmFcXHNtaW5pKVxcLyhbXFx3XFwuLV0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIE1pbmlcbiAgICAgICAgICAgIC8ob3BlcmFcXHNbbW9iaWxldGFiXSspLit2ZXJzaW9uXFwvKFtcXHdcXC4tXSspL2ksICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIE1vYmkvVGFibGV0XG4gICAgICAgICAgICAvKG9wZXJhKS4rdmVyc2lvblxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhID4gOS44MFxuICAgICAgICAgICAgLyhvcGVyYSlbXFwvXFxzXSsoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgPCA5LjgwXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhvcGlvcylbXFwvXFxzXSsoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgbWluaSBvbiBpcGhvbmUgPj0gOC4wXG4gICAgICAgICAgICBdLCBbW05BTUUsICdPcGVyYSBNaW5pJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC9cXHMob3ByKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIFdlYmtpdFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnT3BlcmEnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLy8gTWl4ZWRcbiAgICAgICAgICAgIC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlXG4gICAgICAgICAgICAvKGx1bmFzY2FwZXxtYXh0aG9ufG5ldGZyb250fGphc21pbmV8YmxhemVyKVtcXC9cXHNdPyhbXFx3XFwuXSopL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEx1bmFzY2FwZS9NYXh0aG9uL05ldGZyb250L0phc21pbmUvQmxhemVyXG5cbiAgICAgICAgICAgIC8vIFRyaWRlbnQgYmFzZWRcbiAgICAgICAgICAgIC8oYXZhbnRcXHN8aWVtb2JpbGV8c2xpbXxiYWlkdSkoPzpicm93c2VyKT9bXFwvXFxzXT8oW1xcd1xcLl0qKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdmFudC9JRU1vYmlsZS9TbGltQnJvd3Nlci9CYWlkdVxuICAgICAgICAgICAgLyg/Om1zfFxcKCkoaWUpXFxzKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXJcblxuICAgICAgICAgICAgLy8gV2Via2l0L0tIVE1MIGJhc2VkXG4gICAgICAgICAgICAvKHJla29ucSlcXC8oW1xcd1xcLl0qKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJla29ucVxuICAgICAgICAgICAgLyhjaHJvbWl1bXxmbG9ja3xyb2NrbWVsdHxtaWRvcml8ZXBpcGhhbnl8c2lsa3xza3lmaXJlfG92aWJyb3dzZXJ8Ym9sdHxpcm9ufHZpdmFsZGl8aXJpZGl1bXxwaGFudG9tanN8Ym93c2VyfHF1YXJrfHF1cHppbGxhfGZhbGtvbilcXC8oW1xcd1xcLi1dKykvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bS9GbG9jay9Sb2NrTWVsdC9NaWRvcmkvRXBpcGhhbnkvU2lsay9Ta3lmaXJlL0JvbHQvSXJvbi9JcmlkaXVtL1BoYW50b21KUy9Cb3dzZXIvUXVwWmlsbGEvRmFsa29uXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhrb25xdWVyb3IpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLb25xdWVyb3JcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0tvbnF1ZXJvciddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKHRyaWRlbnQpLitydls6XFxzXShbXFx3XFwuXSspLitsaWtlXFxzZ2Vja28vaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTExXG4gICAgICAgICAgICBdLCBbW05BTUUsICdJRSddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKGVkZ2V8ZWRnaW9zfGVkZ2F8ZWRnKVxcLygoXFxkKyk/W1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgRWRnZVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnRWRnZSddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKHlhYnJvd3NlcilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFlhbmRleFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnWWFuZGV4J10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8ocHVmZmluKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVmZmluXG4gICAgICAgICAgICBdLCBbW05BTUUsICdQdWZmaW4nXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhmb2N1cylcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IEZvY3VzXG4gICAgICAgICAgICBdLCBbW05BTUUsICdGaXJlZm94IEZvY3VzJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8ob3B0KVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgVG91Y2hcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ09wZXJhIFRvdWNoJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oKD86W1xcc1xcL10pdWM/XFxzP2Jyb3dzZXJ8KD86anVjLispdWN3ZWIpW1xcL1xcc10/KFtcXHdcXC5dKykvaSAgICAgICAgIC8vIFVDQnJvd3NlclxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnVUNCcm93c2VyJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oY29tb2RvX2RyYWdvbilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tb2RvIERyYWdvblxuICAgICAgICAgICAgXSwgW1tOQU1FLCAvXy9nLCAnICddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKHdpbmRvd3N3ZWNoYXQgcWJjb3JlKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlQ2hhdCBEZXNrdG9wIGZvciBXaW5kb3dzIEJ1aWx0LWluIEJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1dlQ2hhdChXaW4pIERlc2t0b3AnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhtaWNyb21lc3NlbmdlcilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZUNoYXRcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1dlQ2hhdCddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKGJyYXZlKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnJhdmUgYnJvd3NlclxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnQnJhdmUnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhxcWJyb3dzZXJsaXRlKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRUUJyb3dzZXJMaXRlXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhRUSlcXC8oW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRUSwgYWthIFNob3VRXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL20/KHFxYnJvd3NlcilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUVFCcm93c2VyXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhCSURVQnJvd3NlcilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFpZHUgQnJvd3NlclxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oMjM0NUV4cGxvcmVyKVtcXC9cXHNdPyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIzNDUgQnJvd3NlclxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oTWV0YVNyKVtcXC9cXHNdPyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvdUdvdUJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtOQU1FXSwgW1xuXG4gICAgICAgICAgICAvKExCQlJPV1NFUikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGllQmFvIEJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtOQU1FXSwgW1xuXG4gICAgICAgICAgICAveGlhb21pXFwvbWl1aWJyb3dzZXJcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNSVVJIEJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ01JVUkgQnJvd3NlciddXSwgW1xuXG4gICAgICAgICAgICAvO2ZiYXZcXC8oW1xcd1xcLl0rKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhY2Vib29rIEFwcCBmb3IgaU9TICYgQW5kcm9pZFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnRmFjZWJvb2snXV0sIFtcblxuICAgICAgICAgICAgL3NhZmFyaVxccyhsaW5lKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGluZSBBcHAgZm9yIGlPU1xuICAgICAgICAgICAgL2FuZHJvaWQuKyhsaW5lKVxcLyhbXFx3XFwuXSspXFwvaWFiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGluZSBBcHAgZm9yIEFuZHJvaWRcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvaGVhZGxlc3NjaHJvbWUoPzpcXC8oW1xcd1xcLl0rKXxcXHMpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgSGVhZGxlc3NcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0Nocm9tZSBIZWFkbGVzcyddXSwgW1xuXG4gICAgICAgICAgICAvXFxzd3ZcXCkuKyhjaHJvbWUpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIFdlYlZpZXdcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgLyguKykvLCAnJDEgV2ViVmlldyddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKCg/Om9jdWx1c3xzYW1zdW5nKWJyb3dzZXIpXFwvKFtcXHdcXC5dKykvaVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAvKC4rKD86Z3x1cykpKC4rKS8sICckMSAkMiddLCBWRVJTSU9OXSwgWyAgICAgICAgICAgICAgICAvLyBPY3VsdXMgLyBTYW1zdW5nIEJyb3dzZXJcblxuICAgICAgICAgICAgL2FuZHJvaWQuK3ZlcnNpb25cXC8oW1xcd1xcLl0rKVxccysoPzptb2JpbGVcXHM/c2FmYXJpfHNhZmFyaSkqL2kgICAgICAgIC8vIEFuZHJvaWQgQnJvd3NlclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnQW5kcm9pZCBCcm93c2VyJ11dLCBbXG5cbiAgICAgICAgICAgIC8oc2FpbGZpc2hicm93c2VyKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2FpbGZpc2ggQnJvd3NlclxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnU2FpbGZpc2ggQnJvd3NlciddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKGNocm9tZXxvbW5pd2VifGFyb3JhfFt0aXplbm9rYV17NX1cXHM/YnJvd3NlcilcXC92PyhbXFx3XFwuXSspL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lL09tbmlXZWIvQXJvcmEvVGl6ZW4vTm9raWFcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKGRvbGZpbilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbHBoaW5cbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0RvbHBoaW4nXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLygoPzphbmRyb2lkLispY3Jtb3xjcmlvcylcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQvaU9TXG4gICAgICAgICAgICBdLCBbW05BTUUsICdDaHJvbWUnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhjb2FzdClcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBDb2FzdFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnT3BlcmEgQ29hc3QnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL2Z4aW9zXFwvKFtcXHdcXC4tXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGZvciBpT1NcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0ZpcmVmb3gnXV0sIFtcblxuICAgICAgICAgICAgL3ZlcnNpb25cXC8oW1xcd1xcLl0rKS4rP21vYmlsZVxcL1xcdytcXHMoc2FmYXJpKS9pICAgICAgICAgICAgICAgICAgICAgICAvLyBNb2JpbGUgU2FmYXJpXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdNb2JpbGUgU2FmYXJpJ11dLCBbXG5cbiAgICAgICAgICAgIC92ZXJzaW9uXFwvKFtcXHdcXC5dKykuKz8obW9iaWxlXFxzP3NhZmFyaXxzYWZhcmkpL2kgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSAmIFNhZmFyaSBNb2JpbGVcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXSwgW1xuXG4gICAgICAgICAgICAvd2Via2l0Lis/KGdzYSlcXC8oW1xcd1xcLl0rKS4rPyhtb2JpbGVcXHM/c2FmYXJpfHNhZmFyaSkoXFwvW1xcd1xcLl0rKS9pICAvLyBHb29nbGUgU2VhcmNoIEFwcGxpYW5jZSBvbiBpT1NcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0dTQSddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvd2Via2l0Lis/KG1vYmlsZVxccz9zYWZhcml8c2FmYXJpKShcXC9bXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPCAzLjBcbiAgICAgICAgICAgIF0sIFtOQU1FLCBbVkVSU0lPTiwgbWFwcGVyLnN0ciwgbWFwcy5icm93c2VyLm9sZHNhZmFyaS52ZXJzaW9uXV0sIFtcblxuICAgICAgICAgICAgLyh3ZWJraXR8a2h0bWwpXFwvKFtcXHdcXC5dKykvaVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8vIEdlY2tvIGJhc2VkXG4gICAgICAgICAgICAvKG5hdmlnYXRvcnxuZXRzY2FwZSlcXC8oW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHNjYXBlXG4gICAgICAgICAgICBdLCBbW05BTUUsICdOZXRzY2FwZSddLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyhzd2lmdGZveCkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2lmdGZveFxuICAgICAgICAgICAgLyhpY2VkcmFnb258aWNld2Vhc2VsfGNhbWlub3xjaGltZXJhfGZlbm5lY3xtYWVtb1xcc2Jyb3dzZXJ8bWluaW1vfGNvbmtlcm9yKVtcXC9cXHNdPyhbXFx3XFwuXFwrXSspL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEljZURyYWdvbi9JY2V3ZWFzZWwvQ2FtaW5vL0NoaW1lcmEvRmVubmVjL01hZW1vL01pbmltby9Db25rZXJvclxuICAgICAgICAgICAgLyhmaXJlZm94fHNlYW1vbmtleXxrLW1lbGVvbnxpY2VjYXR8aWNlYXBlfGZpcmViaXJkfHBob2VuaXh8cGFsZW1vb258YmFzaWxpc2t8d2F0ZXJmb3gpXFwvKFtcXHdcXC4tXSspJC9pLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3gvU2VhTW9ua2V5L0stTWVsZW9uL0ljZUNhdC9JY2VBcGUvRmlyZWJpcmQvUGhvZW5peFxuICAgICAgICAgICAgLyhtb3ppbGxhKVxcLyhbXFx3XFwuXSspLitydlxcOi4rZ2Vja29cXC9cXGQrL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ppbGxhXG5cbiAgICAgICAgICAgIC8vIE90aGVyXG4gICAgICAgICAgICAvKHBvbGFyaXN8bHlueHxkaWxsb3xpY2FifGRvcmlzfGFtYXlhfHczbXxuZXRzdXJmfHNsZWlwbmlyKVtcXC9cXHNdPyhbXFx3XFwuXSspL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvbGFyaXMvTHlueC9EaWxsby9pQ2FiL0RvcmlzL0FtYXlhL3czbS9OZXRTdXJmL1NsZWlwbmlyXG4gICAgICAgICAgICAvKGxpbmtzKVxcc1xcKChbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW5rc1xuICAgICAgICAgICAgLyhnb2Jyb3dzZXIpXFwvPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb0Jyb3dzZXJcbiAgICAgICAgICAgIC8oaWNlXFxzP2Jyb3dzZXIpXFwvdj8oW1xcd1xcLl9dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElDRSBCcm93c2VyXG4gICAgICAgICAgICAvKG1vc2FpYylbXFwvXFxzXShbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3NhaWNcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXVxuICAgICAgICBdLFxuXG4gICAgICAgIGNwdSA6IFtbXG5cbiAgICAgICAgICAgIC8oPzooYW1kfHgoPzooPzo4Nnw2NClbXy1dKT98d293fHdpbik2NClbO1xcKV0vaSAgICAgICAgICAgICAgICAgICAgIC8vIEFNRDY0XG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ2FtZDY0J11dLCBbXG5cbiAgICAgICAgICAgIC8oaWEzMig/PTspKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUEzMiAocXVpY2t0aW1lKVxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsIHV0aWwubG93ZXJpemVdXSwgW1xuXG4gICAgICAgICAgICAvKCg/OmlbMzQ2XXx4KTg2KVs7XFwpXS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJQTMyXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ2lhMzInXV0sIFtcblxuICAgICAgICAgICAgLy8gUG9ja2V0UEMgbWlzdGFrZW5seSBpZGVudGlmaWVkIGFzIFBvd2VyUENcbiAgICAgICAgICAgIC93aW5kb3dzXFxzKGNlfG1vYmlsZSk7XFxzcHBjOy9pXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ2FybSddXSwgW1xuXG4gICAgICAgICAgICAvKCg/OnBwY3xwb3dlcnBjKSg/OjY0KT8pKD86XFxzbWFjfDt8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG93ZXJQQ1xuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsIC9vd2VyLywgJycsIHV0aWwubG93ZXJpemVdXSwgW1xuXG4gICAgICAgICAgICAvKHN1bjRcXHcpWztcXCldL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU1BBUkNcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnc3BhcmMnXV0sIFtcblxuICAgICAgICAgICAgLygoPzphdnIzMnxpYTY0KD89OykpfDY4ayg/PVxcKSl8YXJtKD86NjR8KD89dlxcZCtbO2xdKSl8KD89YXRtZWxcXHMpYXZyfCg/OmlyaXh8bWlwc3xzcGFyYykoPzo2NCk/KD89Oyl8cGEtcmlzYykvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJQTY0LCA2OEssIEFSTS82NCwgQVZSLzMyLCBJUklYLzY0LCBNSVBTLzY0LCBTUEFSQy82NCwgUEEtUklTQ1xuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsIHV0aWwubG93ZXJpemVdXVxuICAgICAgICBdLFxuXG4gICAgICAgIGRldmljZSA6IFtbXG5cbiAgICAgICAgICAgIC9cXCgoaXBhZHxwbGF5Ym9vayk7W1xcd1xcc1xcKSw7LV0rKHJpbXxhcHBsZSkvaSAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlQYWQvUGxheUJvb2tcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgVkVORE9SLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FwcGxlY29yZW1lZGlhXFwvW1xcd1xcLl0rIFxcKChpcGFkKS8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaVBhZFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQXBwbGUnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8oYXBwbGVcXHN7MCwxfXR2KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxlIFRWXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnQXBwbGUgVFYnXSwgW1ZFTkRPUiwgJ0FwcGxlJ11dLCBbXG5cbiAgICAgICAgICAgIC8oYXJjaG9zKVxccyhnYW1lcGFkMj8pL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyY2hvc1xuICAgICAgICAgICAgLyhocCkuKyh0b3VjaHBhZCkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIUCBUb3VjaFBhZFxuICAgICAgICAgICAgLyhocCkuKyh0YWJsZXQpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIUCBUYWJsZXRcbiAgICAgICAgICAgIC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlXG4gICAgICAgICAgICAvXFxzKG5vb2spW1xcd1xcc10rYnVpbGRcXC8oXFx3KykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9va1xuICAgICAgICAgICAgLyhkZWxsKVxccyhzdHJlYVtrcHJcXHNcXGRdKltcXGRrb10pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsbCBTdHJlYWtcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLyhrZltBLXpdKylcXHNidWlsZFxcLy4rc2lsa1xcLy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLaW5kbGUgRmlyZSBIRFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQW1hem9uJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyhzZHxrZilbMDM0OWhpam9yc3R1d10rXFxzYnVpbGRcXC8uK3NpbGtcXC8vaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIFBob25lXG4gICAgICAgICAgICBdLCBbW01PREVMLCBtYXBwZXIuc3RyLCBtYXBzLmRldmljZS5hbWF6b24ubW9kZWxdLCBbVkVORE9SLCAnQW1hem9uJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL2FuZHJvaWQuK2FmdChbYm1zXSlcXHNidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZSBUVlxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQW1hem9uJ10sIFtUWVBFLCBTTUFSVFRWXV0sIFtcblxuICAgICAgICAgICAgL1xcKChpcFtob25lZHxcXHNcXHcqXSspOy4rKGFwcGxlKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUG9kL2lQaG9uZVxuICAgICAgICAgICAgXSwgW01PREVMLCBWRU5ET1IsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcKChpcFtob25lZHxcXHNcXHcqXSspOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUG9kL2lQaG9uZVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQXBwbGUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8oYmxhY2tiZXJyeSlbXFxzLV0/KFxcdyspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja0JlcnJ5XG4gICAgICAgICAgICAvKGJsYWNrYmVycnl8YmVucXxwYWxtKD89XFwtKXxzb255ZXJpY3Nzb258YWNlcnxhc3VzfGRlbGx8bWVpenV8bW90b3JvbGF8cG9seXRyb24pW1xcc18tXT8oW1xcdy1dKikvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVuUS9QYWxtL1NvbnktRXJpY3Nzb24vQWNlci9Bc3VzL0RlbGwvTWVpenUvTW90b3JvbGEvUG9seXRyb25cbiAgICAgICAgICAgIC8oaHApXFxzKFtcXHdcXHNdK1xcdykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhQIGlQQVFcbiAgICAgICAgICAgIC8oYXN1cyktPyhcXHcrKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzdXNcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXChiYjEwO1xccyhcXHcrKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tCZXJyeSAxMFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQmxhY2tCZXJyeSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXN1cyBUYWJsZXRzXG4gICAgICAgICAgICAvYW5kcm9pZC4rKHRyYW5zZm9bcHJpbWVcXHNdezQsMTB9XFxzXFx3K3xlZWVwY3xzbGlkZXJcXHNcXHcrfG5leHVzIDd8cGFkZm9uZXxwMDBjKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBc3VzJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvKHNvbnkpXFxzKHRhYmxldFxcc1twc10pXFxzYnVpbGRcXC8vaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ueVxuICAgICAgICAgICAgLyhzb255KT8oPzpzZ3AuKylcXHNidWlsZFxcLy9pXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ1NvbnknXSwgW01PREVMLCAnWHBlcmlhIFRhYmxldCddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9hbmRyb2lkLitcXHMoW2MtZ11cXGR7NH18c29bLWxdXFx3KykoPz1cXHNidWlsZFxcL3xcXCkuK2Nocm9tZVxcLyg/IVsxLTZdezAsMX1cXGRcXC4pKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTb255J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvXFxzKG91eWEpXFxzL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3V5YVxuICAgICAgICAgICAgLyhuaW50ZW5kbylcXHMoW3dpZHMzdV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmludGVuZG9cbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgQ09OU09MRV1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKHNoaWVsZClcXHNidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOdmlkaWFcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ052aWRpYSddLCBbVFlQRSwgQ09OU09MRV1dLCBbXG5cbiAgICAgICAgICAgIC8ocGxheXN0YXRpb25cXHNbMzRwb3J0YWJsZXZpXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYXlzdGF0aW9uXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTb255J10sIFtUWVBFLCBDT05TT0xFXV0sIFtcblxuICAgICAgICAgICAgLyhzcHJpbnRcXHMoXFx3KykpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwcmludCBQaG9uZXNcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCBtYXBwZXIuc3RyLCBtYXBzLmRldmljZS5zcHJpbnQudmVuZG9yXSwgW01PREVMLCBtYXBwZXIuc3RyLCBtYXBzLmRldmljZS5zcHJpbnQubW9kZWxdLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLyhodGMpWztfXFxzLV0rKFtcXHdcXHNdKyg/PVxcKXxcXHNidWlsZCl8XFx3KykvaSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBIVENcbiAgICAgICAgICAgIC8oenRlKS0oXFx3KikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFpURVxuICAgICAgICAgICAgLyhhbGNhdGVsfGdlZWtzcGhvbmV8bmV4aWFufHBhbmFzb25pY3woPz07XFxzKXNvbnkpW19cXHMtXT8oW1xcdy1dKikvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGNhdGVsL0dlZWtzUGhvbmUvTmV4aWFuL1BhbmFzb25pYy9Tb255XG4gICAgICAgICAgICBdLCBbVkVORE9SLCBbTU9ERUwsIC9fL2csICcgJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKG5leHVzXFxzOSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIVEMgTmV4dXMgOVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnSFRDJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvZFxcL2h1YXdlaShbXFx3XFxzLV0rKVs7XFwpXS9pLFxuICAgICAgICAgICAgLyhuZXh1c1xcczZwKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSHVhd2VpXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdIdWF3ZWknXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8obWljcm9zb2Z0KTtcXHMobHVtaWFbXFxzXFx3XSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IEx1bWlhXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9bXFxzXFwoO10oeGJveCg/Olxcc29uZSk/KVtcXHNcXCk7XS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgWGJveFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTWljcm9zb2Z0J10sIFtUWVBFLCBDT05TT0xFXV0sIFtcbiAgICAgICAgICAgIC8oa2luXFwuW29uZXR3XXszfSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBLaW5cbiAgICAgICAgICAgIF0sIFtbTU9ERUwsIC9cXC4vZywgJyAnXSwgW1ZFTkRPUiwgJ01pY3Jvc29mdCddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3Rvcm9sYVxuICAgICAgICAgICAgL1xccyhtaWxlc3RvbmV8ZHJvaWQoPzpbMi00eF18XFxzKD86YmlvbmljfHgyfHByb3xyYXpyKSk/Oj8oXFxzNGcpPylbXFx3XFxzXStidWlsZFxcLy9pLFxuICAgICAgICAgICAgL21vdFtcXHMtXT8oXFx3KikvaSxcbiAgICAgICAgICAgIC8oWFRcXGR7Myw0fSkgYnVpbGRcXC8vaSxcbiAgICAgICAgICAgIC8obmV4dXNcXHM2KS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdNb3Rvcm9sYSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9hbmRyb2lkLitcXHMobXo2MFxcZHx4b29tW1xcczJdezAsMn0pXFxzYnVpbGRcXC8vaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTW90b3JvbGEnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9oYmJ0dlxcL1xcZCtcXC5cXGQrXFwuXFxkK1xccytcXChbXFx3XFxzXSo7XFxzKihcXHdbXjtdKik7KFteO10qKS9pICAgICAgICAgICAgLy8gSGJiVFYgZGV2aWNlc1xuICAgICAgICAgICAgXSwgW1tWRU5ET1IsIHV0aWwudHJpbV0sIFtNT0RFTCwgdXRpbC50cmltXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuXG4gICAgICAgICAgICAvaGJidHYuK21hcGxlOyhcXGQrKS9pXG4gICAgICAgICAgICBdLCBbW01PREVMLCAvXi8sICdTbWFydFRWJ10sIFtWRU5ET1IsICdTYW1zdW5nJ10sIFtUWVBFLCBTTUFSVFRWXV0sIFtcblxuICAgICAgICAgICAgL1xcKGR0dltcXCk7XS4rKGFxdW9zKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYXJwXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTaGFycCddLCBbVFlQRSwgU01BUlRUVl1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLisoKHNjaC1pWzg5XTBcXGR8c2h3LW0zODBzfGd0LXBcXGR7NH18Z3QtblxcZCt8c2doLXQ4WzU2XTl8bmV4dXMgMTApKS9pLFxuICAgICAgICAgICAgLygoU00tVFxcdyspKS9pXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ1NhbXN1bmcnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgWyAgICAgICAgICAgICAgICAgIC8vIFNhbXN1bmdcbiAgICAgICAgICAgIC9zbWFydC10di4rKHNhbXN1bmcpL2lcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIFtUWVBFLCBTTUFSVFRWXSwgTU9ERUxdLCBbXG4gICAgICAgICAgICAvKChzW2NncF1oLVxcdyt8Z3QtXFx3K3xnYWxheHlcXHNuZXh1c3xzbS1cXHdbXFx3XFxkXSspKS9pLFxuICAgICAgICAgICAgLyhzYW1bc3VuZ10qKVtcXHMtXSooXFx3Ky0/W1xcdy1dKikvaSxcbiAgICAgICAgICAgIC9zZWMtKChzZ2hcXHcrKSkvaVxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdTYW1zdW5nJ10sIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL3NpZS0oXFx3KikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2llbWVuc1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU2llbWVucyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLyhtYWVtb3xub2tpYSkuKihuOTAwfGx1bWlhXFxzXFxkKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5va2lhXG4gICAgICAgICAgICAvKG5va2lhKVtcXHNfLV0/KFtcXHctXSopL2lcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnTm9raWEnXSwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZFt4XFxkXFwuXFxzO10rXFxzKFthYl1bMS03XVxcLT9bMDE3OGFdXFxkXFxkPykvaSAgICAgICAgICAgICAgICAgICAvLyBBY2VyXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBY2VyJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rKFt2bF1rXFwtP1xcZHszfSlcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExHIFRhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTEcnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvYW5kcm9pZFxcczNcXC5bXFxzXFx3Oy1dezEwfShsZz8pLShbMDZjdjldezMsNH0pL2kgICAgICAgICAgICAgICAgICAgICAvLyBMRyBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnTEcnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyhsZykgbmV0Y2FzdFxcLnR2L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTEcgU21hcnRUVlxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC8obmV4dXNcXHNbNDVdKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExHXG4gICAgICAgICAgICAvbGdbZTtcXHNcXC8tXSsoXFx3KikvaSxcbiAgICAgICAgICAgIC9hbmRyb2lkLitsZyhcXC0/W1xcZFxcd10rKVxccytidWlsZC9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdMRyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLyhsZW5vdm8pXFxzPyhzKD86NTAwMHw2MDAwKSg/OltcXHctXSspfHRhYig/OltcXHNcXHddKykpL2kgICAgICAgICAgICAgLy8gTGVub3ZvIHRhYmxldHNcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9hbmRyb2lkLisoaWRlYXRhYlthLXowLTlcXC1cXHNdKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZW5vdm9cbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0xlbm92byddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8obGVub3ZvKVtfXFxzLV0/KFtcXHctXSspL2lcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL2xpbnV4Oy4rKChqb2xsYSkpOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKb2xsYVxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKChwZWJibGUpKWFwcFxcL1tcXGRcXC5dK1xccy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQZWJibGVcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgV0VBUkFCTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rO1xccyhvcHBvKVxccz8oW1xcd1xcc10rKVxcc2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT1BQT1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvY3JrZXkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBDaHJvbWVjYXN0XG4gICAgICAgICAgICBdLCBbW01PREVMLCAnQ2hyb21lY2FzdCddLCBbVkVORE9SLCAnR29vZ2xlJ11dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKGdsYXNzKVxcc1xcZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIEdsYXNzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdHb29nbGUnXSwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMocGl4ZWwgYylbXFxzKV0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBQaXhlbCBDXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdHb29nbGUnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKHBpeGVsKCBbMjNdKT8oIHhsKT8pW1xccyldL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgUGl4ZWxcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0dvb2dsZSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMoXFx3KylcXHMrYnVpbGRcXC9obVxcMS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhpYW9taSBIb25nbWkgJ251bWVyaWMnIG1vZGVsc1xuICAgICAgICAgICAgL2FuZHJvaWQuKyhobVtcXHNcXC1fXSpub3RlP1tcXHNfXSooPzpcXGRcXHcpPylcXHMrYnVpbGQvaSwgICAgICAgICAgICAgICAvLyBYaWFvbWkgSG9uZ21pXG4gICAgICAgICAgICAvYW5kcm9pZC4rKG1pW1xcc1xcLV9dKig/OmFcXGR8b25lfG9uZVtcXHNfXXBsdXN8bm90ZSBsdGUpP1tcXHNfXSooPzpcXGQ/XFx3PylbXFxzX10qKD86cGx1cyk/KVxccytidWlsZC9pLCAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWGlhb21pIE1pXG4gICAgICAgICAgICAvYW5kcm9pZC4rKHJlZG1pW1xcc1xcLV9dKig/Om5vdGUpPyg/OltcXHNfXSpbXFx3XFxzXSspKVxccytidWlsZC9pICAgICAgIC8vIFJlZG1pIFBob25lc1xuICAgICAgICAgICAgXSwgW1tNT0RFTCwgL18vZywgJyAnXSwgW1ZFTkRPUiwgJ1hpYW9taSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9hbmRyb2lkLisobWlbXFxzXFwtX10qKD86cGFkKSg/OltcXHNfXSpbXFx3XFxzXSspKVxccytidWlsZC9pICAgICAgICAgICAgLy8gTWkgUGFkIHRhYmxldHNcbiAgICAgICAgICAgIF0sW1tNT0RFTCwgL18vZywgJyAnXSwgW1ZFTkRPUiwgJ1hpYW9taSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKG1bMS01XVxcc25vdGUpXFxzYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVpenVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01laXp1J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhteiktKFtcXHctXXsyLH0pL2lcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnTWVpenUnXSwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rYTAwMCgxKVxccytidWlsZC9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmVQbHVzXG4gICAgICAgICAgICAvYW5kcm9pZC4rb25lcGx1c1xccyhhXFxkezR9KVxccytidWlsZC9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdPbmVQbHVzJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihSQ1RbXFxkXFx3XSspXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkNBIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1JDQSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXFxzXSsoVmVudWVbXFxkXFxzXXsyLDd9KVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGwgVmVudWUgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRGVsbCddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooUVtUfE1dW1xcZFxcd10rKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZlcml6b24gVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdWZXJpem9uJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKyhCYXJuZXNbJlxcc10rTm9ibGVcXHMrfEJOW1JUXSkoVj8uKilcXHMrYnVpbGQvaSAgICAgLy8gQmFybmVzICYgTm9ibGUgVGFibGV0XG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0Jhcm5lcyAmIE5vYmxlJ10sIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccysoVE1cXGR7M30uKlxcYilcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhcm5lcyAmIE5vYmxlIFRhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTnVWaXNpb24nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKGs4OClcXHNidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBaVEUgSyBTZXJpZXMgVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdaVEUnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKGdlblxcZHszfSlcXHMrYnVpbGQuKjQ5aC9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3aXNzIEdFTiBNb2JpbGVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1N3aXNzJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKih6dXJcXGR7M30pXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2lzcyBaVVIgVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTd2lzcyddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooKFpla2kpP1RCLipcXGIpXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWmVraSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdaZWtpJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvKGFuZHJvaWQpLitbO1xcL11cXHMrKFtZUl1cXGR7Mn0pXFxzK2J1aWxkL2ksXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKyhEcmFnb25bXFwtXFxzXStUb3VjaFxccyt8RFQpKFxcd3s1fSlcXHNidWlsZC9pICAgICAgICAvLyBEcmFnb24gVG91Y2ggVGFibGV0XG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0RyYWdvbiBUb3VjaCddLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKE5TLT9cXHd7MCw5fSlcXHNidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2lnbmlhIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0luc2lnbmlhJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKigoTlh8TmV4dCktP1xcd3swLDl9KVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAvLyBOZXh0Qm9vayBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdOZXh0Qm9vayddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooWHRyZW1lXFxfKT8oVigxWzA0NV18MlswMTVdfDMwfDQwfDYwfDdbMDVdfDkwKSlcXHMrYnVpbGQvaVxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdWb2ljZSddLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbICAgICAgICAgICAgICAgICAgICAvLyBWb2ljZSBYdHJlbWUgUGhvbmVzXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKExWVEVMXFwtKT8oVjFbMTJdKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgLy8gTHZUZWwgUGhvbmVzXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0x2VGVsJ10sIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMoUEgtMSlcXHMvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRXNzZW50aWFsJ10sIFtUWVBFLCBNT0JJTEVdXSwgWyAgICAgICAgICAgICAgICAvLyBFc3NlbnRpYWwgUEgtMVxuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihWKDEwME1EfDcwME5BfDcwMTF8OTE3RykuKlxcYilcXHMrYnVpbGQvaSAgICAgICAgICAvLyBFbnZpemVuIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0Vudml6ZW4nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKExlW1xcc1xcLV0rUGFuKVtcXHNcXC1dKyhcXHd7MSw5fSlcXHMrYnVpbGQvaSAgICAgICAgICAvLyBMZSBQYW4gVGFibGV0c1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihUcmlvW1xcc1xcLV0qLiopXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFjaFNwZWVkIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01hY2hTcGVlZCddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooVHJpbml0eSlbXFwtXFxzXSooVFxcZHszfSlcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAvLyBUcmluaXR5IFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccypUVV8oMTQ5MSlcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3RvciBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdSb3RvciddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKyhLUyguKykpXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW1hem9uIEtpbmRsZSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBbWF6b24nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLisoR2lnYXNldClbXFxzXFwtXSsoUVxcd3sxLDl9KVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgIC8vIEdpZ2FzZXQgVGFibGV0c1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvXFxzKHRhYmxldHx0YWIpWztcXC9dL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5pZGVudGlmaWFibGUgVGFibGV0XG4gICAgICAgICAgICAvXFxzKG1vYmlsZSkoPzpbO1xcL118XFxzc2FmYXJpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuaWRlbnRpZmlhYmxlIE1vYmlsZVxuICAgICAgICAgICAgXSwgW1tUWVBFLCB1dGlsLmxvd2VyaXplXSwgVkVORE9SLCBNT0RFTF0sIFtcblxuICAgICAgICAgICAgL1tcXHNcXC9cXChdKHNtYXJ0LT90dilbO1xcKV0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU21hcnRUVlxuICAgICAgICAgICAgXSwgW1tUWVBFLCBTTUFSVFRWXV0sIFtcblxuICAgICAgICAgICAgLyhhbmRyb2lkW1xcd1xcLlxcc1xcLV17MCw5fSk7LitidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJpYyBBbmRyb2lkIERldmljZVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnR2VuZXJpYyddXVxuICAgICAgICBdLFxuXG4gICAgICAgIGVuZ2luZSA6IFtbXG5cbiAgICAgICAgICAgIC93aW5kb3dzLitcXHNlZGdlXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVkZ2VIVE1MXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdFZGdlSFRNTCddXSwgW1xuXG4gICAgICAgICAgICAvd2Via2l0XFwvNTM3XFwuMzYuK2Nocm9tZVxcLyg/ITI3KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsaW5rXG4gICAgICAgICAgICBdLCBbW05BTUUsICdCbGluayddXSwgW1xuXG4gICAgICAgICAgICAvKHByZXN0bylcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXN0b1xuICAgICAgICAgICAgLyh3ZWJraXR8dHJpZGVudHxuZXRmcm9udHxuZXRzdXJmfGFtYXlhfGx5bnh8dzNtfGdvYW5uYSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlYktpdC9UcmlkZW50L05ldEZyb250L05ldFN1cmYvQW1heWEvTHlueC93M20vR29hbm5hXG4gICAgICAgICAgICAvKGtodG1sfHRhc21hbnxsaW5rcylbXFwvXFxzXVxcKD8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS0hUTUwvVGFzbWFuL0xpbmtzXG4gICAgICAgICAgICAvKGljYWIpW1xcL1xcc10oWzIzXVxcLltcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaUNhYlxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC9ydlxcOihbXFx3XFwuXXsxLDl9KS4rKGdlY2tvKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2Vja29cbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXVxuICAgICAgICBdLFxuXG4gICAgICAgIG9zIDogW1tcblxuICAgICAgICAgICAgLy8gV2luZG93cyBiYXNlZFxuICAgICAgICAgICAgL21pY3Jvc29mdFxccyh3aW5kb3dzKVxccyh2aXN0YXx4cCkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgKGlUdW5lcylcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyh3aW5kb3dzKVxcc250XFxzNlxcLjI7XFxzKGFybSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyBSVFxuICAgICAgICAgICAgLyh3aW5kb3dzXFxzcGhvbmUoPzpcXHNvcykqKVtcXHNcXC9dPyhbXFxkXFwuXFxzXFx3XSopL2ksICAgICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgUGhvbmVcbiAgICAgICAgICAgIC8od2luZG93c1xcc21vYmlsZXx3aW5kb3dzKVtcXHNcXC9dPyhbbnRjZVxcZFxcLlxcc10rXFx3KS9pXG4gICAgICAgICAgICBdLCBbTkFNRSwgW1ZFUlNJT04sIG1hcHBlci5zdHIsIG1hcHMub3Mud2luZG93cy52ZXJzaW9uXV0sIFtcbiAgICAgICAgICAgIC8od2luKD89M3w5fG4pfHdpblxcczl4XFxzKShbbnRcXGRcXC5dKykvaVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnV2luZG93cyddLCBbVkVSU0lPTiwgbWFwcGVyLnN0ciwgbWFwcy5vcy53aW5kb3dzLnZlcnNpb25dXSwgW1xuXG4gICAgICAgICAgICAvLyBNb2JpbGUvRW1iZWRkZWQgT1NcbiAgICAgICAgICAgIC9cXCgoYmIpKDEwKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrQmVycnkgMTBcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0JsYWNrQmVycnknXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8oYmxhY2tiZXJyeSlcXHcqXFwvPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrYmVycnlcbiAgICAgICAgICAgIC8odGl6ZW4pW1xcL1xcc10oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRpemVuXG4gICAgICAgICAgICAvKGFuZHJvaWR8d2Vib3N8cGFsbVxcc29zfHFueHxiYWRhfHJpbVxcc3RhYmxldFxcc29zfG1lZWdvfHNhaWxmaXNofGNvbnRpa2kpW1xcL1xccy1dPyhbXFx3XFwuXSopL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5kcm9pZC9XZWJPUy9QYWxtL1FOWC9CYWRhL1JJTS9NZWVHby9Db250aWtpL1NhaWxmaXNoIE9TXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8oc3ltYmlhblxccz9vc3xzeW1ib3N8czYwKD89OykpW1xcL1xccy1dPyhbXFx3XFwuXSopL2kgICAgICAgICAgICAgICAgICAvLyBTeW1iaWFuXG4gICAgICAgICAgICBdLCBbW05BTUUsICdTeW1iaWFuJ10sIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvXFwoKHNlcmllczQwKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXJpZXMgNDBcbiAgICAgICAgICAgIF0sIFtOQU1FXSwgW1xuICAgICAgICAgICAgL21vemlsbGEuK1xcKG1vYmlsZTsuK2dlY2tvLitmaXJlZm94L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBPU1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAnRmlyZWZveCBPUyddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvLyBDb25zb2xlXG4gICAgICAgICAgICAvKG5pbnRlbmRvfHBsYXlzdGF0aW9uKVxccyhbd2lkczM0cG9ydGFibGV2dV0rKS9pLCAgICAgICAgICAgICAgICAgICAvLyBOaW50ZW5kby9QbGF5c3RhdGlvblxuXG4gICAgICAgICAgICAvLyBHTlUvTGludXggYmFzZWRcbiAgICAgICAgICAgIC8obWludClbXFwvXFxzXFwoXT8oXFx3KikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pbnRcbiAgICAgICAgICAgIC8obWFnZWlhfHZlY3RvcmxpbnV4KVs7XFxzXS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hZ2VpYS9WZWN0b3JMaW51eFxuICAgICAgICAgICAgLyhqb2xpfFtreGxuXT91YnVudHV8ZGViaWFufHN1c2V8b3BlbnN1c2V8Z2VudG9vfCg/PVxccylhcmNofHNsYWNrd2FyZXxmZWRvcmF8bWFuZHJpdmF8Y2VudG9zfHBjbGludXhvc3xyZWRoYXR8emVud2Fsa3xsaW5wdXMpW1xcL1xccy1dPyg/IWNocm9tKShbXFx3XFwuLV0qKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKb2xpL1VidW50dS9EZWJpYW4vU1VTRS9HZW50b28vQXJjaC9TbGFja3dhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmVkb3JhL01hbmRyaXZhL0NlbnRPUy9QQ0xpbnV4T1MvUmVkSGF0L1plbndhbGsvTGlucHVzXG4gICAgICAgICAgICAvKGh1cmR8bGludXgpXFxzPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEh1cmQvTGludXhcbiAgICAgICAgICAgIC8oZ251KVxccz8oW1xcd1xcLl0qKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR05VXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhjcm9zKVxcc1tcXHddK1xccyhbXFx3XFwuXStcXHcpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bSBPU1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAnQ2hyb21pdW0gT1MnXSwgVkVSU0lPTl0sW1xuXG4gICAgICAgICAgICAvLyBTb2xhcmlzXG4gICAgICAgICAgICAvKHN1bm9zKVxccz8oW1xcd1xcLlxcZF0qKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb2xhcmlzXG4gICAgICAgICAgICBdLCBbW05BTUUsICdTb2xhcmlzJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8vIEJTRCBiYXNlZFxuICAgICAgICAgICAgL1xccyhbZnJlbnRvcGMtXXswLDR9YnNkfGRyYWdvbmZseSlcXHM/KFtcXHdcXC5dKikvaSAgICAgICAgICAgICAgICAgICAgLy8gRnJlZUJTRC9OZXRCU0QvT3BlbkJTRC9QQy1CU0QvRHJhZ29uRmx5XG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sW1xuXG4gICAgICAgICAgICAvKGhhaWt1KVxccyhcXHcrKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFpa3VcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSxbXG5cbiAgICAgICAgICAgIC9jZm5ldHdvcmtcXC8uK2Rhcndpbi9pLFxuICAgICAgICAgICAgL2lwW2hvbmVhZF17Miw0fSg/Oi4qb3NcXHMoW1xcd10rKVxcc2xpa2VcXHNtYWN8O1xcc29wZXJhKS9pICAgICAgICAgICAgIC8vIGlPU1xuICAgICAgICAgICAgXSwgW1tWRVJTSU9OLCAvXy9nLCAnLiddLCBbTkFNRSwgJ2lPUyddXSwgW1xuXG4gICAgICAgICAgICAvKG1hY1xcc29zXFxzeClcXHM/KFtcXHdcXHNcXC5dKikvaSxcbiAgICAgICAgICAgIC8obWFjaW50b3NofG1hYyg/PV9wb3dlcnBjKVxccykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hYyBPU1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAnTWFjIE9TJ10sIFtWRVJTSU9OLCAvXy9nLCAnLiddXSwgW1xuXG4gICAgICAgICAgICAvLyBPdGhlclxuICAgICAgICAgICAgLygoPzpvcGVuKT9zb2xhcmlzKVtcXC9cXHMtXT8oW1xcd1xcLl0qKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29sYXJpc1xuICAgICAgICAgICAgLyhhaXgpXFxzKChcXGQpKD89XFwufFxcKXxcXHMpW1xcd1xcLl0pKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQUlYXG4gICAgICAgICAgICAvKHBsYW5cXHM5fG1pbml4fGJlb3N8b3NcXC8yfGFtaWdhb3N8bW9ycGhvc3xyaXNjXFxzb3N8b3BlbnZtc3xmdWNoc2lhKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQbGFuOS9NaW5peC9CZU9TL09TMi9BbWlnYU9TL01vcnBoT1MvUklTQ09TL09wZW5WTVMvRnVjaHNpYVxuICAgICAgICAgICAgLyh1bml4KVxccz8oW1xcd1xcLl0qKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVTklYXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl1cbiAgICAgICAgXVxuICAgIH07XG5cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQ29uc3RydWN0b3JcbiAgICAvLy8vLy8vLy8vLy8vLy8vXG4gICAgdmFyIFVBUGFyc2VyID0gZnVuY3Rpb24gKHVhc3RyaW5nLCBleHRlbnNpb25zKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1YXN0cmluZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMgPSB1YXN0cmluZztcbiAgICAgICAgICAgIHVhc3RyaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVBUGFyc2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVQVBhcnNlcih1YXN0cmluZywgZXh0ZW5zaW9ucykuZ2V0UmVzdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdWEgPSB1YXN0cmluZyB8fCAoKHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSA/IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IDogRU1QVFkpO1xuICAgICAgICB2YXIgcmd4bWFwID0gZXh0ZW5zaW9ucyA/IHV0aWwuZXh0ZW5kKHJlZ2V4ZXMsIGV4dGVuc2lvbnMpIDogcmVnZXhlcztcblxuICAgICAgICB0aGlzLmdldEJyb3dzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYnJvd3NlciA9IHsgbmFtZTogdW5kZWZpbmVkLCB2ZXJzaW9uOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIG1hcHBlci5yZ3guY2FsbChicm93c2VyLCB1YSwgcmd4bWFwLmJyb3dzZXIpO1xuICAgICAgICAgICAgYnJvd3Nlci5tYWpvciA9IHV0aWwubWFqb3IoYnJvd3Nlci52ZXJzaW9uKTsgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNwdSA9IHsgYXJjaGl0ZWN0dXJlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIG1hcHBlci5yZ3guY2FsbChjcHUsIHVhLCByZ3htYXAuY3B1KTtcbiAgICAgICAgICAgIHJldHVybiBjcHU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0RGV2aWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRldmljZSA9IHsgdmVuZG9yOiB1bmRlZmluZWQsIG1vZGVsOiB1bmRlZmluZWQsIHR5cGU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgbWFwcGVyLnJneC5jYWxsKGRldmljZSwgdWEsIHJneG1hcC5kZXZpY2UpO1xuICAgICAgICAgICAgcmV0dXJuIGRldmljZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRFbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZW5naW5lID0geyBuYW1lOiB1bmRlZmluZWQsIHZlcnNpb246IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgbWFwcGVyLnJneC5jYWxsKGVuZ2luZSwgdWEsIHJneG1hcC5lbmdpbmUpO1xuICAgICAgICAgICAgcmV0dXJuIGVuZ2luZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRPUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcyA9IHsgbmFtZTogdW5kZWZpbmVkLCB2ZXJzaW9uOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIG1hcHBlci5yZ3guY2FsbChvcywgdWEsIHJneG1hcC5vcyk7XG4gICAgICAgICAgICByZXR1cm4gb3M7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1YSAgICAgIDogdGhpcy5nZXRVQSgpLFxuICAgICAgICAgICAgICAgIGJyb3dzZXIgOiB0aGlzLmdldEJyb3dzZXIoKSxcbiAgICAgICAgICAgICAgICBlbmdpbmUgIDogdGhpcy5nZXRFbmdpbmUoKSxcbiAgICAgICAgICAgICAgICBvcyAgICAgIDogdGhpcy5nZXRPUygpLFxuICAgICAgICAgICAgICAgIGRldmljZSAgOiB0aGlzLmdldERldmljZSgpLFxuICAgICAgICAgICAgICAgIGNwdSAgICAgOiB0aGlzLmdldENQVSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFVBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVhO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFVBID0gZnVuY3Rpb24gKHVhc3RyaW5nKSB7XG4gICAgICAgICAgICB1YSA9IHVhc3RyaW5nO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBVQVBhcnNlci5WRVJTSU9OID0gTElCVkVSU0lPTjtcbiAgICBVQVBhcnNlci5CUk9XU0VSID0ge1xuICAgICAgICBOQU1FICAgIDogTkFNRSxcbiAgICAgICAgTUFKT1IgICA6IE1BSk9SLCAvLyBkZXByZWNhdGVkXG4gICAgICAgIFZFUlNJT04gOiBWRVJTSU9OXG4gICAgfTtcbiAgICBVQVBhcnNlci5DUFUgPSB7XG4gICAgICAgIEFSQ0hJVEVDVFVSRSA6IEFSQ0hJVEVDVFVSRVxuICAgIH07XG4gICAgVUFQYXJzZXIuREVWSUNFID0ge1xuICAgICAgICBNT0RFTCAgIDogTU9ERUwsXG4gICAgICAgIFZFTkRPUiAgOiBWRU5ET1IsXG4gICAgICAgIFRZUEUgICAgOiBUWVBFLFxuICAgICAgICBDT05TT0xFIDogQ09OU09MRSxcbiAgICAgICAgTU9CSUxFICA6IE1PQklMRSxcbiAgICAgICAgU01BUlRUViA6IFNNQVJUVFYsXG4gICAgICAgIFRBQkxFVCAgOiBUQUJMRVQsXG4gICAgICAgIFdFQVJBQkxFOiBXRUFSQUJMRSxcbiAgICAgICAgRU1CRURERUQ6IEVNQkVEREVEXG4gICAgfTtcbiAgICBVQVBhcnNlci5FTkdJTkUgPSB7XG4gICAgICAgIE5BTUUgICAgOiBOQU1FLFxuICAgICAgICBWRVJTSU9OIDogVkVSU0lPTlxuICAgIH07XG4gICAgVUFQYXJzZXIuT1MgPSB7XG4gICAgICAgIE5BTUUgICAgOiBOQU1FLFxuICAgICAgICBWRVJTSU9OIDogVkVSU0lPTlxuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vL1xuICAgIC8vIEV4cG9ydFxuICAgIC8vLy8vLy8vLy9cblxuXG4gICAgLy8gY2hlY2sganMgZW52aXJvbm1lbnRcbiAgICBpZiAodHlwZW9mKGV4cG9ydHMpICE9PSBVTkRFRl9UWVBFKSB7XG4gICAgICAgIC8vIG5vZGVqcyBlbnZcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFVOREVGX1RZUEUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFVBUGFyc2VyO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMuVUFQYXJzZXIgPSBVQVBhcnNlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXF1aXJlanMgZW52IChvcHRpb25hbClcbiAgICAgICAgaWYgKHR5cGVvZihkZWZpbmUpID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFVBUGFyc2VyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93KSB7XG4gICAgICAgICAgICAvLyBicm93c2VyIGVudlxuICAgICAgICAgICAgd2luZG93LlVBUGFyc2VyID0gVUFQYXJzZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBqUXVlcnkvWmVwdG8gc3BlY2lmaWMgKG9wdGlvbmFsKVxuICAgIC8vIE5vdGU6XG4gICAgLy8gICBJbiBBTUQgZW52IHRoZSBnbG9iYWwgc2NvcGUgc2hvdWxkIGJlIGtlcHQgY2xlYW4sIGJ1dCBqUXVlcnkgaXMgYW4gZXhjZXB0aW9uLlxuICAgIC8vICAgalF1ZXJ5IGFsd2F5cyBleHBvcnRzIHRvIGdsb2JhbCBzY29wZSwgdW5sZXNzIGpRdWVyeS5ub0NvbmZsaWN0KHRydWUpIGlzIHVzZWQsXG4gICAgLy8gICBhbmQgd2Ugc2hvdWxkIGNhdGNoIHRoYXQuXG4gICAgdmFyICQgPSB3aW5kb3cgJiYgKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvKTtcbiAgICBpZiAodHlwZW9mICQgIT09IFVOREVGX1RZUEUgJiYgISQudWEpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBVQVBhcnNlcigpO1xuICAgICAgICAkLnVhID0gcGFyc2VyLmdldFJlc3VsdCgpO1xuICAgICAgICAkLnVhLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIuZ2V0VUEoKTtcbiAgICAgICAgfTtcbiAgICAgICAgJC51YS5zZXQgPSBmdW5jdGlvbiAodWFzdHJpbmcpIHtcbiAgICAgICAgICAgIHBhcnNlci5zZXRVQSh1YXN0cmluZyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VyLmdldFJlc3VsdCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAkLnVhW3Byb3BdID0gcmVzdWx0W3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxufSkodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgPyB3aW5kb3cgOiB0aGlzKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEZVTkNUSU9OUyAvL1xuXG52YXIgaXNTdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5cbi8vIElTIEZMT0FUMzJBUlJBWSAvL1xuXG4vKipcbiogRlVOQ1RJT046IGlzRmxvYXQzMkFycmF5KCB2YWx1ZSApXG4qXHRWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhIEZsb2F0MzJBcnJheS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHZhbGlkYXRlXG4qIEByZXR1cm5zIHtCb29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIEZsb2F0MzJBcnJheVxuKi9cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KCB2YWx1ZSApIHtcblx0cmV0dXJuIGlzU3RyLmNhbGwoIHZhbHVlICkgPT09ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nO1xufSAvLyBlbmQgRlVOQ1RJT04gaXNGbG9hdDMyQXJyYXkoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Zsb2F0MzJBcnJheTtcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgZHVwbGV4aWZ5ID0gcmVxdWlyZSgnZHVwbGV4aWZ5JylcbnZhciBXUyA9IHJlcXVpcmUoJ3dzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFN0cmVhbVxuXG5mdW5jdGlvbiBidWlsZFByb3h5IChvcHRpb25zLCBzb2NrZXRXcml0ZSwgc29ja2V0RW5kKSB7XG4gIHZhciBwcm94eSA9IG5ldyBUcmFuc2Zvcm0oe1xuICAgIG9iamVjdE1vZGU6IG9wdGlvbnMub2JqZWN0TW9kZVxuICB9KVxuXG4gIHByb3h5Ll93cml0ZSA9IHNvY2tldFdyaXRlXG4gIHByb3h5Ll9mbHVzaCA9IHNvY2tldEVuZFxuXG4gIHJldHVybiBwcm94eVxufVxuXG5mdW5jdGlvbiBXZWJTb2NrZXRTdHJlYW0odGFyZ2V0LCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgdmFyIHN0cmVhbSwgc29ja2V0XG5cbiAgdmFyIGlzQnJvd3NlciA9IHByb2Nlc3MudGl0bGUgPT09ICdicm93c2VyJ1xuICB2YXIgaXNOYXRpdmUgPSAhIWdsb2JhbC5XZWJTb2NrZXRcbiAgdmFyIHNvY2tldFdyaXRlID0gaXNCcm93c2VyID8gc29ja2V0V3JpdGVCcm93c2VyIDogc29ja2V0V3JpdGVOb2RlXG5cbiAgaWYgKHByb3RvY29scyAmJiAhQXJyYXkuaXNBcnJheShwcm90b2NvbHMpICYmICdvYmplY3QnID09PSB0eXBlb2YgcHJvdG9jb2xzKSB7XG4gICAgLy8gYWNjZXB0IHRoZSBcIm9wdGlvbnNcIiBPYmplY3QgYXMgdGhlIDJuZCBhcmd1bWVudFxuICAgIG9wdGlvbnMgPSBwcm90b2NvbHNcbiAgICBwcm90b2NvbHMgPSBudWxsXG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJvdG9jb2wgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy5wcm90b2NvbCkpIHtcbiAgICAgIHByb3RvY29scyA9IG9wdGlvbnMucHJvdG9jb2w7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cblxuICBpZiAob3B0aW9ucy5vYmplY3RNb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLm9iamVjdE1vZGUgPSAhKG9wdGlvbnMuYmluYXJ5ID09PSB0cnVlIHx8IG9wdGlvbnMuYmluYXJ5ID09PSB1bmRlZmluZWQpXG4gIH1cblxuICB2YXIgcHJveHkgPSBidWlsZFByb3h5KG9wdGlvbnMsIHNvY2tldFdyaXRlLCBzb2NrZXRFbmQpXG5cbiAgaWYgKCFvcHRpb25zLm9iamVjdE1vZGUpIHtcbiAgICBwcm94eS5fd3JpdGV2ID0gd3JpdGV2XG4gIH1cblxuICAvLyBicm93c2VyIG9ubHk6IHNldHMgdGhlIG1heGltdW0gc29ja2V0IGJ1ZmZlciBzaXplIGJlZm9yZSB0aHJvdHRsaW5nXG4gIHZhciBidWZmZXJTaXplID0gb3B0aW9ucy5icm93c2VyQnVmZmVyU2l6ZSB8fCAxMDI0ICogNTEyXG5cbiAgLy8gYnJvd3NlciBvbmx5OiBob3cgbG9uZyB0byB3YWl0IHdoZW4gdGhyb3R0bGluZ1xuICB2YXIgYnVmZmVyVGltZW91dCA9IG9wdGlvbnMuYnJvd3NlckJ1ZmZlclRpbWVvdXQgfHwgMTAwMFxuXG4gIC8vIHVzZSBleGlzdGluZyBXZWJTb2NrZXQgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBpblxuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICBzb2NrZXQgPSB0YXJnZXRcbiAgLy8gb3RoZXJ3aXNlIG1ha2UgYSBuZXcgb25lXG4gIH0gZWxzZSB7XG4gICAgLy8gc3BlY2lhbCBjb25zdHJ1Y3RvciB0cmVhdG1lbnQgZm9yIG5hdGl2ZSB3ZWJzb2NrZXRzIGluIGJyb3dzZXJzLCBzZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vd2Vic29ja2V0LXN0cmVhbS9pc3N1ZXMvODJcbiAgICBpZiAoaXNOYXRpdmUgJiYgaXNCcm93c2VyKSB7XG4gICAgICBzb2NrZXQgPSBuZXcgV1ModGFyZ2V0LCBwcm90b2NvbHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNvY2tldCA9IG5ldyBXUyh0YXJnZXQsIHByb3RvY29scywgb3B0aW9ucylcbiAgICB9XG5cbiAgICBzb2NrZXQuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgfVxuXG4gIC8vIHdhcyBhbHJlYWR5IG9wZW4gd2hlbiBwYXNzZWQgaW5cbiAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBzb2NrZXQuT1BFTikge1xuICAgIHN0cmVhbSA9IHByb3h5XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gc3RyZWFtID0gZHVwbGV4aWZ5KHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zKVxuICAgIGlmICghb3B0aW9ucy5vYmplY3RNb2RlKSB7XG4gICAgICBzdHJlYW0uX3dyaXRldiA9IHdyaXRldlxuICAgIH1cbiAgICBzb2NrZXQub25vcGVuID0gb25vcGVuXG4gIH1cblxuICBzdHJlYW0uc29ja2V0ID0gc29ja2V0XG5cbiAgc29ja2V0Lm9uY2xvc2UgPSBvbmNsb3NlXG4gIHNvY2tldC5vbmVycm9yID0gb25lcnJvclxuICBzb2NrZXQub25tZXNzYWdlID0gb25tZXNzYWdlXG5cbiAgcHJveHkub24oJ2Nsb3NlJywgZGVzdHJveSlcblxuICB2YXIgY29lcmNlVG9CdWZmZXIgPSAhb3B0aW9ucy5vYmplY3RNb2RlXG5cbiAgZnVuY3Rpb24gc29ja2V0V3JpdGVOb2RlKGNodW5rLCBlbmMsIG5leHQpIHtcbiAgICAvLyBhdm9pZCBlcnJvcnMsIHRoaXMgbmV2ZXIgaGFwcGVucyB1bmxlc3NcbiAgICAvLyBkZXN0cm95KCkgaXMgY2FsbGVkXG4gICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSBzb2NrZXQuT1BFTikge1xuICAgICAgbmV4dCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY29lcmNlVG9CdWZmZXIgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgJ3V0ZjgnKVxuICAgIH1cbiAgICBzb2NrZXQuc2VuZChjaHVuaywgbmV4dClcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvY2tldFdyaXRlQnJvd3NlcihjaHVuaywgZW5jLCBuZXh0KSB7XG4gICAgaWYgKHNvY2tldC5idWZmZXJlZEFtb3VudCA+IGJ1ZmZlclNpemUpIHtcbiAgICAgIHNldFRpbWVvdXQoc29ja2V0V3JpdGVCcm93c2VyLCBidWZmZXJUaW1lb3V0LCBjaHVuaywgZW5jLCBuZXh0KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNvZXJjZVRvQnVmZmVyICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssICd1dGY4JylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc29ja2V0LnNlbmQoY2h1bmspXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIHJldHVybiBuZXh0KGVycilcbiAgICB9XG5cbiAgICBuZXh0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvY2tldEVuZChkb25lKSB7XG4gICAgc29ja2V0LmNsb3NlKClcbiAgICBkb25lKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ub3BlbigpIHtcbiAgICBzdHJlYW0uc2V0UmVhZGFibGUocHJveHkpXG4gICAgc3RyZWFtLnNldFdyaXRhYmxlKHByb3h5KVxuICAgIHN0cmVhbS5lbWl0KCdjb25uZWN0JylcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgc3RyZWFtLmVuZCgpXG4gICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIH1cblxuICBmdW5jdGlvbiBvbm1lc3NhZ2UoZXZlbnQpIHtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSlcbiAgICBlbHNlIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCAndXRmOCcpXG4gICAgcHJveHkucHVzaChkYXRhKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBzb2NrZXQuY2xvc2UoKVxuICB9XG5cbiAgLy8gdGhpcyBpcyB0byBiZSBlbmFibGVkIG9ubHkgaWYgb2JqZWN0TW9kZSBpcyBmYWxzZVxuICBmdW5jdGlvbiB3cml0ZXYgKGNodW5rcywgY2IpIHtcbiAgICB2YXIgYnVmZmVycyA9IG5ldyBBcnJheShjaHVua3MubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rc1tpXS5jaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYnVmZmVyc1tpXSA9IEJ1ZmZlci5mcm9tKGNodW5rc1tpXSwgJ3V0ZjgnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyc1tpXSA9IGNodW5rc1tpXS5jaHVua1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3dyaXRlKEJ1ZmZlci5jb25jYXQoYnVmZmVycyksICdiaW5hcnknLCBjYilcbiAgfVxuXG4gIHJldHVybiBzdHJlYW1cbn1cbiIsIlxudmFyIHdzID0gbnVsbFxuXG5pZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSBXZWJTb2NrZXRcbn0gZWxzZSBpZiAodHlwZW9mIE1veldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSBNb3pXZWJTb2NrZXRcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSB3aW5kb3cuV2ViU29ja2V0IHx8IHdpbmRvdy5Nb3pXZWJTb2NrZXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3c1xuIiwiLy8gUmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgd3JhcHBlZCBjYWxsYmFja1xuLy8gVGhlIHdyYXBwZXIgZnVuY3Rpb24gc2hvdWxkIGRvIHNvbWUgc3R1ZmYsIGFuZCByZXR1cm4gYVxuLy8gcHJlc3VtYWJseSBkaWZmZXJlbnQgY2FsbGJhY2sgZnVuY3Rpb24uXG4vLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBvd24gcHJvcGVydGllcyBhcmUgcmV0YWluZWQsIHNvIHRoYXRcbi8vIGRlY29yYXRpb25zIGFuZCBzdWNoIGFyZSBub3QgbG9zdCBhbG9uZyB0aGUgd2F5LlxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHlcbmZ1bmN0aW9uIHdyYXBweSAoZm4sIGNiKSB7XG4gIGlmIChmbiAmJiBjYikgcmV0dXJuIHdyYXBweShmbikoY2IpXG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZWVkIHdyYXBwZXIgZnVuY3Rpb24nKVxuXG4gIE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgd3JhcHBlcltrXSA9IGZuW2tdXG4gIH0pXG5cbiAgcmV0dXJuIHdyYXBwZXJcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICAgIHZhciByZXQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGgtMV1cbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyAmJiByZXQgIT09IGNiKSB7XG4gICAgICBPYmplY3Qua2V5cyhjYikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXRba10gPSBjYltrXVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcInZpZGVvbWFpbC1jbGllbnRcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMi42LjdcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgd2lja2VkIG5wbSBwYWNrYWdlIHRvIHJlY29yZCB2aWRlb3MgZGlyZWN0bHkgaW4gdGhlIGJyb3dzZXIsIHdvaG9vbyFcIixcbiAgXCJhdXRob3JcIjogXCJNaWNoYWVsIEhldWJlcmdlciA8bWljaGFlbC5oZXViZXJnZXJAYmluYXJ5a2l0Y2hlbi5jb20+XCIsXG4gIFwiY29udHJpYnV0b3JzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJNaWNoYWVsIEhldWJlcmdlclwiLFxuICAgICAgXCJlbWFpbFwiOiBcIm1pY2hhZWwuaGV1YmVyZ2VyQGJpbmFyeWtpdGNoZW4uY29tXCJcbiAgICB9XG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3ZpZGVvbWFpbC5pb1wiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLWNsaWVudC5naXRcIlxuICB9LFxuICBcImxpY2Vuc2VcIjogXCJDQzAtMS4wXCIsXG4gIFwicmVhZG1lRmlsZW5hbWVcIjogXCJSRUFETUUubWRcIixcbiAgXCJtb2R1bGVcIjogXCJzcmMvaW5kZXguanNcIixcbiAgXCJtYWluXCI6IFwiZGlzdC92aWRlb21haWwtY2xpZW50LmpzXCIsXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwiZ3VscCB0ZXN0XCIsXG4gICAgXCJzdGFydFwiOiBcIk5PREVfTk9fSFRUUDI9MSBndWxwIGV4YW1wbGVzXCIsXG4gICAgXCJhdWRpdFwiOiBcInlhcm4gcnVuIGF1ZGl0LWNpIC0tY29uZmlnIGF1ZGl0LWNpLmpzb25cIixcbiAgICBcInBhdGNoXCI6IFwiLi9lbnYvZGV2L3JlbGVhc2Uuc2ggLS1pbXBvcnRhbmNlPXBhdGNoXCIsXG4gICAgXCJtaW5vclwiOiBcIi4vZW52L2Rldi9yZWxlYXNlLnNoIC0taW1wb3J0YW5jZT1taW5vclwiLFxuICAgIFwibWFqb3JcIjogXCIuL2Vudi9kZXYvcmVsZWFzZS5zaCAtLWltcG9ydGFuY2U9bWFqb3JcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49OC4xMi4wXCIsXG4gICAgXCJ5YXJuXCI6IFwiPj0xLjMuMFwiLFxuICAgIFwibnBtXCI6IFwiPj01LjQuMFwiXG4gIH0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwid2ViY2FtXCIsXG4gICAgXCJ2aWRlb1wiLFxuICAgIFwidmlkZW9tYWlsXCIsXG4gICAgXCJlbmNvZGVyXCIsXG4gICAgXCJnZXR1c2VybWVkaWFcIixcbiAgICBcImF1ZGlvXCIsXG4gICAgXCJyZWNvcmRlclwiXG4gIF0sXG4gIFwiYnJvd3NlcnNsaXN0XCI6IFtcbiAgICBcImxhc3QgNSB2ZXJzaW9uc1wiLFxuICAgIFwiPiAxJVwiLFxuICAgIFwiRXhwbG9yZXIgPj0gMTFcIixcbiAgICBcIkZpcmVmb3ggRVNSXCIsXG4gICAgXCJpT1MgPj0gOVwiLFxuICAgIFwiYW5kcm9pZCA+PSA0XCJcbiAgXSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYWRkLWV2ZW50bGlzdGVuZXItd2l0aC1vcHRpb25zXCI6IFwiMS4yNS41XCIsXG4gICAgXCJhbmltaXR0ZXJcIjogXCIzLjAuMFwiLFxuICAgIFwiYXVkaW8tc2FtcGxlXCI6IFwiMS4wLjVcIixcbiAgICBcImNhbnZhcy10by1idWZmZXJcIjogXCIxLjAuMTRcIixcbiAgICBcImNsYXNzbGlzdC5qc1wiOiBcIjEuMS4yMDE1MDMxMlwiLFxuICAgIFwiY29udGFpbnNcIjogXCIwLjEuMVwiLFxuICAgIFwiY3JlYXRlLWVycm9yXCI6IFwiMC4zLjFcIixcbiAgICBcImRlZXBtZXJnZVwiOiBcIjMuMy4wXCIsXG4gICAgXCJkZWZpbmVkXCI6IFwiMS4wLjBcIixcbiAgICBcImRlc3BvdFwiOiBcIjEuMS4zXCIsXG4gICAgXCJkb2N1bWVudC12aXNpYmlsaXR5XCI6IFwiMS4wLjFcIixcbiAgICBcImVsZW1lbnQtY2xvc2VzdFwiOiBcIjMuMC4xXCIsXG4gICAgXCJmaWxlc2l6ZVwiOiBcIjQuMS4yXCIsXG4gICAgXCJnZXQtZm9ybS1kYXRhXCI6IFwiMi4wLjBcIixcbiAgICBcImhpZGRlblwiOiBcIjEuMS4xXCIsXG4gICAgXCJodW1hbml6ZS1kdXJhdGlvblwiOiBcIjMuMTguMFwiLFxuICAgIFwiaHlwZXJzY3JpcHRcIjogXCIyLjAuMlwiLFxuICAgIFwiaW5zZXJ0LWNzc1wiOiBcIjIuMC4wXCIsXG4gICAgXCJpcGhvbmUtaW5saW5lLXZpZGVvXCI6IFwiMi4yLjJcIixcbiAgICBcImlzLXBvd2VyLW9mLXR3b1wiOiBcIjEuMC4wXCIsXG4gICAgXCJrZXltaXJyb3JcIjogXCIwLjEuMVwiLFxuICAgIFwibnVtYmVyLWlzLWludGVnZXJcIjogXCIxLjAuMVwiLFxuICAgIFwicmVhZHlzdGF0ZVwiOiBcIjAuNC4xXCIsXG4gICAgXCJyZXF1ZXN0LWZyYW1lXCI6IFwiMS41LjNcIixcbiAgICBcInNhZmUtanNvbi1zdHJpbmdpZnlcIjogXCIxLjIuMFwiLFxuICAgIFwic3VwZXJhZ2VudFwiOiBcIjUuMS4wXCIsXG4gICAgXCJ1YS1wYXJzZXItanNcIjogXCIwLjcuMjBcIixcbiAgICBcIndlYnNvY2tldC1zdHJlYW1cIjogXCI1LjUuMFwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBiYWJlbC9jb3JlXCI6IFwiNy40LjVcIixcbiAgICBcIkBiYWJlbC9wb2x5ZmlsbFwiOiBcIjcuNC40XCIsXG4gICAgXCJAYmFiZWwvcHJlc2V0LWVudlwiOiBcIjcuNC41XCIsXG4gICAgXCJhdWRpdC1jaVwiOiBcIjIuMC4xXCIsXG4gICAgXCJhdXRvcHJlZml4ZXJcIjogXCI5LjYuMFwiLFxuICAgIFwiYmFiZWwtZXNsaW50XCI6IFwiMTAuMC4yXCIsXG4gICAgXCJiYWJlbGlmeVwiOiBcIjEwLjAuMFwiLFxuICAgIFwiYm9keS1wYXJzZXJcIjogXCIxLjE5LjBcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCIxNi4yLjNcIixcbiAgICBcImNvbm5lY3Qtc2VuZC1qc29uXCI6IFwiMS4wLjBcIixcbiAgICBcImNzc25hbm9cIjogXCI0LjEuMTBcIixcbiAgICBcImRlbFwiOiBcIjQuMS4xXCIsXG4gICAgXCJlc2xpbnRcIjogXCI1LjE2LjBcIixcbiAgICBcImZhbmN5LWxvZ1wiOiBcIjEuMy4zXCIsXG4gICAgXCJnbG9iXCI6IFwiNy4xLjRcIixcbiAgICBcImd1bHBcIjogXCI0LjAuMlwiLFxuICAgIFwiZ3VscC1idW1wXCI6IFwiMy4xLjNcIixcbiAgICBcImd1bHAtYnl0ZWRpZmZcIjogXCIxLjAuMFwiLFxuICAgIFwiZ3VscC1jb25jYXRcIjogXCIyLjYuMVwiLFxuICAgIFwiZ3VscC1jb25uZWN0XCI6IFwiNS43LjBcIixcbiAgICBcImd1bHAtZGVyZXF1aXJlXCI6IFwiMi4xLjBcIixcbiAgICBcImd1bHAtaWZcIjogXCIyLjAuMlwiLFxuICAgIFwiZ3VscC1pbmplY3Qtc3RyaW5nXCI6IFwiMS4xLjJcIixcbiAgICBcImd1bHAtbG9hZC1wbHVnaW5zXCI6IFwiMS42LjBcIixcbiAgICBcImd1bHAtcGx1bWJlclwiOiBcIjEuMi4xXCIsXG4gICAgXCJndWxwLXBvc3Rjc3NcIjogXCI4LjAuMFwiLFxuICAgIFwiZ3VscC1yZW5hbWVcIjogXCIxLjQuMFwiLFxuICAgIFwiZ3VscC1zb3VyY2VtYXBzXCI6IFwiMi42LjVcIixcbiAgICBcImd1bHAtc3RhbmRhcmRcIjogXCIxMi4wLjBcIixcbiAgICBcImd1bHAtc3R5bHVzXCI6IFwiMi43LjBcIixcbiAgICBcImd1bHAtdGVyc2VyXCI6IFwiMS4yLjBcIixcbiAgICBcImd1bHAtdG9kb1wiOiBcIjcuMS4xXCIsXG4gICAgXCJtaW5pbWlzdFwiOiBcIjEuMi4wXCIsXG4gICAgXCJuaWJcIjogXCIxLjEuMlwiLFxuICAgIFwicm91dGVyXCI6IFwiMS4zLjNcIixcbiAgICBcInNzbC1yb290LWNhc1wiOiBcIjEuMy4xXCIsXG4gICAgXCJzdGFuZGFyZFwiOiBcIjEyLjAuMVwiLFxuICAgIFwidGFwZVwiOiBcIjQuMTAuMlwiLFxuICAgIFwidGFwZS1jYXRjaFwiOiBcIjEuMC42XCIsXG4gICAgXCJ0YXBlLXJ1blwiOiBcIjYuMC4wXCIsXG4gICAgXCJ2aW55bC1idWZmZXJcIjogXCIxLjAuMVwiLFxuICAgIFwidmlueWwtc291cmNlLXN0cmVhbVwiOiBcIjIuMC4wXCIsXG4gICAgXCJ3YXRjaGlmeVwiOiBcIjMuMTEuMVwiXG4gIH1cbn1cbiIsImltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJ1xuaW1wb3J0IHJlYWR5c3RhdGUgZnJvbSAncmVhZHlzdGF0ZSdcbmltcG9ydCB1dGlsIGZyb20gJ3V0aWwnXG5cbmltcG9ydCBkZWZhdWx0T3B0aW9ucyBmcm9tICcuL29wdGlvbnMnXG5pbXBvcnQgQ29uc3RhbnRzIGZyb20gJy4vY29uc3RhbnRzJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL2V2ZW50cydcbmltcG9ydCBDb2xsZWN0TG9nZ2VyIGZyb20gJy4vdXRpbC9jb2xsZWN0TG9nZ2VyJ1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuL3V0aWwvZXZlbnRFbWl0dGVyJ1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL3dyYXBwZXJzL2NvbnRhaW5lcidcbmltcG9ydCBSZXBsYXkgZnJvbSAnLi93cmFwcGVycy92aXN1YWxzL3JlcGxheSdcbmltcG9ydCBPcHRpb25zV3JhcHBlciBmcm9tICcuL3dyYXBwZXJzL29wdGlvbnNXcmFwcGVyJ1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi91dGlsL2Jyb3dzZXInXG5pbXBvcnQgUmVzb3VyY2UgZnJvbSAnLi9yZXNvdXJjZSdcblxudmFyIGNvbGxlY3RMb2dnZXJcbnZhciBicm93c2VyXG5cbmZ1bmN0aW9uIGFkanVzdE9wdGlvbnMgKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBsb2NhbE9wdGlvbnMgPSBkZWVwbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIHtcbiAgICBhcnJheU1lcmdlOiBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHNvdXJjZSkgeyByZXR1cm4gc291cmNlIH1cbiAgfSlcblxuICBjb2xsZWN0TG9nZ2VyID0gY29sbGVjdExvZ2dlciB8fCBuZXcgQ29sbGVjdExvZ2dlcihsb2NhbE9wdGlvbnMpXG5cbiAgbG9jYWxPcHRpb25zLmxvZ2dlciA9IGNvbGxlY3RMb2dnZXJcbiAgbG9jYWxPcHRpb25zLmRlYnVnID0gbG9jYWxPcHRpb25zLmxvZ2dlci5kZWJ1Z1xuXG4gIE9wdGlvbnNXcmFwcGVyLmFkZEZ1bmN0aW9ucyhsb2NhbE9wdGlvbnMpXG5cbiAgcmV0dXJuIGxvY2FsT3B0aW9uc1xufVxuXG5mdW5jdGlvbiBnZXRCcm93c2VyIChsb2NhbE9wdGlvbnMpIHtcbiAgaWYgKCFicm93c2VyKSB7XG4gICAgYnJvd3NlciA9IG5ldyBCcm93c2VyKGxvY2FsT3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBicm93c2VyXG59XG5cbmNvbnN0IFZpZGVvbWFpbENsaWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGNvbnN0IGxvY2FsT3B0aW9ucyA9IGFkanVzdE9wdGlvbnMob3B0aW9ucylcbiAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbnRhaW5lcihsb2NhbE9wdGlvbnMpXG4gIGNvbnN0IGRlYnVnID0gbG9jYWxPcHRpb25zLmRlYnVnXG5cbiAgdmFyIHJlcGxheVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMsIGxvY2FsT3B0aW9ucywgJ1ZpZGVvbWFpbENsaWVudCcpXG5cbiAgLy8gZXhwb3NlIGFsbCBwb3NzaWJsZSBldmVudHNcbiAgdGhpcy5ldmVudHMgPSBFdmVudHNcblxuICBmdW5jdGlvbiBidWlsZCAoKSB7XG4gICAgdmFyIGJ1aWxkaW5nID0gZmFsc2VcblxuICAgIHJlYWR5c3RhdGUuaW50ZXJhY3RpdmUoZnVuY3Rpb24gKHByZXZpb3VzU3RhdGUpIHtcbiAgICAgIGRlYnVnKFxuICAgICAgICAnQ2xpZW50OiBpbnRlcmFjdGl2ZSgpLCcsXG4gICAgICAgICdwcmV2aW91c1N0YXRlID0nLCBwcmV2aW91c1N0YXRlICsgJywnLFxuICAgICAgICAnIWJ1aWxkaW5nID0nLCAhYnVpbGRpbmcgKyAnLCcsXG4gICAgICAgICchaXNCdWlsdCgpID0nLCAhY29udGFpbmVyLmlzQnVpbHQoKVxuICAgICAgKVxuXG4gICAgICAvLyBpdCBjYW4gaGFwcGVuIHRoYXQgaXQgZ2V0cyBjYWxsZWQgdHdpY2UsIGkuRS4gd2hlbiBhbiBlcnJvciBpcyB0aHJvd25cbiAgICAgIC8vIGluIHRoZSBtaWRkbGUgb2YgdGhlIGJ1aWxkKCkgZm5cbiAgICAgIGlmICghYnVpbGRpbmcgJiYgIWNvbnRhaW5lci5pc0J1aWx0KCkpIHtcbiAgICAgICAgYnVpbGRpbmcgPSB0cnVlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29udGFpbmVyLmJ1aWxkKClcbiAgICAgICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAgICAgdGhyb3cgZXhjXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgYnVpbGRpbmcgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRoaXMuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29udGFpbmVyLmlzQnVpbHQoKSkge1xuICAgICAgY29udGFpbmVyLnNob3coKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uY2UoRXZlbnRzLkJVSUxULCBjb250YWluZXIuc2hvdylcbiAgICB9XG4gIH1cblxuICAvLyBhdXRvbWF0aWNhbGx5IGFkZHMgYSA8dmlkZW8+IGVsZW1lbnQgaW5zaWRlIHRoZSBnaXZlbiBwYXJlbnRFbGVtZW50IGFuZCBsb2Fkc1xuICAvLyBpdCB3aXRoIHRoZSB2aWRlb21haWxcbiAgdGhpcy5yZXBsYXkgPSBmdW5jdGlvbiAodmlkZW9tYWlsLCBwYXJlbnRFbGVtZW50KSB7XG4gICAgZnVuY3Rpb24gYnVpbGRSZXBsYXkgKCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXJlbnRFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocGFyZW50RWxlbWVudClcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIGlmICghY29udGFpbmVyLmlzQnVpbHQoKSkge1xuICAgICAgICAgIC8vIHRoaXMgd2lsbCB0cnkgYnVpbGQgYWxsIG92ZXIgYWdhaW5cbiAgICAgICAgICBjb250YWluZXIuYnVpbGQoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb250YWluZXIuaGFzRWxlbWVudCgpKSB7XG4gICAgICAgICAgLy8gaWYgY29udGFpbmVyLnNldEVsZW1lbnQoKSBmYWlsZWQgdG9vLCB0aGVuIGNvbXBsYWluXG4gICAgICAgICAgcmVhZHlzdGF0ZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlcGxheSB2aWRlbyB3aXRob3V0IGEgY29udGFpbmVyIG5vciBwYXJlbnQgZWxlbWVudC4nKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29udGFpbmVyLmlzT3V0c2lkZUVsZW1lbnRPZihwYXJlbnRFbGVtZW50KSkge1xuICAgICAgICAgIHJlcGxheSA9IG5ldyBSZXBsYXkocGFyZW50RWxlbWVudCwgbG9jYWxPcHRpb25zKVxuICAgICAgICAgIHJlcGxheS5idWlsZCgpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXBsYXkpIHtcbiAgICAgICAgcmVwbGF5ID0gY29udGFpbmVyLmdldFJlcGxheSgpXG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyZW50RWxlbWVudCkge1xuICAgICAgICBwYXJlbnRFbGVtZW50ID0gcmVwbGF5LmdldFBhcmVudEVsZW1lbnQoKVxuICAgICAgfVxuXG4gICAgICBpZiAodmlkZW9tYWlsKSB7XG4gICAgICAgIHZpZGVvbWFpbCA9IGNvbnRhaW5lci5hZGRQbGF5ZXJEaW1lbnNpb25zKHZpZGVvbWFpbCwgcGFyZW50RWxlbWVudClcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRhaW5lci5pc091dHNpZGVFbGVtZW50T2YocGFyZW50RWxlbWVudCkpIHtcbiAgICAgICAgLy8gcmVwbGF5IGVsZW1lbnQgbXVzdCBiZSBvdXRzaWRlIG9mIHRoZSBjb250YWluZXJcbiAgICAgICAgY29udGFpbmVyLmhpZGVGb3JtKHsgZGVlcDogdHJ1ZSB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmxvYWRGb3JtKHZpZGVvbWFpbClcbiAgICAgIH1cblxuICAgICAgLy8gc2xpZ2h0IGRlbGF5IG5lZWRlZCB0byBhdm9pZCBIVFRQIDQxNiBlcnJvcnMgKHJlcXVlc3QgcmFuZ2UgdW5hdmFpbGFibGUpXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVwbGF5LnNldFZpZGVvbWFpbCh2aWRlb21haWwpXG4gICAgICAgIGNvbnRhaW5lci5zaG93UmVwbGF5T25seSgpXG4gICAgICB9LCAxMGUyKSAvLyBub3Qgc3VyZSwgYnV0IHByb2JhYmx5IGNhbiBiZSByZWR1Y2VkIGEgYml0XG4gICAgfVxuXG4gICAgcmVhZHlzdGF0ZS5pbnRlcmFjdGl2ZShidWlsZFJlcGxheSlcbiAgfVxuXG4gIHRoaXMuc3RhcnRPdmVyID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIGlmIChyZXBsYXkpIHtcbiAgICAgIHJlcGxheS5oaWRlKClcbiAgICAgIHJlcGxheS5yZXNldCgpXG4gICAgfVxuXG4gICAgY29udGFpbmVyLnN0YXJ0T3ZlcihwYXJhbXMpXG4gIH1cblxuICB0aGlzLnVubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmVhZHlzdGF0ZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICAgIGNvbnRhaW5lci51bmxvYWQoZSlcbiAgfVxuXG4gIHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb250YWluZXIuaGlkZSgpXG4gIH1cblxuICB0aGlzLmdldCA9IGZ1bmN0aW9uIChhbGlhcywgY2IpIHtcbiAgICBuZXcgUmVzb3VyY2UobG9jYWxPcHRpb25zKS5nZXQoYWxpYXMsIGZ1bmN0aW9uIChlcnIsIHZpZGVvbWFpbCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYihlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihudWxsLCBjb250YWluZXIuYWRkUGxheWVyRGltZW5zaW9ucyh2aWRlb21haWwpKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB0aGlzLmNhblJlY29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0QnJvd3Nlcihsb2NhbE9wdGlvbnMpLmNhblJlY29yZCgpXG4gIH1cblxuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIGEgdmlkZW8gaGFzIGJlZW4gcmVjb3JkZWQgYnV0IGlzIG5vdCBzZW50IHlldFxuICB0aGlzLmlzRGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pc0RpcnR5KClcbiAgfVxuXG4gIHRoaXMuaXNSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pc1JlY29yZGluZygpXG4gIH1cblxuICB0aGlzLnN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb250YWluZXIuc3VibWl0KClcbiAgfVxuXG4gIHRoaXMuZ2V0TG9nTGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGxvY2FsT3B0aW9ucy5sb2dnZXIgJiYgbG9jYWxPcHRpb25zLmxvZ2dlci5nZXRMaW5lcykge1xuICAgICAgcmV0dXJuIGxvY2FsT3B0aW9ucy5sb2dnZXIuZ2V0TGluZXMoKVxuICAgIH1cbiAgfVxuXG4gIGJ1aWxkKClcbn1cblxudXRpbC5pbmhlcml0cyhWaWRlb21haWxDbGllbnQsIEV2ZW50RW1pdHRlcilcblxuT2JqZWN0LmtleXMoQ29uc3RhbnRzLnB1YmxpYykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBWaWRlb21haWxDbGllbnRbbmFtZV0gPSBDb25zdGFudHMucHVibGljW25hbWVdXG59KVxuXG4vLyBqdXN0IGFub3RoZXIgY29udmVuaWVudCB0aGluZ1xuVmlkZW9tYWlsQ2xpZW50LmV2ZW50cyA9IEV2ZW50c1xuXG5leHBvcnQgZGVmYXVsdCBWaWRlb21haWxDbGllbnRcbiIsIi8vIGNvbnN0YW50cyAoY2hhbmdpbmcgdGhlc2Ugb25seSBicmVhayBkb3duIGZ1bmN0aW9uYWxpdHksIHNvIGJlIGNhcmVmdWwpXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgU0lURV9OQU1FX0xBQkVMOiAneC12aWRlb21haWwtc2l0ZS1uYW1lJyxcbiAgVkVSU0lPTl9MQUJFTDogJ3ZpZGVvbWFpbENsaWVudFZlcnNpb24nLFxuXG4gIHB1YmxpYzoge1xuICAgIEVOQ19UWVBFX0FQUF9KU09OOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgRU5DX1RZUEVfRk9STTogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbiAgfVxufVxuIiwiaW1wb3J0IGtleW1pcnJvciBmcm9tICdrZXltaXJyb3InXG5cbmV4cG9ydCBkZWZhdWx0IGtleW1pcnJvcih7XG4gIEJVSUxUOiBudWxsLCAvLyBhbGwgZG9tIGVsZW1lbnRzIGFyZSByZWFkeSwgYXJlIGluIHRoZSBET01cbiAgRk9STV9SRUFEWTogbnVsbCwgLy8gZm9ybSBpcyByZWFkeSwgYXZhaWxhYmxlIGluIHRoZSBET01cbiAgTE9BRElOR19VU0VSX01FRElBOiBudWxsLCAvLyBhc2tpbmcgZm9yIHdlYmNhbSBhY2Nlc3NcbiAgVVNFUl9NRURJQV9SRUFEWTogbnVsbCwgLy8gdXNlciBtZWRpYSAoPSB3ZWJjYW0pIGlzIHJlYWR5LCBsb2FkZWRcbiAgQ09OTkVDVElORzogbnVsbCwgLy8gc29ja2V0IGlzIGNvbm5lY3RpbmcgdG8gc2VydmVyXG4gIENPTk5FQ1RFRDogbnVsbCwgLy8gc29ja2V0IGlzIGNvbm5lY3RlZCB0byBzZXJ2ZXJcbiAgRElTQ09OTkVDVEVEOiBudWxsLCAvLyBzb2NrZXQgdG8gc2VydmVyIGlzIGRpc2Nvbm5lY3RlZFxuICBDT1VOVERPV046IG51bGwsIC8vIGNvdW50ZG93biBmb3IgcmVjb3JkaW5nIGhhcyBzdGFydGVkXG4gIFJFQ09SRElORzogbnVsbCwgLy8gd2ViY2FtIGlzIHJlY29yZGluZ1xuICBTVE9QUElORzogbnVsbCwgLy8gcmVjb3JkaW5nIGlzIGJlaW5nIHN0b3BwZWQgKD0gcHJldmlldylcbiAgUFJPR1JFU1M6IG51bGwsIC8vIHN0YXJ0IHNlbmRpbmdcbiAgQkVHSU5fQVVESU9fRU5DT0RJTkc6IG51bGwsIC8vIGVuY29kaW5nIHZpZGVvXG4gIEJFR0lOX1ZJREVPX0VOQ09ESU5HOiBudWxsLCAvLyBlbmNvZGluZyB2aWRlb1xuICBSRVNFVFRJTkc6IG51bGwsIC8vIHJlc2V0dGluZyBldmVyeXRoaW5nIHRvIGdvIGJhY2sgdG8gaW5pdGlhbCBzdGF0ZVxuICBQQVVTRUQ6IG51bGwsIC8vIHJlY29yZGluZyBpcyBiZWluZyBwYXVzZWRcbiAgUkVTVU1JTkc6IG51bGwsIC8vIHJlY29yZGluZyBpcyByZXN1bWVkXG4gIFBSRVZJRVc6IG51bGwsIC8vIHZpZGVvIHByZXZpZXcgaXMgc2V0XG4gIFBSRVZJRVdfU0hPV046IG51bGwsIC8vIHZpZGVvIHByZXZpZXcgaXMgc2hvd25cbiAgUkVQTEFZX1NIT1dOOiBudWxsLCAvLyBzdWJtaXR0ZWQgdmlkZW8gaXMgc2hvd25cbiAgSU5WQUxJRDogbnVsbCwgLy8gZm9ybSBpcyBpbnZhbGlkXG4gIFZBTElEQVRJTkc6IG51bGwsIC8vIGZvcm0gaXMgYmVpbmcgdmFsaWRhdGVkXG4gIFZBTElEOiBudWxsLCAvLyBmb3JtIGlzIHZhbGlkXG4gIFNVQk1JVFRJTkc6IG51bGwsIC8vIGZvcm0gaXMgYmVpbmcgc3VibWl0dGVkXG4gIFNVQk1JVFRFRDogbnVsbCwgLy8gZm9ybSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgc3VibWl0dGVkXG4gIEVSUk9SOiBudWxsLCAvLyBhbiBlcnJvciBvY2N1cmVkXG4gIEJMT0NLSU5HOiBudWxsLCAvLyBzb21ldGhpbmcgc2VyaW91cywgbW9zdCBsaWtlbHkgYW4gZXJyb3IsIGlzIHNob3duIGFuZCBibG9ja3NcbiAgU0VORElOR19GSVJTVF9GUkFNRTogbnVsbCwgLy8gZW1pdHRlZCBiZWZvcmUgdGhlIGZpcnN0IGZyYW1lIGlzIGJlaW5nIGNvbXB1dGVkXG4gIEZJUlNUX0ZSQU1FX1NFTlQ6IG51bGwsIC8vIGVtaXR0ZWQgb25jZSB3aGVuIGZpc3QgZnJhbWUgaGFzIGJlZW4gc2VudCB0byBzZXJ2ZXJcbiAgSElERTogbnVsbCwgLy8gZW1pdHRlZCB3aGVuIGhpZGRlblxuICBOT1RJRllJTkc6IG51bGwsIC8vIG5vdGlmaWVzIHVzZXIgYWJvdXQgc29tZXRoaW5nIChub3QgYmxvY2tpbmcpXG4gIEVOQUJMSU5HX0FVRElPOiBudWxsLCAvLyBhYm91dCB0byBlbmFibGUgYXVkaW9cbiAgRElTQUJMSU5HX0FVRElPOiBudWxsLCAvLyBhYm91dCB0byBkaXNhYmxlIGF1ZGlvXG4gIExPQURFRF9NRVRBX0RBVEE6IG51bGwsIC8vIHJhaXNlZCB3aGVuIHdlYmNhbSBrbm93cyBpdHMgZGltZW5zaW9uc1xuICBFVkVOVF9FTUlUVEVEOiBudWxsLCAvLyBmb3IgZGVidWdnaW5nIG9ubHksIGlzIGVtaXR0ZWQgd2hlbiBhbiBldmVudCBpcyBlbWl0dGVkIGxvbCxcbiAgR09JTkdfQkFDSzogbnVsbCwgLy8gc3dpdGNoIGZyb20gcmVwbGF5aW5nIGJhY2sgdG8gcmVjb3JkaW5nXG4gIFNUQVJUSU5HX09WRVI6IG51bGwsIC8vIHN0YXJ0aW5nIGFsbCBvdmVyIGFnYWluIGJhY2sgdG8gaXRzIGluaXRhbCBzdGF0ZVxuICBBU0tJTkdfV0VCQ0FNX1BFUk1JU1NJT046IG51bGwsIC8vIHdoZW4gYWJvdXQgdG8gYXNrIGZvciB3ZWJjYW0gcGVybWlzc2lvbnNcbiAgVklTSUJMRTogbnVsbCwgLy8gZG9jdW1lbnQganVzdCBiZWNhbWUgdmlzaWJsZVxuICBJTlZJU0lCTEU6IG51bGwsIC8vIGRvY3VtZW50IGp1c3QgYmVjYW1lIElOdmlzaWJsZVxuICBTV0lUQ0hfRkFDSU5HX01PREU6IG51bGwgLy8gdG8gc3dpdGNoIGNhbWVyYSBvbiBtb2JpbGVzIGJldHdlZW4gZnJvbiBhbmQgYmFja1xufSlcbiIsImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi9wYWNrYWdlLmpzb24nXG5cbmNvbnN0IFBST0RVQ1RJT04gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLXNwYWNlcyAqL1xuLyogZXNsaW50IGluZGVudDogW1wiZXJyb3JcIiwgMiwgeyBcImlnbm9yZUNvbW1lbnRzXCI6IHRydWUgfV0gKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBsb2dnZXI6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmluZSBsb2dnaW5nIGluc3RhbmNlLiBsZWF2ZSBudWxsIGZvciBkZWZhdWx0LCBjb25zb2xlLlxuICBsb2dTdGFja1NpemU6IDMwLCAgICAgICAgICAgICAgICAgICAgIC8vIGxpbWl0cyB0aGUgc3RhY2sgc2l6ZSBvZiBsb2cgb3V0cHV0cyB0byBjb2xsZWN0XG4gIHZlcmJvc2U6ICFQUk9EVUNUSU9OLCAgICAgICAgICAgICAgICAgLy8gc2V0IHRydWUgdG8gbG9nIG1vcmUgaW5mb1xuICBiYXNlVXJsOiAnaHR0cHM6Ly92aWRlb21haWwuaW8nLCAgICAgIC8vIGxlYXZlIGFzIGl0LCBwZXJtYW5lbnQgdXJsIHRvIHBvc3QgdmlkZW9zXG4gIHNvY2tldFVybDogJ3dzczovL3ZpZGVvbWFpbC5pbycsICAgICAgLy8gbGVhdmUgYXMgaXQsIHBlcm1hbmVudCB1cmwgdG8gc2VuZCBmcmFtZXNcbiAgc2l0ZU5hbWU6ICd2aWRlb21haWwtY2xpZW50LWRlbW8nLCAgICAvLyBSZXF1aXJlZCBmb3IgQVBJLCB1c2UgaHR0cHM6Ly92aWRlb21haWwuaW8vd2hpdGVsaXN0XG4gIGNhY2hlOiB0cnVlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVkdWNlcyBHRVQgcXVlcmllcyB3aGVuIGxvYWRpbmcgdmlkZW9zXG4gIGluc2VydENzczogdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0cyBwcmVkZWZpbmVkIENTUywgc2VlIGV4YW1wbGVzXG4gIGVuYWJsZVBhdXNlOiB0cnVlLCAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlIHBhdXNlL3Jlc3VtZSBidXR0b25cbiAgZW5hYmxlQXV0b1BhdXNlOiB0cnVlLCAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IHBhdXNlcyB3aGVuIHdpbmRvdyBiZWNvbWVzIGluYWN0aXZlXG4gIGVuYWJsZVNwYWNlOiB0cnVlLCAgICAgICAgICAgICAgICAgICAgLy8gaGl0dGluZyBzcGFjZSBjYW4gcGF1c2UgcmVjb3JkaW5nXG4gIHN1Ym1pdFdpdGhWaWRlb21haWw6IGZhbHNlLCAgICAgICAgICAgLy8gd2hlbiBlbmFibGVkLCBhbGwgdmlkZW9tYWlsIG1ldGFkYXRhIGlzIHN1Ym1pdHRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuZGVyIHRoZSBgdmlkZW9tYWlsYCBrZXkgaW5zaWRlIHRoZSBmb3JtIGRhdGEgYm9keS5cbiAgZGlzYWJsZVN1Ym1pdDogZmFsc2UsICAgICAgICAgICAgICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGlmIHlvdSBkbyBub3Qgd2FudCB0byBzdWJtaXQgdmlkZW9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBqdXN0IHdhbnQgdG8gcmVjb3JkIGFuZCByZXBsYXkgdGhlc2UgdGVtcG9yYXJpbHlcbiAgZW5hYmxlQXV0b1ZhbGlkYXRpb246IHRydWUsICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IHZhbGlkYXRlcyBhbGwgZm9ybSBpbnB1dHMgaWYgYW55IGV4aXN0IGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IC9lbmFibGUgZGlzYWJsZSBzdWJtaXQgYnV0dG9uIGFmdGVyIHJlY29yZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gc29tZXRoaW5nIGVsc2Ugc2VlbXMgaW52YWxpZC5cbiAgZW5hYmxlQXV0b1N1Ym1pc3Npb246IHRydWUsICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IHN1Ym1pdHMgdGhlIGZvcm0gd2hlcmUgdGhlIHZpZGVvbWFpbC1jbGllbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcHBlYXJzIHVwb24gcHJlc3Mgb2Ygc3VibWl0IGJ1dHRvbi4gZGlzYWJsZSBpdCB3aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geW91IHdhbnQgYSBmcmFtZXdvcmsgdG8gZGVhbCB3aXRoIHRoZSBmb3JtIHN1Ym1pc3Npb24gaXRzZWxmLlxuXG4gIGVuY3R5cGU6ICdhcHBsaWNhdGlvbi9qc29uJywgICAgICAgICAgLy8gZW5jdHlwZSBmb3IgdGhlIGZvcm0gc3VibWlzc2lvbi4gY3VycmVudGx5IGltcGxlbWVudGVkIGFyZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnYXBwbGljYXRpb24vanNvbicgYW5kICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG5cbiAgLy8gZGVmYXVsdCBDU1Mgc2VsZWN0b3JzIHlvdSBjYW4gYWx0ZXIsIHNlZSBleGFtcGxlc1xuICBzZWxlY3RvcnM6IHtcbiAgICBjb250YWluZXJJZDogJ3ZpZGVvbWFpbCcsXG4gICAgcmVwbGF5Q2xhc3M6ICdyZXBsYXknLFxuICAgIHVzZXJNZWRpYUNsYXNzOiAndXNlck1lZGlhJyxcbiAgICB2aXN1YWxzQ2xhc3M6ICd2aXN1YWxzJyxcbiAgICBidXR0b25DbGFzczogbnVsbCwgICAgICAgICAgICAgICAgICAvLyBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgZGVmYXVsdCBjbGFzcyBmb3IgYWxsIGJ1dHRvbnNcbiAgICBidXR0b25zQ2xhc3M6ICdidXR0b25zJyxcblxuICAgIHJlY29yZEJ1dHRvbkNsYXNzOiAncmVjb3JkJyxcbiAgICBwYXVzZUJ1dHRvbkNsYXNzOiAncGF1c2UnLFxuICAgIHJlc3VtZUJ1dHRvbkNsYXNzOiAncmVzdW1lJyxcbiAgICBwcmV2aWV3QnV0dG9uQ2xhc3M6ICdwcmV2aWV3JyxcbiAgICByZWNvcmRBZ2FpbkJ1dHRvbkNsYXNzOiAncmVjb3JkQWdhaW4nLFxuICAgIHN1Ym1pdEJ1dHRvbkNsYXNzOiAnc3VibWl0JyxcblxuICAgIHN1YmplY3RJbnB1dE5hbWU6ICdzdWJqZWN0JywgICAgICAgICAvLyB0aGUgZm9ybSBpbnB1dCBuYW1lIGZvciBzdWJqZWN0XG4gICAgZnJvbUlucHV0TmFtZTogJ2Zyb20nLCAgICAgICAgICAgICAgIC8vIHRoZSBmb3JtIGlucHV0IG5hbWUgZm9yIHRoZSBmcm9tIGVtYWlsXG4gICAgdG9JbnB1dE5hbWU6ICd0bycsICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmb3JtIGlucHV0IG5hbWUgZm9yIHRoZSB0byBlbWFpbFxuICAgIGJvZHlJbnB1dE5hbWU6ICdib2R5JywgICAgICAgICAgICAgICAvLyB0aGUgZm9ybSBpbnB1dCBuYW1lIGZvciB0aGUgbWVzc2FnZSAoYm9keSlcbiAgICBzZW5kQ29weUlucHV0TmFtZTogJ3NlbmRDb3B5JywgICAgICAgLy8gdGhlIGZvcm0gY2hlY2tib3ggbmFtZSBmb3Igc2VuZGluZyBteXNlbGYgYSBjb3B5XG5cbiAgICBrZXlJbnB1dE5hbWU6ICd2aWRlb21haWxfa2V5JyxcbiAgICBwYXJlbnRLZXlJbnB1dE5hbWU6ICd2aWRlb21haWxfcGFyZW50X2tleScsXG4gICAgYWxpYXNJbnB1dE5hbWU6ICd2aWRlb21haWxfYWxpYXMnLFxuXG4gICAgZm9ybUlkOiBudWxsLCAgICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyBmb3JtIGlmIGFueVxuICAgIHN1Ym1pdEJ1dHRvbklkOiBudWxsLCAgICAgICAgICAgICAvLyBzZW1pLWF1dG9tYXRpY2FsbHkgZGV0ZWN0cyBzdWJtaXQgYnV0dG9uIGluIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpZiB0aGF0IGRvZXMgbm90IHdvcmssIHRyeSB1c2luZyB0aGVcbiAgICBzdWJtaXRCdXR0b25TZWxlY3RvcjogbnVsbCAgICAgICAgLy8gc3VibWl0QnV0dG9uU2VsZWN0b3JcbiAgfSxcblxuICBhdWRpbzoge1xuICAgIGVuYWJsZWQ6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAvLyBzZXQgdG8gdHJ1ZSBmb3IgZXhwZXJpbWVudGlhbCBhdWRpbyByZWNvcmRpbmdcbiAgICAnc3dpdGNoJzogZmFsc2UsICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlcyBhIHN3aXRjaGVyIGZvciBhdWRpbyByZWNvcmRpbmcgKG9uL29mZilcbiAgICB2b2x1bWU6IDAuMiwgICAgICAgICAgICAgICAgICAgICAgLy8gbXVzdCBiZSBiZXR3ZWVuIDAgLi4gMSBidXQgMC4yMCBpcyByZWNvbW1lZGVkIHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3RvcnRpbmcgYXQgdGhlIGhpZ2hlciB2b2x1bWUgcGVha3NcbiAgICBidWZmZXJTaXplOiAyMDQ4ICAgICAgICAgICAgICAgICAgLy8gZGVjaWRlcyBob3cgb2Z0ZW4gdGhlIGF1ZGlvIGlzIGJlaW5nIHNhbXBsZWQsIG11c3QgYmUgYSBwb3dlciBvZiB0d28uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBoaWdoZXIgdGhlIGxlc3MgdHJhZmZpYywgYnV0IGhhcmRlciB0byBhZGp1c3Qgd2l0aCBydWJiZXJiYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIG1hdGNoIHdpdGggdGhlIHZpZGVvIGxlbmd0aCBvbiBzZXJ2ZXIgc2lkZSBkdXJpbmcgZW5jb2RpbmdcbiAgfSxcblxuICB2aWRlbzoge1xuICAgIGZwczogMTUsICAgICAgICAgICAgICAgICAgICAvLyBkZXBlbmRzIG9uIHlvdXIgY29ubmVjdGlvblxuICAgIGxpbWl0U2Vjb25kczogMzAsICAgICAgICAgICAvLyByZWNvcmRpbmcgYXV0b21hdGljYWxseSBzdG9wcyBhZnRlciB0aGF0IGxpbWl0XG4gICAgY291bnRkb3duOiAzLCAgICAgICAgICAgICAgIC8vIHNldCBpdCB0byAwIG9yIGZhbHNlIHRvIGRpc2FibGUgaXRcblxuICAgIC8vIGl0IGlzIHJlY29tbWVuZGVkIHRvIHNldCBvbmUgZGltZW5zaW9uIG9ubHkgYW5kIGxlYXZlIHRoZSBvdGhlciBvbmUgdG8gYXV0b1xuICAgIC8vIGJlY2F1c2UgZWFjaCB3ZWJjYW0gaGFzIGEgZGlmZmVyZW50IGFzcGVjdCByYXRpb1xuXG4gICAgd2lkdGg6ICdhdXRvJywgICAgICAvLyBvciB1c2UgYW4gaW50ZWdlciBmb3IgZXhhY3QgcGl4ZWxzXG4gICAgaGVpZ2h0OiAnYXV0bycsICAgICAvLyBvciB1c2UgYW4gaW50ZWdlciBmb3IgZXhhY3QgcGl4ZWxzXG4gICAgZmFjaW5nTW9kZTogJ3VzZXInLCAvLyBjYW4gYmUgJ3VzZXInLCAnZW52aXJvbm1lbnQnLCAnbGVmdCcgb3IgJ3JpZ2h0Jy4gdXNlZnVsIGZvciBtb2JpbGVzLlxuICAgIGZhY2luZ01vZGVCdXR0b246IGZhbHNlXG4gIH0sXG5cbiAgaW1hZ2U6IHtcbiAgICBxdWFsaXR5OiAwLjQ0LFxuICAgIHR5cGVzOiBbJ3dlYnAnLCAnanBlZyddICAgLy8gcmVjb21tZW5kZWQgc2V0dGluZ3MgdG8gbWFrZSBtb3N0IG9mIGFsbCBicm93c2Vyc1xuICB9LFxuXG4gIC8vIGFsdGVyIHRoZXNlIHRleHQgZm9yIGludGVybmF0aW9uYWxpc2F0aW9uXG4gIHRleHQ6IHtcbiAgICBwYXVzZWRIZWFkZXI6ICdQYXVzZWQnLFxuICAgIHBhdXNlZEhpbnQ6IG51bGwsXG4gICAgc2VuZGluZzogJ1RlbGVwb3J0aW5nJyxcbiAgICBlbmNvZGluZzogJ0VuY29kaW5nJyxcbiAgICBsaW1pdFJlYWNoZWQ6ICdMaW1pdCByZWFjaGVkJyxcbiAgICBidXR0b25zOiB7XG4gICAgICAncmVjb3JkJzogJ1JlY29yZCB2aWRlbycsXG4gICAgICAncmVjb3JkQWdhaW4nOiAnUmVjb3JkIGFnYWluJyxcbiAgICAgICdyZXN1bWUnOiAnUmVzdW1lJyxcbiAgICAgICdwYXVzZSc6ICdQYXVzZScsXG4gICAgICAncHJldmlldyc6ICdQcmV2aWV3J1xuICAgIH1cbiAgfSxcblxuICBub3RpZmllcjoge1xuICAgIGVudGVydGFpbjogZmFsc2UsICAgLy8gd2hlbiB0cnVlLCB1c2VyIGlzIGVudGVydGFpbmVkIHdoaWxlIHdhaXRpbmcsIHNlZSBleGFtcGxlc1xuICAgIGVudGVydGFpbkNsYXNzOiAnYmcnLFxuICAgIGVudGVydGFpbkxpbWl0OiA2LFxuICAgIGVudGVydGFpbkludGVydmFsOiA5MDAwXG4gIH0sXG5cbiAgdGltZW91dHM6IHtcbiAgICB1c2VyTWVkaWE6IDIwZTMsICAgICAgICAgLy8gaW4gbWlsbGlzZWNvbmRzLCBpbmNyZWFzZSBpZiB5b3Ugd2FudCB1c2VyIGdpdmUgbW9yZSB0aW1lIHRvIGVuYWJsZSB3ZWJjYW1cbiAgICBjb25uZWN0aW9uOiAxZTQsICAgICAgICAgLy8gaW4gc2Vjb25kcywgaW5jcmVhc2UgaWYgYXBpIGlzIHNsb3dcbiAgICBwaW5nSW50ZXJ2YWw6IDQ1ZTMgICAgICAgLy8gaW4gbWlsbGlzZWNvbmRzLCBrZWVwcyB3ZWJzdHJlYW0gKGNvbm5lY3Rpb24pIGFsaXZlIHdoZW4gcGF1c2luZ1xuICB9LFxuXG4gIGNhbGxiYWNrczoge1xuICAgIC8vIGEgY3VzdG9tIGNhbGxiYWNrIHRvIHR3ZWFrIGZvcm0gZGF0YSBiZWZvcmUgcG9zdGluZyB0byBzZXJ2ZXJcbiAgICAvLyB0aGlzIGlzIGZvciBhZHZhbmNlZCB1c2Ugb25seSBhbmQgc2hvdWxkbid0IGJlIHVzZWQgaWYgcG9zc2libGVcbiAgICBhZGp1c3RGb3JtRGF0YUJlZm9yZVBvc3Rpbmc6IG51bGxcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGZyb206IG51bGwsICAgICAgIC8vIGRlZmluZSBkZWZhdWx0IEZST00gZW1haWwgYWRkcmVzc1xuICAgIHRvOiBudWxsLCAgICAgICAgIC8vIGRlZmluZSBkZWZhdWx0IFRPIGVtYWlsIGFkZHJlc3NcbiAgICBzdWJqZWN0OiBudWxsLCAgICAvLyBkZWZpbmUgZGVmYXVsdCBzdWJqZWN0IGxpbmVcbiAgICBib2R5OiBudWxsICAgICAgICAvLyBkZWZpbmUgZGVmYXVsdCBib2R5IGNvbnRlbnRcbiAgfSxcblxuICAvLyBhIHNwZWNpYWwgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGV2ZXJ5dGhpbmcgdG8gYmUgaW5pdGlhbGlzZWRcbiAgLy8gc2VydmVzIG9ubHkgZm9yIHBsYXlpbmcgZXhpc3RpbmcgdmlkZW9tYWlscyB3aXRoIHRoZSByZXBsYXkgZnVuY3Rpb25cbiAgcGxheWVyT25seTogZmFsc2UsXG5cbiAgLy8gc2hvdyBlcnJvcnMgaW5zaWRlIHRoZSBjb250YWluZXI/XG4gIGRpc3BsYXlFcnJvcnM6IHRydWUsXG5cbiAgLy8gdHJ1ZSA9IGFsbCBmb3JtIGlucHV0cyBnZXQgZGlzYWJsZWQgYW5kIGRpc2FwcGVhciB3aGVuIGJyb3dzZXIgY2FuJ3QgcmVjb3JkXG4gIGFkanVzdEZvcm1PbkJyb3dzZXJFcnJvcjogZmFsc2UsXG5cbiAgLy8gd2hlbiB0cnVlLCBhbnkgZXJyb3JzIHdpbGwgYmUgc2VudCB0byB0aGUgdmlkZW9tYWlsIHNlcnZlciBmb3IgYW5hbHlzaXNcbiAgLy8gcHM6IGNhbiBiZSBhIGZ1bmN0aW9uIHRvbyByZXR1cm5pbmcgYSBib29sZWFuXG4gIHJlcG9ydEVycm9yczogZmFsc2UsXG5cbiAgLy8ganVzdCBmb3IgdGVzdGluZyBwdXJwb3NlcyB0byBzaW11bGF0ZSBicm93c2VyIGFnZW50IGhhbmRsaW5nXG4gIGZha2VVYVN0cmluZzogbnVsbCxcblxuICB2ZXJzaW9uOiB2ZXJzaW9uXG59XG4iLCJpbXBvcnQgc3VwZXJhZ2VudCBmcm9tICdzdXBlcmFnZW50J1xuaW1wb3J0IENvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cydcblxuY29uc3QgQ0FDSEVfS0VZID0gJ2FsaWFzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAob3B0aW9ucykge1xuICBjb25zdCBjYWNoZSA9IHt9XG5cbiAgZnVuY3Rpb24gYXBwbHlEZWZhdWx0VmFsdWUgKHZpZGVvbWFpbCwgbmFtZSkge1xuICAgIGlmIChvcHRpb25zLmRlZmF1bHRzW25hbWVdICYmICF2aWRlb21haWxbbmFtZV0pIHtcbiAgICAgIHZpZGVvbWFpbFtuYW1lXSA9IG9wdGlvbnMuZGVmYXVsdHNbbmFtZV1cbiAgICB9XG5cbiAgICByZXR1cm4gdmlkZW9tYWlsXG4gIH1cblxuICBmdW5jdGlvbiBhcHBseURlZmF1bHRWYWx1ZXMgKHZpZGVvbWFpbCkge1xuICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICB2aWRlb21haWwgPSBhcHBseURlZmF1bHRWYWx1ZSh2aWRlb21haWwsICdmcm9tJylcbiAgICAgIHZpZGVvbWFpbCA9IGFwcGx5RGVmYXVsdFZhbHVlKHZpZGVvbWFpbCwgJ3RvJylcbiAgICAgIHZpZGVvbWFpbCA9IGFwcGx5RGVmYXVsdFZhbHVlKHZpZGVvbWFpbCwgJ3N1YmplY3QnKVxuICAgICAgdmlkZW9tYWlsID0gYXBwbHlEZWZhdWx0VmFsdWUodmlkZW9tYWlsLCAnYm9keScpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZGVvbWFpbFxuICB9XG5cbiAgZnVuY3Rpb24gcGFja0Vycm9yIChlcnIsIHJlcykge1xuICAgIGlmIChyZXMgJiYgcmVzLmJvZHkgJiYgcmVzLmJvZHkuZXJyb3IpIHtcbiAgICAgIC8vIHVzZSB0aGUgc2VydmVyIGdlbmVyYXRlZCB0ZXh0IGluc3RlYWQgb2YgdGhlIHN1cGVyYWdlbnQncyBkZWZhdWx0IHRleHRcbiAgICAgIGVyciA9IHJlcy5ib2R5LmVycm9yXG5cbiAgICAgIGlmICghZXJyLm1lc3NhZ2UgJiYgcmVzLnRleHQpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSByZXMudGV4dFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcnJcbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoIChhbGlhcywgY2IpIHtcbiAgICBzdXBlcmFnZW50XG4gICAgICAuZ2V0KCcvdmlkZW9tYWlsLycgKyBhbGlhcyArICcvc25hcHNob3QnKVxuICAgICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgICAgLnNldChDb25zdGFudHMuU0lURV9OQU1FX0xBQkVMLCBvcHRpb25zLnNpdGVOYW1lKVxuICAgICAgLnRpbWVvdXQob3B0aW9ucy50aW1lb3V0cy5jb25uZWN0aW9uKVxuICAgICAgLmVuZChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgZXJyID0gcGFja0Vycm9yKGVyciwgcmVzKVxuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYihlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdmlkZW9tYWlsID0gcmVzLmJvZHkgPyByZXMuYm9keSA6IG51bGxcblxuICAgICAgICAgIGlmIChvcHRpb25zLmNhY2hlKSB7XG4gICAgICAgICAgICBjYWNoZVtDQUNIRV9LRVldID0gdmlkZW9tYWlsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2IobnVsbCwgdmlkZW9tYWlsKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGUgKG1ldGhvZCwgdmlkZW9tYWlsLCBpZGVudGlmaWVyLCBjYikge1xuICAgIGlmICghY2IpIHtcbiAgICAgIGNiID0gaWRlbnRpZmllclxuICAgICAgaWRlbnRpZmllciA9IG51bGxcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IHt9XG5cbiAgICB2YXIgdXJsID0gb3B0aW9ucy5iYXNlVXJsICsgJy92aWRlb21haWwvJ1xuICAgIHZhciByZXF1ZXN0XG5cbiAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgdXJsICs9IGlkZW50aWZpZXJcbiAgICB9XG5cbiAgICByZXF1ZXN0ID0gc3VwZXJhZ2VudChtZXRob2QsIHVybClcblxuICAgIHF1ZXJ5UGFyYW1zW0NvbnN0YW50cy5TSVRFX05BTUVfTEFCRUxdID0gb3B0aW9ucy5zaXRlTmFtZVxuXG4gICAgcmVxdWVzdFxuICAgICAgLnF1ZXJ5KHF1ZXJ5UGFyYW1zKVxuICAgICAgLnNlbmQodmlkZW9tYWlsKVxuICAgICAgLnRpbWVvdXQob3B0aW9ucy50aW1lb3V0KVxuICAgICAgLmVuZChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgZXJyID0gcGFja0Vycm9yKGVyciwgcmVzKVxuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYihlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2FjaGUgJiYgdmlkZW9tYWlsW0NBQ0hFX0tFWV0pIHtcbiAgICAgICAgICAgIGNhY2hlW3ZpZGVvbWFpbFtDQUNIRV9LRVldXSA9IHJlcy5ib2R5LnZpZGVvbWFpbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNiKG51bGwsIHJlcy5ib2R5LnZpZGVvbWFpbCwgcmVzLmJvZHkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICB0aGlzLmdldCA9IGZ1bmN0aW9uIChhbGlhcywgY2IpIHtcbiAgICBpZiAob3B0aW9ucy5jYWNoZSAmJiBjYWNoZVthbGlhc10pIHtcbiAgICAgIC8vIGtlZXAgYWxsIGNhbGxiYWNrcyBhc3luY1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNiKG51bGwsIGNhY2hlW2FsaWFzXSlcbiAgICAgIH0sIDApXG4gICAgfSBlbHNlIHtcbiAgICAgIGZldGNoKGFsaWFzLCBjYilcbiAgICB9XG4gIH1cblxuICB0aGlzLnJlcG9ydEVycm9yID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IHt9XG4gICAgY29uc3QgdXJsID0gb3B0aW9ucy5iYXNlVXJsICsgJy9jbGllbnQtZXJyb3IvJ1xuICAgIGNvbnN0IHJlcXVlc3QgPSBzdXBlcmFnZW50KCdwb3N0JywgdXJsKVxuXG4gICAgcXVlcnlQYXJhbXNbQ29uc3RhbnRzLlNJVEVfTkFNRV9MQUJFTF0gPSBvcHRpb25zLnNpdGVOYW1lXG5cbiAgICByZXF1ZXN0XG4gICAgICAucXVlcnkocXVlcnlQYXJhbXMpXG4gICAgICAuc2VuZChlcnIpXG4gICAgICAudGltZW91dChvcHRpb25zLnRpbWVvdXQpXG4gICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICBlcnIgPSBwYWNrRXJyb3IoZXJyLCByZXMpXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYiAmJiBjYihlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IgJiYgY2IoKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgdGhpcy5wb3N0ID0gZnVuY3Rpb24gKHZpZGVvbWFpbCwgY2IpIHtcbiAgICB2aWRlb21haWwgPSBhcHBseURlZmF1bHRWYWx1ZXModmlkZW9tYWlsKVxuXG4gICAgLy8gYWx3YXlzIGdvb2QgdG8ga25vdyB0aGUgdmVyc2lvbiBvZiB0aGUgY2xpZW50XG4gICAgLy8gdGhlIHZpZGVvbWFpbCB3YXMgc3VibWl0dGVkIHdpdGhcbiAgICB2aWRlb21haWxbQ29uc3RhbnRzLlZFUlNJT05fTEFCRUxdID0gb3B0aW9ucy52ZXJzaW9uXG5cbiAgICBpZiAob3B0aW9ucy5jYWxsYmFja3MuYWRqdXN0Rm9ybURhdGFCZWZvcmVQb3N0aW5nKSB7XG4gICAgICBvcHRpb25zLmNhbGxiYWNrcy5hZGp1c3RGb3JtRGF0YUJlZm9yZVBvc3RpbmcoXG4gICAgICAgIHZpZGVvbWFpbCxcbiAgICAgICAgZnVuY3Rpb24gKGVyciwgYWRqdXN0ZWRWaWRlb21haWwpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYihlcnIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyaXRlKCdwb3N0JywgYWRqdXN0ZWRWaWRlb21haWwsIGNiKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZSgncG9zdCcsIHZpZGVvbWFpbCwgY2IpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5wdXQgPSBmdW5jdGlvbiAodmlkZW9tYWlsLCBjYikge1xuICAgIHdyaXRlKCdwdXQnLCB2aWRlb21haWwsIHZpZGVvbWFpbC5rZXksIGNiKVxuICB9XG5cbiAgdGhpcy5mb3JtID0gZnVuY3Rpb24gKGZvcm1EYXRhLCB1cmwsIGNiKSB7XG4gICAgdmFyIGZvcm1UeXBlXG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMuZW5jdHlwZSkge1xuICAgICAgY2FzZSBDb25zdGFudHMucHVibGljLkVOQ19UWVBFX0FQUF9KU09OOlxuICAgICAgICBmb3JtVHlwZSA9ICdqc29uJ1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBDb25zdGFudHMucHVibGljLkVOQ19UWVBFX0ZPUk06XG4gICAgICAgIGZvcm1UeXBlID0gJ2Zvcm0nXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBrZWVwIGFsbCBjYWxsYmFja3MgYXN5bmNcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY2IobmV3IEVycm9yKCdJbnZhbGlkIGVuY3R5cGUgZ2l2ZW46ICcgKyBvcHRpb25zLmVuY3R5cGUpKVxuICAgICAgICB9LCAwKVxuICAgIH1cblxuICAgIGlmIChmb3JtVHlwZSkge1xuICAgICAgc3VwZXJhZ2VudFxuICAgICAgICAucG9zdCh1cmwpXG4gICAgICAgIC50eXBlKGZvcm1UeXBlKVxuICAgICAgICAuc2VuZChmb3JtRGF0YSlcbiAgICAgICAgLnRpbWVvdXQob3B0aW9ucy50aW1lb3V0KVxuICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgIGVyciA9IHBhY2tFcnJvcihlcnIsIHJlcylcblxuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2IobnVsbCwgcmVzKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPSdALXdlYmtpdC1rZXlmcmFtZXMgYmxpbmt7MCV7b3BhY2l0eTouOX0zNSV7b3BhY2l0eTouOX01MCV7b3BhY2l0eTouMX04NSV7b3BhY2l0eTouMX10b3tvcGFjaXR5Oi45fX1Aa2V5ZnJhbWVzIGJsaW5rezAle29wYWNpdHk6Ljl9MzUle29wYWNpdHk6Ljl9NTAle29wYWNpdHk6LjF9ODUle29wYWNpdHk6LjF9dG97b3BhY2l0eTouOX19LklJVjo6LXdlYmtpdC1tZWRpYS1jb250cm9scy1wbGF5LWJ1dHRvbiwuSUlWOjotd2Via2l0LW1lZGlhLWNvbnRyb2xzLXN0YXJ0LXBsYXliYWNrLWJ1dHRvbntvcGFjaXR5OjA7cG9pbnRlci1ldmVudHM6bm9uZTt3aWR0aDo1cHh9LnZpZGVvbWFpbCAudmlzdWFsc3twb3NpdGlvbjpyZWxhdGl2ZX0udmlkZW9tYWlsIC52aXN1YWxzIHZpZGVvLnJlcGxheXt3aWR0aDoxMDAlO2hlaWdodDoxMDAlfS52aWRlb21haWwgLmNvdW50ZG93biwudmlkZW9tYWlsIC5wYXVzZWRIZWFkZXIsLnZpZGVvbWFpbCAucGF1c2VkSGludCwudmlkZW9tYWlsIC5yZWNvcmROb3RlLC52aWRlb21haWwgLnJlY29yZFRpbWVye21hcmdpbjowO2hlaWdodDphdXRvfS52aWRlb21haWwgLmNvdW50ZG93biwudmlkZW9tYWlsIC5mYWNpbmdNb2RlLC52aWRlb21haWwgLnBhdXNlZCwudmlkZW9tYWlsIC5yZWNvcmROb3RlLC52aWRlb21haWwgLnJlY29yZFRpbWVyLC52aWRlb21haWwgbm9zY3JpcHR7cG9zaXRpb246YWJzb2x1dGV9LnZpZGVvbWFpbCAuY291bnRkb3duLC52aWRlb21haWwgLnBhdXNlZEhlYWRlciwudmlkZW9tYWlsIC5wYXVzZWRIaW50LC52aWRlb21haWwgLnJlY29yZE5vdGUsLnZpZGVvbWFpbCAucmVjb3JkVGltZXIsLnZpZGVvbWFpbCBub3NjcmlwdHtmb250LXdlaWdodDo3MDB9LnZpZGVvbWFpbCAuY291bnRkb3duLC52aWRlb21haWwgLnBhdXNlZCwudmlkZW9tYWlsIG5vc2NyaXB0e3dpZHRoOjEwMCU7dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpOy1tcy10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX0udmlkZW9tYWlsIC5jb3VudGRvd24sLnZpZGVvbWFpbCAucGF1c2VkSGVhZGVyLC52aWRlb21haWwgLnBhdXNlZEhpbnR7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC1zaGFkb3c6MCAwIDJweCAjZmZmfS52aWRlb21haWwgLmNvdW50ZG93biwudmlkZW9tYWlsIC5wYXVzZWRIZWFkZXJ7b3BhY2l0eTouODU7Zm9udC1zaXplOjQ0MCV9LnZpZGVvbWFpbCAucGF1c2VkSGludHtmb250LXNpemU6MTUwJX0udmlkZW9tYWlsIC5mYWNpbmdNb2Rle3JpZ2h0Oi43ZW07Ym90dG9tOi42ZW07YmFja2dyb3VuZDpyZ2JhKDEwLDEwLDEwLC4zKTtjb2xvcjpoc2xhKDAsMCUsOTYuMSUsLjkpO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTtib3JkZXI6bm9uZTtwYWRkaW5nOi4xZW0gLjNlbTtmb250LXNpemU6MS4yZW07ei1pbmRleDoxMDtvdXRsaW5lOm5vbmU7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMnMgZWFzZTstby10cmFuc2l0aW9uOmFsbCAuMnMgZWFzZTt0cmFuc2l0aW9uOmFsbCAuMnMgZWFzZX0udmlkZW9tYWlsIC5mYWNpbmdNb2RlOmhvdmVye2JhY2tncm91bmQ6cmdiYSg1MCw1MCw1MCwuNyk7Y3Vyc29yOnBvaW50ZXJ9LnZpZGVvbWFpbCAucmVjb3JkTm90ZSwudmlkZW9tYWlsIC5yZWNvcmRUaW1lcntyaWdodDouN2VtO2JhY2tncm91bmQ6cmdiYSgxMCwxMCwxMCwuOCk7cGFkZGluZzouNGVtIC40ZW0gLjNlbTstd2Via2l0LXRyYW5zaXRpb246YWxsIDFzIGVhc2U7LW8tdHJhbnNpdGlvbjphbGwgMXMgZWFzZTt0cmFuc2l0aW9uOmFsbCAxcyBlYXNlO2NvbG9yOiMwMGQ4MTQ7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO29wYWNpdHk6Ljl9LnZpZGVvbWFpbCAucmVjb3JkTm90ZS5uZWFyLC52aWRlb21haWwgLnJlY29yZFRpbWVyLm5lYXJ7Y29sb3I6I2ViOTM2OX0udmlkZW9tYWlsIC5yZWNvcmROb3RlLm5pZ2gsLnZpZGVvbWFpbCAucmVjb3JkVGltZXIubmlnaHtjb2xvcjojZWE0YjJhfS52aWRlb21haWwgLnJlY29yZFRpbWVye3RvcDouN2VtfS52aWRlb21haWwgLnJlY29yZE5vdGV7dG9wOjMuNmVtfS52aWRlb21haWwgLnJlY29yZE5vdGU6YmVmb3Jle2NvbnRlbnQ6XCJSRUNcIjstd2Via2l0LWFuaW1hdGlvbjpibGluayAxcyBpbmZpbml0ZTthbmltYXRpb246YmxpbmsgMXMgaW5maW5pdGV9LnZpZGVvbWFpbCAubm90aWZpZXJ7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtoZWlnaHQ6MTAwJX0udmlkZW9tYWlsIC5yYWRpb0dyb3Vwe2Rpc3BsYXk6YmxvY2t9LnZpZGVvbWFpbCB2aWRlb3ttYXJnaW4tYm90dG9tOjB9JyIsImltcG9ydCBpc1BPVCBmcm9tICdpcy1wb3dlci1vZi10d28nXG5pbXBvcnQgQXVkaW9TYW1wbGUgZnJvbSAnYXVkaW8tc2FtcGxlJ1xuXG5pbXBvcnQgVmlkZW9tYWlsRXJyb3IgZnJvbSAnLi92aWRlb21haWxFcnJvcidcblxuY29uc3QgQ0hBTk5FTFMgPSAxXG5cbi8vIGZvciBpbnNwaXJhdGlvbiBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYWViZWthc3NlYmlsL21pY3JvcGhvbmUtc3RyZWFtXG5cbi8vIHRvZG8gY29kZSBuZWVkcyByZXdyaXRlXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICh1c2VyTWVkaWEsIG9wdGlvbnMpIHtcbiAgdmFyIHNjcmlwdFByb2Nlc3NvclxuICB2YXIgYXVkaW9JbnB1dFxuICB2YXIgdmNBdWRpb0NvbnRleHRcblxuICBmdW5jdGlvbiBnZXRBdWRpb0NvbnRleHRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dFxuICB9XG5cbiAgZnVuY3Rpb24gaGFzQXVkaW9Db250ZXh0ICgpIHtcbiAgICByZXR1cm4gISFnZXRBdWRpb0NvbnRleHRDbGFzcygpICYmICEhZ2V0QXVkaW9Db250ZXh0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEF1ZGlvQ29udGV4dCAoKSB7XG4gICAgLy8gaW5zdGFudGlhdGUgb25seSBvbmNlXG4gICAgaWYgKCF2Y0F1ZGlvQ29udGV4dCkge1xuICAgICAgY29uc3QgQXVkaW9Db250ZXh0ID0gZ2V0QXVkaW9Db250ZXh0Q2xhc3MoKVxuICAgICAgdmNBdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KClcbiAgICB9XG5cbiAgICByZXR1cm4gdmNBdWRpb0NvbnRleHRcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQXVkaW9Qcm9jZXNzIChlLCBjYikge1xuICAgIGlmICghdXNlck1lZGlhLmlzUmVjb3JkaW5nKCkgfHwgdXNlck1lZGlhLmlzUGF1c2VkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBGbG9hdDMyQXJyYXkgY29udGFpbmluZyB0aGUgUENNIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGFubmVsLFxuICAgIC8vIGRlZmluZWQgYnkgdGhlIGNoYW5uZWwgcGFyYW1ldGVyICh3aXRoIDAgcmVwcmVzZW50aW5nIHRoZSBmaXJzdCBjaGFubmVsKVxuICAgIGNvbnN0IGZsb2F0MzJBcnJheSA9IGUuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMClcblxuICAgIGNiKG5ldyBBdWRpb1NhbXBsZShmbG9hdDMyQXJyYXkpKVxuICB9XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKGxvY2FsTWVkaWFTdHJlYW0pIHtcbiAgICBvcHRpb25zLmRlYnVnKCdBdWRpb1JlY29yZGVyOiBpbml0KCknKVxuXG4gICAgLy8gY3JlYXRlcyBhbiBhdWRpbyBub2RlIGZyb20gdGhlIG1pY3JvcGhvbmUgaW5jb21pbmcgc3RyZWFtXG4gICAgY29uc3Qgdm9sdW1lID0gZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlR2FpbigpXG5cbiAgICB0cnkge1xuICAgICAgYXVkaW9JbnB1dCA9IGdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKGxvY2FsTWVkaWFTdHJlYW0pXG4gICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoXG4gICAgICAgICdXZWJjYW0gaGFzIG5vIGF1ZGlvJyxcbiAgICAgICAgZXhjLnRvU3RyaW5nKCksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoIWlzUE9UKG9wdGlvbnMuYXVkaW8uYnVmZmVyU2l6ZSkpIHtcbiAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnQXVkaW8gYnVmZmVyIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIHR3by4nLCBvcHRpb25zKVxuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuYXVkaW8udm9sdW1lIHx8IG9wdGlvbnMuYXVkaW8udm9sdW1lID4gMSkge1xuICAgICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdBdWRpbyB2b2x1bWUgbXVzdCBiZSBiZXR3ZWVuIHplcm8gYW5kIG9uZS4nLCBvcHRpb25zKVxuICAgIH1cblxuICAgIHZvbHVtZS5nYWluLnZhbHVlID0gb3B0aW9ucy5hdWRpby52b2x1bWVcblxuICAgIC8vIENyZWF0ZSBhIFNjcmlwdFByb2Nlc3Nvck5vZGUgd2l0aCB0aGUgZ2l2ZW4gYnVmZmVyU2l6ZSBhbmRcbiAgICAvLyBhIHNpbmdsZSBpbnB1dCBhbmQgb3V0cHV0IGNoYW5uZWxcbiAgICBzY3JpcHRQcm9jZXNzb3IgPSBnZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoXG4gICAgICBvcHRpb25zLmF1ZGlvLmJ1ZmZlclNpemUsXG4gICAgICBDSEFOTkVMUyxcbiAgICAgIENIQU5ORUxTXG4gICAgKVxuXG4gICAgLy8gY29ubmVjdCBzdHJlYW0gdG8gb3VyIHNjcmlwdFByb2Nlc3NvclxuICAgIGF1ZGlvSW5wdXQuY29ubmVjdChzY3JpcHRQcm9jZXNzb3IpXG5cbiAgICAvLyBjb25uZWN0IG91ciBzY3JpcHRQcm9jZXNzb3IgdG8gdGhlIHByZXZpb3VzIGRlc3RpbmF0aW9uXG4gICAgc2NyaXB0UHJvY2Vzc29yLmNvbm5lY3QoZ2V0QXVkaW9Db250ZXh0KCkuZGVzdGluYXRpb24pXG5cbiAgICAvLyBjb25uZWN0IHZvbHVtZVxuICAgIGF1ZGlvSW5wdXQuY29ubmVjdCh2b2x1bWUpXG4gICAgdm9sdW1lLmNvbm5lY3Qoc2NyaXB0UHJvY2Vzc29yKVxuICB9XG5cbiAgdGhpcy5yZWNvcmQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBvcHRpb25zLmRlYnVnKCdBdWRpb1JlY29yZGVyOiByZWNvcmQoKScpXG5cbiAgICBzY3JpcHRQcm9jZXNzb3Iub25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgb25BdWRpb1Byb2Nlc3MoZSwgY2IpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIG9wdGlvbnMuZGVidWcoJ0F1ZGlvUmVjb3JkZXI6IHN0b3AoKScpXG5cbiAgICBpZiAoc2NyaXB0UHJvY2Vzc29yKSB7XG4gICAgICBzY3JpcHRQcm9jZXNzb3Iub25hdWRpb3Byb2Nlc3MgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAoYXVkaW9JbnB1dCkge1xuICAgICAgYXVkaW9JbnB1dC5kaXNjb25uZWN0KClcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0L2Nsb3NlXG4gICAgaWYgKGhhc0F1ZGlvQ29udGV4dCgpKSB7XG4gICAgICBpZiAoZ2V0QXVkaW9Db250ZXh0KCkuY2xvc2UpIHtcbiAgICAgICAgZ2V0QXVkaW9Db250ZXh0KClcbiAgICAgICAgICAuY2xvc2UoKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVidWcoJ0F1ZGlvUmVjb3JkZXI6IGF1ZGlvIGNvbnRleHQgaXMgY2xvc2VkJylcbiAgICAgICAgICAgIHZjQXVkaW9Db250ZXh0ID0gbnVsbFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZShlcnIsIG9wdGlvbnMpXG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZjQXVkaW9Db250ZXh0ID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuZ2V0U2FtcGxlUmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzQXVkaW9Db250ZXh0KCkpIHtcbiAgICAgIHJldHVybiBnZXRBdWRpb0NvbnRleHQoKS5zYW1wbGVSYXRlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IFVBUGFyc2VyIGZyb20gJ3VhLXBhcnNlci1qcydcbmltcG9ydCBkZWZpbmVkIGZyb20gJ2RlZmluZWQnXG5pbXBvcnQgVmlkZW9tYWlsRXJyb3IgZnJvbSAnLi92aWRlb21haWxFcnJvcidcblxuY29uc3QgQnJvd3NlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgY29uc3QgZmlyZWZveERvd25sb2FkID0gJ2h0dHA6Ly93d3cubW96aWxsYS5vcmcvZmlyZWZveC91cGRhdGUvJ1xuICBjb25zdCBlZGdlRG93bmxvYWQgPSAnaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS9lbi11cy9kb3dubG9hZC9kZXRhaWxzLmFzcHg/aWQ9NDgxMjYnXG4gIGNvbnN0IGNocm9tZURvd25sb2FkID0gJ2h0dHA6Ly93d3cuZ29vZ2xlLmNvbS9jaHJvbWUvJ1xuICBjb25zdCBjaHJvbWl1bURvd25sb2FkID0gJ2h0dHA6Ly93d3cuY2hyb21pdW0ub3JnL2dldHRpbmctaW52b2x2ZWQvZG93bmxvYWQtY2hyb21pdW0nXG4gIGNvbnN0IGJyb3dzZUhhcHB5TGluayA9ICdodHRwOi8vYnJvd3NlaGFwcHkuY29tJ1xuICBjb25zdCB1YSA9IGRlZmluZWQob3B0aW9ucy5mYWtlVWFTdHJpbmcsIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHdpbmRvdy5uYXZpZ2F0b3IgJiZcbiAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudFxuICApLCAnJylcblxuICBjb25zdCB1YVBhcnNlciA9IG5ldyBVQVBhcnNlcih1YSkuZ2V0UmVzdWx0KClcblxuICBjb25zdCBpc0lPUyA9IHVhUGFyc2VyLm9zLm5hbWUgPT09ICdpT1MnXG4gIGNvbnN0IGJyb3dzZXJWZXJzaW9uID0gcGFyc2VGbG9hdCh1YVBhcnNlci5icm93c2VyLnZlcnNpb24pXG4gIGNvbnN0IGlzQ2hyb21lID0gdWFQYXJzZXIuYnJvd3Nlci5uYW1lID09PSAnQ2hyb21lJ1xuICBjb25zdCBpc0Nocm9taXVtID0gdWFQYXJzZXIuYnJvd3Nlci5uYW1lID09PSAnQ2hyb21pdW0nXG4gIGNvbnN0IGZpcmVmb3ggPSB1YVBhcnNlci5icm93c2VyLm5hbWUgPT09ICdGaXJlZm94J1xuICBjb25zdCBvc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHVhUGFyc2VyLm9zLnZlcnNpb24pXG4gIGNvbnN0IGlzV2luZG93cyA9IHVhUGFyc2VyLm9zLm5hbWUgPT09ICdXaW5kb3dzJ1xuICBjb25zdCBpc0VkZ2UgPSB1YVBhcnNlci5icm93c2VyLm5hbWUgPT09ICdFZGdlJyB8fCAoaXNXaW5kb3dzICYmIG9zVmVyc2lvbiA+PSAxMClcbiAgY29uc3QgaXNJRSA9IC9JRS8udGVzdCh1YVBhcnNlci5icm93c2VyLm5hbWUpXG4gIGNvbnN0IGlzU2FmYXJpID0gL1NhZmFyaS8udGVzdCh1YVBhcnNlci5icm93c2VyLm5hbWUpXG4gIGNvbnN0IGlzT3BlcmEgPSAvT3BlcmEvLnRlc3QodWFQYXJzZXIuYnJvd3Nlci5uYW1lKVxuICBjb25zdCBpc0FuZHJvaWQgPSAvQW5kcm9pZC8udGVzdCh1YVBhcnNlci5vcy5uYW1lKVxuICBjb25zdCBjaHJvbWVCYXNlZCA9IGlzQ2hyb21lIHx8IGlzQ2hyb21pdW1cbiAgY29uc3QgaXNGYWNlYm9vayA9IHVhUGFyc2VyLmJyb3dzZXIubmFtZSA9PT0gJ0ZhY2Vib29rJyAvLyBGYWNlYm9vayBBcHAgZm9yIGlPUyAmIEFuZHJvaWRcblxuICBjb25zdCBpc01vYmlsZSA9IGlzSU9TIHx8IGlzQW5kcm9pZFxuICBjb25zdCBpc09rU2FmYXJpID0gaXNTYWZhcmkgJiYgYnJvd3NlclZlcnNpb24gPj0gMTFcbiAgY29uc3QgaXNPa0lPUyA9IGlzSU9TICYmIG9zVmVyc2lvbiA+PSAxMVxuICBjb25zdCBpc0JhZElPUyA9IGlzSU9TICYmIG9zVmVyc2lvbiA8IDExXG5cbiAgY29uc3Qgb2tCcm93c2VyID1cbiAgICBjaHJvbWVCYXNlZCB8fFxuICAgIGZpcmVmb3ggfHxcbiAgICBpc0FuZHJvaWQgfHxcbiAgICBpc09wZXJhIHx8XG4gICAgaXNFZGdlIHx8XG4gICAgaXNPa1NhZmFyaSB8fFxuICAgIGlzT2tJT1NcblxuICBjb25zdCBzZWxmID0gdGhpc1xuXG4gIHZhciB2aWRlb1R5cGVcblxuICBmdW5jdGlvbiBnZXRSZWNvbW1lbmRhdGlvbiAoKSB7XG4gICAgdmFyIHdhcm5pbmdcblxuICAgIGlmIChmaXJlZm94KSB7XG4gICAgICBpZiAoaXNJT1MpIHtcbiAgICAgICAgd2FybmluZyA9ICdGaXJlZm94IG9uIGlPUyBpcyBub3QgcmVhZHkgZm9yIGNhbWVyYXMgeWV0LiBIb3BlZnVsbHkgaW4gbmVhciBmdXR1cmUgLi4uJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyA9ICdQcm9iYWJseSB5b3UgbmVlZCB0byA8YSBocmVmPVwiJyArIGZpcmVmb3hEb3dubG9hZCArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj4nICtcbiAgICAgICAgICAgICAgICAgICd1cGdyYWRlIEZpcmVmb3g8L2E+IHRvIGZpeCB0aGlzLidcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQ2hyb21lKSB7XG4gICAgICBpZiAoaXNJT1MpIHtcbiAgICAgICAgd2FybmluZyA9ICdVc2UgU2FmYXJpIGluc3RlYWQuIEFwcGxlIGRvZXNuXFwndCBnaXZlIENocm9tZSBhY2Nlc3MgdG8gaVBob25lIGNhbWVyYXMgKGJvb28pLidcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcgPSAnUHJvYmFibHkgeW91IG5lZWQgdG8gPGEgaHJlZj1cIicgKyBjaHJvbWVEb3dubG9hZCArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj4nICtcbiAgICAgICAgICAgICAgICAgICd1cGdyYWRlIENocm9tZTwvYT4gdG8gZml4IHRoaXMuJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNDaHJvbWl1bSkge1xuICAgICAgd2FybmluZyA9ICdQcm9iYWJseSB5b3UgbmVlZCB0byA8YSBocmVmPVwiJyArIGNocm9taXVtRG93bmxvYWQgKyAnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+JyArXG4gICAgICAgICAgICAgICAgJ3VwZ3JhZGUgQ2hyb21pdW08L2E+IHRvIGZpeCB0aGlzLidcbiAgICB9IGVsc2UgaWYgKGlzSUUpIHtcbiAgICAgIHdhcm5pbmcgPSAnSW5zdGVhZCBvZiBJbnRlcm5ldCBFeHBsb3JlciB5b3UgbmVlZCB0byB1cGdyYWRlIHRvJyArXG4gICAgICAgICAgICAgICAgJyA8YSBocmVmPVwiJyArIGVkZ2VEb3dubG9hZCArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj5FZGdlPC9hPi4nXG4gICAgfSBlbHNlIGlmIChpc09rU2FmYXJpKSB7XG4gICAgICB3YXJuaW5nID0gJ1Byb2JhYmx5IHlvdSBuZWVkIHRvIHNodXQgZG93biBTYWZhcmkgYW5kIHJlc3RhcnQgaXQsIHRoaXMgZm9yIGNvcnJlY3Qgd2ViY2FtIGFjY2Vzcy4nXG4gICAgfSBlbHNlIGlmIChpc1NhZmFyaSkge1xuICAgICAgd2FybmluZyA9ICdTYWZhcmkgYmVsb3cgdmVyc2lvbiAxMSBoYXMgbm8gd2ViY2FtIHN1cHBvcnQuPGJyLz5CZXR0ZXIgdXBncmFkZSBTYWZhcmkgb3IgcGljaycgK1xuICAgICAgICAgICAgICAgICcgPGEgaHJlZj1cIicgKyBjaHJvbWVEb3dubG9hZCArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj5DaHJvbWU8L2E+LCcgK1xuICAgICAgICAgICAgICAgICcgPGEgaHJlZj1cIicgKyBmaXJlZm94RG93bmxvYWQgKyAnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+RmlyZWZveDwvYT4gb3IgQW5kcm9pZC4nXG4gICAgfVxuXG4gICAgcmV0dXJuIHdhcm5pbmdcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVzZXJNZWRpYVdhcm5pbmcgKCkge1xuICAgIHZhciB3YXJuaW5nXG5cbiAgICBpZiAoaXNCYWRJT1MpIHtcbiAgICAgIHdhcm5pbmcgPSAnT24gaVBhZHMgb3IgaVBob25lcyBiZWxvdyBpT1MgdjExIHRoaXMgY2FtZXJhIGZlYXR1cmUgaXMgbWlzc2luZy48YnIvPjxici8+JyArXG4gICAgICAgICAgICAgICAgJ0ZvciBub3csIHdlIHJlY29tbWVuZCB5b3UgdG8gdXBncmFkZSBpT1Mgb3IgdG8gdXNlIGFuIEFuZHJvaWQgZGV2aWNlLidcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyA9IGdldFJlY29tbWVuZGF0aW9uKClcbiAgICB9XG5cbiAgICBpZiAoIXdhcm5pbmcpIHtcbiAgICAgIGlmIChzZWxmLmlzQ2hyb21lQmFzZWQoKSB8fCBzZWxmLmlzRmlyZWZveCgpIHx8IGlzU2FmYXJpKSB7XG4gICAgICAgIHdhcm5pbmcgPSAnRm9yIHRoZSB3ZWJjYW0gZmVhdHVyZSwgeW91ciBicm93c2VyIG5lZWRzIGFuIHVwZ3JhZGUuJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRmFjZWJvb2spIHtcbiAgICAgICAgICB3YXJuaW5nID0gJ0hlbmNlIHdlIHJlY29tbWVuZCB5b3UgdG8gdXNlIGEgcmVhbCBicm93c2VyIGxpa2UgJyArXG4gICAgICAgICAgICAgICAgICAgICc8YSBocmVmPVwiJyArIGNocm9tZURvd25sb2FkICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiPkNocm9tZTwvYT4sICcgK1xuICAgICAgICAgICAgICAgICAgICAnPGEgaHJlZj1cIicgKyBmaXJlZm94RG93bmxvYWQgKyAnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+RmlyZWZveDwvYT4gb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICc8YSBocmVmPVwiJyArIGVkZ2VEb3dubG9hZCArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj5FZGdlPC9hPi4nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyA9ICdIZW5jZSB3ZSByZWNvbW1lbmQgeW91IHRvIHVzZSBlaXRoZXIgJyArXG4gICAgICAgICAgICAgICAgICAgICc8YSBocmVmPVwiJyArIGNocm9tZURvd25sb2FkICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiPkNocm9tZTwvYT4sICcgK1xuICAgICAgICAgICAgICAgICAgICAnPGEgaHJlZj1cIicgKyBmaXJlZm94RG93bmxvYWQgKyAnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+RmlyZWZveDwvYT4sICcgK1xuICAgICAgICAgICAgICAgICAgICAnPGEgaHJlZj1cIicgKyBlZGdlRG93bmxvYWQgKyAnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+RWRnZTwvYT4gb3IgQW5kcm9pZC4nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd2FybmluZ1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGxheWJhY2tXYXJuaW5nICgpIHtcbiAgICB2YXIgd2FybmluZyA9IGdldFJlY29tbWVuZGF0aW9uKClcblxuICAgIGlmICghd2FybmluZykge1xuICAgICAgd2FybmluZyA9ICc8YSBocmVmPVwiJyArIGJyb3dzZUhhcHB5TGluayArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj5VcGdyYWRpbmcgeW91ciBicm93c2VyPC9hPiBtaWdodCBoZWxwLidcbiAgICB9XG5cbiAgICByZXR1cm4gd2FybmluZ1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuUGxheVR5cGUgKHZpZGVvLCB0eXBlKSB7XG4gICAgdmFyIGNhblBsYXlUeXBlXG5cbiAgICBpZiAodmlkZW8gJiYgdmlkZW8uY2FuUGxheVR5cGUpIHtcbiAgICAgIGNhblBsYXlUeXBlID0gdmlkZW8uY2FuUGxheVR5cGUoJ3ZpZGVvLycgKyB0eXBlKVxuICAgIH1cblxuICAgIHJldHVybiBjYW5QbGF5VHlwZVxuICB9XG5cbiAgLy8ganVzdCB0ZW1wb3JhcnlcbiAgdGhpcy5jYW5SZWNvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgaGFzTmF2aWdhdG9yID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgICB2YXIgY2FuUmVjb3JkID0gZmFsc2VcblxuICAgIGlmIChoYXNOYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgICAgY2FuUmVjb3JkID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBnZXRVc2VyTWVkaWFUeXBlID0gaGFzTmF2aWdhdG9yICYmIHR5cGVvZiBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhX1xuXG4gICAgICBjYW5SZWNvcmQgPSBnZXRVc2VyTWVkaWFUeXBlID09PSAnZnVuY3Rpb24nXG4gICAgfVxuXG4gICAgcmV0dXJuIGNhblJlY29yZFxuICB9XG5cbiAgdGhpcy5jaGVja1JlY29yZGluZ0NhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXJyXG5cbiAgICBpZiAoIW9rQnJvd3NlciB8fCAhdGhpcy5jYW5SZWNvcmQoKSkge1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gW11cblxuICAgICAgaWYgKGlzQmFkSU9TKSB7XG4gICAgICAgIGNsYXNzTGlzdC5wdXNoKFZpZGVvbWFpbEVycm9yLklPU19QUk9CTEVNKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3NMaXN0LnB1c2goVmlkZW9tYWlsRXJyb3IuQlJPV1NFUl9QUk9CTEVNKVxuICAgICAgfVxuXG4gICAgICB2YXIgbWVzc2FnZVxuXG4gICAgICAvLyBnb29kIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0d28gcmVhc29ucyB3aHkgYW5kIHdoYXQgc29ydCBvZiBjYW1lcmEgaXQgaXNcbiAgICAgIGlmICghb2tCcm93c2VyKSB7XG4gICAgICAgIGlmIChpc01vYmlsZSkge1xuICAgICAgICAgIG1lc3NhZ2UgPSAnU29ycnksIHlvdXIgYnJvd3NlciBpcyB1bmFibGUgdG8gdXNlIHlvdXIgbW9iaWxlIGNhbWVyYSdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXNzYWdlID0gJ1NvcnJ5LCB5b3VyIGJyb3dzZXIgaXMgdW5hYmxlIHRvIHVzZSB3ZWJjYW1zJ1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNNb2JpbGUpIHtcbiAgICAgICAgICBpZiAoaXNGYWNlYm9vaykge1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdTb3JyeSwgdGhlIEZhY2Vib29rIGFwcCBjYW5ub3QgcmVjb3JkIGZyb20geW91ciBtb2JpbGUgY2FtZXJhJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gJ1NvcnJ5LCB5b3VyIGJyb3dzZXIgY2Fubm90IHJlY29yZCBmcm9tIHlvdXIgbW9iaWxlIGNhbWVyYSdcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVzc2FnZSA9ICdTb3JyeSwgeW91ciBicm93c2VyIGNhbm5vdCByZWNvcmQgZnJvbSB3ZWJjYW1zJ1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0JhZElPUykge1xuICAgICAgICAvLyBvbiBvbGRlciBpcGhvbmVzIGxlbmd0aCBvZiBKU09OIGlzIGxpbWl0ZWQgYW5kIGJyZWFraW5nXG4gICAgICAgIC8vIHNvIGp1c3QgZG9udCByZXBvcnQgYW5kIGlnbm9yZVxuICAgICAgICBvcHRpb25zLnJlcG9ydEVycm9ycyA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGVyciA9IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSh7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgIH0sIGdldFVzZXJNZWRpYVdhcm5pbmcoKSwgb3B0aW9ucywge1xuICAgICAgICBjbGFzc0xpc3Q6IGNsYXNzTGlzdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyXG4gIH1cblxuICB0aGlzLmNoZWNrUGxheWJhY2tDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAodmlkZW8pIHtcbiAgICBvcHRpb25zLmRlYnVnKCdCcm93c2VyOiBjaGVja1BsYXliYWNrQ2FwYWJpbGl0aWVzKCknKVxuXG4gICAgdmFyIGVyclxuICAgIHZhciBtZXNzYWdlXG5cbiAgICBpZiAoIXZpZGVvKSB7XG4gICAgICBtZXNzYWdlID0gJ05vIEhUTUw1IHN1cHBvcnQgZm9yIHZpZGVvIHRhZyEnXG4gICAgfSBlbHNlIGlmICghdGhpcy5nZXRWaWRlb1R5cGUodmlkZW8pKSB7XG4gICAgICBtZXNzYWdlID0gJ1lvdXIgb2xkIGJyb3dzZXIgY2Fubm90IHN1cHBvcnQgbW9kZXJuIHZpZGVvIGNvZGVjcydcbiAgICB9IGVsc2UgaWYgKCF2aWRlby5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgIC8vIGZpeGVzIFwiTm90IGltcGxlbWVudGVkXCIgZXJyb3Igb24gb2xkZXIgYnJvd3NlcnNcbiAgICAgIG1lc3NhZ2UgPSAnVW5hYmxlIHRvIHNldCB2aWRlbyBhdHRyaWJ1dGVzIGluIHlvdXIgb2xkIGJyb3dzZXInXG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIGVyciA9IFZpZGVvbWFpbEVycm9yLmNyZWF0ZShtZXNzYWdlLCBnZXRQbGF5YmFja1dhcm5pbmcoKSwgb3B0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyXG4gIH1cblxuICB0aGlzLmNoZWNrQnVmZmVyVHlwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVyclxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuYXRvYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVyciA9IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnYXRvYiBpcyBub3Qgc3VwcG9ydGVkJywgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cuQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnIgPSBWaWRlb21haWxFcnJvci5jcmVhdGUoJ0FycmF5QnVmZmVycyBhcmUgbm90IHN1cHBvcnRlZCcsIG9wdGlvbnMpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93LlVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnIgPSBWaWRlb21haWxFcnJvci5jcmVhdGUoJ1VpbnQ4QXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkJywgb3B0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyXG4gIH1cblxuICB0aGlzLmdldFZpZGVvVHlwZSA9IGZ1bmN0aW9uICh2aWRlbykge1xuICAgIGlmICghdmlkZW9UeXBlKSB7XG4gICAgICAvLyB0aGVyZSBpcyBhIGJ1ZyBpbiBjYW5QbGF5VHlwZSB3aXRoaW4gY2hyb21lIGZvciBtcDRcbiAgICAgIGlmIChjYW5QbGF5VHlwZSh2aWRlbywgJ21wNCcpICYmICFjaHJvbWVCYXNlZCkge1xuICAgICAgICB2aWRlb1R5cGUgPSAnbXA0J1xuICAgICAgfSBlbHNlIGlmIChjYW5QbGF5VHlwZSh2aWRlbywgJ3dlYm0nKSkge1xuICAgICAgICB2aWRlb1R5cGUgPSAnd2VibSdcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmlkZW9UeXBlXG4gIH1cblxuICB0aGlzLmdldE5vQWNjZXNzSXNzdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9ICdVbmFibGUgdG8gYWNjZXNzIHdlYmNhbSdcbiAgICB2YXIgZXhwbGFuYXRpb25cblxuICAgIGlmICh0aGlzLmlzQ2hyb21lQmFzZWQoKSkge1xuICAgICAgZXhwbGFuYXRpb24gPSAnQ2xpY2sgb24gdGhlIGFsbG93IGJ1dHRvbiB0byBncmFudCBhY2Nlc3MgdG8geW91ciB3ZWJjYW0uJ1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0ZpcmVmb3goKSkge1xuICAgICAgZXhwbGFuYXRpb24gPSAnUGxlYXNlIGdyYW50IEZpcmVmb3ggYWNjZXNzIHRvIHlvdXIgd2ViY2FtLidcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwbGFuYXRpb24gPSAnWW91ciBzeXN0ZW0gZG9lcyBub3QgbGV0IHlvdXIgYnJvd3NlciBhY2Nlc3MgeW91ciB3ZWJjYW0uJ1xuICAgIH1cblxuICAgIHJldHVybiBWaWRlb21haWxFcnJvci5jcmVhdGUobWVzc2FnZSwgZXhwbGFuYXRpb24sIG9wdGlvbnMpXG4gIH1cblxuICB0aGlzLmlzQ2hyb21lQmFzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNocm9tZUJhc2VkXG4gIH1cblxuICB0aGlzLmlzRmlyZWZveCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmlyZWZveFxuICB9XG5cbiAgdGhpcy5pc0VkZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzRWRnZVxuICB9XG5cbiAgdGhpcy5pc0FuZHJvaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzQW5kcm9pZFxuICB9XG5cbiAgdGhpcy5pc01vYmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdWFQYXJzZXIuZGV2aWNlLnR5cGUgPT09ICdtb2JpbGUnXG4gIH1cblxuICB0aGlzLmlzT2tTYWZhcmkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzT2tTYWZhcmlcbiAgfVxuXG4gIHRoaXMuZ2V0VXNlZnVsRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3NlcjogdWFQYXJzZXIuYnJvd3NlcixcbiAgICAgIGRldmljZTogdWFQYXJzZXIuZGV2aWNlLFxuICAgICAgb3M6IHVhUGFyc2VyLm9zLFxuICAgICAgZW5naW5lOiB1YVBhcnNlci5lbmdpbmUsXG4gICAgICB1c2VyQWdlbnQ6IHVhXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJyb3dzZXJcblxuLy8gc28gdGhhdCB3ZSBhbHNvIGNhbiByZXF1aXJlKCkgaXQgZnJvbSB2aWRlb21haWxFcnJvci5qcyB3aXRoaW5cbm1vZHVsZS5leHBvcnRzID0gQnJvd3NlclxuIiwiaW1wb3J0IHV0aWwgZnJvbSAndXRpbCdcbmltcG9ydCBCcm93c2VyIGZyb20gJy4vYnJvd3NlcidcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGxvY2FsT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGJyb3dzZXIgPSBuZXcgQnJvd3Nlcihsb2NhbE9wdGlvbnMpXG4gIGNvbnN0IGxvZ2dlciA9IGxvY2FsT3B0aW9ucy5sb2dnZXIgfHwgY29uc29sZVxuICBjb25zdCBjb250YWluZXJJZCA9IChsb2NhbE9wdGlvbnMuc2VsZWN0b3JzICYmIGxvY2FsT3B0aW9ucy5zZWxlY3RvcnMuY29udGFpbmVySWQpIHx8ICd1bmRlZmluZWQgY29udGFpbmVyIGlkJ1xuICBjb25zdCBzdGFjayA9IFtdXG5cbiAgZnVuY3Rpb24gbGlmbyAobGV2ZWwsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBsaW5lID0gdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgcGFyYW1ldGVycylcblxuICAgIGlmIChzdGFjay5sZW5ndGggPiBsb2NhbE9wdGlvbnMubG9nU3RhY2tTaXplKSB7XG4gICAgICBzdGFjay5wb3AoKVxuICAgIH1cblxuICAgIHN0YWNrLnB1c2goJ1snICsgbGV2ZWwgKyAnXSAnICsgbGluZSlcblxuICAgIHJldHVybiBsaW5lXG4gIH1cblxuICBmdW5jdGlvbiBhZGRDb250YWluZXJJZCAoZmlyc3RBcmd1bWVudCkge1xuICAgIHJldHVybiAnIycgKyBjb250YWluZXJJZCArICcgWycgKyBuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpICsgJ10gPiAnICsgZmlyc3RBcmd1bWVudFxuICB9XG5cbiAgLy8gd29ya2Fyb3VuZDogc2luY2Ugd2UgY2Fubm90IG92ZXJ3cml0ZSBjb25zb2xlLmxvZyB3aXRob3V0IGhhdmluZyB0aGUgY29ycmVjdCBmaWxlIGFuZCBsaW5lIG51bWJlclxuICAvLyB3ZSdsbCB1c2UgZ3JvdXBDb2xsYXBzZWQoKSBhbmQgdHJhY2UoKSBpbnN0ZWFkIHRvIGdldCB0aGVzZS5cbiAgdGhpcy5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBhbHdheXMgYWRkIGl0IGZvciBiZXR0ZXIgY2xpZW50IGVycm9yIHJlcG9ydHNcbiAgICBjb25zdCBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG4gICAgYXJnc1swXSA9IGFkZENvbnRhaW5lcklkKGFyZ3NbMF0pXG5cbiAgICBjb25zdCBvdXRwdXQgPSBsaWZvKCdkZWJ1ZycsIGFyZ3MpXG5cbiAgICBpZiAobG9jYWxPcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgIGlmIChicm93c2VyLmlzRmlyZWZveCgpKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhvdXRwdXQpXG4gICAgICB9IGVsc2UgaWYgKGxvZ2dlci5ncm91cENvbGxhcHNlZCkge1xuICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQob3V0cHV0KVxuICAgICAgICBsb2dnZXIudHJhY2UoJ1RyYWNlJylcbiAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKClcbiAgICAgIH0gZWxzZSBpZiAobG9nZ2VyLmRlYnVnKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhvdXRwdXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsYXN0IHJlc29ydCBpZiBldmVyeXRoaW5nIGVsc2UgZmFpbHMgZm9yIGFueSB3ZWlyZCByZWFzb25zXG4gICAgICAgIGNvbnNvbGUubG9nKG91dHB1dClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcbiAgICBhcmdzWzBdID0gYWRkQ29udGFpbmVySWQoYXJnc1swXSlcblxuICAgIGxvZ2dlci5lcnJvcihsaWZvKCdlcnJvcicsIGFyZ3MpKVxuICB9XG5cbiAgdGhpcy53YXJuID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcbiAgICBhcmdzWzBdID0gYWRkQ29udGFpbmVySWQoYXJnc1swXSlcblxuICAgIGxvZ2dlci53YXJuKGxpZm8oJ3dhcm4nLCBhcmdzKSlcbiAgfVxuXG4gIHRoaXMuZ2V0TGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0YWNrXG4gIH1cbn1cbiIsImltcG9ydCBkZXNwb3QgZnJvbSAnZGVzcG90J1xuXG5pbXBvcnQgVmlkZW9tYWlsRXJyb3IgZnJvbSAnLi92aWRlb21haWxFcnJvcidcbmltcG9ydCBFdmVudHMgZnJvbSAnLi8uLi9ldmVudHMnXG5cbi8vIFRPRE86IE1BS0UgRVZFTlQgRU1JVFRJTkcgSU4gREVTUE9UIE5PVCBHTE9CQUwgQlVUIEJZIENPTlRBSU5FUiBJRCBJTlNURUFEXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChvcHRpb25zLCBuYW1lKSB7XG4gIHRoaXMuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG5cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ1lvdSBjYW5ub3QgZW1pdCB3aXRob3V0IGFuIGV2ZW50LicsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gQXV0b21hdGljYWxseSBjb252ZXJ0IGVycm9ycyB0byB2aWRlb21haWwgZXJyb3JzXG4gICAgaWYgKGV2ZW50ID09PSBFdmVudHMuRVJST1IpIHtcbiAgICAgIHZhciBlcnIgPSBhcmdzWzFdXG5cbiAgICAgIGVyciA9IFZpZGVvbWFpbEVycm9yLmNyZWF0ZShlcnIsIG9wdGlvbnMpXG5cbiAgICAgIGFyZ3NbMV0gPSBlcnJcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgaWYgKGV2ZW50ICE9PSAncmVtb3ZlTGlzdGVuZXInICYmIGV2ZW50ICE9PSAnbmV3TGlzdGVuZXInKSB7XG4gICAgICAgIHZhciBtb3JlQXJndW1lbnRzXG5cbiAgICAgICAgaWYgKGFyZ3NbMV0pIHtcbiAgICAgICAgICBtb3JlQXJndW1lbnRzID0gYXJncy5zbGljZSgxKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vcmVBcmd1bWVudHMpIHtcbiAgICAgICAgICBvcHRpb25zLmRlYnVnKCclcyBlbWl0czogJXMnLCBuYW1lLCBldmVudCwgbW9yZUFyZ3VtZW50cylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLmRlYnVnKCclcyBlbWl0czogJXMnLCBuYW1lLCBldmVudClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGRlc3BvdC5lbWl0LmFwcGx5KGRlc3BvdCwgYXJncylcblxuICAgIC8vIFRvZG86IGhhdmUgdGhpcyBlbWl0dGVkIHRocm91Z2ggYSBjb25maWd1cmF0aW9uIGJlY2F1c2UgaXQgaXMgcHJldHR5IG5vaXN5XG4gICAgLy8gaWYgKGV2ZW50ICE9PSBFdmVudHMuRVZFTlRfRU1JVFRFRClcbiAgICAvLyAgICAgdGhpcy5lbWl0KEV2ZW50cy5FVkVOVF9FTUlUVEVELCBldmVudClcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHRoaXMub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYikge1xuICAgIHJldHVybiBkZXNwb3Qub24oZXZlbnROYW1lLCBjYilcbiAgfVxuXG4gIHRoaXMub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNiKSB7XG4gICAgcmV0dXJuIGRlc3BvdC5vbmNlKGV2ZW50TmFtZSwgY2IpXG4gIH1cblxuICB0aGlzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICByZXR1cm4gZGVzcG90Lmxpc3RlbmVycyhldmVudE5hbWUpXG4gIH1cblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2IpIHtcbiAgICByZXR1cm4gZGVzcG90LnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgY2IpXG4gIH1cblxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXNwb3QucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgfVxufVxuIiwiaW1wb3J0IGZpbGVzaXplIGZyb20gJ2ZpbGVzaXplJ1xuaW1wb3J0IGh1bWFuaXplRHVyYXRpb24gZnJvbSAnaHVtYW5pemUtZHVyYXRpb24nXG5cbi8vIHRvZG8gZ2V0IHJpZCBvZiB0aGlzIGNsYXNzIGFuZCB1c2UgdGhvc2UgaW1wb3J0cyBkaXJlY3RseVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGZpbGVzaXplOiBmdW5jdGlvbiAoYnl0ZXMsIHJvdW5kKSB7XG4gICAgcmV0dXJuIGZpbGVzaXplKGJ5dGVzLCB7XG4gICAgICByb3VuZDogcm91bmRcbiAgICB9KVxuICB9LFxuXG4gIHRvVGltZTogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gaHVtYW5pemVEdXJhdGlvbih0KVxuICB9XG59XG4iLCIvLyB0YWtlbiBmcm9tXG4vLyBodHRwczovL2JiYy5naXRodWIuaW8vdGFsL2pzZG9jL2V2ZW50c19tZWRpYWV2ZW50LmpzLmh0bWxcblxuZXhwb3J0IGRlZmF1bHQgW1xuICAvLyBUaGUgdXNlciBhZ2VudCBiZWdpbnMgbG9va2luZyBmb3IgbWVkaWEgZGF0YSwgYXMgcGFydCBvZlxuICAvLyB0aGUgcmVzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobS5cbiAgJ2xvYWRzdGFydCcsXG5cbiAgLy8gVGhlIHVzZXIgYWdlbnQgaXMgaW50ZW50aW9uYWxseSBub3QgY3VycmVudGx5IGZldGNoaW5nIG1lZGlhIGRhdGEsXG4gIC8vIGJ1dCBkb2VzIG5vdCBoYXZlIHRoZSBlbnRpcmUgbWVkaWEgcmVzb3VyY2UgZG93bmxvYWRlZC4gbmV0d29ya1N0YXRlIGVxdWFscyBORVRXT1JLX0lETEVcbiAgJ3N1c3BlbmQnLFxuXG4gIC8vIFBsYXliYWNrIGhhcyBiZWd1bi4gRmlyZWQgYWZ0ZXIgdGhlIHBsYXkoKSBtZXRob2QgaGFzIHJldHVybmVkLFxuICAvLyBvciB3aGVuIHRoZSBhdXRvcGxheSBhdHRyaWJ1dGUgaGFzIGNhdXNlZCBwbGF5YmFjayB0byBiZWdpbi5cbiAgLy8gcGF1c2VkIGlzIG5ld2x5IGZhbHNlLlxuICAvLyAncGxheScsIGNvbW1lbnRlZCBvdXQgc2luY2UgaXQgaGFzIHNwZWNpYWwgdHJlYXRtZW50XG5cbiAgLy8gVGhlIHVzZXIgYWdlbnQgaGFzIGp1c3QgZGV0ZXJtaW5lZCB0aGUgZHVyYXRpb24gYW5kIGRpbWVuc2lvbnMgb2YgdGhlXG4gIC8vIG1lZGlhIHJlc291cmNlIGFuZCB0aGUgdGltZWQgdHJhY2tzIGFyZSByZWFkeS5cbiAgLy8gcmVhZHlTdGF0ZSBpcyBuZXdseSBlcXVhbCB0byBIQVZFX01FVEFEQVRBIG9yIGdyZWF0ZXIgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAvLyAnbG9hZGVkbWV0YWRhdGEnLCBjb21tZW50ZWQgb3V0IHNpbmNlIGl0IGhhcyBzcGVjaWFsIHRyZWF0bWVudFxuXG4gIC8vIFRoZSB1c2VyIGFnZW50IGlzIGZldGNoaW5nIG1lZGlhIGRhdGEuXG4gICdwcm9ncmVzcycsXG5cbiAgLy8gVGhlIHVzZXIgYWdlbnQgaXMgaW50ZW50aW9uYWxseSBub3QgY3VycmVudGx5IGZldGNoaW5nIG1lZGlhIGRhdGEsXG4gIC8vIGJ1dCBkb2VzIG5vdCBoYXZlIHRoZSBlbnRpcmUgbWVkaWEgcmVzb3VyY2UgZG93bmxvYWRlZC5cbiAgLy8gJ3N1c3BlbmQnLCAvLyBjb21tZW50ZWQgb3V0LCB3ZSBhcmUgYWxyZWFkeSBsaXN0ZW5pbmcgdG8gaXQgaW4gY29kZVxuXG4gIC8vIEV2ZW50IFRoZSB1c2VyIGFnZW50IHN0b3BzIGZldGNoaW5nIHRoZSBtZWRpYSBkYXRhIGJlZm9yZSBpdCBpcyBjb21wbGV0ZWx5IGRvd25sb2FkZWQsXG4gIC8vIGJ1dCBub3QgZHVlIHRvIGFuIGVycm9yLiAgZXJyb3IgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGNvZGUgTUVESUFfRVJSX0FCT1JURUQuXG4gICdhYm9ydCcsXG5cbiAgLy8gQSBtZWRpYSBlbGVtZW50IHdob3NlIG5ldHdvcmtTdGF0ZSB3YXMgcHJldmlvdXNseSBub3QgaW4gdGhlIE5FVFdPUktfRU1QVFlcbiAgLy8gc3RhdGUgaGFzIGp1c3Qgc3dpdGNoZWQgdG8gdGhhdCBzdGF0ZSAoZWl0aGVyIGJlY2F1c2Ugb2YgYSBmYXRhbCBlcnJvclxuICAvLyBkdXJpbmcgbG9hZCB0aGF0J3MgYWJvdXQgdG8gYmUgcmVwb3J0ZWQsIG9yIGJlY2F1c2UgdGhlIGxvYWQoKSBtZXRob2Qgd2FzXG4gIC8vIGludm9rZWQgd2hpbGUgdGhlIHJlc291cmNlIHNlbGVjdGlvbiBhbGdvcml0aG0gd2FzIGFscmVhZHkgcnVubmluZykuXG4gICdlbXB0aWVkJyxcblxuICAvLyBUaGUgdXNlciBhZ2VudCBpcyB0cnlpbmcgdG8gZmV0Y2ggbWVkaWEgZGF0YSwgYnV0IGRhdGEgaXNcbiAgLy8gdW5leHBlY3RlZGx5IG5vdCBmb3J0aGNvbWluZ1xuICAnc3RhbGxlZCcsXG5cbiAgLy8gUGxheWJhY2sgaGFzIGJlZW4gcGF1c2VkLiBGaXJlZCBhZnRlciB0aGUgcGF1c2UoKSBtZXRob2QgaGFzIHJldHVybmVkLlxuICAvLyBwYXVzZWQgaXMgbmV3bHkgdHJ1ZS5cbiAgJ3BhdXNlJyxcblxuICAvLyBUaGUgdXNlciBhZ2VudCBjYW4gcmVuZGVyIHRoZSBtZWRpYSBkYXRhIGF0IHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uXG4gIC8vIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgLy8gcmVhZHlTdGF0ZSBuZXdseSBpbmNyZWFzZWQgdG8gSEFWRV9DVVJSRU5UX0RBVEEgb3IgZ3JlYXRlciBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICdsb2FkZWRkYXRhJyxcblxuICAvLyBQbGF5YmFjayBoYXMgc3RvcHBlZCBiZWNhdXNlIHRoZSBuZXh0IGZyYW1lIGlzIG5vdCBhdmFpbGFibGUsIGJ1dCB0aGUgdXNlclxuICAvLyBhZ2VudCBleHBlY3RzIHRoYXQgZnJhbWUgdG8gYmVjb21lIGF2YWlsYWJsZSBpbiBkdWUgY291cnNlLlxuICAvLyByZWFkeVN0YXRlIGlzIG5ld2x5IGVxdWFsIHRvIG9yIGxlc3MgdGhhbiBIQVZFX0NVUlJFTlRfREFUQSxcbiAgLy8gYW5kIHBhdXNlZCBpcyBmYWxzZS4gRWl0aGVyIHNlZWtpbmcgaXMgdHJ1ZSwgb3IgdGhlIGN1cnJlbnQgcGxheWJhY2tcbiAgLy8gcG9zaXRpb24gaXMgbm90IGNvbnRhaW5lZCBpbiBhbnkgb2YgdGhlIHJhbmdlcyBpbiBidWZmZXJlZC5cbiAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHBsYXliYWNrIHRvIHN0b3AgZm9yIHR3byBvdGhlciByZWFzb25zIHdpdGhvdXRcbiAgLy8gcGF1c2VkIGJlaW5nIGZhbHNlLCBidXQgdGhvc2UgdHdvIHJlYXNvbnMgZG8gbm90IGZpcmUgdGhpcyBldmVudDpcbiAgLy8gbWF5YmUgcGxheWJhY2sgZW5kZWQsIG9yIHBsYXliYWNrIHN0b3BwZWQgZHVlIHRvIGVycm9ycy5cbiAgJ3dhaXRpbmcnLFxuXG4gIC8vIFBsYXliYWNrIGhhcyBzdGFydGVkLiByZWFkeVN0YXRlIGlzIG5ld2x5IGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhblxuICAvLyBIQVZFX0ZVVFVSRV9EQVRBLCBwYXVzZWQgaXMgZmFsc2UsIHNlZWtpbmcgaXMgZmFsc2UsXG4gIC8vIG9yIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGNvbnRhaW5lZCBpbiBvbmUgb2YgdGhlIHJhbmdlcyBpbiBidWZmZXJlZC5cbiAgJ3BsYXlpbmcnLFxuXG4gIC8vIFRoZSB1c2VyIGFnZW50IGNhbiByZXN1bWUgcGxheWJhY2sgb2YgdGhlIG1lZGlhIGRhdGEsXG4gIC8vIGJ1dCBlc3RpbWF0ZXMgdGhhdCBpZiBwbGF5YmFjayB3ZXJlIHRvIGJlIHN0YXJ0ZWQgbm93LCB0aGUgbWVkaWEgcmVzb3VyY2VcbiAgLy8gY291bGQgbm90IGJlIHJlbmRlcmVkIGF0IHRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUgdXAgdG8gaXRzIGVuZCB3aXRob3V0XG4gIC8vIGhhdmluZyB0byBzdG9wIGZvciBmdXJ0aGVyIGJ1ZmZlcmluZyBvZiBjb250ZW50LlxuICAvLyByZWFkeVN0YXRlIG5ld2x5IGluY3JlYXNlZCB0byBIQVZFX0ZVVFVSRV9EQVRBIG9yIGdyZWF0ZXIuXG4gICdjYW5wbGF5JyxcblxuICAvLyBUaGUgdXNlciBhZ2VudCBlc3RpbWF0ZXMgdGhhdCBpZiBwbGF5YmFjayB3ZXJlIHRvIGJlIHN0YXJ0ZWQgbm93LFxuICAvLyB0aGUgbWVkaWEgcmVzb3VyY2UgY291bGQgYmUgcmVuZGVyZWQgYXQgdGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZVxuICAvLyBhbGwgdGhlIHdheSB0byBpdHMgZW5kIHdpdGhvdXQgaGF2aW5nIHRvIHN0b3AgZm9yIGZ1cnRoZXIgYnVmZmVyaW5nLlxuICAvLyByZWFkeVN0YXRlIGlzIG5ld2x5IGVxdWFsIHRvIEhBVkVfRU5PVUdIX0RBVEEuXG4gICdjYW5wbGF5dGhyb3VnaCcsXG5cbiAgLy8gVGhlIHNlZWtpbmcgSURMIGF0dHJpYnV0ZSBjaGFuZ2VkIHRvIHRydWUgYW5kIHRoZSBzZWVrIG9wZXJhdGlvbiBpc1xuICAvLyB0YWtpbmcgbG9uZyBlbm91Z2ggdGhhdCB0aGUgdXNlciBhZ2VudCBoYXMgdGltZSB0byBmaXJlIHRoZSBldmVudC5cbiAgJ3NlZWtpbmcnLFxuXG4gIC8vIFRoZSBzZWVraW5nIElETCBhdHRyaWJ1dGUgY2hhbmdlZCB0byBmYWxzZS5cbiAgJ3NlZWtlZCcsXG5cbiAgLy8gUGxheWJhY2sgaGFzIHN0b3BwZWQgYmVjYXVzZSB0aGUgZW5kIG9mIHRoZSBtZWRpYSByZXNvdXJjZSB3YXMgcmVhY2hlZC5cbiAgLy8gY3VycmVudFRpbWUgZXF1YWxzIHRoZSBlbmQgb2YgdGhlIG1lZGlhIHJlc291cmNlOyBlbmRlZCBpcyB0cnVlLlxuICAnZW5kZWQnLFxuXG4gIC8vIEVpdGhlciB0aGUgZGVmYXVsdFBsYXliYWNrUmF0ZSBvciB0aGUgcGxheWJhY2tSYXRlIGF0dHJpYnV0ZVxuICAvLyBoYXMganVzdCBiZWVuIHVwZGF0ZWQuXG4gICdyYXRlY2hhbmdlJyxcblxuICAvLyBUaGUgZHVyYXRpb24gYXR0cmlidXRlIGhhcyBqdXN0IGJlZW4gdXBkYXRlZC5cbiAgJ2R1cmF0aW9uY2hhbmdlJyxcblxuICAvLyBFaXRoZXIgdGhlIHZvbHVtZSBhdHRyaWJ1dGUgb3IgdGhlIG11dGVkIGF0dHJpYnV0ZSBoYXMgY2hhbmdlZC5cbiAgLy8gRmlyZWQgYWZ0ZXIgdGhlIHJlbGV2YW50IGF0dHJpYnV0ZSdzIHNldHRlciBoYXMgcmV0dXJuZWQuXG4gICd2b2x1bWVjaGFuZ2UnXG5cbiAgLy8gY29tbWVudGVkIG91dCwgaGFwcGVuIHRvbyBvZnRlblxuXG4gIC8vIFRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGNoYW5nZWQgYXMgcGFydCBvZiBub3JtYWwgcGxheWJhY2sgb3IgaW5cbiAgLy8gYW4gZXNwZWNpYWxseSBpbnRlcmVzdGluZyB3YXksIGZvciBleGFtcGxlIGRpc2NvbnRpbnVvdXNseS5cbiAgLy8gJ3RpbWV1cGRhdGUnXG5dXG4iLCJpbXBvcnQgc3RyaW5naWZ5IGZyb20gJ3NhZmUtanNvbi1zdHJpbmdpZnknXG5cbmNvbnN0IERBU0ggPSAnLSAnXG5jb25zdCBTRVBBUkFUT1IgPSAnPGJyLz4nICsgREFTSFxuXG5mdW5jdGlvbiBhcnJheVRvU3RyaW5nIChhcnJheSkge1xuICBpZiAoYXJyYXkubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxpbmVzID0gW11cblxuICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGxpbmVzLnB1c2goc3RyaW5naWZ5KGVsZW1lbnQpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gREFTSCArIGxpbmVzLmpvaW4oU0VQQVJBVE9SKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nIChvYmplY3QsIG9wdGlvbnMpIHtcbiAgY29uc3QgcHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdClcbiAgY29uc3QgZXhjbHVkZXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLmV4Y2x1ZGVzKSB8fCBbXVxuICBjb25zdCBsaW5lcyA9IFtdXG4gIHZhciBzTGluZXNcblxuICAvLyBhbHdheXMgaWdub3JlIHRoZXNlXG4gIGV4Y2x1ZGVzLnB1c2goJ3N0YWNrJylcblxuICBpZiAocHJvcGVydHlOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV4Y2x1ZGUgPSBmYWxzZVxuXG4gICAgcHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAoZXhjbHVkZXMpIHtcbiAgICAgICAgZXhjbHVkZSA9IGV4Y2x1ZGVzLmluZGV4T2YobmFtZSkgPj0gMFxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4Y2x1ZGUgJiYgb2JqZWN0W25hbWVdKSB7XG4gICAgICAgIC8vIHRoaXMgdG8gY292ZXIgdGhpcyBwcm9ibGVtOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwtY2xpZW50L2lzc3Vlcy8xNTdcbiAgICAgICAgbGluZXMucHVzaChzdHJpbmdpZnkob2JqZWN0W25hbWVdKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHNMaW5lcyA9IGxpbmVzLmpvaW4oKVxuICB9IGVsc2UgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICBzTGluZXMgPSBEQVNIICsgbGluZXMuam9pbihTRVBBUkFUT1IpXG4gIH1cblxuICByZXR1cm4gc0xpbmVzXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhbnl0aGluZywgb3B0aW9ucykge1xuICBpZiAoYW55dGhpbmcgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFueXRoaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAndW5kZWZpbmVkJ1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhbnl0aGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYW55dGhpbmdcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFueXRoaW5nKSkge1xuICAgIHJldHVybiBhcnJheVRvU3RyaW5nKGFueXRoaW5nKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhbnl0aGluZyA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYW55dGhpbmcsIG9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFueXRoaW5nLnRvU3RyaW5nKClcbiAgfVxufVxuIiwiaW1wb3J0ICdjbGFzc2xpc3QuanMnXG5cbi8vIG5lZWRlZCBmb3IgSUUgMTFcbmltcG9ydCAnZWxlbWVudC1jbG9zZXN0J1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanVsaWVuZXRpZS9yZXF1ZXN0LWZyYW1lXG5pbXBvcnQgcmVxdWVzdEZyYW1lIGZyb20gJ3JlcXVlc3QtZnJhbWUnXG5cbi8vIHVzZSB0aG9zZSBkZWZhdWx0IHBhcmFtcyBmb3IgdW5pdCB0ZXN0c1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHdpbmRvdyA9IHt9LCBuYXZpZ2F0b3IgPSB7fSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vanVsaWVuZXRpZS9yZXF1ZXN0LWZyYW1lL2lzc3Vlcy82XG4gIGlmICghd2luZG93LnNjcmVlbikge1xuICAgIHdpbmRvdy5zY3JlZW4gPSB7fVxuICB9XG5cbiAgcmVxdWVzdEZyYW1lKCduYXRpdmUnKVxuXG4gIC8vIGF2b2lkcyB3YXJuaW5nIFwibmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSBoYXMgYmVlbiByZXBsYWNlZCBieSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYVwiLFxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLWNsaWVudC9pc3N1ZXMvNzlcbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAvLyBkbyBub3Qgc2hpbVxuICB9IGVsc2Uge1xuICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWFfID1cbiAgICAgICAgICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYVxuICB9XG5cbiAgaWYgKCF3aW5kb3cuQXVkaW9Db250ZXh0ICYmIHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpIHtcbiAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dFxuICB9XG5cbiAgaWYgKCF3aW5kb3cuVVJMKSB7XG4gICAgd2luZG93LlVSTCA9IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkxcbiAgfVxuXG4gIGNvbnN0IG1ldGhvZHMgPSBbXG4gICAgJ2RlYnVnJywgJ2dyb3VwQ29sbGFwc2VkJywgJ2dyb3VwRW5kJywgJ2Vycm9yJyxcbiAgICAnZXhjZXB0aW9uJywgJ2luZm8nLCAnbG9nJywgJ3RyYWNlJywgJ3dhcm4nXG4gIF1cblxuICB2YXIgY29uc29sZSA9IHt9XG5cbiAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlXG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmNvbnNvbGUgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgdmFyIG1ldGhvZFxuICB2YXIgbGVuZ3RoID0gbWV0aG9kcy5sZW5ndGhcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBtZXRob2QgPSBtZXRob2RzW2xlbmd0aF1cblxuICAgIGlmICghY29uc29sZVttZXRob2RdKSB7XG4gICAgICBjb25zb2xlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7fVxuICAgIH1cbiAgfVxufVxuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3Rncmllc3Nlci9jcmVhdGUtZXJyb3JcbmltcG9ydCBjcmVhdGVFcnJvciBmcm9tICdjcmVhdGUtZXJyb3InXG5pbXBvcnQgdXRpbCBmcm9tICd1dGlsJ1xuXG5pbXBvcnQgb3JpZ2luYWxQcmV0dHkgZnJvbSAnLi9wcmV0dHknXG5pbXBvcnQgUmVzb3VyY2UgZnJvbSAnLi8uLi9yZXNvdXJjZSdcblxuY29uc3QgVklERU9NQUlMX0VSUl9OQU1FID0gJ1ZpZGVvbWFpbCBFcnJvcidcblxuY29uc3QgVmlkZW9tYWlsRXJyb3IgPSBjcmVhdGVFcnJvcihFcnJvciwgVklERU9NQUlMX0VSUl9OQU1FLCB7XG4gICdleHBsYW5hdGlvbic6IHVuZGVmaW5lZCxcbiAgJ2xvZ0xpbmVzJzogdW5kZWZpbmVkLFxuICAndXNlcmFnZW50JzogdW5kZWZpbmVkLFxuICAndXJsJzogdW5kZWZpbmVkLFxuICAnc3RhY2snOiB1bmRlZmluZWRcbn0pXG5cbi8vIHNoaW0gcHJldHR5IHRvIGV4Y2x1ZGUgc3RhY2sgYWx3YXlzXG5jb25zdCBwcmV0dHkgPSBmdW5jdGlvbiAoYW55dGhpbmcpIHtcbiAgcmV0dXJuIG9yaWdpbmFsUHJldHR5KGFueXRoaW5nLCB7IGV4Y2x1ZGVzOiBbJ3N0YWNrJ10gfSlcbn1cblxuLy8gc3RhdGljIGFuZCBwdWJsaWMgYXR0cmlidXRlIG9mIHRoaXMgY2xhc3NcblZpZGVvbWFpbEVycm9yLlBFUk1JU1NJT05fREVOSUVEID0gJ1BFUk1JU1NJT05fREVOSUVEJ1xuVmlkZW9tYWlsRXJyb3IuTk9UX0FMTE9XRURfRVJST1IgPSAnTm90QWxsb3dlZEVycm9yJ1xuVmlkZW9tYWlsRXJyb3IuTk9UX0NPTk5FQ1RFRCA9ICdOb3QgY29ubmVjdGVkJ1xuVmlkZW9tYWlsRXJyb3IuRE9NX0VYQ0VQVElPTiA9ICdET01FeGNlcHRpb24nXG5WaWRlb21haWxFcnJvci5TVEFSVElOR19GQUlMRUQgPSAnU3RhcnRpbmcgdmlkZW8gZmFpbGVkJ1xuVmlkZW9tYWlsRXJyb3IuTUVESUFfREVWSUNFX05PVF9TVVBQT1JURUQgPSAnTWVkaWFEZXZpY2VOb3RTdXBwb3J0ZWQnXG5WaWRlb21haWxFcnJvci5CUk9XU0VSX1BST0JMRU0gPSAnYnJvd3Nlci1wcm9ibGVtJ1xuVmlkZW9tYWlsRXJyb3IuV0VCQ0FNX1BST0JMRU0gPSAnd2ViY2FtLXByb2JsZW0nXG5WaWRlb21haWxFcnJvci5JT1NfUFJPQkxFTSA9ICdpb3MtcHJvYmxlbSdcblZpZGVvbWFpbEVycm9yLk9WRVJDT05TVFJBSU5FRCA9ICdPdmVyY29uc3RyYWluZWRFcnJvcidcblZpZGVvbWFpbEVycm9yLk5PVF9GT1VORF9FUlJPUiA9ICdOb3RGb3VuZEVycm9yJ1xuVmlkZW9tYWlsRXJyb3IuTk9UX1JFQURBQkxFX0VSUk9SID0gJ05vdFJlYWRhYmxlRXJyb3InXG5WaWRlb21haWxFcnJvci5TRUNVUklUWV9FUlJPUiA9ICdTZWN1cml0eUVycm9yJ1xuVmlkZW9tYWlsRXJyb3IuVFJBQ0tfU1RBUlRfRVJST1IgPSAnVHJhY2tTdGFydEVycm9yJ1xuVmlkZW9tYWlsRXJyb3IuSU5WQUxJRF9TVEFURV9FUlJPUiA9ICdJbnZhbGlkU3RhdGVFcnJvcidcblxuLy8gc3RhdGljIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gZXJyb3IgaW50byBhIHZpZGVvbWFpbCBlcnJvclxuVmlkZW9tYWlsRXJyb3IuY3JlYXRlID0gZnVuY3Rpb24gKGVyciwgZXhwbGFuYXRpb24sIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgaWYgKGVyciAmJiBlcnIubmFtZSA9PT0gVklERU9NQUlMX0VSUl9OQU1FKSB7XG4gICAgcmV0dXJuIGVyclxuICB9XG5cbiAgaWYgKCFvcHRpb25zICYmIGV4cGxhbmF0aW9uKSB7XG4gICAgb3B0aW9ucyA9IGV4cGxhbmF0aW9uXG4gICAgZXhwbGFuYXRpb24gPSB1bmRlZmluZWRcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9XG5cbiAgLy8gYmUgc3VwZXIgcm9idXN0XG4gIGNvbnN0IGRlYnVnID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZykgfHwgY29uc29sZS5sb2dcbiAgY29uc3QgYXVkaW9FbmFibGVkID0gb3B0aW9ucyAmJiBvcHRpb25zLmlzQXVkaW9FbmFibGVkICYmIG9wdGlvbnMuaXNBdWRpb0VuYWJsZWQoKVxuXG4gIGRlYnVnKCdWaWRlb21haWxFcnJvcjogY3JlYXRlKCknLCBlcnIsIGV4cGxhbmF0aW9uIHx8ICcobm8gZXhwbGFuYXRpb24gc2V0KScpXG5cbiAgY29uc3QgY2xhc3NMaXN0ID0gcGFyYW1ldGVycy5jbGFzc0xpc3QgfHwgW11cblxuICAvLyBSZXF1aXJlIEJyb3dzZXIgaGVyZSwgbm90IGF0IHRoZSB0b3Agb2YgdGhlIGZpbGUgdG8gYXZvaWRcbiAgLy8gcmVjdXJzaW9uLiBCZWNhdXNlIHRoZSBCcm93c2VyIGNsYXNzIGlzIHJlcXVpcmluZyB0aGlzIGZpbGUgYXMgd2VsbC5cbiAgY29uc3QgQnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpXG4gIGNvbnN0IGJyb3dzZXIgPSBuZXcgQnJvd3NlcihvcHRpb25zKVxuXG4gIHZhciBlcnJUeXBlXG4gIHZhciBtZXNzYWdlXG4gIHZhciBzdGFja1xuXG4gIC8vIHdob2xlIGNvZGUgaXMgdWdseSBiZWNhdXNlIGFsbCBicm93c2VycyBiZWhhdmUgc28gZGlmZmVyZW50bHkgOihcblxuICBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoZXJyLm5hbWUgPT09IFZpZGVvbWFpbEVycm9yLlRSQUNLX1NUQVJUX0VSUk9SKSB7XG4gICAgICBlcnJUeXBlID0gVmlkZW9tYWlsRXJyb3IuVFJBQ0tfU1RBUlRfRVJST1JcbiAgICB9IGVsc2UgaWYgKGVyci5uYW1lID09PSBWaWRlb21haWxFcnJvci5TRUNVUklUWV9FUlJPUikge1xuICAgICAgZXJyVHlwZSA9IFZpZGVvbWFpbEVycm9yLlNFQ1VSSVRZX0VSUk9SXG4gICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gOCAmJiBlcnIubmFtZSA9PT0gVmlkZW9tYWlsRXJyb3IuTm90Rm91bmRFcnJvcikge1xuICAgICAgZXJyVHlwZSA9IFZpZGVvbWFpbEVycm9yLk5vdEZvdW5kRXJyb3JcbiAgICB9IGVsc2UgaWYgKGVyci5jb2RlID09PSAzNSB8fCBlcnIubmFtZSA9PT0gVmlkZW9tYWlsRXJyb3IuTk9UX0FMTE9XRURfRVJST1IpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC5pby9pc3N1ZXMvNDExXG4gICAgICBlcnJUeXBlID0gVmlkZW9tYWlsRXJyb3IuTk9UX0FMTE9XRURfRVJST1JcbiAgICB9IGVsc2UgaWYgKGVyci5jb2RlID09PSAxICYmIGVyci5QRVJNSVNTSU9OX0RFTklFRCA9PT0gMSkge1xuICAgICAgZXJyVHlwZSA9IFZpZGVvbWFpbEVycm9yLlBFUk1JU1NJT05fREVOSUVEXG4gICAgfSBlbHNlIGlmIChlcnIuY29uc3RydWN0b3IgJiYgZXJyLmNvbnN0cnVjdG9yLm5hbWUgPT09IFZpZGVvbWFpbEVycm9yLkRPTV9FWENFUFRJT04pIHtcbiAgICAgIGlmIChlcnIubmFtZSA9PT0gVmlkZW9tYWlsRXJyb3IuTk9UX1JFQURBQkxFX0VSUk9SKSB7XG4gICAgICAgIGVyclR5cGUgPSBWaWRlb21haWxFcnJvci5OT1RfUkVBREFCTEVfRVJST1JcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyclR5cGUgPSBWaWRlb21haWxFcnJvci5ET01fRVhDRVBUSU9OXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlcnIuY29uc3RydWN0b3IgJiYgZXJyLmNvbnN0cnVjdG9yLm5hbWUgPT09IFZpZGVvbWFpbEVycm9yLk9WRVJDT05TVFJBSU5FRCkge1xuICAgICAgZXJyVHlwZSA9IFZpZGVvbWFpbEVycm9yLk9WRVJDT05TVFJBSU5FRFxuICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2UgPT09IFZpZGVvbWFpbEVycm9yLlNUQVJUSU5HX0ZBSUxFRCkge1xuICAgICAgZXJyVHlwZSA9IGVyci5tZXNzYWdlXG4gICAgfSBlbHNlIGlmIChlcnIubmFtZSkge1xuICAgICAgZXJyVHlwZSA9IGVyci5uYW1lXG4gICAgfSBlbHNlIGlmIChlcnIudHlwZSA9PT0gJ2Vycm9yJyAmJiBlcnIudGFyZ2V0LmJ1ZmZlcmVkQW1vdW50ID09PSAwKSB7XG4gICAgICBlcnJUeXBlID0gVmlkZW9tYWlsRXJyb3IuTk9UX0NPTk5FQ1RFRFxuICAgIH1cbiAgfSBlbHNlIGlmIChlcnIgPT09IFZpZGVvbWFpbEVycm9yLk5PVF9DT05ORUNURUQpIHtcbiAgICBlcnJUeXBlID0gVmlkZW9tYWlsRXJyb3IuTk9UX0NPTk5FQ1RFRFxuICB9IGVsc2Uge1xuICAgIGVyclR5cGUgPSBlcnJcbiAgfVxuXG4gIGlmIChlcnIgJiYgZXJyLnN0YWNrKSB7XG4gICAgc3RhY2sgPSBlcnIuc3RhY2tcbiAgfSBlbHNlIHtcbiAgICBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrXG4gIH1cblxuICBzd2l0Y2ggKGVyclR5cGUpIHtcbiAgICBjYXNlIFZpZGVvbWFpbEVycm9yLlNFQ1VSSVRZX0VSUk9SOlxuICAgICAgbWVzc2FnZSA9ICdUaGUgb3BlcmF0aW9uIHdhcyBpbnNlY3VyZSdcbiAgICAgIGV4cGxhbmF0aW9uID0gJ1Byb2JhYmx5IHlvdSBoYXZlIGRpc2FsbG93ZWQgQ29va2llcyBmb3IgdGhpcyBwYWdlPydcbiAgICAgIGNsYXNzTGlzdC5wdXNoKFZpZGVvbWFpbEVycm9yLkJST1dTRVJfUFJPQkxFTSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBWaWRlb21haWxFcnJvci5PVkVSQ09OU1RSQUlORUQ6XG4gICAgICBtZXNzYWdlID0gJ0ludmFsaWQgd2ViY2FtIGNvbnN0cmFpbnRzJ1xuXG4gICAgICBpZiAoZXJyLmNvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKGVyci5jb25zdHJhaW50ID09PSAnd2lkdGgnKSB7XG4gICAgICAgICAgZXhwbGFuYXRpb24gPSAnWW91ciB3ZWJjYW0gZG9lcyBub3QgbWVldCB0aGUgd2lkdGggcmVxdWlyZW1lbnQuJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cGxhbmF0aW9uID0gJ1VubWV0IGNvbnN0cmFpbnQ6ICcgKyBlcnIuY29uc3RyYWludFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHBsYW5hdGlvbiA9ICcgRGV0YWlsczogJyArIGVyci50b1N0cmluZygpXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgJ01lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93bic6XG4gICAgICBtZXNzYWdlID0gJ1dlYmNhbSBpcyBzaHV0dGluZyBkb3duJ1xuICAgICAgZXhwbGFuYXRpb24gPSAnVGhpcyBoYXBwZW5zIHlvdXIgd2ViY2FtIGlzIGFscmVhZHkgc3dpdGNoaW5nIG9mZiBhbmQgbm90IGdpdmluZyB5b3UgcGVybWlzc2lvbiB0byB1c2UgaXQuJ1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdTb3VyY2VVbmF2YWlsYWJsZUVycm9yJzpcbiAgICAgIG1lc3NhZ2UgPSAnU291cmNlIG9mIHlvdXIgd2ViY2FtIGNhbm5vdCBiZSBhY2Nlc3NlZCdcbiAgICAgIGV4cGxhbmF0aW9uID0gJ1Byb2JhYmx5IGl0IGlzIGxvY2tlZCBmcm9tIGFub3RoZXIgcHJvY2VzcyBvciBoYXMgYSBoYXJkd2FyZSBlcnJvci4nXG5cbiAgICAgIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgICBlcnIubWVzc2FnZSArPSAnIERldGFpbHM6ICcgKyBlcnIubWVzc2FnZVxuICAgICAgfVxuXG4gICAgICBicmVha1xuICAgIGNhc2UgVmlkZW9tYWlsRXJyb3IuTk9UX0ZPVU5EX0VSUk9SOlxuICAgIGNhc2UgJ05PX0RFVklDRVNfRk9VTkQnOlxuICAgICAgaWYgKGF1ZGlvRW5hYmxlZCkge1xuICAgICAgICBtZXNzYWdlID0gJ05vIHdlYmNhbSBub3IgbWljcm9waG9uZSBmb3VuZCdcbiAgICAgICAgZXhwbGFuYXRpb24gPSAnWW91ciBicm93c2VyIGNhbm5vdCBmaW5kIGEgd2ViY2FtIHdpdGggbWljcm9waG9uZSBhdHRhY2hlZCB0byB5b3VyIG1hY2hpbmUuJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9ICdObyB3ZWJjYW0gZm91bmQnXG4gICAgICAgIGV4cGxhbmF0aW9uID0gJ1lvdXIgYnJvd3NlciBjYW5ub3QgZmluZCBhIHdlYmNhbSBhdHRhY2hlZCB0byB5b3VyIG1hY2hpbmUuJ1xuICAgICAgfVxuXG4gICAgICBjbGFzc0xpc3QucHVzaChWaWRlb21haWxFcnJvci5XRUJDQU1fUFJPQkxFTSlcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdQZXJtaXNzaW9uRGlzbWlzc2VkRXJyb3InOlxuICAgICAgbWVzc2FnZSA9ICdPb29wcywgeW91IGRpZG5cXCd0IGdpdmUgbWUgYW55IHBlcm1pc3Npb25zPydcbiAgICAgIGV4cGxhbmF0aW9uID0gJ0xvb2tzIGxpa2UgeW91IHNraXBwZWQgdGhlIHdlYmNhbSBwZXJtaXNzaW9uIGRpYWxvZ3VlLjxici8+JyArXG4gICAgICAgICAgICAgICAgICAgICdQbGVhc2UgZ3JhbnQgYWNjZXNzIG5leHQgdGltZSB0aGUgZGlhbG9ndWUgYXBwZWFycy4nXG4gICAgICBjbGFzc0xpc3QucHVzaChWaWRlb21haWxFcnJvci5XRUJDQU1fUFJPQkxFTSlcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFZpZGVvbWFpbEVycm9yLk5PVF9BTExPV0VEX0VSUk9SOlxuICAgIGNhc2UgVmlkZW9tYWlsRXJyb3IuUEVSTUlTU0lPTl9ERU5JRUQ6XG4gICAgY2FzZSAnUGVybWlzc2lvbkRlbmllZEVycm9yJzpcbiAgICAgIG1lc3NhZ2UgPSAnUGVybWlzc2lvbiBkZW5pZWQnXG5cbiAgICAgIGV4cGxhbmF0aW9uID0gJ0Nhbm5vdCBhY2Nlc3MgeW91ciB3ZWJjYW0uIFRoaXMgY2FuIGhhdmUgdHdvIHJlYXNvbnM6PGJyLz4nICtcbiAgICAgICAgICAgICAgICAgICAgJ2EpIHlvdSBibG9ja2VkIGFjY2VzcyB0byB3ZWJjYW07IG9yPGJyLz4nICtcbiAgICAgICAgICAgICAgICAgICAgJ2IpIHlvdXIgd2ViY2FtIGlzIGFscmVhZHkgaW4gdXNlLidcblxuICAgICAgY2xhc3NMaXN0LnB1c2goVmlkZW9tYWlsRXJyb3IuV0VCQ0FNX1BST0JMRU0pXG5cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdIQVJEV0FSRV9VTkFWQUlMQUJMRSc6XG4gICAgICBtZXNzYWdlID0gJ1dlYmNhbSBpcyB1bmF2YWlsYWJsZSdcbiAgICAgIGV4cGxhbmF0aW9uID0gJ01heWJlIGl0IGlzIGFscmVhZHkgYnVzeSBpbiBhbm90aGVyIHdpbmRvdz8nXG5cbiAgICAgIGlmIChicm93c2VyLmlzQ2hyb21lQmFzZWQoKSkge1xuICAgICAgICBleHBsYW5hdGlvbiArPSAnIE9yIHlvdSBoYXZlIHRvIGFsbG93IGFjY2VzcyBhYm92ZT8nXG4gICAgICB9XG5cbiAgICAgIGNsYXNzTGlzdC5wdXNoKFZpZGVvbWFpbEVycm9yLldFQkNBTV9QUk9CTEVNKVxuXG4gICAgICBicmVha1xuXG4gICAgY2FzZSBWaWRlb21haWxFcnJvci5OT1RfQ09OTkVDVEVEOlxuICAgICAgbWVzc2FnZSA9ICdVbmFibGUgdG8gY29ubmVjdCdcbiAgICAgIGV4cGxhbmF0aW9uID0gJ0VpdGhlciB0aGUgdmlkZW9tYWlsIHNlcnZlciBvciB5b3VyIGNvbm5lY3Rpb24gaXMgZG93bi4gJyArXG4gICAgICAgICAgICAgICAgICAgICdUcnlpbmcgdG8gcmVjb25uZWN0IGV2ZXJ5IGZldyBzZWNvbmRzIOKApidcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdOT19WSURFT19GRUVEJzpcbiAgICAgIG1lc3NhZ2UgPSAnTm8gdmlkZW8gZmVlZCBmb3VuZCEnXG4gICAgICBleHBsYW5hdGlvbiA9ICdZb3VyIHdlYmNhbSBpcyBhbHJlYWR5IHVzZWQgaW4gYW5vdGhlciBicm93c2VyLidcbiAgICAgIGNsYXNzTGlzdC5wdXNoKFZpZGVvbWFpbEVycm9yLldFQkNBTV9QUk9CTEVNKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVmlkZW9tYWlsRXJyb3IuU1RBUlRJTkdfRkFJTEVEOlxuICAgICAgbWVzc2FnZSA9ICdTdGFydGluZyB2aWRlbyBmYWlsZWQnXG4gICAgICBleHBsYW5hdGlvbiA9ICdNb3N0IGxpa2VseSB0aGlzIGhhcHBlbnMgd2hlbiB0aGUgd2ViYW0gaXMgYWxyZWFkeSBhY3RpdmUgaW4gYW5vdGhlciBicm93c2VyLidcbiAgICAgIGNsYXNzTGlzdC5wdXNoKFZpZGVvbWFpbEVycm9yLldFQkNBTV9QUk9CTEVNKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ0RldmljZXNOb3RGb3VuZEVycm9yJzpcbiAgICAgIG1lc3NhZ2UgPSAnTm8gYXZhaWxhYmxlIHdlYmNhbSBjb3VsZCBiZSBmb3VuZCdcbiAgICAgIGV4cGxhbmF0aW9uID0gJ0xvb2tzIGxpa2UgeW91IGRvIG5vdCBoYXZlIGFueSB3ZWJjYW0gYXR0YWNoZWQgdG8geW91ciBtYWNoaW5lOyBvciAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RoZSBvbmUgeW91IHBsdWdnZWQgaW4gaXMgYWxyZWFkeSB1c2VkLidcbiAgICAgIGNsYXNzTGlzdC5wdXNoKFZpZGVvbWFpbEVycm9yLldFQkNBTV9QUk9CTEVNKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVmlkZW9tYWlsRXJyb3IuTk9UX1JFQURBQkxFX0VSUk9SOlxuICAgIGNhc2UgVmlkZW9tYWlsRXJyb3IuVFJBQ0tfU1RBUlRfRVJST1I6XG4gICAgICBtZXNzYWdlID0gJ05vIGFjY2VzcyB0byB3ZWJjYW0nXG4gICAgICBleHBsYW5hdGlvbiA9ICdBIGhhcmR3YXJlIGVycm9yIG9jY3VycmVkIHdoaWNoIHByZXZlbnRlZCBhY2Nlc3MgdG8geW91ciB3ZWJjYW0uJ1xuICAgICAgY2xhc3NMaXN0LnB1c2goVmlkZW9tYWlsRXJyb3IuV0VCQ0FNX1BST0JMRU0pXG4gICAgICBicmVha1xuXG4gICAgY2FzZSBWaWRlb21haWxFcnJvci5JTlZBTElEX1NUQVRFX0VSUk9SOlxuICAgICAgbWVzc2FnZSA9ICdJbnZhbGlkIHN0YXRlJ1xuICAgICAgZXhwbGFuYXRpb24gPSAnVmlkZW8gcmVjb3JkaW5nIHN0cmVhbSBmcm9tIHlvdXIgd2ViY2FtIGFscmVhZHkgaGFzIGZpbmlzaGVkLidcbiAgICAgIGNsYXNzTGlzdC5wdXNoKFZpZGVvbWFpbEVycm9yLldFQkNBTV9QUk9CTEVNKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVmlkZW9tYWlsRXJyb3IuRE9NX0VYQ0VQVElPTjpcbiAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIG1lc3NhZ2UgPSAnUmVxdWVzdGVkIHdlYmNhbSBub3QgZm91bmQnXG4gICAgICAgICAgZXhwbGFuYXRpb24gPSAnQSB3ZWJjYW0gaXMgbmVlZGVkIGJ1dCBjb3VsZCBub3QgYmUgZm91bmQuJ1xuICAgICAgICAgIGNsYXNzTGlzdC5wdXNoKFZpZGVvbWFpbEVycm9yLldFQkNBTV9QUk9CTEVNKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBjb25zdCBuZXdVcmwgPSAnaHR0cHM6JyArIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnN1YnN0cmluZyh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wubGVuZ3RoKVxuICAgICAgICAgIG1lc3NhZ2UgPSAnU2VjdXJpdHkgdXBncmFkZSBuZWVkZWQnXG4gICAgICAgICAgZXhwbGFuYXRpb24gPSAnQ2xpY2sgPGEgaHJlZj1cIicgKyBuZXdVcmwgKyAnXCI+aGVyZTwvYT4gdG8gc3dpdGNoIHRvIEhUVFBzIHdoaWNoIGlzIG1vcmUgc2FmZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgYW5kIGVuYWJsZXMgZW5jcnlwdGVkIHZpZGVvbWFpbCB0cmFuc2ZlcnMuJ1xuICAgICAgICAgIGNsYXNzTGlzdC5wdXNoKFZpZGVvbWFpbEVycm9yLkJST1dTRVJfUFJPQkxFTSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIG1lc3NhZ2UgPSAnSW52YWxpZCBTdGF0ZSdcbiAgICAgICAgICBleHBsYW5hdGlvbiA9ICdUaGUgb2JqZWN0IGlzIGluIGFuIGludmFsaWQsIHVudXNhYmxlIHN0YXRlLidcbiAgICAgICAgICBjbGFzc0xpc3QucHVzaChWaWRlb21haWxFcnJvci5CUk9XU0VSX1BST0JMRU0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBtZXNzYWdlID0gJ0RPTSBFeGNlcHRpb24nXG4gICAgICAgICAgZXhwbGFuYXRpb24gPSBwcmV0dHkoZXJyKVxuICAgICAgICAgIGNsYXNzTGlzdC5wdXNoKFZpZGVvbWFpbEVycm9yLkJST1dTRVJfUFJPQkxFTSlcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIC8vIENocm9tZSBoYXMgYSB3ZWlyZCBwcm9ibGVtIHdoZXJlIGlmIHlvdSB0cnkgdG8gZG8gYSBnZXRVc2VyTWVkaWEgcmVxdWVzdCB0b28gZWFybHksIGl0XG4gICAgLy8gY2FuIHJldHVybiBhIE1lZGlhRGV2aWNlTm90U3VwcG9ydGVkIGVycm9yIChldmVuIHRob3VnaCBub3RoaW5nIGlzIHdyb25nIGFuZCBwZXJtaXNzaW9uXG4gICAgLy8gaGFzIGJlZW4gZ3JhbnRlZCkuIExvb2sgYXQgdXNlck1lZGlhRXJyb3JDYWxsYmFjaygpIGluIHJlY29yZGVyLCB0aGVyZSB3ZSBkbyBub3RcbiAgICAvLyBlbWl0IHRob3NlIGtpbmQgb2YgZXJyb3JzIGZ1cnRoZXIgYW5kIGp1c3QgcmV0cnkuXG4gICAgLy9cbiAgICAvLyBidXQgZm9yIHdoYXRldmVyIHJlYXNvbnMsIGlmIGl0IGhhcHBlbnMgdG8gcmVhY2ggdGhpcyBjb2RlLCB0aGVuIGludmVzdGlnYXRlIHRoaXMgZnVydGhlci5cbiAgICBjYXNlIFZpZGVvbWFpbEVycm9yLk1FRElBX0RFVklDRV9OT1RfU1VQUE9SVEVEOlxuICAgICAgbWVzc2FnZSA9ICdNZWRpYSBkZXZpY2Ugbm90IHN1cHBvcnRlZCdcbiAgICAgIGV4cGxhbmF0aW9uID0gcHJldHR5KGVycilcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgY29uc3Qgb3JpZ2luYWxFeHBsYW5hdGlvbiA9IGV4cGxhbmF0aW9uXG5cbiAgICAgIGlmIChleHBsYW5hdGlvbiAmJiB0eXBlb2YgZXhwbGFuYXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGV4cGxhbmF0aW9uID0gcHJldHR5KGV4cGxhbmF0aW9uKVxuICAgICAgfVxuXG4gICAgICAvLyBpdCBjYW4gYmUgdGhhdCBleHBsYW5hdGlvbiBpdHNlbGYgaXMgYW4gZXJyb3Igb2JqZWN0XG4gICAgICAvLyBlcnJvciBvYmplY3RzIGNhbiBiZSBwcmV0dGlmaWVkIHRvIHVuZGVmaW5lZCBzb21ldGltZXNcbiAgICAgIGlmICghZXhwbGFuYXRpb24gJiYgb3JpZ2luYWxFeHBsYW5hdGlvbikge1xuICAgICAgICBpZiAob3JpZ2luYWxFeHBsYW5hdGlvbi5tZXNzYWdlKSB7XG4gICAgICAgICAgZXhwbGFuYXRpb24gPSBvcmlnaW5hbEV4cGxhbmF0aW9uLm1lc3NhZ2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0cmllZCB0b1N0cmluZyBiZWZvcmUgYnV0IG5haFxuICAgICAgICAgIGV4cGxhbmF0aW9uID0gJ0luc3BlY3RlZDogJyArIHV0aWwuaW5zcGVjdChvcmlnaW5hbEV4cGxhbmF0aW9uLCB7XG4gICAgICAgICAgICBzaG93SGlkZGVuOiB0cnVlXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZXJyICYmIHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UpIHtcbiAgICAgICAgICBtZXNzYWdlID0gcHJldHR5KGVyci5tZXNzYWdlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVyciAmJiBlcnIuZXhwbGFuYXRpb24pIHtcbiAgICAgICAgICBpZiAoIWV4cGxhbmF0aW9uKSB7XG4gICAgICAgICAgICBleHBsYW5hdGlvbiA9IHByZXR0eShlcnIuZXhwbGFuYXRpb24pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGxhbmF0aW9uICs9ICc7PGJyLz4nICsgcHJldHR5KGVyci5leHBsYW5hdGlvbilcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyICYmIGVyci5kZXRhaWxzKSB7XG4gICAgICAgICAgdmFyIGRldGFpbHMgPSBwcmV0dHkoZXJyLmRldGFpbHMpXG5cbiAgICAgICAgICBpZiAoIWV4cGxhbmF0aW9uKSB7XG4gICAgICAgICAgICBleHBsYW5hdGlvbiA9IGRldGFpbHNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwbGFuYXRpb24gKz0gJzs8YnIvPicgKyBkZXRhaWxzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGZvciB3ZWlyZCwgdW5kZWZpbmVkIGNhc2VzXG4gICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGVyclR5cGUpIHtcbiAgICAgICAgICBtZXNzYWdlID0gZXJyVHlwZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleHBsYW5hdGlvbiAmJiBlcnIpIHtcbiAgICAgICAgICBleHBsYW5hdGlvbiA9IHByZXR0eShlcnIsIHsgZXhjbHVkZXM6IFsnc3RhY2snXSB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXZvaWQgZHVwZXNcbiAgICAgICAgaWYgKHByZXR0eShtZXNzYWdlKSA9PT0gZXhwbGFuYXRpb24pIHtcbiAgICAgICAgICBleHBsYW5hdGlvbiA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrXG4gIH1cblxuICB2YXIgbG9nTGluZXMgPSBudWxsXG5cbiAgaWYgKG9wdGlvbnMubG9nZ2VyICYmIG9wdGlvbnMubG9nZ2VyLmdldExpbmVzKSB7XG4gICAgbG9nTGluZXMgPSBvcHRpb25zLmxvZ2dlci5nZXRMaW5lcygpXG4gIH1cblxuICBpZiAoc3RhY2spIHtcbiAgICBtZXNzYWdlID0gbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgbWVzc2FnZS5zdGFjayA9IHN0YWNrXG4gIH1cblxuICB2YXIgZXJyQ29kZSA9ICdub25lJ1xuXG4gIGlmIChlcnIpIHtcbiAgICBlcnJDb2RlID0gJ2NvZGU9JyArIChlcnIuY29kZSA/IGVyci5jb2RlIDogJ3VuZGVmaW5lZCcpXG4gICAgZXJyQ29kZSArPSAnLCB0eXBlPScgKyAoZXJyLnR5cGUgPyBlcnIudHlwZSA6ICd1bmRlZmluZWQnKVxuICAgIGVyckNvZGUgKz0gJywgbmFtZT0nICsgKGVyci5uYW1lID8gZXJyLm5hbWUgOiAndW5kZWZpbmVkJylcbiAgICBlcnJDb2RlICs9ICcsIG1lc3NhZ2U9JyArIChlcnIubWVzc2FnZSA/IGVyci5tZXNzYWdlIDogJ3VuZGVmaW5lZCcpXG4gIH1cblxuICBjb25zdCB2aWRlb21haWxFcnJvciA9IG5ldyBWaWRlb21haWxFcnJvcihtZXNzYWdlLCB7XG4gICAgZXhwbGFuYXRpb246IGV4cGxhbmF0aW9uLFxuICAgIGxvZ0xpbmVzOiBsb2dMaW5lcyxcbiAgICBjbGllbnQ6IGJyb3dzZXIuZ2V0VXNlZnVsRGF0YSgpLFxuICAgIHVybDogd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gICAgc2l0ZU5hbWU6IG9wdGlvbnMuc2l0ZU5hbWUsXG4gICAgY29kZTogZXJyQ29kZSxcbiAgICBzdGFjazogc3RhY2sgLy8gaGF2ZSB0byBhc3NpZ24gaXQgbWFudWFsbHkgYWdhaW4gYmVjYXVzZSBpdCBpcyBraW5kYSBwcm90ZWN0ZWRcbiAgfSlcblxuICB2YXIgcmVzb3VyY2VcbiAgdmFyIHJlcG9ydEVycm9ycyA9IGZhbHNlXG5cbiAgaWYgKG9wdGlvbnMucmVwb3J0RXJyb3JzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlcG9ydEVycm9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVwb3J0RXJyb3JzID0gb3B0aW9ucy5yZXBvcnRFcnJvcnModmlkZW9tYWlsRXJyb3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcG9ydEVycm9ycyA9IG9wdGlvbnMucmVwb3J0RXJyb3JzXG4gICAgfVxuICB9XG5cbiAgaWYgKHJlcG9ydEVycm9ycykge1xuICAgIHJlc291cmNlID0gbmV3IFJlc291cmNlKG9wdGlvbnMpXG4gIH1cblxuICBpZiAocmVzb3VyY2UpIHtcbiAgICByZXNvdXJjZS5yZXBvcnRFcnJvcih2aWRlb21haWxFcnJvciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICAgIGlmIChlcnIyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuYWJsZSB0byByZXBvcnQgZXJyb3InLCBlcnIyKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBoYXNDbGFzcyAobmFtZSkge1xuICAgIHJldHVybiBjbGFzc0xpc3QuaW5kZXhPZihuYW1lKSA+PSAwXG4gIH1cblxuICBmdW5jdGlvbiBpc0Jyb3dzZXJQcm9ibGVtICgpIHtcbiAgICByZXR1cm4gaGFzQ2xhc3MoVmlkZW9tYWlsRXJyb3IuQlJPV1NFUl9QUk9CTEVNKSB8fCBwYXJhbWV0ZXJzLmJyb3dzZXJQcm9ibGVtXG4gIH1cblxuICAvLyBhZGQgc29tZSBwdWJsaWMgZnVuY3Rpb25zXG5cbiAgLy8gdGhpcyBvbmUgaXMgdXNlZnVsIHNvIHRoYXQgdGhlIG5vdGlmaWVyIGNhbiBoYXZlIGRpZmZlcmVudCBjc3MgY2xhc3Nlc1xuICB2aWRlb21haWxFcnJvci5nZXRDbGFzc0xpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNsYXNzTGlzdFxuICB9XG5cbiAgdmlkZW9tYWlsRXJyb3IucmVtb3ZlRGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGFzQ2xhc3MoVmlkZW9tYWlsRXJyb3IuSU9TX1BST0JMRU0pIHx8IGJyb3dzZXIuaXNNb2JpbGUoKVxuICB9XG5cbiAgdmlkZW9tYWlsRXJyb3IuaGlkZUJ1dHRvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzQnJvd3NlclByb2JsZW0oKSB8fCBoYXNDbGFzcyhWaWRlb21haWxFcnJvci5JT1NfUFJPQkxFTSlcbiAgfVxuXG4gIHZpZGVvbWFpbEVycm9yLmhpZGVGb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoYXNDbGFzcyhWaWRlb21haWxFcnJvci5JT1NfUFJPQkxFTSlcbiAgfVxuXG4gIHJldHVybiB2aWRlb21haWxFcnJvclxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWRlb21haWxFcnJvclxuIiwiaW1wb3J0IHV0aWwgZnJvbSAndXRpbCdcbmltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IGhpZGRlbiBmcm9tICdoaWRkZW4nXG5pbXBvcnQgY29udGFpbnMgZnJvbSAnY29udGFpbnMnXG5cbmltcG9ydCBFdmVudHMgZnJvbSAnLi8uLi9ldmVudHMnXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vLi4vdXRpbC9ldmVudEVtaXR0ZXInXG5cbmNvbnN0IEJ1dHRvbnMgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMsIG9wdGlvbnMsICdCdXR0b25zJylcblxuICBjb25zdCBzZWxmID0gdGhpc1xuICBjb25zdCBkZWJ1ZyA9IG9wdGlvbnMuZGVidWdcblxuICB2YXIgYnV0dG9uc0VsZW1lbnRcbiAgdmFyIHJlY29yZEJ1dHRvblxuICB2YXIgcGF1c2VCdXR0b25cbiAgdmFyIHJlc3VtZUJ1dHRvblxuICB2YXIgcHJldmlld0J1dHRvblxuICB2YXIgcmVjb3JkQWdhaW5CdXR0b25cbiAgdmFyIHN1Ym1pdEJ1dHRvblxuXG4gIHZhciBhdWRpb09uUmFkaW9QYWlyXG4gIHZhciBhdWRpb09mZlJhZGlvUGFpclxuXG4gIHZhciBidWlsdFxuXG4gIGZ1bmN0aW9uIGhpZGUgKGVsZW1lbnRzKSB7XG4gICAgaWYgKGVsZW1lbnRzICYmICFBcnJheS5pc0FycmF5KGVsZW1lbnRzKSkge1xuICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdXG4gICAgfVxuXG4gICAgZWxlbWVudHMgJiYgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgaGlkZGVuKGVsZW1lbnQsIHRydWUpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3cgKGVsZW1lbnRzKSB7XG4gICAgaWYgKGVsZW1lbnRzICYmICFBcnJheS5pc0FycmF5KGVsZW1lbnRzKSkge1xuICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdXG4gICAgfVxuXG4gICAgZWxlbWVudHMgJiYgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgaGlkZGVuKGVsZW1lbnQsIGZhbHNlKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBpc1Nob3duIChlbGVtZW50cykge1xuICAgIHZhciBpc1Nob3duID0gZWxlbWVudHMgJiYgdHJ1ZVxuXG4gICAgaWYgKGVsZW1lbnRzICYmICFBcnJheS5pc0FycmF5KGVsZW1lbnRzKSkge1xuICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdXG4gICAgfVxuXG4gICAgZWxlbWVudHMgJiYgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgaXNTaG93biA9IGlzU2hvd24gJiYgZWxlbWVudCAmJiAhaGlkZGVuKGVsZW1lbnQpXG4gICAgfSlcblxuICAgIHJldHVybiBpc1Nob3duXG4gIH1cblxuICBmdW5jdGlvbiBkaXNhYmxlIChlbGVtZW50cykge1xuICAgIGlmIChlbGVtZW50cyAmJiAhQXJyYXkuaXNBcnJheShlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXVxuICAgIH1cblxuICAgIGVsZW1lbnRzICYmIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC1jbGllbnQvaXNzdWVzLzE0OFxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCBlbGVtZW50LnRhZ05hbWUgPT09ICdCVVRUT04nKSB7XG4gICAgICAgICAgZWxlbWVudC5kaXNhYmxlZCA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBlbmFibGUgKGVsZW1lbnRzKSB7XG4gICAgaWYgKGVsZW1lbnRzICYmICFBcnJheS5pc0FycmF5KGVsZW1lbnRzKSkge1xuICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdXG4gICAgfVxuXG4gICAgZWxlbWVudHMgJiYgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLWNsaWVudC9pc3N1ZXMvMTQ4XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnSU5QVVQnIHx8IGVsZW1lbnQudGFnTmFtZSA9PT0gJ0JVVFRPTicpIHtcbiAgICAgICAgICBlbGVtZW50LmRpc2FibGVkID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBhZGp1c3RCdXR0b24gKGJ1dHRvbkVsZW1lbnQsIHNob3csIHR5cGUsIGRpc2FibGVkKSB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICBkaXNhYmxlKGJ1dHRvbkVsZW1lbnQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGJ1dHRvbkVsZW1lbnQudHlwZSA9IHR5cGVcbiAgICB9IGVsc2UgaWYgKCFidXR0b25FbGVtZW50LnR5cGUpIHtcbiAgICAgIGJ1dHRvbkVsZW1lbnQudHlwZSA9ICdidXR0b24nXG4gICAgfVxuXG4gICAgIXNob3cgJiYgaGlkZShidXR0b25FbGVtZW50KVxuXG4gICAgcmV0dXJuIGJ1dHRvbkVsZW1lbnRcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VDbGlja0hhbmRsZXIgKGVsZW1lbnQsIGNsaWNrSGFuZGxlcikge1xuICAgIGNvbnN0IHdyYXBwZWRDbGlja0hhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KClcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY2xpY2tIYW5kbGVyKHsgZXZlbnQ6IGUgfSlcbiAgICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgICBzZWxmLmVtaXQoRXZlbnRzLkVSUk9SLCBleGMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudC5vbmNsaWNrID0gd3JhcHBlZENsaWNrSGFuZGxlclxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVJhZGlvQnV0dG9uUGFpciAob3B0aW9ucykge1xuICAgIHZhciByYWRpb0J1dHRvbkVsZW1lbnRcbiAgICB2YXIgcmFkaW9CdXR0b25Hcm91cFxuXG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgIHJhZGlvQnV0dG9uRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuaWQpXG4gICAgfVxuXG4gICAgaWYgKCFyYWRpb0J1dHRvbkVsZW1lbnQpIHtcbiAgICAgIHJhZGlvQnV0dG9uRWxlbWVudCA9IGgoJ2lucHV0IycgKyBvcHRpb25zLmlkLCB7XG4gICAgICAgIHR5cGU6ICdyYWRpbycsXG4gICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgIGNoZWNrZWQ6IG9wdGlvbnMuY2hlY2tlZFxuICAgICAgfSlcblxuICAgICAgcmFkaW9CdXR0b25Hcm91cCA9IGgoJ3NwYW4ucmFkaW9Hcm91cCcsIHJhZGlvQnV0dG9uRWxlbWVudCwgaCgnbGFiZWwnLCB7XG4gICAgICAgICdodG1sRm9yJzogb3B0aW9ucy5pZFxuICAgICAgfSwgb3B0aW9ucy5sYWJlbCkpXG5cbiAgICAgIC8vIGRvdWJsZSBjaGVjayB0aGF0IHN1Ym1pdCBidXR0b24gaXMgYWxyZWFkeSBpbiB0aGUgYnV0dG9uc0VsZW1lbnQgY29udGFpbmVyIGFzIGEgY2hpbGQ/XG4gICAgICBpZiAoc3VibWl0QnV0dG9uICYmIGNvbnRhaW5zKGJ1dHRvbnNFbGVtZW50LCBzdWJtaXRCdXR0b24pKSB7XG4gICAgICAgIGJ1dHRvbnNFbGVtZW50Lmluc2VydEJlZm9yZShyYWRpb0J1dHRvbkdyb3VwLCBzdWJtaXRCdXR0b24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidXR0b25zRWxlbWVudC5hcHBlbmRDaGlsZChyYWRpb0J1dHRvbkdyb3VwKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNoYW5nZUhhbmRsZXIpIHtcbiAgICAgIHJhZGlvQnV0dG9uRWxlbWVudC5vbmNoYW5nZSA9IG9wdGlvbnMuY2hhbmdlSGFuZGxlclxuICAgIH1cblxuICAgIGRpc2FibGUocmFkaW9CdXR0b25FbGVtZW50KVxuXG4gICAgcmV0dXJuIFtyYWRpb0J1dHRvbkVsZW1lbnQsIHJhZGlvQnV0dG9uR3JvdXBdXG4gIH1cblxuICBmdW5jdGlvbiBtYWtlQnV0dG9uIChidXR0b25DbGFzcywgdGV4dCwgY2xpY2tIYW5kbGVyLCBzaG93LCBpZCwgdHlwZSwgc2VsZWN0b3IsIGRpc2FibGVkID0gdHJ1ZSkge1xuICAgIHZhciBidXR0b25FbGVtZW50XG5cbiAgICBpZiAoaWQpIHtcbiAgICAgIGJ1dHRvbkVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZClcbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBidXR0b25FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICB9IGVsc2Uge1xuICAgICAgYnV0dG9uRWxlbWVudCA9IGJ1dHRvbnNFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgYnV0dG9uQ2xhc3MpXG4gICAgfVxuXG4gICAgaWYgKCFidXR0b25FbGVtZW50KSB7XG4gICAgICBpZiAob3B0aW9ucy5zZWxlY3RvcnMuYnV0dG9uQ2xhc3MpIHtcbiAgICAgICAgYnV0dG9uQ2xhc3MgKz0gJy4nICsgb3B0aW9ucy5zZWxlY3RvcnMuYnV0dG9uQ2xhc3NcbiAgICAgIH1cblxuICAgICAgYnV0dG9uRWxlbWVudCA9IGgoJ2J1dHRvbi4nICsgYnV0dG9uQ2xhc3MpXG4gICAgICBidXR0b25FbGVtZW50ID0gYWRqdXN0QnV0dG9uKGJ1dHRvbkVsZW1lbnQsIHNob3csIHR5cGUsIGRpc2FibGVkKVxuXG4gICAgICBidXR0b25FbGVtZW50LmlubmVySFRNTCA9IHRleHRcblxuICAgICAgLy8gZG91YmxlIGNoZWNrIHRoYXQgc3VibWl0IGJ1dHRvbiBpcyBhbHJlYWR5IGluIHRoZSBidXR0b25zRWxlbWVudCBjb250YWluZXJcbiAgICAgIGlmIChzdWJtaXRCdXR0b24gJiYgY29udGFpbnMoYnV0dG9uc0VsZW1lbnQsIHN1Ym1pdEJ1dHRvbikpIHtcbiAgICAgICAgYnV0dG9uc0VsZW1lbnQuaW5zZXJ0QmVmb3JlKGJ1dHRvbkVsZW1lbnQsIHN1Ym1pdEJ1dHRvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1dHRvbnNFbGVtZW50LmFwcGVuZENoaWxkKGJ1dHRvbkVsZW1lbnQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1dHRvbkVsZW1lbnQgPSBhZGp1c3RCdXR0b24oYnV0dG9uRWxlbWVudCwgc2hvdywgdHlwZSwgZGlzYWJsZWQpXG4gICAgfVxuXG4gICAgaWYgKGNsaWNrSGFuZGxlcikge1xuICAgICAgcmVwbGFjZUNsaWNrSGFuZGxlcihidXR0b25FbGVtZW50LCBjbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1dHRvbkVsZW1lbnRcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQnV0dG9ucyAoKSB7XG4gICAgaWYgKCFvcHRpb25zLmRpc2FibGVTdWJtaXQpIHtcbiAgICAgIGlmICghc3VibWl0QnV0dG9uKSB7XG4gICAgICAgIHN1Ym1pdEJ1dHRvbiA9IG1ha2VCdXR0b24oXG4gICAgICAgICAgb3B0aW9ucy5zZWxlY3RvcnMuc3VibWl0QnV0dG9uQ2xhc3MsXG4gICAgICAgICAgJ1N1Ym1pdCcsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIG9wdGlvbnMuc2VsZWN0b3JzLnN1Ym1pdEJ1dHRvbklkLFxuICAgICAgICAgICdzdWJtaXQnLFxuICAgICAgICAgIG9wdGlvbnMuc2VsZWN0b3JzLnN1Ym1pdEJ1dHRvblNlbGVjdG9yLFxuICAgICAgICAgIG9wdGlvbnMuZW5hYmxlQXV0b1ZhbGlkYXRpb25cbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzYWJsZShzdWJtaXRCdXR0b24pXG4gICAgICB9XG5cbiAgICAgIC8vIG5vIG5lZWQgdG8gbGlzdGVuIHRvIHRoZSBzdWJtaXQgZXZlbnQgd2hlbiBpdCdzIGFscmVhZHkgbGlzdGVuZWRcbiAgICAgIC8vIHdpdGhpbiB0aGUgZm9ybSBlbGVtZW50IGNsYXNzXG4gICAgICBpZiAoIWNvbnRhaW5lci5oYXNGb3JtKCkgJiYgc3VibWl0QnV0dG9uKSB7XG4gICAgICAgIHJlcGxhY2VDbGlja0hhbmRsZXIoc3VibWl0QnV0dG9uLCBzdWJtaXQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVjb3JkQnV0dG9uID0gbWFrZUJ1dHRvbihcbiAgICAgIG9wdGlvbnMuc2VsZWN0b3JzLnJlY29yZEJ1dHRvbkNsYXNzLFxuICAgICAgb3B0aW9ucy50ZXh0LmJ1dHRvbnMucmVjb3JkLFxuICAgICAgcmVjb3JkLFxuICAgICAgZmFsc2VcbiAgICApXG5cbiAgICBpZiAob3B0aW9ucy5lbmFibGVQYXVzZSkge1xuICAgICAgcGF1c2VCdXR0b24gPSBtYWtlQnV0dG9uKFxuICAgICAgICBvcHRpb25zLnNlbGVjdG9ycy5wYXVzZUJ1dHRvbkNsYXNzLFxuICAgICAgICBvcHRpb25zLnRleHQuYnV0dG9ucy5wYXVzZSxcbiAgICAgICAgY29udGFpbmVyLnBhdXNlLFxuICAgICAgICBmYWxzZVxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmVuYWJsZVBhdXNlKSB7XG4gICAgICByZXN1bWVCdXR0b24gPSBtYWtlQnV0dG9uKFxuICAgICAgICBvcHRpb25zLnNlbGVjdG9ycy5yZXN1bWVCdXR0b25DbGFzcyxcbiAgICAgICAgb3B0aW9ucy50ZXh0LmJ1dHRvbnMucmVzdW1lLFxuICAgICAgICBjb250YWluZXIucmVzdW1lLFxuICAgICAgICBmYWxzZVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIHNob3cgc3RvcCBvbmx5IHdoZW4gcGF1c2UgaXMgZW5hYmxlZCAtIGxvb2tzIGJldHRlciB0aGF0IHdheSBvdGhlcndpc2UgYnV0dG9uXG4gICAgLy8gbW92ZSBsZWZ0IGFuZCByaWdodCBiZXR3ZWVuIHJlY29yZCBhbmQgc3RvcCAocHJldmlldylcbiAgICBwcmV2aWV3QnV0dG9uID0gbWFrZUJ1dHRvbihcbiAgICAgIG9wdGlvbnMuc2VsZWN0b3JzLnByZXZpZXdCdXR0b25DbGFzcyxcbiAgICAgIG9wdGlvbnMudGV4dC5idXR0b25zLnByZXZpZXcsXG4gICAgICBjb250YWluZXIuc3RvcCxcbiAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgcmVjb3JkQWdhaW5CdXR0b24gPSBtYWtlQnV0dG9uKFxuICAgICAgb3B0aW9ucy5zZWxlY3RvcnMucmVjb3JkQWdhaW5CdXR0b25DbGFzcyxcbiAgICAgIG9wdGlvbnMudGV4dC5idXR0b25zLnJlY29yZEFnYWluLFxuICAgICAgcmVjb3JkQWdhaW4sXG4gICAgICBmYWxzZVxuICAgIClcblxuICAgIGlmIChvcHRpb25zLmF1ZGlvICYmIG9wdGlvbnMuYXVkaW8uc3dpdGNoKSB7XG4gICAgICBhdWRpb09mZlJhZGlvUGFpciA9IG1ha2VSYWRpb0J1dHRvblBhaXIoe1xuICAgICAgICBpZDogJ2F1ZGlvT2ZmT3B0aW9uJyxcbiAgICAgICAgbmFtZTogJ2F1ZGlvJyxcbiAgICAgICAgdmFsdWU6ICdvZmYnLFxuICAgICAgICBsYWJlbDogJ0F1ZGlvIE9mZicsXG4gICAgICAgIGNoZWNrZWQ6ICFvcHRpb25zLmlzQXVkaW9FbmFibGVkKCksXG4gICAgICAgIGNoYW5nZUhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb250YWluZXIuZGlzYWJsZUF1ZGlvKClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgYXVkaW9PblJhZGlvUGFpciA9IG1ha2VSYWRpb0J1dHRvblBhaXIoe1xuICAgICAgICBpZDogJ2F1ZGlvT25PcHRpb24nLFxuICAgICAgICBuYW1lOiAnYXVkaW8nLFxuICAgICAgICB2YWx1ZTogJ29uJyxcbiAgICAgICAgbGFiZWw6ICdBdWRpbyBPbiAoQmV0YSknLFxuICAgICAgICBjaGVja2VkOiBvcHRpb25zLmlzQXVkaW9FbmFibGVkKCksXG4gICAgICAgIGNoYW5nZUhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb250YWluZXIuZW5hYmxlQXVkaW8oKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRm9ybVJlYWR5IChwYXJhbXMpIHtcbiAgICAvLyBubyBuZWVkIHRvIHNob3cgcmVjb3JkIGJ1dHRvbiB3aGVuIGRvaW5nIGEgcmVjb3JkIGFnYWluXG4gICAgaWYgKCFpc1Nob3duKHJlY29yZEFnYWluQnV0dG9uKSkge1xuICAgICAgaWYgKCFwYXJhbXMucGF1c2VkKSB7XG4gICAgICAgIHNob3cocmVjb3JkQnV0dG9uKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyYW1zLnBhdXNlZCkge1xuICAgICAgZGlzYWJsZShwcmV2aWV3QnV0dG9uKVxuICAgICAgaGlkZShwcmV2aWV3QnV0dG9uKVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5lbmFibGVBdXRvVmFsaWRhdGlvbikge1xuICAgICAgZW5hYmxlKHN1Ym1pdEJ1dHRvbilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkdvaW5nQmFjayAoKSB7XG4gICAgaGlkZShyZWNvcmRBZ2FpbkJ1dHRvbilcbiAgICBzaG93KHJlY29yZEJ1dHRvbilcbiAgICBzaG93KHN1Ym1pdEJ1dHRvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUmVwbGF5U2hvd24gKCkge1xuICAgIHNlbGYuaGlkZSgpXG4gIH1cblxuICBmdW5jdGlvbiBvblVzZXJNZWRpYVJlYWR5IChwYXJhbXMpIHtcbiAgICBvbkZvcm1SZWFkeShwYXJhbXMpXG5cbiAgICBpZiAoaXNTaG93bihyZWNvcmRCdXR0b24pKSB7XG4gICAgICBlbmFibGUocmVjb3JkQnV0dG9uKVxuICAgIH1cblxuICAgIGlmIChpc1Nob3duKGF1ZGlvT25SYWRpb1BhaXIpKSB7XG4gICAgICBlbmFibGUoYXVkaW9PblJhZGlvUGFpcilcbiAgICB9XG5cbiAgICBpZiAoaXNTaG93bihhdWRpb09mZlJhZGlvUGFpcikpIHtcbiAgICAgIGVuYWJsZShhdWRpb09mZlJhZGlvUGFpcilcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5lbmFibGVBdXRvVmFsaWRhdGlvbikge1xuICAgICAgZGlzYWJsZShzdWJtaXRCdXR0b24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZXNldHRpbmcgKCkge1xuICAgIGRpc2FibGUoc3VibWl0QnV0dG9uKVxuXG4gICAgc2VsZi5yZXNldCgpXG4gIH1cblxuICBmdW5jdGlvbiBvblByZXZpZXcgKCkge1xuICAgIGhpZGUocmVjb3JkQnV0dG9uKVxuICAgIGhpZGUocHJldmlld0J1dHRvbilcbiAgICBkaXNhYmxlKGF1ZGlvT25SYWRpb1BhaXIpXG4gICAgZGlzYWJsZShhdWRpb09mZlJhZGlvUGFpcilcblxuICAgIHNob3cocmVjb3JkQWdhaW5CdXR0b24pXG4gICAgZW5hYmxlKHJlY29yZEFnYWluQnV0dG9uKVxuXG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZUF1dG9WYWxpZGF0aW9uKSB7XG4gICAgICBlbmFibGUoc3VibWl0QnV0dG9uKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuZW5hYmxlU3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgIGVuYWJsZShzdWJtaXRCdXR0b24pXG4gIH1cblxuICB0aGlzLmFkanVzdEJ1dHRvbnNGb3JQYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNlbGYuaXNDb3VudGluZ0Rvd24oKSkge1xuICAgICAgcGF1c2VCdXR0b24gJiYgaGlkZShwYXVzZUJ1dHRvbilcbiAgICAgIHNob3cocmVzdW1lQnV0dG9uKVxuICAgICAgZW5hYmxlKHJlc3VtZUJ1dHRvbilcbiAgICAgIGhpZGUocmVjb3JkQnV0dG9uKVxuICAgICAgc2hvdyhwcmV2aWV3QnV0dG9uKVxuICAgICAgZW5hYmxlKHByZXZpZXdCdXR0b24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25GaXJzdEZyYW1lU2VudCAoKSB7XG4gICAgaGlkZShyZWNvcmRCdXR0b24pXG4gICAgaGlkZShyZWNvcmRBZ2FpbkJ1dHRvbilcblxuICAgIGlmIChwYXVzZUJ1dHRvbikge1xuICAgICAgc2hvdyhwYXVzZUJ1dHRvbilcbiAgICAgIGVuYWJsZShwYXVzZUJ1dHRvbilcbiAgICB9XG5cbiAgICBlbmFibGUocHJldmlld0J1dHRvbilcbiAgICBzaG93KHByZXZpZXdCdXR0b24pXG4gIH1cblxuICBmdW5jdGlvbiBvblJlY29yZGluZyAoZnJhbWVzQ291bnQpIHtcbiAgICAvLyBpdCBpcyBwb3NzaWJsZSB0byBoaWRlIHdoaWxlIHJlY29yZGluZywgaGVuY2VcbiAgICAvLyBjaGVjayBmcmFtZXNDb3VudCBmaXJzdCAoY29taW5nIGZyb20gcmVjb3JkZXIpXG4gICAgaWYgKGZyYW1lc0NvdW50ID4gMSkge1xuICAgICAgb25GaXJzdEZyYW1lU2VudCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc2FibGUoYXVkaW9PZmZSYWRpb1BhaXIpXG4gICAgICBkaXNhYmxlKGF1ZGlvT25SYWRpb1BhaXIpXG4gICAgICBkaXNhYmxlKHJlY29yZEFnYWluQnV0dG9uKVxuICAgICAgZGlzYWJsZShyZWNvcmRCdXR0b24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZXN1bWluZyAoKSB7XG4gICAgaGlkZShyZXN1bWVCdXR0b24pXG4gICAgaGlkZShyZWNvcmRCdXR0b24pXG5cbiAgICBpZiAocGF1c2VCdXR0b24pIHtcbiAgICAgIGVuYWJsZShwYXVzZUJ1dHRvbilcbiAgICAgIHNob3cocGF1c2VCdXR0b24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25TdG9wcGluZyAoKSB7XG4gICAgZGlzYWJsZShwcmV2aWV3QnV0dG9uKVxuICAgIGhpZGUocGF1c2VCdXR0b24pXG4gICAgaGlkZShyZXN1bWVCdXR0b24pXG4gIH1cblxuICBmdW5jdGlvbiBvbkNvdW50ZG93biAoKSB7XG4gICAgZGlzYWJsZShyZWNvcmRCdXR0b24pXG4gICAgZGlzYWJsZShhdWRpb09mZlJhZGlvUGFpcilcbiAgICBkaXNhYmxlKGF1ZGlvT25SYWRpb1BhaXIpXG4gIH1cblxuICBmdW5jdGlvbiBvblN1Ym1pdHRpbmcgKCkge1xuICAgIGRpc2FibGUoc3VibWl0QnV0dG9uKVxuICAgIGRpc2FibGUocmVjb3JkQWdhaW5CdXR0b24pXG4gIH1cblxuICBmdW5jdGlvbiBvblN1Ym1pdHRlZCAoKSB7XG4gICAgZGlzYWJsZShwcmV2aWV3QnV0dG9uKVxuICAgIGRpc2FibGUocmVjb3JkQWdhaW5CdXR0b24pXG4gICAgZGlzYWJsZShyZWNvcmRCdXR0b24pXG4gICAgZGlzYWJsZShzdWJtaXRCdXR0b24pXG4gIH1cblxuICBmdW5jdGlvbiBvbkludmFsaWQgKCkge1xuICAgIGlmIChvcHRpb25zLmVuYWJsZUF1dG9WYWxpZGF0aW9uKSB7XG4gICAgICBkaXNhYmxlKHN1Ym1pdEJ1dHRvbilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblZhbGlkICgpIHtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVBdXRvVmFsaWRhdGlvbikge1xuICAgICAgZW5hYmxlKHN1Ym1pdEJ1dHRvbilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkhpZGRlbiAoKSB7XG4gICAgaGlkZShyZWNvcmRCdXR0b24pXG4gICAgaGlkZShwcmV2aWV3QnV0dG9uKVxuICAgIGhpZGUocmVjb3JkQWdhaW5CdXR0b24pXG4gICAgaGlkZShyZXN1bWVCdXR0b24pXG4gIH1cblxuICBmdW5jdGlvbiBvbkVuYWJsaW5nQXVkaW8gKCkge1xuICAgIGRpc2FibGUocmVjb3JkQnV0dG9uKVxuICAgIGRpc2FibGUoYXVkaW9PblJhZGlvUGFpcilcbiAgICBkaXNhYmxlKGF1ZGlvT2ZmUmFkaW9QYWlyKVxuICB9XG5cbiAgZnVuY3Rpb24gb25EaXNhYmxpbmdBdWRpbyAoKSB7XG4gICAgZGlzYWJsZShyZWNvcmRCdXR0b24pXG4gICAgZGlzYWJsZShhdWRpb09uUmFkaW9QYWlyKVxuICAgIGRpc2FibGUoYXVkaW9PZmZSYWRpb1BhaXIpXG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRBZ2FpbiAoKSB7XG4gICAgZGlzYWJsZShyZWNvcmRBZ2FpbkJ1dHRvbilcbiAgICBjb250YWluZXIuYmVnaW5XYWl0aW5nKClcbiAgICBjb250YWluZXIucmVjb3JkQWdhaW4oKVxuICB9XG5cbiAgZnVuY3Rpb24gb25TdGFydGluZ092ZXIgKCkge1xuICAgIHNob3coc3VibWl0QnV0dG9uKVxuICB9XG5cbiAgZnVuY3Rpb24gc3VibWl0ICgpIHtcbiAgICBjb250YWluZXIuc3VibWl0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZCAocGFyYW1zKSB7XG4gICAgZGlzYWJsZShyZWNvcmRCdXR0b24pXG4gICAgY29udGFpbmVyLnJlY29yZChwYXJhbXMpXG4gIH1cblxuICBmdW5jdGlvbiBpbml0RXZlbnRzICgpIHtcbiAgICBkZWJ1ZygnQnV0dG9uczogaW5pdEV2ZW50cygpJylcblxuICAgIHNlbGYub24oRXZlbnRzLlVTRVJfTUVESUFfUkVBRFksIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIGlmICghcGFyYW1zLnN3aXRjaGluZ0ZhY2luZ01vZGUpIHtcbiAgICAgICAgb25Vc2VyTWVkaWFSZWFkeShwYXJhbXMpXG4gICAgICB9XG4gICAgfSkub24oRXZlbnRzLlBSRVZJRVcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uUHJldmlldygpXG4gICAgfSkub24oRXZlbnRzLlBBVVNFRCwgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5hZGp1c3RCdXR0b25zRm9yUGF1c2UoKVxuICAgIH0pLm9uKEV2ZW50cy5SRUNPUkRJTkcsIGZ1bmN0aW9uIChmcmFtZXNDb3VudCkge1xuICAgICAgb25SZWNvcmRpbmcoZnJhbWVzQ291bnQpXG4gICAgfSkub24oRXZlbnRzLkZJUlNUX0ZSQU1FX1NFTlQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uRmlyc3RGcmFtZVNlbnQoKVxuICAgIH0pLm9uKEV2ZW50cy5SRVNVTUlORywgZnVuY3Rpb24gKCkge1xuICAgICAgb25SZXN1bWluZygpXG4gICAgfSkub24oRXZlbnRzLlNUT1BQSU5HLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvblN0b3BwaW5nKClcbiAgICB9KS5vbihFdmVudHMuQ09VTlRET1dOLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvbkNvdW50ZG93bigpXG4gICAgfSkub24oRXZlbnRzLlNVQk1JVFRJTkcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uU3VibWl0dGluZygpXG4gICAgfSkub24oRXZlbnRzLlJFU0VUVElORywgZnVuY3Rpb24gKCkge1xuICAgICAgb25SZXNldHRpbmcoKVxuICAgIH0pLm9uKEV2ZW50cy5JTlZBTElELCBmdW5jdGlvbiAoKSB7XG4gICAgICBvbkludmFsaWQoKVxuICAgIH0pLm9uKEV2ZW50cy5WQUxJRCwgZnVuY3Rpb24gKCkge1xuICAgICAgb25WYWxpZCgpXG4gICAgfSkub24oRXZlbnRzLlNVQk1JVFRFRCwgZnVuY3Rpb24gKCkge1xuICAgICAgb25TdWJtaXR0ZWQoKVxuICAgIH0pLm9uKEV2ZW50cy5ISURFLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvbkhpZGRlbigpXG4gICAgfSkub24oRXZlbnRzLkZPUk1fUkVBRFksIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIG9uRm9ybVJlYWR5KHBhcmFtcylcbiAgICB9KS5vbihFdmVudHMuUkVQTEFZX1NIT1dOLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvblJlcGxheVNob3duKClcbiAgICB9KS5vbihFdmVudHMuR09JTkdfQkFDSywgZnVuY3Rpb24gKCkge1xuICAgICAgb25Hb2luZ0JhY2soKVxuICAgIH0pLm9uKEV2ZW50cy5FTkFCTElOR19BVURJTywgZnVuY3Rpb24gKCkge1xuICAgICAgb25FbmFibGluZ0F1ZGlvKClcbiAgICB9KS5vbihFdmVudHMuRElTQUJMSU5HX0FVRElPLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvbkRpc2FibGluZ0F1ZGlvKClcbiAgICB9KS5vbihFdmVudHMuU1RBUlRJTkdfT1ZFUiwgZnVuY3Rpb24gKCkge1xuICAgICAgb25TdGFydGluZ092ZXIoKVxuICAgIH0pLm9uKEV2ZW50cy5FUlJPUiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgLy8gc2luY2UgaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLWNsaWVudC9pc3N1ZXMvNjBcbiAgICAgIC8vIHdlIGhpZGUgYXJlYXMgdG8gbWFrZSBpdCBlYXNpZXIgZm9yIHRoZSB1c2VyXG4gICAgICBpZiAoZXJyLmhpZGVCdXR0b25zICYmIGVyci5oaWRlQnV0dG9ucygpICYmIG9wdGlvbnMuYWRqdXN0Rm9ybU9uQnJvd3NlckVycm9yKSB7XG4gICAgICAgIHNlbGYuaGlkZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgb3B0aW9ucy5kZWJ1ZygnQnV0dG9uczogcmVzZXQoKScpXG5cbiAgICBkaXNhYmxlKHBhdXNlQnV0dG9uKVxuICAgIGRpc2FibGUocmVzdW1lQnV0dG9uKVxuICAgIGRpc2FibGUocmVjb3JkQnV0dG9uKVxuICAgIGRpc2FibGUocHJldmlld0J1dHRvbilcbiAgICBkaXNhYmxlKHJlY29yZEFnYWluQnV0dG9uKVxuICB9XG5cbiAgdGhpcy5pc1JlY29yZEFnYWluQnV0dG9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXJlY29yZEFnYWluQnV0dG9uLmRpc2FibGVkXG4gIH1cblxuICB0aGlzLmlzUmVjb3JkQnV0dG9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXJlY29yZEJ1dHRvbi5kaXNhYmxlZFxuICB9XG5cbiAgdGhpcy5zZXRTdWJtaXRCdXR0b24gPSBmdW5jdGlvbiAobmV3U3VibWl0QnV0dG9uKSB7XG4gICAgc3VibWl0QnV0dG9uID0gbmV3U3VibWl0QnV0dG9uXG4gIH1cblxuICB0aGlzLmdldFN1Ym1pdEJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3VibWl0QnV0dG9uXG4gIH1cblxuICB0aGlzLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgIGJ1dHRvbnNFbGVtZW50ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy4nICsgb3B0aW9ucy5zZWxlY3RvcnMuYnV0dG9uc0NsYXNzKVxuXG4gICAgaWYgKCFidXR0b25zRWxlbWVudCkge1xuICAgICAgYnV0dG9uc0VsZW1lbnQgPSBoKCdkaXYuJyArIG9wdGlvbnMuc2VsZWN0b3JzLmJ1dHRvbnNDbGFzcylcblxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGJ1dHRvbnNFbGVtZW50KVxuICAgIH1cblxuICAgIGJ1aWxkQnV0dG9ucygpXG5cbiAgICAhYnVpbHQgJiYgaW5pdEV2ZW50cygpXG5cbiAgICBidWlsdCA9IHRydWVcbiAgfVxuXG4gIHRoaXMudW5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIGJ1aWx0ID0gZmFsc2VcbiAgfVxuXG4gIHRoaXMuaGlkZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBoaWRlKGJ1dHRvbnNFbGVtZW50KVxuXG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuZGVlcCkge1xuICAgICAgaGlkZShyZWNvcmRCdXR0b24pXG4gICAgICBoaWRlKHBhdXNlQnV0dG9uKVxuICAgICAgaGlkZShyZXN1bWVCdXR0b24pXG4gICAgICBoaWRlKHByZXZpZXdCdXR0b24pXG4gICAgICBoaWRlKHJlY29yZEFnYWluQnV0dG9uKVxuICAgICAgaGlkZShzdWJtaXRCdXR0b24pXG4gICAgfVxuICB9XG5cbiAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHNob3coYnV0dG9uc0VsZW1lbnQpXG4gIH1cblxuICB0aGlzLmlzQ291bnRpbmdEb3duID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb250YWluZXIuaXNDb3VudGluZ0Rvd24oKVxuICB9XG59XG5cbnV0aWwuaW5oZXJpdHMoQnV0dG9ucywgRXZlbnRFbWl0dGVyKVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25zXG4iLCJpbXBvcnQgaW5zZXJ0Q3NzIGZyb20gJ2luc2VydC1jc3MnXG5pbXBvcnQgaGlkZGVuIGZyb20gJ2hpZGRlbidcbmltcG9ydCB1dGlsIGZyb20gJ3V0aWwnXG5pbXBvcnQgVmlzaWJpbGl0eSBmcm9tICdkb2N1bWVudC12aXNpYmlsaXR5J1xuXG5pbXBvcnQgRGltZW5zaW9uIGZyb20gJy4vZGltZW5zaW9uJ1xuaW1wb3J0IFZpc3VhbHMgZnJvbSAnLi92aXN1YWxzJ1xuaW1wb3J0IEJ1dHRvbnMgZnJvbSAnLi9idXR0b25zJ1xuaW1wb3J0IEZvcm0gZnJvbSAnLi9mb3JtJ1xuaW1wb3J0IE9wdGlvbnNXcmFwcGVyIGZyb20gJy4vb3B0aW9uc1dyYXBwZXInXG5cbmltcG9ydCBSZXNvdXJjZSBmcm9tICcuLy4uL3Jlc291cmNlJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLy4uL2V2ZW50cydcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLy4uL3V0aWwvZXZlbnRFbWl0dGVyJ1xuaW1wb3J0IFZpZGVvbWFpbEVycm9yIGZyb20gJy4vLi4vdXRpbC92aWRlb21haWxFcnJvcidcbmltcG9ydCBjc3MgZnJvbSAnLi8uLi9zdHlsZXMvY3NzL21haW4ubWluLmNzcy5qcydcblxudmFyIENvbnRhaW5lciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMsIG9wdGlvbnMsICdDb250YWluZXInKVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgY29uc3QgdmlzaWJpbGl0eSA9IFZpc2liaWxpdHkoKVxuICBjb25zdCB2aXN1YWxzID0gbmV3IFZpc3VhbHModGhpcywgb3B0aW9ucylcbiAgY29uc3QgYnV0dG9ucyA9IG5ldyBCdXR0b25zKHRoaXMsIG9wdGlvbnMpXG4gIGNvbnN0IHJlc291cmNlID0gbmV3IFJlc291cmNlKG9wdGlvbnMpXG4gIGNvbnN0IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvciAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sJylcbiAgY29uc3QgZGVidWcgPSBvcHRpb25zLmRlYnVnXG5cbiAgdmFyIGhhc0Vycm9yID0gZmFsc2VcbiAgdmFyIHN1Ym1pdHRlZCA9IGZhbHNlXG4gIHZhciBsYXN0VmFsaWRhdGlvbiA9IGZhbHNlXG5cbiAgdmFyIGNvbnRhaW5lckVsZW1lbnRcbiAgdmFyIGJ1aWx0XG4gIHZhciBmb3JtXG5cbiAgZnVuY3Rpb24gcHJlcGVuZERlZmF1bHRDc3MgKCkge1xuICAgIGluc2VydENzcyhjc3MsIHsgcHJlcGVuZDogdHJ1ZSB9KVxuICB9XG5cbiAgLy8gc2luY2UgaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLWNsaWVudC9pc3N1ZXMvODdcbiAgZnVuY3Rpb24gZmluZFBhcmVudEZvcm1FbGVtZW50ICgpIHtcbiAgICByZXR1cm4gY29udGFpbmVyRWxlbWVudC5jbG9zZXN0KCdmb3JtJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZvcm1FbGVtZW50ICgpIHtcbiAgICB2YXIgZm9ybUVsZW1lbnRcblxuICAgIGlmIChjb250YWluZXJFbGVtZW50LnRhZ05hbWUgPT09ICdGT1JNJykge1xuICAgICAgZm9ybUVsZW1lbnQgPSBjb250YWluZXJFbGVtZW50XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlbGVjdG9ycy5mb3JtSWQpIHtcbiAgICAgIGZvcm1FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5zZWxlY3RvcnMuZm9ybUlkKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtRWxlbWVudCA9IGZpbmRQYXJlbnRGb3JtRWxlbWVudCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1FbGVtZW50XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZEZvcm0gKCkge1xuICAgIGNvbnN0IGZvcm1FbGVtZW50ID0gZ2V0Rm9ybUVsZW1lbnQoKVxuXG4gICAgaWYgKGZvcm1FbGVtZW50KSB7XG4gICAgICBkZWJ1ZygnQ29udGFpbmVyOiBidWlsZEZvcm0oKScpXG4gICAgICBmb3JtID0gbmV3IEZvcm0oc2VsZiwgZm9ybUVsZW1lbnQsIG9wdGlvbnMpXG5cbiAgICAgIGNvbnN0IHN1Ym1pdEJ1dHRvbiA9IGZvcm0uZmluZFN1Ym1pdEJ1dHRvbigpXG4gICAgICBzdWJtaXRCdXR0b24gJiYgYnV0dG9ucy5zZXRTdWJtaXRCdXR0b24oc3VibWl0QnV0dG9uKVxuXG4gICAgICBmb3JtLmJ1aWxkKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZENoaWxkcmVuICgpIHtcbiAgICBkZWJ1ZygnQ29udGFpbmVyOiBidWlsZENoaWxkcmVuKCknKVxuXG4gICAgaWYgKCFjb250YWluZXJFbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdTb3JyeSwgeW91ciBicm93c2VyIGlzIHRvbyBvbGQhJywgb3B0aW9ucykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lckVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndmlkZW9tYWlsJylcblxuICAgICAgaWYgKCFvcHRpb25zLnBsYXllck9ubHkpIHtcbiAgICAgICAgYnV0dG9ucy5idWlsZCgpXG4gICAgICB9XG5cbiAgICAgIHZpc3VhbHMuYnVpbGQoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NFcnJvciAoZXJyKSB7XG4gICAgaGFzRXJyb3IgPSB0cnVlXG5cbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICBvcHRpb25zLmxvZ2dlci5lcnJvcihlcnIuc3RhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMubG9nZ2VyLmVycm9yKGVycilcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kaXNwbGF5RXJyb3JzKSB7XG4gICAgICB2aXN1YWxzLmVycm9yKGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgdmlzdWFscy5yZXNldCgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEV2ZW50cyAoKSB7XG4gICAgZGVidWcoJ0NvbnRhaW5lcjogaW5pdEV2ZW50cygpJylcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoZSkgPT4ge1xuICAgICAgc2VsZi51bmxvYWQoZSlcbiAgICB9KVxuXG4gICAgaWYgKCFvcHRpb25zLnBsYXllck9ubHkpIHtcbiAgICAgIHZpc2liaWxpdHkub25DaGFuZ2UoZnVuY3Rpb24gKHZpc2libGUpIHtcbiAgICAgICAgLy8gYnVpbHQ/IHNlZSBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwuaW8vaXNzdWVzLzMyNlxuICAgICAgICBpZiAoYnVpbHQpIHtcbiAgICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaXNBdXRvUGF1c2VFbmFibGVkKCkgJiYgc2VsZi5pc0NvdW50aW5nRG93bigpKSB7XG4gICAgICAgICAgICAgIHNlbGYucmVzdW1lKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5WSVNJQkxFKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pc0F1dG9QYXVzZUVuYWJsZWQoKSAmJiAoc2VsZi5pc0NvdW50aW5nRG93bigpIHx8IHNlbGYuaXNSZWNvcmRpbmcoKSkpIHtcbiAgICAgICAgICAgICAgc2VsZi5wYXVzZSgnZG9jdW1lbnQgaW52aXNpYmxlJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5JTlZJU0lCTEUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmVuYWJsZVNwYWNlKSB7XG4gICAgICBpZiAoIW9wdGlvbnMucGxheWVyT25seSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlLnRhcmdldC50YWdOYW1lXG4gICAgICAgICAgY29uc3QgaXNFZGl0YWJsZSA9IGUudGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9PT0gdHJ1ZVxuXG4gICAgICAgICAgLy8gYmV3YXJlIG9mIHJpY2ggdGV4dCBlZGl0b3JzLCBoZW5jZSB0aGUgaXNFZGl0YWJsZSBjaGVjayAod29yZHByZXNzIHBsdWdpbiBpc3N1ZSlcbiAgICAgICAgICBpZiAoIWlzRWRpdGFibGUgJiYgdGFnTmFtZSAhPT0gJ0lOUFVUJyAmJiB0YWdOYW1lICE9PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gZS5rZXlDb2RlID8gZS5rZXlDb2RlIDogZS53aGljaFxuXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMzIpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlUGF1c2UpIHtcbiAgICAgICAgICAgICAgICB2aXN1YWxzLnBhdXNlT3JSZXN1bWUoKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZpc3VhbHMucmVjb3JkT3JTdG9wKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBiZXR0ZXIgdG8ga2VlcCB0aGUgb25lIGFuZCBvbmx5IGVycm9yIGxpc3RlbmVyc1xuICAgIC8vIGF0IG9uZSBzcG90LCBoZXJlLCBiZWNhdXNlIHVubG9hZCgpIHdpbGwgZG8gYSByZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICAgIHNlbGYub24oRXZlbnRzLkVSUk9SLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBwcm9jZXNzRXJyb3IoZXJyKVxuICAgICAgdW5sb2FkQ2hpbGRyZW4oZXJyKVxuXG4gICAgICBpZiAoZXJyLnJlbW92ZURpbWVuc2lvbnMgJiYgZXJyLnJlbW92ZURpbWVuc2lvbnMoKSkge1xuICAgICAgICByZW1vdmVEaW1lbnNpb25zKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKCFvcHRpb25zLnBsYXllck9ubHkpIHtcbiAgICAgIHNlbGYub24oRXZlbnRzLkxPQURFRF9NRVRBX0RBVEEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29ycmVjdERpbWVuc2lvbnMoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMgKCkge1xuICAgIGlmIChvcHRpb25zLmhhc0RlZmluZWRXaWR0aCgpICYmIG9wdGlvbnMudmlkZW8ud2lkdGggJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ1dpZHRoIG11c3QgYmUgZGl2aXNpYmxlIGJ5IHR3by4nLCBvcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhc0RlZmluZWRIZWlnaHQoKSAmJiBvcHRpb25zLnZpZGVvLmhlaWdodCAlIDIgIT09IDApIHtcbiAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnSGVpZ2h0IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHR3by4nLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIC8vIHRoaXMgd2lsbCBqdXN0IHNldCB0aGUgd2lkdGggYnV0IG5vdCB0aGUgaGVpZ2h0IGJlY2F1c2VcbiAgLy8gaXQgY2FuIGJlIGEgZm9ybSB3aXRoIG1vcmUgaW5wdXRzIGVsZW1lbnRzXG4gIGZ1bmN0aW9uIGNvcnJlY3REaW1lbnNpb25zICgpIHtcbiAgICBjb25zdCB3aWR0aCA9IHZpc3VhbHMuZ2V0UmVjb3JkZXJXaWR0aCh0cnVlKVxuXG4gICAgaWYgKHdpZHRoIDwgMSkge1xuICAgICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdSZWNvcmRlciB3aWR0aCBjYW5ub3QgYmUgbGVzcyB0aGFuIDEhJywgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4J1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZURpbWVuc2lvbnMgKCkge1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUud2lkdGggPSAnYXV0bydcbiAgfVxuXG4gIGZ1bmN0aW9uIHVubG9hZENoaWxkcmVuIChlKSB7XG4gICAgdmlzdWFscy51bmxvYWQoZSlcbiAgICBidXR0b25zLnVubG9hZCgpXG4gICAgc2VsZi5lbmRXYWl0aW5nKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGVNeVNlbGYgKCkge1xuICAgIGhpZGRlbihjb250YWluZXJFbGVtZW50LCB0cnVlKVxuICB9XG5cbiAgLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLWNsaWVudC9pc3N1ZXMvNzFcbiAgZnVuY3Rpb24gdHJpbUVtYWlsIChlbWFpbCkge1xuICAgIHJldHVybiBlbWFpbC5yZXBsYWNlKC8oXlssXFxzXSspfChbLFxcc10rJCkvZywgJycpXG4gIH1cblxuICBmdW5jdGlvbiBzdWJtaXRWaWRlb21haWwgKGZvcm1EYXRhLCBtZXRob2QsIGNiKSB7XG4gICAgY29uc3QgRk9STV9GSUVMRFMgPSB7XG4gICAgICAnc3ViamVjdCc6IG9wdGlvbnMuc2VsZWN0b3JzLnN1YmplY3RJbnB1dE5hbWUsXG4gICAgICAnZnJvbSc6IG9wdGlvbnMuc2VsZWN0b3JzLmZyb21JbnB1dE5hbWUsXG4gICAgICAndG8nOiBvcHRpb25zLnNlbGVjdG9ycy50b0lucHV0TmFtZSxcbiAgICAgICdib2R5Jzogb3B0aW9ucy5zZWxlY3RvcnMuYm9keUlucHV0TmFtZSxcbiAgICAgICdrZXknOiBvcHRpb25zLnNlbGVjdG9ycy5rZXlJbnB1dE5hbWUsXG4gICAgICAncGFyZW50S2V5Jzogb3B0aW9ucy5zZWxlY3RvcnMucGFyZW50S2V5SW5wdXROYW1lLFxuICAgICAgJ3NlbmRDb3B5Jzogb3B0aW9ucy5zZWxlY3RvcnMuc2VuZENvcHlJbnB1dE5hbWVcbiAgICB9XG5cbiAgICBjb25zdCB2aWRlb21haWxGb3JtRGF0YSA9IHt9XG5cbiAgICBPYmplY3Qua2V5cyhGT1JNX0ZJRUxEUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoZm9ybURhdGEuaGFzT3duUHJvcGVydHkoRk9STV9GSUVMRFNba2V5XSkpIHtcbiAgICAgICAgdmlkZW9tYWlsRm9ybURhdGFba2V5XSA9IGZvcm1EYXRhW0ZPUk1fRklFTERTW2tleV1dXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmICh2aWRlb21haWxGb3JtRGF0YS5mcm9tKSB7XG4gICAgICB2aWRlb21haWxGb3JtRGF0YS5mcm9tID0gdHJpbUVtYWlsKHZpZGVvbWFpbEZvcm1EYXRhLmZyb20pXG4gICAgfVxuXG4gICAgaWYgKHZpZGVvbWFpbEZvcm1EYXRhLnRvKSB7XG4gICAgICB2aWRlb21haWxGb3JtRGF0YS50byA9IHRyaW1FbWFpbCh2aWRlb21haWxGb3JtRGF0YS50bylcbiAgICB9XG5cbiAgICAvLyB3aGVuIG1ldGhvZCBpcyB1bmRlZmluZWQsIHRyZWF0IGl0IGFzIGEgcG9zdFxuICAgIGlmIChpc1Bvc3QobWV0aG9kKSB8fCAhbWV0aG9kKSB7XG4gICAgICB2aWRlb21haWxGb3JtRGF0YS5yZWNvcmRpbmdTdGF0cyA9IHZpc3VhbHMuZ2V0UmVjb3JkaW5nU3RhdHMoKVxuICAgICAgdmlkZW9tYWlsRm9ybURhdGEud2lkdGggPSB2aXN1YWxzLmdldFJlY29yZGVyV2lkdGgodHJ1ZSlcbiAgICAgIHZpZGVvbWFpbEZvcm1EYXRhLmhlaWdodCA9IHZpc3VhbHMuZ2V0UmVjb3JkZXJIZWlnaHQodHJ1ZSlcblxuICAgICAgcmVzb3VyY2UucG9zdCh2aWRlb21haWxGb3JtRGF0YSwgY2IpXG4gICAgfSBlbHNlIGlmIChpc1B1dChtZXRob2QpKSB7XG4gICAgICByZXNvdXJjZS5wdXQodmlkZW9tYWlsRm9ybURhdGEsIGNiKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN1Ym1pdEZvcm0gKGZvcm1EYXRhLCB2aWRlb21haWxSZXNwb25zZSwgdXJsLCBjYikge1xuICAgIC8vIGZvciBub3csIGFjY2VwdCBQT1NUcyBvbmx5IHdoaWNoIGhhdmUgYW4gVVJMIHVubGlrZSBudWxsIGFuZFxuICAgIC8vIHRyZWF0IGFsbCBvdGhlciBzdWJtaXNzaW9ucyBhcyBkaXJlY3Qgc3VibWlzc2lvbnNcblxuICAgIGlmICghdXJsIHx8IHVybCA9PT0gJycpIHtcbiAgICAgIC8vIGZpZ3VyZSBvdXQgVVJMIGF1dG9tYXRpY2FsbHkgdGhlblxuICAgICAgdXJsID0gZG9jdW1lbnQuYmFzZVVSSVxuICAgIH1cblxuICAgIC8vIGNhbiBiZSBtaXNzaW5nIHdoZW4gbm8gdmlkZW9tYWlsIHdhcyByZWNvcmRlZCBhbmQgaXMgbm90IHJlcXVpcmVkXG4gICAgaWYgKHZpZGVvbWFpbFJlc3BvbnNlKSB7XG4gICAgICBmb3JtRGF0YVtvcHRpb25zLnNlbGVjdG9ycy5hbGlhc0lucHV0TmFtZV0gPSB2aWRlb21haWxSZXNwb25zZS52aWRlb21haWwuYWxpYXNcblxuICAgICAgLy8gdGhpcyBpbiBjYXNlIGlmIHVzZXIgd2FudHMgYWxsIHZpZGVvbWFpbCBtZXRhZGF0YSB0byBiZSBwb3N0ZWRcbiAgICAgIC8vIGFsdG9nZXRoZXIgd2l0aCB0aGUgcmVtYWluaW5nIGZvcm1cbiAgICAgIGlmIChvcHRpb25zLnN1Ym1pdFdpdGhWaWRlb21haWwpIHtcbiAgICAgICAgZm9ybURhdGEudmlkZW9tYWlsID0gdmlkZW9tYWlsUmVzcG9uc2UudmlkZW9tYWlsXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzb3VyY2UuZm9ybShmb3JtRGF0YSwgdXJsLCBjYilcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmFsaXplU3VibWlzc2lvbnMgKGVyciwgbWV0aG9kLCB2aWRlb21haWwsIHJlc3BvbnNlLCBmb3JtUmVzcG9uc2UpIHtcbiAgICBzZWxmLmVuZFdhaXRpbmcoKVxuXG4gICAgaWYgKGVycikge1xuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWJtaXR0ZWQgPSB0cnVlXG5cbiAgICAgIC8vIG1lcmdlIHR3byBqc29uIHJlc3BvbnNlIGJvZGllcyB0byBmYWtlIGFzIGlmIGl0IHdlcmUgb25seSBvbmUgcmVxdWVzdFxuICAgICAgaWYgKHJlc3BvbnNlICYmIGZvcm1SZXNwb25zZSAmJiBmb3JtUmVzcG9uc2UuYm9keSkge1xuICAgICAgICBPYmplY3Qua2V5cyhmb3JtUmVzcG9uc2UuYm9keSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmVzcG9uc2Vba2V5XSA9IGZvcm1SZXNwb25zZS5ib2R5W2tleV1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgc2VsZi5lbWl0KFxuICAgICAgICBFdmVudHMuU1VCTUlUVEVELFxuICAgICAgICB2aWRlb21haWwsXG4gICAgICAgIHJlc3BvbnNlIHx8IGZvcm1SZXNwb25zZVxuICAgICAgKVxuXG4gICAgICBpZiAoZm9ybVJlc3BvbnNlICYmIGZvcm1SZXNwb25zZS50eXBlID09PSAndGV4dC9odG1sJyAmJiBmb3JtUmVzcG9uc2UudGV4dCkge1xuICAgICAgICAvLyBzZXJ2ZXIgcmVwbGllZCB3aXRoIEhUTUwgY29udGVudHMgLSBkaXNwbGF5IHRoZXNlXG4gICAgICAgIGRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID0gZm9ybVJlc3BvbnNlLnRleHRcblxuICAgICAgICAvLyB0b2RvOiBmaWd1cmUgb3V0IGhvdyB0byBmaXJlIGRvbSdzIG9ubG9hZCBldmVudCBhZ2FpblxuICAgICAgICAvLyB0b2RvOiBvciBob3cgdG8gcnVuIGFsbCB0aGUgc2NyaXB0cyBvdmVyIGFnYWluXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hZGRQbGF5ZXJEaW1lbnNpb25zID0gZnVuY3Rpb24gKHZpZGVvbWFpbCwgZWxlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICB2aWRlb21haWwucGxheWVySGVpZ2h0ID0gdGhpcy5jYWxjdWxhdGVIZWlnaHQoe1xuICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgICAgICB2aWRlb1dpZHRoOiB2aWRlb21haWwud2lkdGgsXG4gICAgICAgIHJhdGlvOiB2aWRlb21haWwuaGVpZ2h0IC8gdmlkZW9tYWlsLndpZHRoXG4gICAgICB9LCBlbGVtZW50KVxuXG4gICAgICB2aWRlb21haWwucGxheWVyV2lkdGggPSB0aGlzLmNhbGN1bGF0ZVdpZHRoKHtcbiAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAgICAgdmlkZW9IZWlnaHQ6IHZpZGVvbWFpbC5wbGF5ZXJIZWlnaHQsXG4gICAgICAgIHJhdGlvOiB2aWRlb21haWwuaGVpZ2h0IC8gdmlkZW9tYWlsLndpZHRoXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gdmlkZW9tYWlsXG4gICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICBzZWxmLmVtaXQoRXZlbnRzLkVSUk9SLCBleGMpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5saW1pdFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgcmV0dXJuIERpbWVuc2lvbi5saW1pdFdpZHRoKGNvbnRhaW5lckVsZW1lbnQsIHdpZHRoLCBvcHRpb25zKVxuICB9XG5cbiAgdGhpcy5saW1pdEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICByZXR1cm4gRGltZW5zaW9uLmxpbWl0SGVpZ2h0KGhlaWdodCwgb3B0aW9ucylcbiAgfVxuXG4gIHRoaXMuY2FsY3VsYXRlV2lkdGggPSBmdW5jdGlvbiAoZm5PcHRpb25zKSB7XG4gICAgcmV0dXJuIERpbWVuc2lvbi5jYWxjdWxhdGVXaWR0aChcbiAgICAgIE9wdGlvbnNXcmFwcGVyLm1lcmdlKG9wdGlvbnMsIGZuT3B0aW9ucywgdHJ1ZSlcbiAgICApXG4gIH1cblxuICB0aGlzLmNhbGN1bGF0ZUhlaWdodCA9IGZ1bmN0aW9uIChmbk9wdGlvbnMsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGlmIChjb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQgPSBjb250YWluZXJFbGVtZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBiZXR0ZXIgdGhhbiBub3RoaW5nXG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5ib2R5XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIERpbWVuc2lvbi5jYWxjdWxhdGVIZWlnaHQoXG4gICAgICBlbGVtZW50LFxuICAgICAgT3B0aW9uc1dyYXBwZXIubWVyZ2Uob3B0aW9ucywgZm5PcHRpb25zLCB0cnVlKVxuICAgIClcbiAgfVxuXG4gIHRoaXMuYXJlVmlzdWFsc0hpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdmlzdWFscy5pc0hpZGRlbigpXG4gIH1cblxuICB0aGlzLmhhc0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhY29udGFpbmVyRWxlbWVudFxuICB9XG5cbiAgdGhpcy5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgY29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuc2VsZWN0b3JzLmNvbnRhaW5lcklkKVxuXG4gICAgICAvLyBvbmx5IGJ1aWxkIHdoZW4gYSBjb250YWluZXIgZWxlbWVudCBoYXN0IGJlZW4gZm91bmQsIG90aGVyd2lzZVxuICAgICAgLy8gYmUgc2lsZW50IGFuZCBkbyBub3RoaW5nXG4gICAgICBpZiAoY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgICBvcHRpb25zLmluc2VydENzcyAmJiBwcmVwZW5kRGVmYXVsdENzcygpXG5cbiAgICAgICAgIWJ1aWx0ICYmIGluaXRFdmVudHMoKVxuICAgICAgICB2YWxpZGF0ZU9wdGlvbnMoKVxuICAgICAgICBjb3JyZWN0RGltZW5zaW9ucygpXG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYXllck9ubHkpIHtcbiAgICAgICAgICBidWlsZEZvcm0oKVxuICAgICAgICB9XG5cbiAgICAgICAgYnVpbGRDaGlsZHJlbigpXG5cbiAgICAgICAgaWYgKCFoYXNFcnJvcikge1xuICAgICAgICAgIGRlYnVnKCdDb250YWluZXI6IGJ1aWx0LicpXG4gICAgICAgICAgYnVpbHQgPSB0cnVlXG4gICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5CVUlMVClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnQ29udGFpbmVyOiBidWlsZGluZyBmYWlsZWQgZHVlIHRvIGFuIGVycm9yLicpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbW1lbnRlZCBvdXQgc2luY2UgaXQgZG9lcyB0b28gbXVjaCBub2lzZSBvbiB2aWRlb21haWwncyB2aWV3IHBhZ2Ugd2hpY2ggaXMgZmluZVxuICAgICAgICAvLyBkZWJ1ZygnQ29udGFpbmVyOiBubyBjb250YWluZXIgZWxlbWVudCB3aXRoIElEICcgKyBvcHRpb25zLnNlbGVjdG9ycy5jb250YWluZXJJZCArICcgZm91bmQuIERvIG5vdGhpbmcuJylcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgIGlmICh2aXN1YWxzLmlzTm90aWZpZXJCdWlsdCgpKSB7XG4gICAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGV4YylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGV4Y1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuZ2V0U3VibWl0QnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBidXR0b25zLmdldFN1Ym1pdEJ1dHRvbigpXG4gIH1cblxuICB0aGlzLnF1ZXJ5U2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gY29udGFpbmVyRWxlbWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICB9XG5cbiAgdGhpcy5iZWdpbldhaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaHRtbEVsZW1lbnQuY2xhc3NMaXN0ICYmIGh0bWxFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3dhaXQnKVxuICB9XG5cbiAgdGhpcy5lbmRXYWl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGh0bWxFbGVtZW50LmNsYXNzTGlzdCAmJiBodG1sRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCd3YWl0JylcbiAgfVxuXG4gIHRoaXMuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkKVxuICB9XG5cbiAgdGhpcy5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoY2hpbGQsIHJlZmVyZW5jZSkge1xuICAgIGNvbnRhaW5lckVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCByZWZlcmVuY2UpXG4gIH1cblxuICB0aGlzLnVubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZGVidWcoJ0NvbnRhaW5lcjogdW5sb2FkKCknLCBlKVxuXG4gICAgdHJ5IHtcbiAgICAgIHVubG9hZENoaWxkcmVuKGUpXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpXG5cbiAgICAgIGJ1aWx0ID0gc3VibWl0dGVkID0gZmFsc2VcbiAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGV4YylcbiAgICB9XG4gIH1cblxuICB0aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgIGhpZGRlbihjb250YWluZXJFbGVtZW50LCBmYWxzZSlcblxuICAgICAgdmlzdWFscy5zaG93KClcblxuICAgICAgaWYgKCFoYXNFcnJvcikge1xuICAgICAgICBjb25zdCBwYXVzZWQgPSBzZWxmLmlzUGF1c2VkKClcblxuICAgICAgICBpZiAocGF1c2VkKSB7XG4gICAgICAgICAgYnV0dG9ucy5hZGp1c3RCdXR0b25zRm9yUGF1c2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2luY2UgaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLWNsaWVudC9pc3N1ZXMvNjBcbiAgICAgICAgLy8gd2UgaGlkZSBhcmVhcyB0byBtYWtlIGl0IGVhc2llciBmb3IgdGhlIHVzZXJcbiAgICAgICAgYnV0dG9ucy5zaG93KClcblxuICAgICAgICBpZiAoc2VsZi5pc1JlcGxheVNob3duKCkpIHtcbiAgICAgICAgICBzZWxmLmVtaXQoRXZlbnRzLlBSRVZJRVcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5GT1JNX1JFQURZLCB7IHBhdXNlZDogcGF1c2VkIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ0NvbnRhaW5lcjogaGlkZSgpJylcblxuICAgIGhhc0Vycm9yID0gZmFsc2VcblxuICAgIHRoaXMuaXNSZWNvcmRpbmcoKSAmJiB0aGlzLnBhdXNlKClcblxuICAgIHZpc3VhbHMuaGlkZSgpXG5cbiAgICBpZiAoc3VibWl0dGVkKSB7XG4gICAgICBidXR0b25zLmhpZGUoKVxuICAgICAgaGlkZU15U2VsZigpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5zdGFydE92ZXIgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuZW1pdChFdmVudHMuU1RBUlRJTkdfT1ZFUilcblxuICAgICAgc3VibWl0dGVkID0gZmFsc2VcbiAgICAgIGZvcm0uc2hvdygpXG4gICAgICB2aXN1YWxzLmJhY2socGFyYW1zLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwYXJhbXMua2VlcEhpZGRlbikge1xuICAgICAgICAgIC8vIGp1c3QgZW5hYmxlIGZvcm0sIGRvIG5vdGhpbmcgZWxzZS5cbiAgICAgICAgICAvLyBzZWUgZXhhbXBsZSBjb250YWN0X2Zvcm0uaHRtbCB3aGVuIHlvdSBzdWJtaXQgd2l0aG91dCB2aWRlb21pbFxuICAgICAgICAgIC8vIGFuZCBnbyBiYWNrXG4gICAgICAgICAgc2VsZi5lbmFibGVGb3JtKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnNob3cocGFyYW1zKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXhjKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuc2hvd1JlcGxheU9ubHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaGFzRXJyb3IgPSBmYWxzZVxuXG4gICAgdGhpcy5pc1JlY29yZGluZygpICYmIHRoaXMucGF1c2UoKVxuXG4gICAgdmlzdWFscy5zaG93UmVwbGF5T25seSgpXG5cbiAgICBzdWJtaXR0ZWQgJiYgYnV0dG9ucy5oaWRlKClcbiAgfVxuXG4gIHRoaXMuaXNOb3RpZnlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHZpc3VhbHMuaXNOb3RpZnlpbmcoKVxuICB9XG5cbiAgdGhpcy5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdmlzdWFscy5pc1BhdXNlZCgpXG4gIH1cblxuICB0aGlzLnBhdXNlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZpc3VhbHMucGF1c2UocGFyYW1zKVxuICB9XG5cbiAgLy8gdGhpcyBjb2RlIG5lZWRzIGEgZ29vZCByZXdyaXRlIDooXG4gIHRoaXMudmFsaWRhdGUgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICB2YXIgcnVuVmFsaWRhdGlvbiA9IHRydWVcbiAgICB2YXIgdmFsaWRcblxuICAgIGlmICghb3B0aW9ucy5lbmFibGVBdXRvVmFsaWRhdGlvbikge1xuICAgICAgcnVuVmFsaWRhdGlvbiA9IGZhbHNlXG4gICAgICBsYXN0VmFsaWRhdGlvbiA9IHRydWUgLy8gbmVlZGVkIHNvIHRoYXQgaXQgY2FuIGJlIHN1Ym1pdHRlZCBhbnl3YXksIHNlZSBzdWJtaXQoKVxuICAgIH0gZWxzZSBpZiAoZm9yY2UpIHtcbiAgICAgIHJ1blZhbGlkYXRpb24gPSBmb3JjZVxuICAgIH0gZWxzZSBpZiAoc2VsZi5pc05vdGlmeWluZygpKSB7XG4gICAgICBydW5WYWxpZGF0aW9uID0gZmFsc2VcbiAgICB9IGVsc2UgaWYgKHZpc3VhbHMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgcnVuVmFsaWRhdGlvbiA9IHZpc3VhbHMuaXNVc2VyTWVkaWFMb2FkZWQoKSB8fCB2aXN1YWxzLmlzUmVwbGF5U2hvd24oKVxuICAgIH0gZWxzZSBpZiAodmlzdWFscy5pc0Nvbm5lY3RpbmcoKSkge1xuICAgICAgcnVuVmFsaWRhdGlvbiA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHJ1blZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuZW1pdChFdmVudHMuVkFMSURBVElORylcblxuICAgICAgY29uc3QgdmlzdWFsc1ZhbGlkID0gdmlzdWFscy52YWxpZGF0ZSgpICYmIGJ1dHRvbnMuaXNSZWNvcmRBZ2FpbkJ1dHRvbkVuYWJsZWQoKVxuICAgICAgdmFyIHdoeUludmFsaWRcblxuICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgdmFsaWQgPSBmb3JtLnZhbGlkYXRlKClcblxuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYXJlVmlzdWFsc0hpZGRlbigpICYmICF2aXN1YWxzVmFsaWQpIHtcbiAgICAgICAgICAgIGlmIChzdWJtaXR0ZWQgfHwgdGhpcy5pc1JlYWR5KCkgfHwgdGhpcy5pc1JlY29yZGluZygpIHx8IHRoaXMuaXNQYXVzZWQoKSB8fCB0aGlzLmlzQ291bnRpbmdEb3duKCkpIHtcbiAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgIHdoeUludmFsaWQgPSAnVmlkZW8gaXMgbm90IHJlY29yZGVkJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBpbnZhbGlkSW5wdXQgPSBmb3JtLmdldEludmFsaWRFbGVtZW50KClcblxuICAgICAgICAgIGlmIChpbnZhbGlkSW5wdXQpIHtcbiAgICAgICAgICAgIHdoeUludmFsaWQgPSAnRm9ybSBpbnB1dCBuYW1lZCAnICsgaW52YWxpZElucHV0Lm5hbWUgKyAnIGlzIGludmFsaWQnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoeUludmFsaWQgPSAnRm9ybSBpbnB1dChzKCkgYXJlIGludmFsaWQnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZCA9IHZpc3VhbHNWYWxpZFxuICAgICAgfVxuXG4gICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgdGhpcy5lbWl0KEV2ZW50cy5WQUxJRClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdChFdmVudHMuSU5WQUxJRCwgd2h5SW52YWxpZClcbiAgICAgIH1cblxuICAgICAgbGFzdFZhbGlkYXRpb24gPSB2YWxpZFxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZFxuICB9XG5cbiAgdGhpcy5kaXNhYmxlRm9ybSA9IGZ1bmN0aW9uIChidXR0b25zVG9vKSB7XG4gICAgZm9ybSAmJiBmb3JtLmRpc2FibGUoYnV0dG9uc1RvbylcbiAgfVxuXG4gIHRoaXMuZW5hYmxlRm9ybSA9IGZ1bmN0aW9uIChidXR0b25zVG9vKSB7XG4gICAgZm9ybSAmJiBmb3JtLmVuYWJsZShidXR0b25zVG9vKVxuICB9XG5cbiAgdGhpcy5oYXNGb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIWZvcm1cbiAgfVxuXG4gIHRoaXMuaXNSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYnV0dG9ucy5pc1JlY29yZEJ1dHRvbkVuYWJsZWQoKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQb3N0IChtZXRob2QpIHtcbiAgICByZXR1cm4gbWV0aG9kICYmIG1ldGhvZC50b1VwcGVyQ2FzZSgpID09PSAnUE9TVCdcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUHV0IChtZXRob2QpIHtcbiAgICByZXR1cm4gbWV0aG9kICYmIG1ldGhvZC50b1VwcGVyQ2FzZSgpID09PSAnUFVUJ1xuICB9XG5cbiAgdGhpcy5zdWJtaXRBbGwgPSBmdW5jdGlvbiAoZm9ybURhdGEsIG1ldGhvZCwgdXJsKSB7XG4gICAgY29uc3QgcG9zdCA9IGlzUG9zdChtZXRob2QpXG4gICAgY29uc3QgaGFzVmlkZW9tYWlsS2V5ID0gISFmb3JtRGF0YVtvcHRpb25zLnNlbGVjdG9ycy5rZXlJbnB1dE5hbWVdXG5cbiAgICBmdW5jdGlvbiBzdGFydFN1Ym1pc3Npb24gKCkge1xuICAgICAgc2VsZi5iZWdpbldhaXRpbmcoKVxuICAgICAgc2VsZi5kaXNhYmxlRm9ybSh0cnVlKVxuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5TVUJNSVRUSU5HKVxuICAgIH1cblxuICAgIC8vIGEgY2xvc3VyZSBzbyB0aGF0IHdlIGNhbiBhY2Nlc3MgbWV0aG9kXG4gICAgdmFyIHN1Ym1pdFZpZGVvbWFpbENhbGxiYWNrID0gZnVuY3Rpb24gKGVycjEsIHZpZGVvbWFpbCwgdmlkZW9tYWlsUmVzcG9uc2UpIHtcbiAgICAgIGlmIChlcnIxKSB7XG4gICAgICAgIGZpbmFsaXplU3VibWlzc2lvbnMoZXJyMSwgbWV0aG9kLCB2aWRlb21haWwsIHZpZGVvbWFpbFJlc3BvbnNlKVxuICAgICAgfSBlbHNlIGlmIChwb3N0KSB7XG4gICAgICAgIHN1Ym1pdEZvcm0oZm9ybURhdGEsIHZpZGVvbWFpbFJlc3BvbnNlLCB1cmwsIGZ1bmN0aW9uIChlcnIyLCBmb3JtUmVzcG9uc2UpIHtcbiAgICAgICAgICBmaW5hbGl6ZVN1Ym1pc3Npb25zKGVycjIsIG1ldGhvZCwgdmlkZW9tYWlsLCB2aWRlb21haWxSZXNwb25zZSwgZm9ybVJlc3BvbnNlKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaXQncyBhIGRpcmVjdCBzdWJtaXNzaW9uXG4gICAgICAgIGZpbmFsaXplU3VibWlzc2lvbnMobnVsbCwgbWV0aG9kLCB2aWRlb21haWwsIHZpZGVvbWFpbFJlc3BvbnNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vICFoYXNWaWRlb21haWxLZXkgbWFrZXMgaXQgcG9zc2libGUgdG8gc3VibWl0IGZvcm0gd2hlbiB2aWRlb21haWwgaXRzZWxmXG4gICAgLy8gaXMgbm90IG9wdGlvbmFsLlxuICAgIGlmICghaGFzVmlkZW9tYWlsS2V5KSB7XG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVBdXRvU3VibWlzc2lvbikge1xuICAgICAgICBzdGFydFN1Ym1pc3Npb24oKVxuICAgICAgICBzdWJtaXRGb3JtKGZvcm1EYXRhLCBudWxsLCB1cmwsIGZ1bmN0aW9uIChlcnIyLCBmb3JtUmVzcG9uc2UpIHtcbiAgICAgICAgICBmaW5hbGl6ZVN1Ym1pc3Npb25zKGVycjIsIG1ldGhvZCwgbnVsbCwgbnVsbCwgZm9ybVJlc3BvbnNlKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgLy8gLi4uIGFuZCB3aGVuIHRoZSBlbmFibGVBdXRvU3VibWlzc2lvbiBvcHRpb24gaXMgZmFsc2UsXG4gICAgICAvLyB0aGVuIHRoYXQgY2FuIG1lYW4sIGxlYXZlIGl0IHRvIHRoZSBmcmFtZXdvcmsgdG8gcHJvY2VzcyB3aXRoIHRoZSBmb3JtXG4gICAgICAvLyB2YWxpZGF0aW9uL2hhbmRsaW5nL3N1Ym1pc3Npb24gaXRzZWxmLiBmb3IgZXhhbXBsZSB0aGUgbmluamEgZm9ybVxuICAgICAgLy8gd2lsbCB3YW50IHRvIGhpZ2hsaWdodCB3aGljaCBvbmUgaW5wdXQgYXJlIHdyb25nLlxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFN1Ym1pc3Npb24oKVxuICAgICAgc3VibWl0VmlkZW9tYWlsKGZvcm1EYXRhLCBtZXRob2QsIHN1Ym1pdFZpZGVvbWFpbENhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaXNCdWlsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYnVpbHRcbiAgfVxuXG4gIHRoaXMuaXNSZXBsYXlTaG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdmlzdWFscy5pc1JlcGxheVNob3duKClcbiAgfVxuXG4gIHRoaXMuaXNEaXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXNEaXJ0eSA9IGZhbHNlXG5cbiAgICBpZiAoZm9ybSkge1xuICAgICAgaWYgKHZpc3VhbHMuaXNSZWNvcmRlclVubG9hZGVkKCkpIHtcbiAgICAgICAgaXNEaXJ0eSA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNSZXBsYXlTaG93bigpIHx8IHRoaXMuaXNQYXVzZWQoKSkge1xuICAgICAgICBpc0RpcnR5ID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpc0RpcnR5XG4gIH1cblxuICB0aGlzLmdldFJlcGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdmlzdWFscy5nZXRSZXBsYXkoKVxuICB9XG5cbiAgdGhpcy5pc091dHNpZGVFbGVtZW50T2YgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgIT09IGNvbnRhaW5lckVsZW1lbnQgJiYgZWxlbWVudCAhPT0gY29udGFpbmVyRWxlbWVudFxuICB9XG5cbiAgdGhpcy5oaWRlRm9ybSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAvLyBmb3JtIGNoZWNrIG5lZWRlZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC1jbGllbnQvaXNzdWVzLzEyN1xuICAgIGZvcm0gJiYgZm9ybS5oaWRlKClcbiAgICBidXR0b25zICYmIGJ1dHRvbnMuaGlkZShwYXJhbXMpXG4gIH1cblxuICB0aGlzLmxvYWRGb3JtID0gZnVuY3Rpb24gKHZpZGVvbWFpbCkge1xuICAgIGlmIChmb3JtKSB7XG4gICAgICBmb3JtLmxvYWRWaWRlb21haWwodmlkZW9tYWlsKVxuICAgICAgdGhpcy52YWxpZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5lbmFibGVBdWRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICBvcHRpb25zLnNldEF1ZGlvRW5hYmxlZCh0cnVlKVxuICAgIHRoaXMuZW1pdChFdmVudHMuRU5BQkxJTkdfQVVESU8pXG4gIH1cblxuICB0aGlzLmRpc2FibGVBdWRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICBvcHRpb25zLnNldEF1ZGlvRW5hYmxlZChmYWxzZSlcbiAgICB0aGlzLmVtaXQoRXZlbnRzLkRJU0FCTElOR19BVURJTylcbiAgfVxuXG4gIHRoaXMuc3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgIGxhc3RWYWxpZGF0aW9uICYmIGZvcm0gJiYgZm9ybS5kb1RoZVN1Ym1pdCgpXG4gIH1cblxuICB0aGlzLmlzQ291bnRpbmdEb3duID0gdmlzdWFscy5pc0NvdW50aW5nRG93bi5iaW5kKHZpc3VhbHMpXG4gIHRoaXMuaXNSZWNvcmRpbmcgPSB2aXN1YWxzLmlzUmVjb3JkaW5nLmJpbmQodmlzdWFscylcbiAgdGhpcy5yZWNvcmQgPSB2aXN1YWxzLnJlY29yZC5iaW5kKHZpc3VhbHMpXG4gIHRoaXMucmVzdW1lID0gdmlzdWFscy5yZXN1bWUuYmluZCh2aXN1YWxzKVxuICB0aGlzLnN0b3AgPSB2aXN1YWxzLnN0b3AuYmluZCh2aXN1YWxzKVxuICB0aGlzLnJlY29yZEFnYWluID0gdmlzdWFscy5yZWNvcmRBZ2Fpbi5iaW5kKHZpc3VhbHMpXG59XG5cbnV0aWwuaW5oZXJpdHMoQ29udGFpbmVyLCBFdmVudEVtaXR0ZXIpXG5cbmV4cG9ydCBkZWZhdWx0IENvbnRhaW5lclxuIiwiaW1wb3J0IG51bWJlcklzSW50ZWdlciBmcm9tICdudW1iZXItaXMtaW50ZWdlcidcblxuaW1wb3J0IFZpZGVvbWFpbEVycm9yIGZyb20gJy4vLi4vdXRpbC92aWRlb21haWxFcnJvcidcblxuZnVuY3Rpb24gZ2V0T3V0ZXJXaWR0aCAoZWxlbWVudCkge1xuICB2YXIgb3V0ZXJXaWR0aCA9IDBcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgaWYgKHJlY3QpIHtcbiAgICBvdXRlcldpZHRoID0gcmVjdC5yaWdodCAtIHJlY3QubGVmdFxuICB9XG5cbiAgaWYgKG91dGVyV2lkdGggPCAxKSB7XG4gICAgLy8gbGFzdCBlZmZvcnQsIGNhbiBoYXBwZW4gd2hlbiByZXBsYXlpbmcgb25seVxuICAgIHJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgb3V0ZXJXaWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnRcbiAgfVxuXG4gIHJldHVybiBvdXRlcldpZHRoXG59XG5cbmZ1bmN0aW9uIGZpZ3VyZU1pbkhlaWdodCAoaGVpZ2h0LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmhhc0RlZmluZWRIZWlnaHQoKSkge1xuICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBvcHRpb25zLnZpZGVvLmhlaWdodFxuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSBNYXRoLm1pbihvcHRpb25zLnZpZGVvLmhlaWdodCwgaGVpZ2h0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChudW1iZXJJc0ludGVnZXIoaGVpZ2h0KSAmJiBoZWlnaHQgPCAxKSB7XG4gICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgJ0dvdCBhIHZpZGVvIGhlaWdodCBsZXNzIHRoYW4gMSAoJyArXG4gICAgICBoZWlnaHQgK1xuICAgICAgJykgd2hpbGUgZmlndXJpbmcgb3V0IHRoZSBtaW5pbXVtIScsXG4gICAgICBvcHRpb25zXG4gICAgKVxuICB9XG5cbiAgLy8ganVzdCByZXR1cm4gaXQsIGNhbiBiZSBcImF1dG9cIlxuICByZXR1cm4gaGVpZ2h0XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICBsaW1pdFdpZHRoOiBmdW5jdGlvbiAoZWxlbWVudCwgd2lkdGgsIG9wdGlvbnMpIHtcbiAgICB2YXIgbGltaXRlZFdpZHRoXG5cbiAgICBjb25zdCBvdXRlcldpZHRoID0gZ2V0T3V0ZXJXaWR0aChlbGVtZW50KVxuXG4gICAgaWYgKHdpZHRoKSB7XG4gICAgICAvLyBvbmx5IHdoZW4gdGhhdCBlbGVtZW50IGhhcyBhIGRlZmluZWQgd2lkdGgsIGFwcGx5IHRoaXMgbG9naWNcbiAgICAgIGxpbWl0ZWRXaWR0aCA9IG91dGVyV2lkdGggPiAwICYmIG91dGVyV2lkdGggPCB3aWR0aCA/IG91dGVyV2lkdGggOiB3aWR0aFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbHNlIGFwcGx5IHRoZSBvdXRlciB3aWR0aCB3aGVuIHRoZSBlbGVtZW50IGhhcyBubyBkZWZpbmVkIHdpZHRoIHlldFxuICAgICAgbGltaXRlZFdpZHRoID0gb3V0ZXJXaWR0aFxuICAgIH1cblxuICAgIGlmIChudW1iZXJJc0ludGVnZXIobGltaXRlZFdpZHRoKSAmJiBsaW1pdGVkV2lkdGggPCAxKSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ0xpbWl0ZWQgd2lkdGggY2Fubm90IGJlIGxlc3MgdGhhbiAxIScsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsaW1pdGVkV2lkdGhcbiAgICB9XG4gIH0sXG5cbiAgLy8gdGhpcyBpcyBkaWZmaWN1bHQgdG8gY29tcHV0ZSBhbmQgaXMgbm90IGVudGlyZWx5IGNvcnJlY3QuXG4gIC8vIGJ1dCBnb29kIGVub3VnaCBmb3Igbm93IHRvIGVuc3VyZSBzb21lIHN0YWJpbGl0eS5cbiAgbGltaXRIZWlnaHQ6IGZ1bmN0aW9uIChoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICBpZiAobnVtYmVySXNJbnRlZ2VyKGhlaWdodCkgJiYgaGVpZ2h0IDwgMSkge1xuICAgICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdQYXNzZWQgbGltaXQtaGVpZ2h0IGFyZ3VtZW50IGNhbm5vdCBiZSBsZXNzIHRoYW4gMSEnLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsaW1pdGVkSGVpZ2h0ID0gTWF0aC5taW4oXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgLy8gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgIClcblxuICAgICAgaWYgKGxpbWl0ZWRIZWlnaHQgPCAxKSB7XG4gICAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnTGltaXRlZCBoZWlnaHQgY2Fubm90IGJlIGxlc3MgdGhhbiAxIScsIG9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGltaXRlZEhlaWdodFxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjYWxjdWxhdGVXaWR0aDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy52aWRlb0hlaWdodCB8fCBudWxsXG4gICAgY29uc3QgcmF0aW8gPSBvcHRpb25zLnJhdGlvIHx8IG9wdGlvbnMuZ2V0UmF0aW8oKVxuXG4gICAgaGVpZ2h0ID0gZmlndXJlTWluSGVpZ2h0KGhlaWdodCwgb3B0aW9ucylcblxuICAgIGlmIChvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubGltaXRIZWlnaHQoaGVpZ2h0LCBvcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChudW1iZXJJc0ludGVnZXIoaGVpZ2h0KSAmJiBoZWlnaHQgPCAxKSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ0hlaWdodCBjYW5ub3QgYmUgc21hbGxlciB0aGFuIDEgd2hlbiBjYWxjdWxhdGluZyB3aWR0aC4nLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjYWxjdWxhdGVkV2lkdGggPSBwYXJzZUludChoZWlnaHQgLyByYXRpbylcblxuICAgICAgaWYgKGNhbGN1bGF0ZWRXaWR0aCA8IDEpIHtcbiAgICAgICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdDYWxjdWxhdGVkIHdpZHRoIGNhbm5vdCBiZSBzbWFsbGVyIHRoYW4gMSEnLCBvcHRpb25zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRXaWR0aFxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjYWxjdWxhdGVIZWlnaHQ6IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHdpZHRoID0gb3B0aW9ucy52aWRlb1dpZHRoIHx8IG51bGxcbiAgICB2YXIgaGVpZ2h0XG5cbiAgICBjb25zdCByYXRpbyA9IG9wdGlvbnMucmF0aW8gfHwgb3B0aW9ucy5nZXRSYXRpbygpXG5cbiAgICBpZiAob3B0aW9ucy5oYXNEZWZpbmVkV2lkdGgoKSkge1xuICAgICAgd2lkdGggPSBvcHRpb25zLnZpZGVvLndpZHRoXG4gICAgfVxuXG4gICAgaWYgKG51bWJlcklzSW50ZWdlcih3aWR0aCkgJiYgd2lkdGggPCAxKSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ1VuYWJsZSB0byBjYWxjdWxhdGUgaGVpZ2h0IHdoZW4gd2lkdGggaXMgbGVzcyB0aGFuIDEuJywgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgd2lkdGggPSB0aGlzLmxpbWl0V2lkdGgoZWxlbWVudCwgd2lkdGgsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgaWYgKHdpZHRoKSB7XG4gICAgICBoZWlnaHQgPSBwYXJzZUludCh3aWR0aCAqIHJhdGlvKVxuICAgIH1cblxuICAgIGlmIChudW1iZXJJc0ludGVnZXIoaGVpZ2h0KSAmJiBoZWlnaHQgPCAxKSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ0p1c3QgY2FsY3VsYXRlZCBhIGhlaWdodCBsZXNzIHRoYW4gMSB3aGljaCBpcyB3cm9uZy4nLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmlndXJlTWluSGVpZ2h0KGhlaWdodCwgb3B0aW9ucylcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IHV0aWwgZnJvbSAndXRpbCdcbmltcG9ydCBoaWRkZW4gZnJvbSAnaGlkZGVuJ1xuaW1wb3J0IGdldEZvcm1EYXRhIGZyb20gJ2dldC1mb3JtLWRhdGEnXG5cbmltcG9ydCBFdmVudHMgZnJvbSAnLi8uLi9ldmVudHMnXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vLi4vdXRpbC9ldmVudEVtaXR0ZXInXG5pbXBvcnQgVmlkZW9tYWlsRXJyb3IgZnJvbSAnLi8uLi91dGlsL3ZpZGVvbWFpbEVycm9yJ1xuXG5jb25zdCBGb3JtID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgZm9ybUVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgb3B0aW9ucywgJ0Zvcm0nKVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgdmFyIGRpc2FibGVDb250YWluZXJWYWxpZGF0aW9uXG4gIHZhciBrZXlJbnB1dFxuXG4gIGZ1bmN0aW9uIGdldERhdGEgKCkge1xuICAgIHJldHVybiBnZXRGb3JtRGF0YShmb3JtRWxlbWVudClcbiAgfVxuXG4gIHRoaXMubG9hZFZpZGVvbWFpbCA9IGZ1bmN0aW9uICh2aWRlb21haWwpIHtcbiAgICBjb25zdCBsaW1pdCA9IGZvcm1FbGVtZW50LmVsZW1lbnRzLmxlbmd0aFxuXG4gICAgdmFyIGlucHV0XG4gICAgdmFyIG5hbWVcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgaW5wdXQgPSBmb3JtRWxlbWVudC5lbGVtZW50c1tpXVxuICAgICAgbmFtZSA9IGlucHV0Lm5hbWVcblxuICAgICAgaWYgKHZpZGVvbWFpbFtuYW1lXSkge1xuICAgICAgICBpbnB1dC52YWx1ZSA9IHZpZGVvbWFpbFtuYW1lXVxuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gb3B0aW9ucy5zZWxlY3RvcnMuc3ViamVjdElucHV0TmFtZSB8fFxuICAgICAgICAgIG5hbWUgPT09IG9wdGlvbnMuc2VsZWN0b3JzLmJvZHlJbnB1dE5hbWUpIHtcbiAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9ybUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZXRob2QnLCAncHV0JylcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm90QnV0dG9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZSAhPT0gJ0JVVFRPTicgJiYgZWxlbWVudC50eXBlICE9PSAnc3VibWl0J1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RGlzYWJsZWQgKGRpc2FibGVkLCBidXR0b25zVG9vKSB7XG4gICAgY29uc3QgbGltaXQgPSBmb3JtRWxlbWVudC5lbGVtZW50cy5sZW5ndGhcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgaWYgKGJ1dHRvbnNUb28gfHwgKCFidXR0b25zVG9vICYmIGlzTm90QnV0dG9uKGZvcm1FbGVtZW50LmVsZW1lbnRzW2ldKSkpIHtcbiAgICAgICAgZm9ybUVsZW1lbnQuZWxlbWVudHNbaV0uZGlzYWJsZWQgPSBkaXNhYmxlZFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGVBbGwgKCkge1xuICAgIGNvbnN0IGxpbWl0ID0gZm9ybUVsZW1lbnQuZWxlbWVudHMubGVuZ3RoXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgIGhpZGRlbihmb3JtRWxlbWVudC5lbGVtZW50c1tpXSwgdHJ1ZSlcbiAgICB9XG5cbiAgICBoaWRkZW4oZm9ybUVsZW1lbnQsIHRydWUpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbnB1dEVsZW1lbnRzICgpIHtcbiAgICByZXR1cm4gZm9ybUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsIHRleHRhcmVhJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlbGVjdEVsZW1lbnRzICgpIHtcbiAgICByZXR1cm4gZm9ybUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0JylcbiAgfVxuXG4gIHRoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uIChidXR0b25zVG9vKSB7XG4gICAgc2V0RGlzYWJsZWQodHJ1ZSwgYnV0dG9uc1RvbylcbiAgfVxuXG4gIHRoaXMuZW5hYmxlID0gZnVuY3Rpb24gKGJ1dHRvbnNUb28pIHtcbiAgICBzZXREaXNhYmxlZChmYWxzZSwgYnV0dG9uc1RvbylcbiAgfVxuXG4gIHRoaXMuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlQXV0b1ZhbGlkYXRpb24pIHtcbiAgICAgIGNvbnN0IGlucHV0RWxlbWVudHMgPSBnZXRJbnB1dEVsZW1lbnRzKClcbiAgICAgIHZhciBpbnB1dEVsZW1lbnRcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlucHV0RWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW5wdXRFbGVtZW50ID0gaW5wdXRFbGVtZW50c1tpXVxuXG4gICAgICAgIGlmIChpbnB1dEVsZW1lbnQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgIGlucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250YWluZXIudmFsaWRhdGUoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnZhbGlkYXRlKClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVjYXVzZSBvZiBhbmd1bGFyJ3MgZGlnZXN0IGN5Y2xlLCB2YWxpZGF0ZSBhZ2FpbiB3aGVuIGl0IGJlY2FtZSBpbnZhbGlkXG4gICAgICAgIGlucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnZhbGlkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghZGlzYWJsZUNvbnRhaW5lclZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci52YWxpZGF0ZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZWxlY3RFbGVtZW50cyA9IGdldFNlbGVjdEVsZW1lbnRzKClcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbjIgPSBzZWxlY3RFbGVtZW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgc2VsZWN0RWxlbWVudHNbal0uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci52YWxpZGF0ZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAga2V5SW5wdXQgPSBmb3JtRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPVwiJyArIG9wdGlvbnMuc2VsZWN0b3JzLmtleUlucHV0TmFtZSArICdcIl0nKVxuXG4gICAgaWYgKCFrZXlJbnB1dCkge1xuICAgICAga2V5SW5wdXQgPSBoKCdpbnB1dCcsIHtcbiAgICAgICAgbmFtZTogb3B0aW9ucy5zZWxlY3RvcnMua2V5SW5wdXROYW1lLFxuICAgICAgICB0eXBlOiAnaGlkZGVuJ1xuICAgICAgfSlcblxuICAgICAgZm9ybUVsZW1lbnQuYXBwZW5kQ2hpbGQoa2V5SW5wdXQpXG4gICAgfVxuXG4gICAgdGhpcy5vbihFdmVudHMuUFJFVklFVywgZnVuY3Rpb24gKHZpZGVvbWFpbEtleSkge1xuICAgICAgLy8gYmV3YXJlIHRoYXQgcHJldmlldyBkb2Vzbid0IGFsd2F5cyBjb21lIHdpdGggYSBrZXksIGkuRS5cbiAgICAgIC8vIGNvbnRhaW5lci5zaG93KCkgY2FuIGVtaXQgUFJFVklFVyB3aXRob3V0IGEga2V5IHdoZW4gYSByZXBsYXkgYWxyZWFkeSBleGlzdHNcbiAgICAgIC8vIChjYW4gaGFwcGVuIHdoZW4gc2hvd2luZyAtIGhpZGluZyAtIHNob3dpbmcgdmlkZW9tYWlsIG92ZXIgYWdhaW4pXG5cbiAgICAgIC8vIG9ubHkgZW1pdCBlcnJvciBpZiBrZXkgaXMgbWlzc2luZyBBTkQgdGhlIGlucHV0IGhhcyBubyBrZXkgKHZhbHVlKSB5ZXRcbiAgICAgIGlmICghdmlkZW9tYWlsS2V5ICYmICFrZXlJbnB1dC52YWx1ZSkge1xuICAgICAgICBzZWxmLmVtaXQoXG4gICAgICAgICAgRXZlbnRzLkVSUk9SLFxuICAgICAgICAgIFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnVmlkZW9tYWlsIGtleSBmb3IgcHJldmlldyBpcyBtaXNzaW5nIScsIG9wdGlvbnMpXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAodmlkZW9tYWlsS2V5KSB7XG4gICAgICAgIGtleUlucHV0LnZhbHVlID0gdmlkZW9tYWlsS2V5XG4gICAgICB9XG4gICAgICAvLyBlbHNlXG4gICAgICAvLyBsZWF2ZSBhcyBpdCBhbmQgdXNlIGV4aXN0aW5nIGtleUlucHV0LnZhbHVlXG4gICAgfSlcblxuICAgIC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC1jbGllbnQvaXNzdWVzLzkxXG4gICAgdGhpcy5vbihFdmVudHMuR09JTkdfQkFDSywgKCkgPT4ge1xuICAgICAga2V5SW5wdXQudmFsdWUgPSBudWxsXG4gICAgfSlcblxuICAgIHRoaXMub24oRXZlbnRzLkVSUk9SLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAvLyBzaW5jZSBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwtY2xpZW50L2lzc3Vlcy82MFxuICAgICAgLy8gd2UgaGlkZSBhcmVhcyB0byBtYWtlIGl0IGVhc2llciBmb3IgdGhlIHVzZXIgdG8gcHJvY2VzcyBhbiBlcnJvclxuICAgICAgLy8gKD0gbGVzcyBkaXN0cmFjdGlvbnMpXG4gICAgICBpZiAoZXJyLmhpZGVGb3JtICYmIGVyci5oaWRlRm9ybSgpICYmIG9wdGlvbnMuYWRqdXN0Rm9ybU9uQnJvd3NlckVycm9yKSB7XG4gICAgICAgIGhpZGVBbGwoKVxuICAgICAgfSBlbHNlIGlmIChlcnIuaGlkZUJ1dHRvbnMgJiYgZXJyLmhpZGVCdXR0b25zKCkgJiYgb3B0aW9ucy5hZGp1c3RGb3JtT25Ccm93c2VyRXJyb3IpIHtcbiAgICAgICAgaGlkZVN1Ym1pdEJ1dHRvbigpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMub24oRXZlbnRzLkJVSUxULCBmdW5jdGlvbiAoKSB7XG4gICAgICBzdGFydExpc3RlbmluZ1RvU3VibWl0RXZlbnRzKClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gaGlkZVN1Ym1pdEJ1dHRvbiAoKSB7XG4gICAgY29uc3Qgc3VibWl0QnV0dG9uID0gc2VsZi5maW5kU3VibWl0QnV0dG9uKClcbiAgICBoaWRkZW4oc3VibWl0QnV0dG9uLCB0cnVlKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRMaXN0ZW5pbmdUb1N1Ym1pdEV2ZW50cyAoKSB7XG4gICAgY29uc3Qgc3VibWl0QnV0dG9uID0gY29udGFpbmVyLmdldFN1Ym1pdEJ1dHRvbigpXG4gICAgc3VibWl0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2VsZi5kb1RoZVN1Ym1pdC5iaW5kKHNlbGYpKVxuICB9XG5cbiAgdGhpcy5kb1RoZVN1Ym1pdCA9IChlKSA9PiB7XG4gICAgaWYgKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIC8vIG9ubHkgc3VibWl0IHdoZW4gdGhlcmUgaXMgYSBjb250YWluZXIsXG4gICAgLy8gb3RoZXJ3aXNlIGRvIG5vdGhpbmcgYW5kIGxlYXZlIGFzIGl0XG4gICAgaWYgKGNvbnRhaW5lci5oYXNFbGVtZW50KCkpIHtcbiAgICAgIGNvbnRhaW5lci5zdWJtaXRBbGwoXG4gICAgICAgIGdldERhdGEoKSxcbiAgICAgICAgZm9ybUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtZXRob2QnKSxcbiAgICAgICAgZm9ybUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhY3Rpb24nKVxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSAvLyBpbXBvcnRhbnQgdG8gc3RvcCBzdWJtaXNzaW9uXG4gIH1cblxuICB0aGlzLmdldEludmFsaWRFbGVtZW50ID0gKCkgPT4ge1xuICAgIGNvbnN0IGlucHV0RWxlbWVudHMgPSBnZXRJbnB1dEVsZW1lbnRzKClcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbnB1dEVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWlucHV0RWxlbWVudHNbaV0udmFsaWRpdHkudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0RWxlbWVudHNbaV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RFbGVtZW50cyA9IGdldFNlbGVjdEVsZW1lbnRzKClcblxuICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gc2VsZWN0RWxlbWVudHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICBpZiAoIXNlbGVjdEVsZW1lbnRzW2ldLnZhbGlkaXR5LnZhbGlkKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RFbGVtZW50c1tqXVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB0aGlzLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByZXZlbnRzIGVuZGxlc3MgdmFsaWRhdGlvbiBsb29wXG4gICAgZGlzYWJsZUNvbnRhaW5lclZhbGlkYXRpb24gPSB0cnVlXG5cbiAgICBjb25zdCBmb3JtSXNWYWxpZCA9IGZvcm1FbGVtZW50LmNoZWNrVmFsaWRpdHkoKVxuXG4gICAgZGlzYWJsZUNvbnRhaW5lclZhbGlkYXRpb24gPSBmYWxzZVxuXG4gICAgcmV0dXJuIGZvcm1Jc1ZhbGlkXG4gIH1cblxuICB0aGlzLmZpbmRTdWJtaXRCdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZvcm1FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbdHlwZT0nc3VibWl0J11cIilcbiAgfVxuXG4gIHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3JtRWxlbWVudCAmJiBoaWRkZW4oZm9ybUVsZW1lbnQsIHRydWUpXG4gIH1cblxuICB0aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9ybUVsZW1lbnQgJiYgaGlkZGVuKGZvcm1FbGVtZW50LCBmYWxzZSlcbiAgfVxufVxuXG51dGlsLmluaGVyaXRzKEZvcm0sIEV2ZW50RW1pdHRlcilcblxuZXhwb3J0IGRlZmF1bHQgRm9ybVxuIiwiLy8gZW5oYW5jZXMgb3B0aW9ucyB3aXRoIHVzZWZ1bCBmdW5jdGlvbnMgd2UgY2FuIHJldXNlIGV2ZXJ5d2hlcmVcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGFkZEZ1bmN0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgYXVkaW9FbmFibGVkID0gb3B0aW9ucy5hdWRpbyAmJiBvcHRpb25zLmF1ZGlvLmVuYWJsZWRcblxuICAgIG9wdGlvbnMuaGFzRGVmaW5lZEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZGVvLmhlaWdodCAmJiB0aGlzLnZpZGVvLmhlaWdodCAhPT0gJ2F1dG8nXG4gICAgfVxuXG4gICAgb3B0aW9ucy5oYXNEZWZpbmVkV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWRlby53aWR0aCAmJiB0aGlzLnZpZGVvLndpZHRoICE9PSAnYXV0bydcbiAgICB9XG5cbiAgICBvcHRpb25zLmhhc0RlZmluZWREaW1lbnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNEZWZpbmVkV2lkdGgoKSB8fCB0aGlzLmhhc0RlZmluZWRIZWlnaHQoKVxuICAgIH1cblxuICAgIG9wdGlvbnMuaGFzRGVmaW5lZERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNEZWZpbmVkV2lkdGgoKSAmJiB0aGlzLmhhc0RlZmluZWRIZWlnaHQoKVxuICAgIH1cblxuICAgIG9wdGlvbnMuZ2V0UmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmF0aW8gPSAxIC8vIGp1c3QgYSBkZWZhdWx0IG9uZSB3aGVuIG5vIGNvbXB1dGF0aW9ucyBhcmUgcG9zc2libGVcblxuICAgICAgLy8gdG9kbyBmaXggdGhpcywgaXQncyBub3QgcmVhbGx5IGFuIG9wdGlvblxuICAgICAgY29uc3QgaGFzVmlkZW9EaW1lbnNpb25zID0gdGhpcy52aWRlb0hlaWdodCAmJiB0aGlzLnZpZGVvV2lkdGhcblxuICAgICAgaWYgKHRoaXMuaGFzRGVmaW5lZERpbWVuc2lvbnMoKSkge1xuICAgICAgICBpZiAoaGFzVmlkZW9EaW1lbnNpb25zKSB7XG4gICAgICAgICAgLy8gZmlndXJlIG91dCBmaXJzdCB3aGljaCBvbmUgdG8gcGlja1xuICAgICAgICAgIGlmICh0aGlzLnZpZGVvSGVpZ2h0IDwgdGhpcy52aWRlby5oZWlnaHQgfHxcbiAgICAgICAgICAgICAgdGhpcy52aWRlb1dpZHRoIDwgdGhpcy52aWRlby53aWR0aCkge1xuICAgICAgICAgICAgcmF0aW8gPSB0aGlzLnZpZGVvSGVpZ2h0IC8gdGhpcy52aWRlb1dpZHRoXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhdGlvID0gdGhpcy52aWRlby5oZWlnaHQgLyB0aGlzLnZpZGVvLndpZHRoXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhdGlvID0gdGhpcy52aWRlby5oZWlnaHQgLyB0aGlzLnZpZGVvLndpZHRoXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGFzVmlkZW9EaW1lbnNpb25zKSB7XG4gICAgICAgIHJhdGlvID0gdGhpcy52aWRlb0hlaWdodCAvIHRoaXMudmlkZW9XaWR0aFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmF0aW9cbiAgICB9XG5cbiAgICBvcHRpb25zLmlzQXVkaW9FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGF1ZGlvRW5hYmxlZFxuICAgIH1cblxuICAgIG9wdGlvbnMuc2V0QXVkaW9FbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgIGF1ZGlvRW5hYmxlZCA9IGVuYWJsZWRcbiAgICB9XG5cbiAgICBvcHRpb25zLmlzQXV0b1BhdXNlRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuYWJsZUF1dG9QYXVzZSAmJiB0aGlzLmVuYWJsZVBhdXNlXG4gICAgfVxuICB9LFxuXG4gIC8vIG5vdCB2ZXJ5IGVsZWdhbnQgYnV0IHdvcmtzISBhbmQgaWYgeW91IGhlcmUgYXJlIHJlYWRpbmcgdGhpcywgYW5kXG4gIC8vIHN0YXJ0IHRvIGRvdWJ0LCByZXN0IGFzc3VyZWQsIGl0J3Mgc29saWQgYW5kIHJ1biB0aG91c2FuZCB0aW1lcyBvdmVyXG4gIC8vIGFuZCBvdmVyIGFnYWluIGVhY2ggZGF5LiBhbmQgb3RoZXIgbGFyZ2Ugc2l0ZXMgb3V0IHRoZXJlIGhhdmUgdGhlaXIgb3duXG4gIC8vIHRlY2ggZGVidHMuIGhvcGUgaSBoYXZlIHNoYXR0ZXJlZCB5b3VyIGlsbHVzaW9uIG9uIHBlcmZlY3Rpb24/XG4gIG1lcmdlOiBmdW5jdGlvbiAoZGVmYXVsdE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gZGVlcG1lcmdlKGRlZmF1bHRPcHRpb25zLCBuZXdPcHRpb25zLCB7XG4gICAgICBhcnJheU1lcmdlOiBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHNvdXJjZSkgeyByZXR1cm4gc291cmNlIH1cbiAgICB9KVxuXG4gICAgdGhpcy5hZGRGdW5jdGlvbnMob3B0aW9ucylcblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cbn1cbiIsImltcG9ydCB1dGlsIGZyb20gJ3V0aWwnXG5pbXBvcnQgaCBmcm9tICdoeXBlcnNjcmlwdCdcbmltcG9ydCBoaWRkZW4gZnJvbSAnaGlkZGVuJ1xuXG5pbXBvcnQgUmVwbGF5IGZyb20gJy4vdmlzdWFscy9yZXBsYXknXG5pbXBvcnQgUmVjb3JkZXIgZnJvbSAnLi92aXN1YWxzL3JlY29yZGVyJ1xuaW1wb3J0IE5vdGlmaWVyIGZyb20gJy4vdmlzdWFscy9ub3RpZmllcidcbmltcG9ydCBSZWNvcmRlckluc2lkZXMgZnJvbSAnLi92aXN1YWxzL2luc2lkZS9yZWNvcmRlckluc2lkZXMnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi8uLi91dGlsL2V2ZW50RW1pdHRlcidcbmltcG9ydCBFdmVudHMgZnJvbSAnLi8uLi9ldmVudHMnXG5cbmNvbnN0IFZpc3VhbHMgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMsIG9wdGlvbnMsICdWaXN1YWxzJylcblxuICBjb25zdCBzZWxmID0gdGhpc1xuXG4gIC8vIGNhbiBiZSBvdmVyd3JpdHRlbiB3aXRoIHNldHRlciBmblxuICB2YXIgcmVwbGF5ID0gbmV3IFJlcGxheSh0aGlzLCBvcHRpb25zKVxuXG4gIGNvbnN0IHJlY29yZGVyID0gbmV3IFJlY29yZGVyKHRoaXMsIHJlcGxheSwgb3B0aW9ucylcbiAgY29uc3QgcmVjb3JkZXJJbnNpZGVzID0gbmV3IFJlY29yZGVySW5zaWRlcyh0aGlzLCBvcHRpb25zKVxuXG4gIGNvbnN0IG5vdGlmaWVyID0gbmV3IE5vdGlmaWVyKHRoaXMsIG9wdGlvbnMpXG5cbiAgY29uc3QgZGVidWcgPSBvcHRpb25zLmRlYnVnXG5cbiAgdmFyIHZpc3VhbHNFbGVtZW50XG4gIHZhciBidWlsdFxuXG4gIGZ1bmN0aW9uIGJ1aWxkTm9TY3JpcHRUYWcgKCkge1xuICAgIHZhciBub1NjcmlwdEVsZW1lbnQgPSBjb250YWluZXIucXVlcnlTZWxlY3Rvcignbm9zY3JpcHQnKVxuXG4gICAgaWYgKCFub1NjcmlwdEVsZW1lbnQpIHtcbiAgICAgIG5vU2NyaXB0RWxlbWVudCA9IGgoJ25vc2NyaXB0JylcbiAgICAgIG5vU2NyaXB0RWxlbWVudC5pbm5lckhUTUwgPSAnUGxlYXNlIGVuYWJsZSBKYXZhc2NyaXB0J1xuXG4gICAgICB2aXN1YWxzRWxlbWVudC5hcHBlbmRDaGlsZChub1NjcmlwdEVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRDaGlsZHJlbiAoKSB7XG4gICAgZGVidWcoJ1Zpc3VhbHM6IGJ1aWxkQ2hpbGRyZW4oKScpXG5cbiAgICBidWlsZE5vU2NyaXB0VGFnKClcblxuICAgIGlmICghb3B0aW9ucy5wbGF5ZXJPbmx5KSB7XG4gICAgICBub3RpZmllci5idWlsZCgpXG4gICAgICByZWNvcmRlckluc2lkZXMuYnVpbGQoKVxuICAgIH1cblxuICAgIHJlcGxheS5idWlsZCgpXG5cbiAgICBkZWJ1ZygnVmlzdWFsczogYnVpbHQuJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRFdmVudHMgKCkge1xuICAgIGlmICghb3B0aW9ucy5wbGF5ZXJPbmx5KSB7XG4gICAgICBkZWJ1ZygnVmlzdWFsczogaW5pdEV2ZW50cygpJylcblxuICAgICAgc2VsZlxuICAgICAgICAub24oRXZlbnRzLlVTRVJfTUVESUFfUkVBRFksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBidWlsdCA9IHRydWVcbiAgICAgICAgICBzZWxmLmVuZFdhaXRpbmcoKVxuICAgICAgICAgIGNvbnRhaW5lci5lbmFibGVGb3JtKGZhbHNlKVxuICAgICAgICB9KVxuICAgICAgICAub24oRXZlbnRzLlBSRVZJRVcsICgpID0+IHtcbiAgICAgICAgICBzZWxmLmVuZFdhaXRpbmcoKVxuICAgICAgICB9KVxuICAgICAgICAub24oRXZlbnRzLkJMT0NLSU5HLCBmdW5jdGlvbiAoYmxvY2tpbmdPcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFibG9ja2luZ09wdGlvbnMuaGlkZUZvcm0gJiYgIW9wdGlvbnMuYWRqdXN0Rm9ybU9uQnJvd3NlckVycm9yKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nLCB1c2VyIHN0aWxsIGNhbiBlbnRlciBmb3JtIGlucHV0c1xuICAgICAgICAgICAgLy8gY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBhcmUgb24gaS5FLiBzZWVmbG93J3MgY29udGFjdCBwYWdlIGFuZFxuICAgICAgICAgICAgLy8gc3RpbGwgd2FudCB0byB0aWNrIG9mZiB0aGUgd2ViY2FtIG9wdGlvblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXIuZGlzYWJsZUZvcm0odHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihFdmVudHMuUFJFVklFV19TSE9XTiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci52YWxpZGF0ZSh0cnVlKVxuICAgICAgICB9KVxuICAgICAgICAub24oRXZlbnRzLkxPQURFRF9NRVRBX0RBVEEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb3JyZWN0RGltZW5zaW9ucygpXG4gICAgICAgIH0pXG4gICAgICAgIC5vbihFdmVudHMuRVJST1IsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyLnJlbW92ZURpbWVuc2lvbnMgJiYgZXJyLnJlbW92ZURpbWVuc2lvbnMoKSkge1xuICAgICAgICAgICAgcmVtb3ZlRGltZW5zaW9ucygpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcnJlY3REaW1lbnNpb25zICgpIHtcbiAgICB2aXN1YWxzRWxlbWVudC5zdHlsZS53aWR0aCA9IHNlbGYuZ2V0UmVjb3JkZXJXaWR0aCh0cnVlKSArICdweCdcbiAgICB2aXN1YWxzRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBzZWxmLmdldFJlY29yZGVySGVpZ2h0KHRydWUpICsgJ3B4J1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRGltZW5zaW9ucyAoKSB7XG4gICAgdmlzdWFsc0VsZW1lbnQuc3R5bGUud2lkdGggPSAnYXV0bydcbiAgICB2aXN1YWxzRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnYXV0bydcbiAgfVxuXG4gIHRoaXMuZ2V0UmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZpc3VhbHNFbGVtZW50LmNsaWVudFdpZHRoKSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHNhZmFyaSwgc2VlIGdldFJhdGlvKCkgaW4gcmVjb3JkZXJcbiAgICAgIHJldHVybiB2aXN1YWxzRWxlbWVudC5jbGllbnRIZWlnaHQgLyB2aXN1YWxzRWxlbWVudC5jbGllbnRXaWR0aFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVjb3JkYWJsZSAoKSB7XG4gICAgcmV0dXJuICFzZWxmLmlzTm90aWZ5aW5nKCkgJiYgIXJlcGxheS5pc1Nob3duKCkgJiYgIXNlbGYuaXNDb3VudGluZ0Rvd24oKVxuICB9XG5cbiAgdGhpcy5pc0NvdW50aW5nRG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVjb3JkZXJJbnNpZGVzLmlzQ291bnRpbmdEb3duKClcbiAgfVxuXG4gIHRoaXMuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmlzdWFsc0VsZW1lbnQgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLicgKyBvcHRpb25zLnNlbGVjdG9ycy52aXN1YWxzQ2xhc3MpXG5cbiAgICBpZiAoIXZpc3VhbHNFbGVtZW50KSB7XG4gICAgICB2aXN1YWxzRWxlbWVudCA9IGgoJ2Rpdi4nICsgb3B0aW9ucy5zZWxlY3RvcnMudmlzdWFsc0NsYXNzKVxuXG4gICAgICBjb25zdCBidXR0b25zRWxlbWVudCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuJyArIG9wdGlvbnMuc2VsZWN0b3JzLmJ1dHRvbnNDbGFzcylcblxuICAgICAgLy8gbWFrZSBzdXJlIGl0J3MgcGxhY2VkIGJlZm9yZSB0aGUgYnV0dG9ucywgYnV0IG9ubHkgaWYgaXQncyBhIGNoaWxkXG4gICAgICAvLyBlbGVtZW50IG9mIHRoZSBjb250YWluZXIgPSBpbnNpZGUgdGhlIGNvbnRhaW5lclxuICAgICAgaWYgKGJ1dHRvbnNFbGVtZW50ICYmICFjb250YWluZXIuaXNPdXRzaWRlRWxlbWVudE9mKGJ1dHRvbnNFbGVtZW50KSkge1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHZpc3VhbHNFbGVtZW50LCBidXR0b25zRWxlbWVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh2aXN1YWxzRWxlbWVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkbyBub3QgaGlkZSB2aXN1YWxzIGVsZW1lbnQgc28gdGhhdCBhcHBzIGNhbiBnaXZlIGl0IGEgcHJlZGVmaW5lZFxuICAgIC8vIHdpZHRoIG9yIGhlaWdodCB0aHJvdWdoIGNzcyBidXQgaGlkZSBhbGwgY2hpbGRyZW5cblxuICAgIHZpc3VhbHNFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Zpc3VhbHMnKVxuXG4gICAgY29ycmVjdERpbWVuc2lvbnMoKVxuXG4gICAgIWJ1aWx0ICYmIGluaXRFdmVudHMoKVxuICAgIGJ1aWxkQ2hpbGRyZW4oKVxuXG4gICAgLy8gbmVlZGVkIGZvciByZXBsYXkgaGFuZGxpbmcgYW5kIGNvbnRhaW5lci5pc091dHNpZGVFbGVtZW50T2YoKVxuICAgIHNlbGYucGFyZW50Tm9kZSA9IHZpc3VhbHNFbGVtZW50LnBhcmVudE5vZGVcblxuICAgIGJ1aWx0ID0gdHJ1ZVxuICB9XG5cbiAgdGhpcy5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHZpc3VhbHNFbGVtZW50ICYmIHZpc3VhbHNFbGVtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gIH1cblxuICB0aGlzLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmlzdWFsc0VsZW1lbnQgJiYgdmlzdWFsc0VsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG4gIH1cblxuICB0aGlzLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmlzdWFsc0VsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGQpXG4gIH1cblxuICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5kV2FpdGluZygpXG4gICAgcmVjb3JkZXIucmVzZXQoKVxuICB9XG5cbiAgdGhpcy5iZWdpbldhaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29udGFpbmVyLmJlZ2luV2FpdGluZygpXG4gIH1cblxuICB0aGlzLmVuZFdhaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29udGFpbmVyLmVuZFdhaXRpbmcoKVxuICB9XG5cbiAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHJlY29yZGVyLnN0b3AocGFyYW1zKVxuICAgIHJlY29yZGVySW5zaWRlcy5oaWRlUGF1c2UoKVxuICB9XG5cbiAgdGhpcy5iYWNrID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICBpZiAoIWNiICYmIHBhcmFtcykge1xuICAgICAgY2IgPSBwYXJhbXNcbiAgICAgIHBhcmFtcyA9IHt9XG4gICAgfVxuXG4gICAgcmVwbGF5LmhpZGUoKVxuICAgIG5vdGlmaWVyLmhpZGUoKVxuXG4gICAgaWYgKHBhcmFtcy5rZWVwSGlkZGVuKSB7XG4gICAgICByZWNvcmRlci5oaWRlKClcbiAgICAgIGNiICYmIGNiKClcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb3JkZXIuYmFjayhjYilcbiAgICB9XG4gIH1cblxuICB0aGlzLnJlY29yZEFnYWluID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLm9uY2UoRXZlbnRzLlVTRVJfTUVESUFfUkVBRFksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5yZWNvcmQoKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdGhpcy51bmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHRyeSB7XG4gICAgICByZWNvcmRlci51bmxvYWQoZSlcbiAgICAgIHJlY29yZGVySW5zaWRlcy51bmxvYWQoZSlcbiAgICAgIHJlcGxheS51bmxvYWQoZSlcblxuICAgICAgYnVpbHQgPSBmYWxzZVxuICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgdGhpcy5lbWl0KEV2ZW50cy5FUlJPUiwgZXhjKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaXNOb3RpZnlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5vdGlmaWVyLmlzVmlzaWJsZSgpXG4gIH1cblxuICB0aGlzLmlzUmVwbGF5U2hvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlcGxheS5pc1Nob3duKClcbiAgfVxuXG4gIHRoaXMucGF1c2UgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgcmVjb3JkZXIucGF1c2UocGFyYW1zKVxuICAgIHJlY29yZGVySW5zaWRlcy5zaG93UGF1c2UoKVxuICB9XG5cbiAgdGhpcy5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlY29yZGVySW5zaWRlcy5pc0NvdW50aW5nRG93bigpKSB7XG4gICAgICByZWNvcmRlckluc2lkZXMucmVzdW1lQ291bnRkb3duKClcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb3JkZXIucmVzdW1lKClcbiAgICB9XG5cbiAgICByZWNvcmRlckluc2lkZXMuaGlkZVBhdXNlKClcbiAgfVxuXG4gIHRoaXMucGF1c2VPclJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNSZWNvcmRhYmxlLmNhbGwodGhpcykpIHtcbiAgICAgIGlmICh0aGlzLmlzUmVjb3JkaW5nKCkpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpXG4gICAgICB9IGVsc2UgaWYgKHJlY29yZGVyLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5yZXN1bWUoKVxuICAgICAgfSBlbHNlIGlmIChyZWNvcmRlci5pc1JlYWR5KCkpIHtcbiAgICAgICAgdGhpcy5yZWNvcmQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMucmVjb3JkT3JTdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc1JlY29yZGFibGUoKSkge1xuICAgICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcoKSkge1xuICAgICAgICB0aGlzLnN0b3AoKVxuICAgICAgfSBlbHNlIGlmIChyZWNvcmRlci5pc1JlYWR5KCkpIHtcbiAgICAgICAgdGhpcy5yZWNvcmQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMucmVjb3JkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcHRpb25zLnZpZGVvLmNvdW50ZG93bikge1xuICAgICAgdGhpcy5lbWl0KEV2ZW50cy5DT1VOVERPV04pXG4gICAgICByZWNvcmRlckluc2lkZXMuc3RhcnRDb3VudGRvd24ocmVjb3JkZXIucmVjb3JkLmJpbmQocmVjb3JkZXIpKVxuICAgIH0gZWxzZSB7IHJlY29yZGVyLnJlY29yZCgpIH1cbiAgfVxuXG4gIHRoaXMuZ2V0UmVjb3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlY29yZGVyXG4gIH1cblxuICB0aGlzLmdldFJlcGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVwbGF5XG4gIH1cblxuICB0aGlzLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWNvcmRlci52YWxpZGF0ZSgpICYmIHRoaXMuaXNSZXBsYXlTaG93bigpXG4gIH1cblxuICB0aGlzLmdldFJlY29yZGluZ1N0YXRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWNvcmRlci5nZXRSZWNvcmRpbmdTdGF0cygpXG4gIH1cblxuICB0aGlzLmdldEF1ZGlvU2FtcGxlUmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVjb3JkZXIuZ2V0QXVkaW9TYW1wbGVSYXRlKClcbiAgfVxuXG4gIHRoaXMuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlY29yZGVyLmlzUGF1c2VkKClcbiAgfVxuXG4gIHRoaXMuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgbm90aWZpZXIuZXJyb3IoZXJyKVxuICB9XG5cbiAgdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh2aXN1YWxzRWxlbWVudCkge1xuICAgICAgaGlkZGVuKHZpc3VhbHNFbGVtZW50LCB0cnVlKVxuICAgICAgdGhpcy5lbWl0KEV2ZW50cy5ISURFKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaXNIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFidWlsdCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKHZpc3VhbHNFbGVtZW50KSB7XG4gICAgICByZXR1cm4gaGlkZGVuKHZpc3VhbHNFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuc2hvd1Zpc3VhbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmlzdWFsc0VsZW1lbnQgJiYgaGlkZGVuKHZpc3VhbHNFbGVtZW50LCBmYWxzZSlcbiAgfVxuXG4gIHRoaXMuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAhdGhpcy5pc1JlcGxheVNob3duKCkgJiYgdmlzdWFsc0VsZW1lbnQgJiYgcmVjb3JkZXIuYnVpbGQoKVxuICAgIHRoaXMuc2hvd1Zpc3VhbHMoKVxuICB9XG5cbiAgdGhpcy5zaG93UmVwbGF5T25seSA9IGZ1bmN0aW9uICgpIHtcbiAgICAhdGhpcy5pc1JlcGxheVNob3duKCkgJiYgcmVwbGF5LnNob3coKVxuXG4gICAgdGhpcy5zaG93KClcbiAgICByZWNvcmRlci5oaWRlKClcbiAgICBub3RpZmllci5oaWRlKClcbiAgfVxuXG4gIHRoaXMuaXNSZWNvcmRlclVubG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWNvcmRlci5pc1VubG9hZGVkKClcbiAgfVxuXG4gIHRoaXMuaXNDb25uZWN0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWNvcmRlci5pc0Nvbm5lY3RpbmcoKVxuICB9XG5cbiAgdGhpcy5nZXRSZWNvcmRlcldpZHRoID0gZnVuY3Rpb24gKHJlc3BvbnNpdmUpIHtcbiAgICByZXR1cm4gcmVjb3JkZXIuZ2V0UmVjb3JkZXJXaWR0aChyZXNwb25zaXZlKVxuICB9XG5cbiAgdGhpcy5nZXRSZWNvcmRlckhlaWdodCA9IGZ1bmN0aW9uIChyZXNwb25zaXZlKSB7XG4gICAgcmV0dXJuIHJlY29yZGVyLmdldFJlY29yZGVySGVpZ2h0KHJlc3BvbnNpdmUpXG4gIH1cblxuICB0aGlzLmxpbWl0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmxpbWl0V2lkdGgod2lkdGgsIG9wdGlvbnMpXG4gIH1cblxuICB0aGlzLmxpbWl0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgIHJldHVybiBjb250YWluZXIubGltaXRIZWlnaHQoaGVpZ2h0KVxuICB9XG5cbiAgdGhpcy5jYWxjdWxhdGVXaWR0aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5jYWxjdWxhdGVXaWR0aChvcHRpb25zKVxuICB9XG5cbiAgdGhpcy5jYWxjdWxhdGVIZWlnaHQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBjb250YWluZXIuY2FsY3VsYXRlSGVpZ2h0KG9wdGlvbnMpXG4gIH1cblxuICB0aGlzLmdldFJlcGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVwbGF5XG4gIH1cblxuICB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwtY2xpZW50L2lzc3Vlcy8xMjZcbiAgICByZXR1cm4gdmlzdWFsc0VsZW1lbnQgJiYgdmlzdWFsc0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgfVxuXG4gIHRoaXMuY2hlY2tUaW1lciA9IGZ1bmN0aW9uIChpbnRlcnZhbFN1bSkge1xuICAgIHJlY29yZGVySW5zaWRlcy5jaGVja1RpbWVyKGludGVydmFsU3VtKVxuICB9XG5cbiAgdGhpcy5pc05vdGlmaWVyQnVpbHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5vdGlmaWVyICYmIG5vdGlmaWVyLmlzQnVpbHQoKVxuICB9XG5cbiAgdGhpcy5pc1JlcGxheVNob3duID0gcmVwbGF5LmlzU2hvd24uYmluZChyZXBsYXkpXG4gIHRoaXMuaGlkZVJlcGxheSA9IHJlcGxheS5oaWRlLmJpbmQocmVwbGF5KVxuICB0aGlzLmhpZGVSZWNvcmRlciA9IHJlY29yZGVyLmhpZGUuYmluZChyZWNvcmRlcilcbiAgdGhpcy5pc1JlY29yZGluZyA9IHJlY29yZGVyLmlzUmVjb3JkaW5nLmJpbmQocmVjb3JkZXIpXG4gIHRoaXMuaXNVc2VyTWVkaWFMb2FkZWQgPSByZWNvcmRlci5pc1VzZXJNZWRpYUxvYWRlZC5iaW5kKHJlY29yZGVyKVxuICB0aGlzLmlzQ29ubmVjdGVkID0gcmVjb3JkZXIuaXNDb25uZWN0ZWQuYmluZChyZWNvcmRlcilcbn1cblxudXRpbC5pbmhlcml0cyhWaXN1YWxzLCBFdmVudEVtaXR0ZXIpXG5cbmV4cG9ydCBkZWZhdWx0IFZpc3VhbHNcbiIsImltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IGhpZGRlbiBmcm9tICdoaWRkZW4nXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICh2aXN1YWxzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgdmFyIGNvdW50ZG93bkVsZW1lbnRcbiAgdmFyIGludGVydmFsSWRcbiAgdmFyIGNvdW50ZG93blxuICB2YXIgcGF1c2VkXG5cbiAgZnVuY3Rpb24gZmlyZSAoY2IpIHtcbiAgICBzZWxmLnVubG9hZCgpXG4gICAgc2VsZi5oaWRlKClcblxuICAgIC8vIGtlZXAgYWxsIGNhbGxiYWNrcyBhc3luY1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2IoKVxuICAgIH0sIDApXG4gIH1cblxuICBmdW5jdGlvbiBjb3VudEJhY2t3YXJkIChjYikge1xuICAgIGlmICghcGF1c2VkKSB7XG4gICAgICBvcHRpb25zLmRlYnVnKCdDb3VudGRvd24nLCBjb3VudGRvd24pXG4gICAgICBjb3VudGRvd24tLVxuXG4gICAgICBpZiAoY291bnRkb3duIDwgMSkge1xuICAgICAgICBmaXJlKGNiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5pbm5lckhUTUwgPSBjb3VudGRvd25cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgY291bnRkb3duRWxlbWVudC5pbm5lckhUTUwgPSBjb3VudGRvd24gPSBvcHRpb25zLnZpZGVvLmNvdW50ZG93blxuXG4gICAgdGhpcy5zaG93KClcblxuICAgIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChjb3VudEJhY2t3YXJkLmJpbmQodGhpcywgY2IpLCA5NTApXG4gIH1cblxuICB0aGlzLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHBhdXNlZCA9IHRydWVcbiAgfVxuXG4gIHRoaXMucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlXG4gIH1cblxuICB0aGlzLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgIGNvdW50ZG93bkVsZW1lbnQgPSB2aXN1YWxzLnF1ZXJ5U2VsZWN0b3IoJy5jb3VudGRvd24nKVxuXG4gICAgaWYgKCFjb3VudGRvd25FbGVtZW50KSB7XG4gICAgICBjb3VudGRvd25FbGVtZW50ID0gaCgncC5jb3VudGRvd24nKVxuXG4gICAgICB0aGlzLmhpZGUoKVxuXG4gICAgICB2aXN1YWxzLmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGhpZGRlbihjb3VudGRvd25FbGVtZW50LCBmYWxzZSlcbiAgfVxuXG4gIHRoaXMuaXNDb3VudGluZ0Rvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhaW50ZXJ2YWxJZFxuICB9XG5cbiAgdGhpcy51bmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKVxuICAgIHBhdXNlZCA9IGZhbHNlXG4gICAgaW50ZXJ2YWxJZCA9IG51bGxcbiAgfVxuXG4gIHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBoaWRkZW4oY291bnRkb3duRWxlbWVudCwgdHJ1ZSlcbiAgICB0aGlzLnVubG9hZCgpXG4gIH1cbn1cbiIsImltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IGhpZGRlbiBmcm9tICdoaWRkZW4nXG5cbmltcG9ydCBFdmVudHMgZnJvbSAnLi8uLi8uLi8uLi8uLi9ldmVudHMnXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vLi4vLi4vLi4vLi4vdXRpbC9ldmVudEVtaXR0ZXInXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICh2aXN1YWxzLCBvcHRpb25zKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMsIG9wdGlvbnMsICdGYWNpbmcgTW9kZScpXG5cbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgdmFyIGZhY2luZ01vZGVFbGVtZW50XG5cbiAgZnVuY3Rpb24gaW5pdEV2ZW50cyAoKSB7XG4gICAgc2VsZi5vbihFdmVudHMuRVJST1IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuaGlkZSgpXG4gICAgfSlcbiAgfVxuXG4gIHRoaXMuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZmFjaW5nTW9kZUVsZW1lbnQgPSB2aXN1YWxzLnF1ZXJ5U2VsZWN0b3IoJy5mYWNpbmdNb2RlJylcblxuICAgIGlmICghZmFjaW5nTW9kZUVsZW1lbnQpIHtcbiAgICAgIGZhY2luZ01vZGVFbGVtZW50ID0gaCgnYnV0dG9uLmZhY2luZ01vZGUnKVxuICAgICAgZmFjaW5nTW9kZUVsZW1lbnQuaW5uZXJIVE1MID0gJ+KkvidcblxuICAgICAgZmFjaW5nTW9kZUVsZW1lbnQub25jbGljayA9IChlKSA9PiB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZWxmLmVtaXQoRXZlbnRzLlNXSVRDSF9GQUNJTkdfTU9ERSlcbiAgICAgICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXhjKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGlkZSgpXG5cbiAgICAgIHZpc3VhbHMuYXBwZW5kQ2hpbGQoZmFjaW5nTW9kZUVsZW1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgfVxuXG4gICAgaW5pdEV2ZW50cygpXG4gIH1cblxuICB0aGlzLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaGlkZGVuKGZhY2luZ01vZGVFbGVtZW50LCB0cnVlKVxuICB9XG5cbiAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGhpZGRlbihmYWNpbmdNb2RlRWxlbWVudCwgZmFsc2UpXG4gIH1cbn1cbiIsImltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IGhpZGRlbiBmcm9tICdoaWRkZW4nXG5cbmltcG9ydCBWaWRlb21haWxFcnJvciBmcm9tICcuLy4uLy4uLy4uLy4uL3V0aWwvdmlkZW9tYWlsRXJyb3InXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICh2aXN1YWxzLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucy50ZXh0LnBhdXNlZEhlYWRlcikge1xuICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnUGF1c2VkIGhlYWRlciBjYW5ub3QgYmUgZW1wdHknLCBvcHRpb25zKVxuICB9XG5cbiAgdmFyIHBhdXNlZEJsb2NrRWxlbWVudFxuICB2YXIgcGF1c2VkSGVhZGVyRWxlbWVudFxuICB2YXIgcGF1c2VkSGludEVsZW1lbnRcblxuICBmdW5jdGlvbiBoYXNQYXVzZWRIaW50ICgpIHtcbiAgICByZXR1cm4gb3B0aW9ucy50ZXh0LnBhdXNlZEhpbnRcbiAgfVxuXG4gIHRoaXMuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGF1c2VkQmxvY2tFbGVtZW50ID0gdmlzdWFscy5xdWVyeVNlbGVjdG9yKCcucGF1c2VkJylcbiAgICBwYXVzZWRIZWFkZXJFbGVtZW50ID0gdmlzdWFscy5xdWVyeVNlbGVjdG9yKCcucGF1c2VkSGVhZGVyJylcblxuICAgIGlmICghcGF1c2VkSGVhZGVyRWxlbWVudCkge1xuICAgICAgcGF1c2VkQmxvY2tFbGVtZW50ID0gaCgnZGl2LnBhdXNlZCcpXG4gICAgICBwYXVzZWRIZWFkZXJFbGVtZW50ID0gaCgncC5wYXVzZWRIZWFkZXInKVxuXG4gICAgICB0aGlzLmhpZGUoKVxuXG4gICAgICBwYXVzZWRIZWFkZXJFbGVtZW50LmlubmVySFRNTCA9IG9wdGlvbnMudGV4dC5wYXVzZWRIZWFkZXJcblxuICAgICAgcGF1c2VkQmxvY2tFbGVtZW50LmFwcGVuZENoaWxkKHBhdXNlZEhlYWRlckVsZW1lbnQpXG5cbiAgICAgIGlmIChoYXNQYXVzZWRIaW50KCkpIHtcbiAgICAgICAgcGF1c2VkSGludEVsZW1lbnQgPSB2aXN1YWxzLnF1ZXJ5U2VsZWN0b3IoJy5wYXVzZWRIaW50JylcbiAgICAgICAgcGF1c2VkSGludEVsZW1lbnQgPSBoKCdwLnBhdXNlZEhpbnQnKVxuICAgICAgICBwYXVzZWRIaW50RWxlbWVudC5pbm5lckhUTUwgPSBvcHRpb25zLnRleHQucGF1c2VkSGludFxuICAgICAgICBwYXVzZWRCbG9ja0VsZW1lbnQuYXBwZW5kQ2hpbGQocGF1c2VkSGludEVsZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIHZpc3VhbHMuYXBwZW5kQ2hpbGQocGF1c2VkQmxvY2tFbGVtZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGUoKVxuXG4gICAgICBwYXVzZWRIZWFkZXJFbGVtZW50LmlubmVySFRNTCA9IG9wdGlvbnMudGV4dC5wYXVzZWRIZWFkZXJcblxuICAgICAgaWYgKGhhc1BhdXNlZEhpbnQoKSkge1xuICAgICAgICBwYXVzZWRIaW50RWxlbWVudC5pbm5lckhUTUwgPSBvcHRpb25zLnRleHQucGF1c2VkSGludFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBoaWRkZW4ocGF1c2VkQmxvY2tFbGVtZW50LCB0cnVlKVxuICB9XG5cbiAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGhpZGRlbihwYXVzZWRCbG9ja0VsZW1lbnQsIGZhbHNlKVxuICB9XG59XG4iLCJpbXBvcnQgaCBmcm9tICdoeXBlcnNjcmlwdCdcbmltcG9ydCBoaWRkZW4gZnJvbSAnaGlkZGVuJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAodmlzdWFscykge1xuICB2YXIgcmVjb3JkTm90ZUVsZW1lbnRcblxuICB0aGlzLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgIHJlY29yZE5vdGVFbGVtZW50ID0gdmlzdWFscy5xdWVyeVNlbGVjdG9yKCcucmVjb3JkTm90ZScpXG5cbiAgICBpZiAoIXJlY29yZE5vdGVFbGVtZW50KSB7XG4gICAgICByZWNvcmROb3RlRWxlbWVudCA9IGgoJ3AucmVjb3JkTm90ZScpXG5cbiAgICAgIHRoaXMuaGlkZSgpXG5cbiAgICAgIHZpc3VhbHMuYXBwZW5kQ2hpbGQocmVjb3JkTm90ZUVsZW1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGlkZSgpXG4gICAgcmVjb3JkTm90ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnbmVhcicpXG4gICAgcmVjb3JkTm90ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnbmlnaCcpXG4gIH1cblxuICB0aGlzLnNldE5lYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVjb3JkTm90ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbmVhcicpXG4gIH1cblxuICB0aGlzLnNldE5pZ2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVjb3JkTm90ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbmlnaCcpXG4gIH1cblxuICB0aGlzLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaGlkZGVuKHJlY29yZE5vdGVFbGVtZW50LCB0cnVlKVxuICB9XG5cbiAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGhpZGRlbihyZWNvcmROb3RlRWxlbWVudCwgZmFsc2UpXG4gIH1cbn1cbiIsImltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IGhpZGRlbiBmcm9tICdoaWRkZW4nXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICh2aXN1YWxzLCByZWNvcmROb3RlLCBvcHRpb25zKSB7XG4gIHZhciByZWNvcmRUaW1lckVsZW1lbnRcblxuICB2YXIgbmVhckNvbXB1dGVkID0gZmFsc2VcbiAgdmFyIGVuZE5pZ2hDb21wdXRlZCA9IGZhbHNlXG5cbiAgdmFyIHN0YXJ0ZWRcbiAgdmFyIGNvdW50ZG93blxuXG4gIGZ1bmN0aW9uIHBhZCAobikge1xuICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogblxuICB9XG5cbiAgZnVuY3Rpb24gdGhyZXNob2xkUmVhY2hlZCAoc2VjcywgdGhyZXNob2xkKSB7XG4gICAgcmV0dXJuIHNlY3MgPj0gb3B0aW9ucy52aWRlby5saW1pdFNlY29uZHMgKiB0aHJlc2hvbGRcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTmVhciAoc2Vjcykge1xuICAgIGlmICghbmVhckNvbXB1dGVkICYmIHRocmVzaG9sZFJlYWNoZWQoc2VjcywgMC42KSkge1xuICAgICAgbmVhckNvbXB1dGVkID0gdHJ1ZVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kSXNOaWdoIChzZWNzKSB7XG4gICAgaWYgKCFlbmROaWdoQ29tcHV0ZWQgJiYgdGhyZXNob2xkUmVhY2hlZChzZWNzLCAwLjgpKSB7XG4gICAgICBlbmROaWdoQ29tcHV0ZWQgPSB0cnVlXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXROZWFyICgpIHtcbiAgICByZWNvcmRUaW1lckVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbmVhcicpXG4gIH1cblxuICBmdW5jdGlvbiBzZXROaWdoICgpIHtcbiAgICByZWNvcmRUaW1lckVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbmlnaCcpXG4gIH1cblxuICB0aGlzLmNoZWNrID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBjb25zdCBuZXdDb3VudGRvd24gPSBnZXRTdGFydFNlY29uZHMoKSAtIE1hdGguZmxvb3Iob3B0cy5pbnRlcnZhbFN1bSAvIDFlMylcblxuICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXNhdGlvbiAoYW5vdGhlciByZWFzb24gd2UgbmVlZCByZWFjdCBoZXJlISlcbiAgICBpZiAobmV3Q291bnRkb3duICE9PSBjb3VudGRvd24pIHtcbiAgICAgIGNvdW50ZG93biA9IG5ld0NvdW50ZG93blxuICAgICAgdXBkYXRlKClcbiAgICAgIGNvdW50ZG93biA8IDEgJiYgdmlzdWFscy5zdG9wKHRydWUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgICBjb25zdCBtaW5zID0gcGFyc2VJbnQoY291bnRkb3duIC8gNjAsIDEwKVxuICAgIGNvbnN0IHNlY3MgPSBjb3VudGRvd24gLSBtaW5zICogNjBcblxuICAgIGlmICghbmVhckNvbXB1dGVkIHx8ICFlbmROaWdoQ29tcHV0ZWQpIHtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ1NlY29uZHMgPSBvcHRpb25zLnZpZGVvLmxpbWl0U2Vjb25kcyAtIGNvdW50ZG93blxuXG4gICAgICBpZiAoaXNOZWFyKHJlbWFpbmluZ1NlY29uZHMpKSB7XG4gICAgICAgIHJlY29yZE5vdGUuc2V0TmVhcigpXG4gICAgICAgIHNldE5lYXIoKVxuXG4gICAgICAgIG9wdGlvbnMuZGVidWcoJ0VuZCBpcyBuZWFyLCAnICsgY291bnRkb3duICsgJyBzZWNvbmRzIHRvIGdvJylcbiAgICAgIH0gZWxzZSBpZiAoZW5kSXNOaWdoKHJlbWFpbmluZ1NlY29uZHMpKSB7XG4gICAgICAgIHJlY29yZE5vdGUuc2V0TmlnaCgpXG4gICAgICAgIHNldE5pZ2goKVxuXG4gICAgICAgIG9wdGlvbnMuZGVidWcoJ0VuZCBpcyBuaWdoLCAnICsgY291bnRkb3duICsgJyBzZWNvbmRzIHRvIGdvJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWNvcmRUaW1lckVsZW1lbnQuaW5uZXJIVE1MID0gbWlucyArICc6JyArIHBhZChzZWNzKVxuICB9XG5cbiAgZnVuY3Rpb24gaGlkZSAoKSB7XG4gICAgaGlkZGVuKHJlY29yZFRpbWVyRWxlbWVudCwgdHJ1ZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3cgKCkge1xuICAgIHJlY29yZFRpbWVyRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCduZWFyJylcbiAgICByZWNvcmRUaW1lckVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnbmlnaCcpXG5cbiAgICBoaWRkZW4ocmVjb3JkVGltZXJFbGVtZW50LCBmYWxzZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlY29uZHNSZWNvcmRlZCAoKSB7XG4gICAgcmV0dXJuIGdldFN0YXJ0U2Vjb25kcygpIC0gY291bnRkb3duXG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdGFydFNlY29uZHMgKCkge1xuICAgIHJldHVybiBvcHRpb25zLnZpZGVvLmxpbWl0U2Vjb25kc1xuICB9XG5cbiAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb3VudGRvd24gPSBnZXRTdGFydFNlY29uZHMoKVxuICAgIG5lYXJDb21wdXRlZCA9IGVuZE5pZ2hDb21wdXRlZCA9IGZhbHNlXG4gICAgc3RhcnRlZCA9IHRydWVcblxuICAgIHVwZGF0ZSgpXG5cbiAgICBzaG93KClcbiAgfVxuXG4gIHRoaXMucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVjb3JkTm90ZS5oaWRlKClcbiAgfVxuXG4gIHRoaXMucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJlY29yZE5vdGUuc2hvdygpXG4gIH1cblxuICBmdW5jdGlvbiBpc1N0b3BwZWQgKCkge1xuICAgIHJldHVybiBjb3VudGRvd24gPT09IG51bGxcbiAgfVxuXG4gIHRoaXMuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzU3RvcHBlZCgpICYmIHN0YXJ0ZWQpIHtcbiAgICAgIG9wdGlvbnMuZGVidWcoJ1N0b3BwaW5nIHJlY29yZCB0aW1lci4gV2FzIHJlY29yZGluZyBmb3IgYWJvdXQgficgKyBnZXRTZWNvbmRzUmVjb3JkZWQoKSArICcgc2Vjb25kcy4nKVxuXG4gICAgICBoaWRlKClcbiAgICAgIHJlY29yZE5vdGUuc3RvcCgpXG5cbiAgICAgIGNvdW50ZG93biA9IG51bGxcbiAgICAgIHN0YXJ0ZWQgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVjb3JkVGltZXJFbGVtZW50ID0gdmlzdWFscy5xdWVyeVNlbGVjdG9yKCcucmVjb3JkVGltZXInKVxuXG4gICAgaWYgKCFyZWNvcmRUaW1lckVsZW1lbnQpIHtcbiAgICAgIHJlY29yZFRpbWVyRWxlbWVudCA9IGgoJ3AucmVjb3JkVGltZXInKVxuXG4gICAgICBoaWRlKClcblxuICAgICAgdmlzdWFscy5hcHBlbmRDaGlsZChyZWNvcmRUaW1lckVsZW1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGUoKVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHV0aWwgZnJvbSAndXRpbCdcblxuaW1wb3J0IEV2ZW50cyBmcm9tICcuLy4uLy4uLy4uL2V2ZW50cydcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi8uLi8uLi8uLi91dGlsL2V2ZW50RW1pdHRlcidcbmltcG9ydCBCcm93c2VyIGZyb20gJy4vLi4vLi4vLi4vdXRpbC9icm93c2VyJ1xuXG5pbXBvcnQgQ291bnRkb3duIGZyb20gJy4vcmVjb3JkZXIvY291bnRkb3duJ1xuaW1wb3J0IFBhdXNlZE5vdGUgZnJvbSAnLi9yZWNvcmRlci9wYXVzZWROb3RlJ1xuaW1wb3J0IFJlY29yZE5vdGUgZnJvbSAnLi9yZWNvcmRlci9yZWNvcmROb3RlJ1xuaW1wb3J0IFJlY29yZFRpbWVyIGZyb20gJy4vcmVjb3JkZXIvcmVjb3JkVGltZXInXG5pbXBvcnQgRmFjaW5nTW9kZSBmcm9tICcuL3JlY29yZGVyL2ZhY2luZ01vZGUnXG5cbmNvbnN0IFJlY29yZGVySW5zaWRlcyA9IGZ1bmN0aW9uICh2aXN1YWxzLCBvcHRpb25zKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMsIG9wdGlvbnMsICdSZWNvcmRlckluc2lkZXMnKVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGNvbnN0IGRlYnVnID0gb3B0aW9ucy5kZWJ1Z1xuXG4gIGNvbnN0IHJlY29yZE5vdGUgPSBuZXcgUmVjb3JkTm90ZSh2aXN1YWxzKVxuICBjb25zdCByZWNvcmRUaW1lciA9IG5ldyBSZWNvcmRUaW1lcih2aXN1YWxzLCByZWNvcmROb3RlLCBvcHRpb25zKVxuICBjb25zdCBicm93c2VyID0gbmV3IEJyb3dzZXIob3B0aW9ucylcblxuICB2YXIgY291bnRkb3duXG4gIHZhciBwYXVzZWROb3RlXG4gIHZhciBidWlsdFxuICB2YXIgZmFjaW5nTW9kZVxuXG4gIGlmIChvcHRpb25zLnZpZGVvLmNvdW50ZG93bikge1xuICAgIGNvdW50ZG93biA9IG5ldyBDb3VudGRvd24odmlzdWFscywgb3B0aW9ucylcbiAgfVxuXG4gIGlmIChvcHRpb25zLnZpZGVvLmZhY2luZ01vZGVCdXR0b24gJiYgYnJvd3Nlci5pc01vYmlsZSgpKSB7XG4gICAgZmFjaW5nTW9kZSA9IG5ldyBGYWNpbmdNb2RlKHZpc3VhbHMsIG9wdGlvbnMpXG4gIH1cblxuICBpZiAob3B0aW9ucy5lbmFibGVQYXVzZSkge1xuICAgIHBhdXNlZE5vdGUgPSBuZXcgUGF1c2VkTm90ZSh2aXN1YWxzLCBvcHRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRSZWNvcmRpbmcgKCkge1xuICAgIHJlY29yZFRpbWVyLnN0YXJ0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3VtZVJlY29yZGluZyAoKSB7XG4gICAgcmVjb3JkVGltZXIucmVzdW1lKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3BSZWNvcmRpbmcgKCkge1xuICAgIHJlY29yZFRpbWVyLnN0b3AoKVxuICB9XG5cbiAgZnVuY3Rpb24gcGF1c2VSZWNvcmRpbmcgKCkge1xuICAgIGlmIChzZWxmLmlzQ291bnRpbmdEb3duKCkpIHtcbiAgICAgIGNvdW50ZG93bi5wYXVzZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29yZFRpbWVyLnBhdXNlKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblJlc2V0dGluZyAoKSB7XG4gICAgc2VsZi5oaWRlUGF1c2UoKVxuICAgIHNlbGYuaGlkZUNvdW50ZG93bigpXG4gICAgcmVjb3JkVGltZXIuc3RvcCgpXG4gICAgZmFjaW5nTW9kZSAmJiBmYWNpbmdNb2RlLmhpZGUoKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEV2ZW50cyAoKSB7XG4gICAgZGVidWcoJ1JlY29yZGVySW5zaWRlczogaW5pdEV2ZW50cygpJylcblxuICAgIHNlbGZcbiAgICAgIC5vbihFdmVudHMuVVNFUl9NRURJQV9SRUFEWSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmYWNpbmdNb2RlICYmIGZhY2luZ01vZGUuc2hvdygpXG4gICAgICB9KVxuICAgICAgLm9uKEV2ZW50cy5SRUNPUkRJTkcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RhcnRSZWNvcmRpbmcoKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuUkVTVU1JTkcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzdW1lUmVjb3JkaW5nKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLlNUT1BQSU5HLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0b3BSZWNvcmRpbmcoKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuUEFVU0VELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhdXNlUmVjb3JkaW5nKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLlJFU0VUVElORywgb25SZXNldHRpbmcpXG4gICAgICAub24oRXZlbnRzLkhJREUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5oaWRlQ291bnRkb3duKClcbiAgICAgIH0pXG4gIH1cblxuICB0aGlzLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCdSZWNvcmRlckluc2lkZXM6IGJ1aWxkKCknKVxuXG4gICAgY291bnRkb3duICYmIGNvdW50ZG93bi5idWlsZCgpXG4gICAgcGF1c2VkTm90ZSAmJiBwYXVzZWROb3RlLmJ1aWxkKClcbiAgICBmYWNpbmdNb2RlICYmIGZhY2luZ01vZGUuYnVpbGQoKVxuXG4gICAgcmVjb3JkTm90ZS5idWlsZCgpXG4gICAgcmVjb3JkVGltZXIuYnVpbGQoKVxuXG4gICAgIWJ1aWx0ICYmIGluaXRFdmVudHMoKVxuXG4gICAgYnVpbHQgPSB0cnVlXG4gIH1cblxuICB0aGlzLnVubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb3VudGRvd24gJiYgY291bnRkb3duLnVubG9hZCgpXG5cbiAgICBidWlsdCA9IGZhbHNlXG4gIH1cblxuICB0aGlzLnNob3dQYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYXVzZWROb3RlICYmIHBhdXNlZE5vdGUuc2hvdygpXG4gIH1cblxuICB0aGlzLmhpZGVQYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYXVzZWROb3RlICYmIHBhdXNlZE5vdGUuaGlkZSgpXG4gIH1cblxuICB0aGlzLmhpZGVDb3VudGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgY291bnRkb3duICYmIGNvdW50ZG93bi5oaWRlKClcbiAgfVxuXG4gIHRoaXMuc3RhcnRDb3VudGRvd24gPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBjb3VudGRvd24gJiYgY291bnRkb3duLnN0YXJ0KGNiKVxuICB9XG5cbiAgdGhpcy5yZXN1bWVDb3VudGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgY291bnRkb3duICYmIGNvdW50ZG93bi5yZXN1bWUoKVxuICB9XG5cbiAgdGhpcy5pc0NvdW50aW5nRG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY291bnRkb3duICYmIGNvdW50ZG93bi5pc0NvdW50aW5nRG93bigpXG4gIH1cblxuICB0aGlzLmNoZWNrVGltZXIgPSBmdW5jdGlvbiAoaW50ZXJ2YWxTdW0pIHtcbiAgICByZWNvcmRUaW1lci5jaGVjayhpbnRlcnZhbFN1bSlcbiAgfVxufVxuXG51dGlsLmluaGVyaXRzKFJlY29yZGVySW5zaWRlcywgRXZlbnRFbWl0dGVyKVxuXG5leHBvcnQgZGVmYXVsdCBSZWNvcmRlckluc2lkZXNcbiIsImltcG9ydCB1dGlsIGZyb20gJ3V0aWwnXG5pbXBvcnQgaCBmcm9tICdoeXBlcnNjcmlwdCdcbmltcG9ydCBoaWRkZW4gZnJvbSAnaGlkZGVuJ1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vLi4vLi4vdXRpbC9ldmVudEVtaXR0ZXInXG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vLi4vLi4vZXZlbnRzJ1xuXG5jb25zdCBOb3RpZmllciA9IGZ1bmN0aW9uICh2aXN1YWxzLCBvcHRpb25zKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMsIG9wdGlvbnMsICdOb3RpZmllcicpXG5cbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgZGVidWcgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVidWdcblxuICB2YXIgbm90aWZ5RWxlbWVudFxuICB2YXIgbWVzc2FnZUVsZW1lbnRcbiAgdmFyIGV4cGxhbmF0aW9uRWxlbWVudFxuICB2YXIgZW50ZXJ0YWluVGltZW91dElkXG4gIHZhciBlbnRlcnRhaW5pbmdcbiAgdmFyIGJ1aWx0XG5cbiAgZnVuY3Rpb24gb25TdG9wcGluZyAobGltaXRSZWFjaGVkKSB7XG4gICAgdmFyIGxlYWQgPSAnJ1xuXG4gICAgdmlzdWFscy5iZWdpbldhaXRpbmcoKVxuXG4gICAgaWYgKGxpbWl0UmVhY2hlZCkge1xuICAgICAgZGVidWcoJ0xpbWl0IHJlYWNoZWQnKVxuICAgICAgbGVhZCArPSBvcHRpb25zLnRleHQubGltaXRSZWFjaGVkICsgJy48YnIvPidcbiAgICB9XG5cbiAgICBsZWFkICs9IG9wdGlvbnMudGV4dC5zZW5kaW5nICsgJyDigKYnXG5cbiAgICBzZWxmLm5vdGlmeShsZWFkLCBudWxsLCB7XG4gICAgICBzdGlsbFdhaXQ6IHRydWUsXG4gICAgICBlbnRlcnRhaW46IG9wdGlvbnMubm90aWZpZXIuZW50ZXJ0YWluXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdGluZyAoKSB7XG4gICAgc2VsZi5ub3RpZnkoJ0Nvbm5lY3Rpbmcg4oCmJylcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTG9hZGluZ1VzZXJNZWRpYSAoKSB7XG4gICAgc2VsZi5ub3RpZnkoJ0xvYWRpbmcgd2ViY2FtIOKApicpXG4gIH1cblxuICBmdW5jdGlvbiBvblByb2dyZXNzIChmcmFtZVByb2dyZXNzLCBzYW1wbGVQcm9ncmVzcykge1xuICAgIHZhciBvdmVyYWxsUHJvZ3Jlc3NcblxuICAgIGlmIChvcHRpb25zLmlzQXVkaW9FbmFibGVkKCkpIHtcbiAgICAgIG92ZXJhbGxQcm9ncmVzcyA9ICdWaWRlbzogJyArIGZyYW1lUHJvZ3Jlc3NcblxuICAgICAgaWYgKHNhbXBsZVByb2dyZXNzKSB7XG4gICAgICAgIG92ZXJhbGxQcm9ncmVzcyArPSAnLCBBdWRpbzogJyArIHNhbXBsZVByb2dyZXNzXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG92ZXJhbGxQcm9ncmVzcyA9IGZyYW1lUHJvZ3Jlc3NcbiAgICB9XG5cbiAgICBzZWxmLnNldEV4cGxhbmF0aW9uKG92ZXJhbGxQcm9ncmVzcylcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQmVnaW5WaWRlb0VuY29kaW5nICgpIHtcbiAgICB2aXN1YWxzLmJlZ2luV2FpdGluZygpXG5cbiAgICBjb25zdCBsZWFkID0gb3B0aW9ucy50ZXh0LmVuY29kaW5nICsgJyDigKYnXG5cbiAgICBzZWxmLm5vdGlmeShsZWFkLCBudWxsLCB7XG4gICAgICBzdGlsbFdhaXQ6IHRydWUsXG4gICAgICBlbnRlcnRhaW46IG9wdGlvbnMubm90aWZpZXIuZW50ZXJ0YWluXG4gICAgfSlcblxuICAgIGhpZGVFeHBsYW5hdGlvbigpXG4gIH1cblxuICBmdW5jdGlvbiBpbml0RXZlbnRzICgpIHtcbiAgICBkZWJ1ZygnTm90aWZpZXI6IGluaXRFdmVudHMoKScpXG5cbiAgICBzZWxmXG4gICAgICAub24oRXZlbnRzLkNPTk5FQ1RJTkcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25Db25uZWN0aW5nKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLkxPQURJTkdfVVNFUl9NRURJQSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkxvYWRpbmdVc2VyTWVkaWEoKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuVVNFUl9NRURJQV9SRUFEWSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmhpZGUoKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuTE9BREVEX01FVEFfREFUQSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb3JyZWN0RGltZW5zaW9ucygpXG4gICAgICB9KVxuICAgICAgLm9uKEV2ZW50cy5QUkVWSUVXLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuaGlkZSgpXG4gICAgICB9KVxuICAgICAgLm9uKEV2ZW50cy5TVE9QUElORywgZnVuY3Rpb24gKGxpbWl0UmVhY2hlZCkge1xuICAgICAgICBvblN0b3BwaW5nKGxpbWl0UmVhY2hlZClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLlBST0dSRVNTLCBmdW5jdGlvbiAoZnJhbWVQcm9ncmVzcywgc2FtcGxlUHJvZ3Jlc3MpIHtcbiAgICAgICAgb25Qcm9ncmVzcyhmcmFtZVByb2dyZXNzLCBzYW1wbGVQcm9ncmVzcylcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLkJFR0lOX1ZJREVPX0VOQ09ESU5HLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uQmVnaW5WaWRlb0VuY29kaW5nKClcbiAgICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb3JyZWN0RGltZW5zaW9ucyAoKSB7XG4gICAgbm90aWZ5RWxlbWVudC5zdHlsZS53aWR0aCA9IHZpc3VhbHMuZ2V0UmVjb3JkZXJXaWR0aCh0cnVlKSArICdweCdcbiAgICBub3RpZnlFbGVtZW50LnN0eWxlLmhlaWdodCA9IHZpc3VhbHMuZ2V0UmVjb3JkZXJIZWlnaHQodHJ1ZSkgKyAncHgnXG4gIH1cblxuICBmdW5jdGlvbiBzaG93ICgpIHtcbiAgICBub3RpZnlFbGVtZW50ICYmIGhpZGRlbihub3RpZnlFbGVtZW50LCBmYWxzZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bkVudGVydGFpbm1lbnQgKCkge1xuICAgIGlmIChvcHRpb25zLm5vdGlmaWVyLmVudGVydGFpbikge1xuICAgICAgaWYgKCFlbnRlcnRhaW5pbmcpIHtcbiAgICAgICAgY29uc3QgcmFuZG9tQmFja2dyb3VuZENsYXNzID0gTWF0aC5mbG9vcigoTWF0aC5yYW5kb20oKSAqIG9wdGlvbnMubm90aWZpZXIuZW50ZXJ0YWluTGltaXQpICsgMSlcblxuICAgICAgICBub3RpZnlFbGVtZW50LmNsYXNzTmFtZSA9ICdub3RpZmllciBlbnRlcnRhaW4gJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ub3RpZmllci5lbnRlcnRhaW5DbGFzcyArXG4gICAgICAgICAgICAgICAgcmFuZG9tQmFja2dyb3VuZENsYXNzXG5cbiAgICAgICAgZW50ZXJ0YWluVGltZW91dElkID0gc2V0VGltZW91dChydW5FbnRlcnRhaW5tZW50LCBvcHRpb25zLm5vdGlmaWVyLmVudGVydGFpbkludGVydmFsKVxuICAgICAgICBlbnRlcnRhaW5pbmcgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbmNlbEVudGVydGFpbm1lbnQoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEVudGVydGFpbm1lbnQgKCkge1xuICAgIGlmIChub3RpZnlFbGVtZW50KSB7XG4gICAgICBub3RpZnlFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2VudGVydGFpbicpXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KGVudGVydGFpblRpbWVvdXRJZClcbiAgICBlbnRlcnRhaW5UaW1lb3V0SWQgPSBudWxsXG4gICAgZW50ZXJ0YWluaW5nID0gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldE1lc3NhZ2UgKG1lc3NhZ2UsIG1lc3NhZ2VPcHRpb25zKSB7XG4gICAgY29uc3QgcHJvYmxlbSA9IG1lc3NhZ2VPcHRpb25zLnByb2JsZW0gPyBtZXNzYWdlT3B0aW9ucy5wcm9ibGVtIDogZmFsc2VcblxuICAgIGlmIChtZXNzYWdlRWxlbWVudCkge1xuICAgICAgbWVzc2FnZUVsZW1lbnQuaW5uZXJIVE1MID0gKHByb2JsZW0gPyAnJiN4MjYzOTsgJyA6ICcnKSArIG1lc3NhZ2VcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5sb2dnZXIud2FybihcbiAgICAgICAgJ1VuYWJsZSB0byBzaG93IGZvbGxvd2luZyBiZWNhdXNlIG1lc3NhZ2VFbGVtZW50IGlzIGVtcHR5OicsXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICB0aGlzLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnIubWVzc2FnZSA/IGVyci5tZXNzYWdlLnRvU3RyaW5nKCkgOiBlcnIudG9TdHJpbmcoKVxuICAgIGNvbnN0IGV4cGxhbmF0aW9uID0gZXJyLmV4cGxhbmF0aW9uID8gZXJyLmV4cGxhbmF0aW9uLnRvU3RyaW5nKCkgOiBudWxsXG5cbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgIG9wdGlvbnMuZGVidWcoJ1dlaXJkIGVtcHR5IG1lc3NhZ2UgZ2VuZXJhdGVkIGZvciBlcnJvcicsIGVycilcbiAgICB9XG5cbiAgICBzZWxmLm5vdGlmeShtZXNzYWdlLCBleHBsYW5hdGlvbiwge1xuICAgICAgYmxvY2tpbmc6IHRydWUsXG4gICAgICBwcm9ibGVtOiB0cnVlLFxuICAgICAgaGlkZUZvcm06IGVyci5oaWRlRm9ybSAmJiBlcnIuaGlkZUZvcm0oKSxcbiAgICAgIGNsYXNzTGlzdDogZXJyLmdldENsYXNzTGlzdCAmJiBlcnIuZ2V0Q2xhc3NMaXN0KCksXG4gICAgICByZW1vdmVEaW1lbnNpb25zOiBlcnIucmVtb3ZlRGltZW5zaW9ucyAmJiBlcnIucmVtb3ZlRGltZW5zaW9ucygpXG4gICAgfSlcbiAgfVxuXG4gIHRoaXMuc2V0RXhwbGFuYXRpb24gPSBmdW5jdGlvbiAoZXhwbGFuYXRpb24pIHtcbiAgICBpZiAoIWV4cGxhbmF0aW9uRWxlbWVudCkge1xuICAgICAgZXhwbGFuYXRpb25FbGVtZW50ID0gaCgncCcpXG5cbiAgICAgIGlmIChub3RpZnlFbGVtZW50KSB7XG4gICAgICAgIG5vdGlmeUVsZW1lbnQuYXBwZW5kQ2hpbGQoZXhwbGFuYXRpb25FbGVtZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5sb2dnZXIud2FybihcbiAgICAgICAgICAnVW5hYmxlIHRvIHNob3cgZXhwbGFuYXRpb24gYmVjYXVzZSBub3RpZnlFbGVtZW50IGlzIGVtcHR5OicsXG4gICAgICAgICAgZXhwbGFuYXRpb25cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGV4cGxhbmF0aW9uRWxlbWVudC5pbm5lckhUTUwgPSBleHBsYW5hdGlvblxuXG4gICAgaGlkZGVuKGV4cGxhbmF0aW9uRWxlbWVudCwgZmFsc2UpXG4gIH1cblxuICB0aGlzLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgIG9wdGlvbnMuZGVidWcoJ05vdGlmaWVyOiBidWlsZCgpJylcblxuICAgIG5vdGlmeUVsZW1lbnQgPSB2aXN1YWxzLnF1ZXJ5U2VsZWN0b3IoJy5ub3RpZmllcicpXG5cbiAgICBpZiAoIW5vdGlmeUVsZW1lbnQpIHtcbiAgICAgIG5vdGlmeUVsZW1lbnQgPSBoKCcubm90aWZpZXInKSAvLyBkZWZhdWx0cyB0byBkaXZcblxuICAgICAgdGhpcy5oaWRlKClcblxuICAgICAgdmlzdWFscy5hcHBlbmRDaGlsZChub3RpZnlFbGVtZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGUoKVxuICAgIH1cblxuICAgICFidWlsdCAmJiBpbml0RXZlbnRzKClcblxuICAgIGJ1aWx0ID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gaGlkZUV4cGxhbmF0aW9uICgpIHtcbiAgICBpZiAoZXhwbGFuYXRpb25FbGVtZW50KSB7XG4gICAgICBleHBsYW5hdGlvbkVsZW1lbnQuaW5uZXJIVE1MID0gbnVsbFxuICAgICAgaGlkZGVuKGV4cGxhbmF0aW9uRWxlbWVudCwgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICB0aGlzLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FuY2VsRW50ZXJ0YWlubWVudCgpXG5cbiAgICBpZiAobm90aWZ5RWxlbWVudCkge1xuICAgICAgaGlkZGVuKG5vdGlmeUVsZW1lbnQsIHRydWUpXG4gICAgICBub3RpZnlFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2Jsb2NraW5nJylcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZUVsZW1lbnQpIHtcbiAgICAgIG1lc3NhZ2VFbGVtZW50LmlubmVySFRNTCA9IG51bGxcbiAgICB9XG5cbiAgICBoaWRlRXhwbGFuYXRpb24oKVxuICB9XG5cbiAgdGhpcy5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFidWlsdCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub3RpZnlFbGVtZW50ICYmICFoaWRkZW4obm90aWZ5RWxlbWVudClcbiAgICB9XG4gIH1cblxuICB0aGlzLmlzQnVpbHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGJ1aWx0XG4gIH1cblxuICB0aGlzLm5vdGlmeSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBleHBsYW5hdGlvbiwgbm90aWZ5T3B0aW9ucykge1xuICAgIG9wdGlvbnMuZGVidWcoJ05vdGlmaWVyOiBub3RpZnkoKScpXG5cbiAgICBpZiAoIW5vdGlmeU9wdGlvbnMpIHtcbiAgICAgIG5vdGlmeU9wdGlvbnMgPSB7fVxuICAgIH1cblxuICAgIGNvbnN0IHN0aWxsV2FpdCA9IG5vdGlmeU9wdGlvbnMuc3RpbGxXYWl0ID8gbm90aWZ5T3B0aW9ucy5zdGlsbFdhaXQgOiBmYWxzZVxuICAgIGNvbnN0IGVudGVydGFpbiA9IG5vdGlmeU9wdGlvbnMuZW50ZXJ0YWluID8gbm90aWZ5T3B0aW9ucy5lbnRlcnRhaW4gOiBmYWxzZVxuICAgIGNvbnN0IGJsb2NraW5nID0gbm90aWZ5T3B0aW9ucy5ibG9ja2luZyA/IG5vdGlmeU9wdGlvbnMuYmxvY2tpbmcgOiBmYWxzZVxuICAgIGNvbnN0IGhpZGVGb3JtID0gbm90aWZ5T3B0aW9ucy5oaWRlRm9ybSA/IG5vdGlmeU9wdGlvbnMuaGlkZUZvcm0gOiBmYWxzZVxuICAgIGNvbnN0IGNsYXNzTGlzdCA9IG5vdGlmeU9wdGlvbnMuY2xhc3NMaXN0ID8gbm90aWZ5T3B0aW9ucy5jbGFzc0xpc3QgOiBmYWxzZVxuICAgIGNvbnN0IHJlbW92ZURpbWVuc2lvbnMgPSBub3RpZnlPcHRpb25zLnJlbW92ZURpbWVuc2lvbnMgPyBub3RpZnlPcHRpb25zLnJlbW92ZURpbWVuc2lvbnMgOiBmYWxzZVxuXG4gICAgaWYgKCFtZXNzYWdlRWxlbWVudCAmJiBub3RpZnlFbGVtZW50KSB7XG4gICAgICBtZXNzYWdlRWxlbWVudCA9IGgoJ2gyJylcblxuICAgICAgaWYgKGV4cGxhbmF0aW9uRWxlbWVudCkge1xuICAgICAgICBub3RpZnlFbGVtZW50Lmluc2VydEJlZm9yZShtZXNzYWdlRWxlbWVudCwgZXhwbGFuYXRpb25FbGVtZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm90aWZ5RWxlbWVudC5hcHBlbmRDaGlsZChtZXNzYWdlRWxlbWVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm90aWZ5RWxlbWVudCkge1xuICAgICAgLy8gcmVzZXRcbiAgICAgIGlmICghZW50ZXJ0YWluKSB7XG4gICAgICAgIG5vdGlmeUVsZW1lbnQuY2xhc3NOYW1lID0gJ25vdGlmaWVyJ1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xhc3NMaXN0KSB7XG4gICAgICAgIGNsYXNzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICBub3RpZnlFbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlRGltZW5zaW9ucykge1xuICAgICAgICBub3RpZnlFbGVtZW50LnN0eWxlLndpZHRoID0gJ2F1dG8nXG4gICAgICAgIG5vdGlmeUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJsb2NraW5nKSB7XG4gICAgICBub3RpZnlFbGVtZW50ICYmIG5vdGlmeUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYmxvY2tpbmcnKVxuICAgICAgdGhpcy5lbWl0KEV2ZW50cy5CTE9DS0lORywgeyBoaWRlRm9ybTogaGlkZUZvcm0gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KEV2ZW50cy5OT1RJRllJTkcpXG4gICAgfVxuXG4gICAgdmlzdWFscy5oaWRlUmVwbGF5KClcbiAgICB2aXN1YWxzLmhpZGVSZWNvcmRlcigpXG5cbiAgICBzZXRNZXNzYWdlKG1lc3NhZ2UsIG5vdGlmeU9wdGlvbnMpXG5cbiAgICBpZiAoZXhwbGFuYXRpb24gJiYgZXhwbGFuYXRpb24ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zZXRFeHBsYW5hdGlvbihleHBsYW5hdGlvbilcbiAgICB9XG5cbiAgICBpZiAoZW50ZXJ0YWluKSB7XG4gICAgICBydW5FbnRlcnRhaW5tZW50KClcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuY2VsRW50ZXJ0YWlubWVudCgpXG4gICAgfVxuXG4gICAgLy8ganVzdCBhcyBhIHNhZmV0eSBpbiBjYXNlIGlmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgbWlkZGxlIG9mIHRoZSBidWlsZCBwcm9jZXNzXG4gICAgLy8gYW5kIHZpc3VhbHMgYXJlbid0IGJ1aWx0L3Nob3duIHlldC5cbiAgICB2aXN1YWxzLnNob3dWaXN1YWxzKClcblxuICAgIHNob3coKVxuXG4gICAgIXN0aWxsV2FpdCAmJiB2aXN1YWxzLmVuZFdhaXRpbmcoKVxuICB9XG59XG5cbnV0aWwuaW5oZXJpdHMoTm90aWZpZXIsIEV2ZW50RW1pdHRlcilcblxuZXhwb3J0IGRlZmF1bHQgTm90aWZpZXJcbiIsImltcG9ydCB3ZWJzb2NrZXQgZnJvbSAnd2Vic29ja2V0LXN0cmVhbSdcbmltcG9ydCBGcmFtZSBmcm9tICdjYW52YXMtdG8tYnVmZmVyJ1xuaW1wb3J0IHV0aWwgZnJvbSAndXRpbCdcbmltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IGhpZGRlbiBmcm9tICdoaWRkZW4nXG5pbXBvcnQgYW5pbWl0dGVyIGZyb20gJ2FuaW1pdHRlcidcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnc2FmZS1qc29uLXN0cmluZ2lmeSdcblxuaW1wb3J0IFVzZXJNZWRpYSBmcm9tICcuL3VzZXJNZWRpYSdcblxuaW1wb3J0IEV2ZW50cyBmcm9tICcuLy4uLy4uL2V2ZW50cydcbmltcG9ydCBDb25zdGFudHMgZnJvbSAnLi8uLi8uLi9jb25zdGFudHMnXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vLi4vLi4vdXRpbC9ldmVudEVtaXR0ZXInXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLy4uLy4uL3V0aWwvYnJvd3NlcidcbmltcG9ydCBIdW1hbml6ZSBmcm9tICcuLy4uLy4uL3V0aWwvaHVtYW5pemUnXG5pbXBvcnQgcHJldHR5IGZyb20gJy4vLi4vLi4vdXRpbC9wcmV0dHknXG5pbXBvcnQgVmlkZW9tYWlsRXJyb3IgZnJvbSAnLi8uLi8uLi91dGlsL3ZpZGVvbWFpbEVycm9yJ1xuXG4vLyBjcmVkaXRzIGh0dHA6Ly8xbGluZWFydC5rdWxhb25lLmNvbS8jL1xuY29uc3QgUElQRV9TWU1CT0wgPSAnwrDCusKkw7gswrjCuCzDuMKkwrrCsGDCsMK6wqTDuCzCuCzDuMKkwrDCusKkw7gswrjCuCzDuMKkwrrCsGDCsMK6wqTDuCzCuCAnXG5cbmNvbnN0IFJlY29yZGVyID0gZnVuY3Rpb24gKHZpc3VhbHMsIHJlcGxheSwgb3B0aW9ucykge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzLCBvcHRpb25zLCAnUmVjb3JkZXInKVxuXG4gIC8vIHZhbGlkYXRlIHNvbWUgb3B0aW9ucyB0aGlzIGNsYXNzIG5lZWRzXG4gIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy52aWRlbyB8fCAhb3B0aW9ucy52aWRlby5mcHMpIHtcbiAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ0ZQUyBtdXN0IGJlIGRlZmluZWQnLCBvcHRpb25zKVxuICB9XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgYnJvd3NlciA9IG5ldyBCcm93c2VyKG9wdGlvbnMpXG4gIGNvbnN0IGRlYnVnID0gb3B0aW9ucy5kZWJ1Z1xuXG4gIHZhciBsb29wID0gbnVsbFxuXG4gIHZhciBvcmlnaW5hbEFuaW1hdGlvbkZyYW1lT2JqZWN0XG5cbiAgdmFyIHNhbXBsZXNDb3VudCA9IDBcbiAgdmFyIGZyYW1lc0NvdW50ID0gMFxuICB2YXIgZmFjaW5nTW9kZSA9IG9wdGlvbnMudmlkZW8uZmFjaW5nTW9kZSAvLyBkZWZhdWx0IGlzICd1c2VyJ1xuXG4gIHZhciByZWNvcmRpbmdTdGF0cyA9IHt9XG5cbiAgdmFyIGNvbmZpcm1lZEZyYW1lTnVtYmVyID0gMFxuICB2YXIgY29uZmlybWVkU2FtcGxlTnVtYmVyID0gMFxuXG4gIHZhciByZWNvcmRlckVsZW1lbnRcbiAgdmFyIHVzZXJNZWRpYVxuXG4gIHZhciB1c2VyTWVkaWFUaW1lb3V0XG4gIHZhciByZXRyeVRpbWVvdXRcblxuICB2YXIgYnl0ZXNTdW1cblxuICB2YXIgZnJhbWVQcm9ncmVzc1xuICB2YXIgc2FtcGxlUHJvZ3Jlc3NcblxuICB2YXIgY2FudmFzXG4gIHZhciBjdHhcblxuICB2YXIgdXNlck1lZGlhTG9hZGVkXG4gIHZhciB1c2VyTWVkaWFMb2FkaW5nXG4gIHZhciBzdWJtaXR0aW5nXG4gIHZhciB1bmxvYWRlZFxuICB2YXIgc3RvcFRpbWVcbiAgdmFyIHN0cmVhbVxuICB2YXIgY29ubmVjdGluZ1xuICB2YXIgY29ubmVjdGVkXG4gIHZhciBibG9ja2luZ1xuICB2YXIgYnVpbHRcbiAgdmFyIGtleVxuICB2YXIgd2FpdGluZ1RpbWVcblxuICB2YXIgcGluZ0ludGVydmFsXG5cbiAgdmFyIGZyYW1lXG5cbiAgdmFyIHJlY29yZGluZ0J1ZmZlckxlbmd0aFxuICB2YXIgcmVjb3JkaW5nQnVmZmVyXG5cbiAgZnVuY3Rpb24gd3JpdGVTdHJlYW0gKGJ1ZmZlciwgb3B0cykge1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICAgIC8vIHByZXZlbnRzIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC5pby9pc3N1ZXMvMzkzXG4gICAgICAgIHN0b3BQaW5ncygpXG5cbiAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgICAgICdBbHJlYWR5IGRpc2Nvbm5lY3RlZCcsXG4gICAgICAgICAgJ1NvcnJ5LCBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gZGVzdHJveWVkLiBQbGVhc2UgcmVsb2FkLicsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb25GbHVzaGVkQ2FsbGJhY2sgPSBvcHRzICYmIG9wdHMub25GbHVzaGVkQ2FsbGJhY2tcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0cmVhbS53cml0ZShidWZmZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9uRmx1c2hlZENhbGxiYWNrICYmIG9uRmx1c2hlZENhbGxiYWNrKG9wdHMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgICAgICAgJ0ZhaWxlZCB3cml0aW5nIHRvIHNlcnZlcicsXG4gICAgICAgICAgICAnc3RyZWFtLndyaXRlKCkgZmFpbGVkIGJlY2F1c2Ugb2YgJyArIHByZXR0eShleGMpLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZW5kUGluZ3MgKCkge1xuICAgIHBpbmdJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnUmVjb3JkZXI6IHBpbmdpbmcuLi4nKVxuICAgICAgd3JpdGVTdHJlYW0oQnVmZmVyLmZyb20oJycpKVxuICAgIH0sIG9wdGlvbnMudGltZW91dHMucGluZ0ludGVydmFsKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcFBpbmdzICgpIHtcbiAgICBjbGVhckludGVydmFsKHBpbmdJbnRlcnZhbClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQXVkaW9TYW1wbGUgKGF1ZGlvU2FtcGxlKSB7XG4gICAgc2FtcGxlc0NvdW50KytcblxuICAgIGNvbnN0IGF1ZGlvQnVmZmVyID0gYXVkaW9TYW1wbGUudG9CdWZmZXIoKVxuXG4gICAgLy8gaWYgKG9wdGlvbnMudmVyYm9zZSkge1xuICAgIC8vICAgICBkZWJ1ZyhcbiAgICAvLyAgICAgICAgICdTYW1wbGUgIycgKyBzYW1wbGVzQ291bnQgKyAnICgnICsgYXVkaW9CdWZmZXIubGVuZ3RoICsgJyBieXRlcyk6J1xuICAgIC8vICAgICApXG4gICAgLy8gfVxuXG4gICAgd3JpdGVTdHJlYW0oYXVkaW9CdWZmZXIpXG4gIH1cblxuICBmdW5jdGlvbiBzaG93ICgpIHtcbiAgICByZWNvcmRlckVsZW1lbnQgJiYgaGlkZGVuKHJlY29yZGVyRWxlbWVudCwgZmFsc2UpXG4gIH1cblxuICBmdW5jdGlvbiBvblVzZXJNZWRpYVJlYWR5IChwYXJhbXMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZygnUmVjb3JkZXI6IG9uVXNlck1lZGlhUmVhZHkoKScsIHBhcmFtcylcblxuICAgICAgY29uc3Qgc3dpdGNoaW5nRmFjaW5nTW9kZSA9IHBhcmFtcy5zd2l0Y2hpbmdGYWNpbmdNb2RlXG5cbiAgICAgIHVzZXJNZWRpYUxvYWRpbmcgPSBibG9ja2luZyA9IHVubG9hZGVkID0gc3VibWl0dGluZyA9IGZhbHNlXG4gICAgICB1c2VyTWVkaWFMb2FkZWQgPSB0cnVlXG5cbiAgICAgIGlmICghc3dpdGNoaW5nRmFjaW5nTW9kZSkge1xuICAgICAgICBsb29wID0gY3JlYXRlTG9vcCgpXG4gICAgICB9XG5cbiAgICAgIHNob3coKVxuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5VU0VSX01FRElBX1JFQURZLCB7XG4gICAgICAgIHN3aXRjaGluZ0ZhY2luZ01vZGU6IHBhcmFtcy5zd2l0Y2hpbmdGYWNpbmdNb2RlLFxuICAgICAgICBwYXVzZWQ6IHNlbGYuaXNQYXVzZWQoKVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGV4YylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhclJldHJ5VGltZW91dCAoKSB7XG4gICAgZGVidWcoJ1JlY29yZGVyOiBjbGVhclJldHJ5VGltZW91dCgpJylcblxuICAgIHJldHJ5VGltZW91dCAmJiBjbGVhclRpbWVvdXQocmV0cnlUaW1lb3V0KVxuICAgIHJldHJ5VGltZW91dCA9IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyVXNlck1lZGlhVGltZW91dCAoKSB7XG4gICAgaWYgKHVzZXJNZWRpYVRpbWVvdXQpIHtcbiAgICAgIGRlYnVnKCdSZWNvcmRlcjogY2xlYXJVc2VyTWVkaWFUaW1lb3V0KCknKVxuXG4gICAgICB1c2VyTWVkaWFUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh1c2VyTWVkaWFUaW1lb3V0KVxuICAgICAgdXNlck1lZGlhVGltZW91dCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVGcmFtZVByb2dyZXNzICgpIHtcbiAgICByZXR1cm4gKGNvbmZpcm1lZEZyYW1lTnVtYmVyIC8gKGZyYW1lc0NvdW50IHx8IDEpICogMTAwKS50b0ZpeGVkKDIpICsgJyUnXG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVTYW1wbGVQcm9ncmVzcyAoKSB7XG4gICAgcmV0dXJuIChjb25maXJtZWRTYW1wbGVOdW1iZXIgLyAoc2FtcGxlc0NvdW50IHx8IDEpICogMTAwKS50b0ZpeGVkKDIpICsgJyUnXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVPdmVyYWxsUHJvZ3Jlc3MgKCkge1xuICAgIC8vIHdoZW4gcHJvZ3Jlc3NlcyBhcmVuJ3QgaW5pdGlhbGl6ZWQsXG4gICAgLy8gdGhlbiBkbyBhIGZpcnN0IGNhbGN1bGF0aW9uIHRvIGF2b2lkIGBpbmZpbml0ZWAgb3IgYG51bGxgIGRpc3BsYXlzXG5cbiAgICBpZiAoIWZyYW1lUHJvZ3Jlc3MpIHtcbiAgICAgIGZyYW1lUHJvZ3Jlc3MgPSBjYWxjdWxhdGVGcmFtZVByb2dyZXNzKClcbiAgICB9XG5cbiAgICBpZiAoIXNhbXBsZVByb2dyZXNzKSB7XG4gICAgICBzYW1wbGVQcm9ncmVzcyA9IGNhbGN1bGF0ZVNhbXBsZVByb2dyZXNzKClcbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoXG4gICAgICBFdmVudHMuUFJPR1JFU1MsXG4gICAgICBmcmFtZVByb2dyZXNzLFxuICAgICAgc2FtcGxlUHJvZ3Jlc3NcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFtZVByb2dyZXNzIChhcmdzKSB7XG4gICAgY29uZmlybWVkRnJhbWVOdW1iZXIgPSBhcmdzLmZyYW1lID8gYXJncy5mcmFtZSA6IGNvbmZpcm1lZEZyYW1lTnVtYmVyXG5cbiAgICBmcmFtZVByb2dyZXNzID0gY2FsY3VsYXRlRnJhbWVQcm9ncmVzcygpXG5cbiAgICB1cGRhdGVPdmVyYWxsUHJvZ3Jlc3MoKVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2FtcGxlUHJvZ3Jlc3MgKGFyZ3MpIHtcbiAgICBjb25maXJtZWRTYW1wbGVOdW1iZXIgPSBhcmdzLnNhbXBsZSA/IGFyZ3Muc2FtcGxlIDogY29uZmlybWVkU2FtcGxlTnVtYmVyXG5cbiAgICBzYW1wbGVQcm9ncmVzcyA9IGNhbGN1bGF0ZVNhbXBsZVByb2dyZXNzKClcblxuICAgIHVwZGF0ZU92ZXJhbGxQcm9ncmVzcygpXG4gIH1cblxuICBmdW5jdGlvbiBwcmV2aWV3IChhcmdzKSB7XG4gICAgY29uZmlybWVkRnJhbWVOdW1iZXIgPVxuICAgIGNvbmZpcm1lZFNhbXBsZU51bWJlciA9XG4gICAgc2FtcGxlc0NvdW50ID1cbiAgICBmcmFtZXNDb3VudCA9IDBcblxuICAgIHNhbXBsZVByb2dyZXNzID0gZnJhbWVQcm9ncmVzcyA9IG51bGxcblxuICAgIGtleSA9IGFyZ3Mua2V5XG5cbiAgICBpZiAoYXJncy5tcDQpIHtcbiAgICAgIHJlcGxheS5zZXRNcDRTb3VyY2UoXG4gICAgICAgIGFyZ3MubXA0ICsgQ29uc3RhbnRzLlNJVEVfTkFNRV9MQUJFTCArICcvJyArIG9wdGlvbnMuc2l0ZU5hbWUgKyAnL3ZpZGVvbWFpbC5tcDQnLFxuICAgICAgICB0cnVlXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKGFyZ3Mud2VibSkge1xuICAgICAgcmVwbGF5LnNldFdlYk1Tb3VyY2UoXG4gICAgICAgIGFyZ3Mud2VibSArIENvbnN0YW50cy5TSVRFX05BTUVfTEFCRUwgKyAnLycgKyBvcHRpb25zLnNpdGVOYW1lICsgJy92aWRlb21haWwud2VibScsXG4gICAgICAgIHRydWVcbiAgICAgIClcbiAgICB9XG5cbiAgICBzZWxmLmhpZGUoKVxuXG4gICAgY29uc3Qgd2lkdGggPSBzZWxmLmdldFJlY29yZGVyV2lkdGgodHJ1ZSlcbiAgICBjb25zdCBoZWlnaHQgPSBzZWxmLmdldFJlY29yZGVySGVpZ2h0KHRydWUpXG5cbiAgICBzZWxmLmVtaXQoRXZlbnRzLlBSRVZJRVcsIGtleSwgd2lkdGgsIGhlaWdodClcblxuICAgIC8vIGtlZXAgaXQgZm9yIHJlY29yZGluZyBzdGF0c1xuICAgIHdhaXRpbmdUaW1lID0gRGF0ZS5ub3coKSAtIHN0b3BUaW1lXG5cbiAgICByZWNvcmRpbmdTdGF0cy53YWl0aW5nVGltZSA9IHdhaXRpbmdUaW1lXG5cbiAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgZGVidWcoXG4gICAgICAgICdXaGlsZSByZWNvcmRpbmcsICVzIGhhdmUgYmVlbiB0cmFuc2ZlcnJlZCBhbmQgd2FpdGluZyB0aW1lIHdhcyAlcycsXG4gICAgICAgIEh1bWFuaXplLmZpbGVzaXplKGJ5dGVzU3VtLCAyKSxcbiAgICAgICAgSHVtYW5pemUudG9UaW1lKHdhaXRpbmdUaW1lKVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRTb2NrZXQgKGNiKSB7XG4gICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgIGNvbm5lY3RpbmcgPSB0cnVlXG5cbiAgICAgIGRlYnVnKCdSZWNvcmRlcjogaW5pdGlhbGlzaW5nIHdlYiBzb2NrZXQgdG8gJXMnLCBvcHRpb25zLnNvY2tldFVybClcblxuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5DT05ORUNUSU5HKVxuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vd2Vic29ja2V0LXN0cmVhbSNiaW5hcnktc29ja2V0c1xuXG4gICAgICAvLyB3ZSB1c2UgcXVlcnkgcGFyYW1ldGVycyBoZXJlIGJlY2F1c2Ugd2UgY2Fubm90IHNldCBjdXN0b20gaGVhZGVycyBpbiB3ZWIgc29ja2V0cyxcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvNDY3XG5cbiAgICAgIGNvbnN0IHVybDJDb25uZWN0ID1cbiAgICAgICAgb3B0aW9ucy5zb2NrZXRVcmwgK1xuICAgICAgICAnPycgK1xuICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoQ29uc3RhbnRzLlNJVEVfTkFNRV9MQUJFTCkgK1xuICAgICAgICAnPScgK1xuICAgICAgICBlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5zaXRlTmFtZSlcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gd2Vic29ja2V0IG9wdGlvbnMgY2Fubm90IGJlIHNldCBvbiBjbGllbnQgc2lkZSwgb25seSBvbiBzZXJ2ZXIsIHNlZVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vd2Vic29ja2V0LXN0cmVhbS9pc3N1ZXMvMTE2I2lzc3VlY29tbWVudC0yOTY0MjEwNzdcbiAgICAgICAgc3RyZWFtID0gd2Vic29ja2V0KHVybDJDb25uZWN0LCB7XG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vd2Vic29ja2V0LXN0cmVhbS9pc3N1ZXMvMTE3I2lzc3VlY29tbWVudC0yOTg4MjYwMTFcbiAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgICAgY29ubmVjdGluZyA9IGNvbm5lY3RlZCA9IGZhbHNlXG5cbiAgICAgICAgdmFyIGVyclxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2Vic29ja2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGVyciA9IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnVGhlcmUgaXMgbm8gd2Vic29ja2V0JywgJ0NhdXNlOiAnICsgcHJldHR5KGV4YyksIG9wdGlvbnMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyID0gVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgICAgICAgJ0ZhaWxlZCB0byBjb25uZWN0IHRvIHNlcnZlcicsXG4gICAgICAgICAgICAnUGxlYXNlIHVwZ3JhZGUgeW91ciBicm93c2VyLiBZb3VyIGN1cnJlbnQgdmVyc2lvbiBkb2VzIG5vdCBzZWVtIHRvIHN1cHBvcnQgd2Vic29ja2V0cy4nLFxuICAgICAgICAgICAgb3B0aW9ucywge1xuICAgICAgICAgICAgICBicm93c2VyUHJvYmxlbTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGVycilcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAvLyAvLyB1c2VmdWwgZm9yIGRlYnVnZ2luZyBzdHJlYW1zXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlmICghc3RyZWFtLm9yaWdpbmFsRW1pdCkge1xuICAgICAgICAvLyAgIHN0cmVhbS5vcmlnaW5hbEVtaXQgPSBzdHJlYW0uZW1pdFxuICAgICAgICAvLyB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHN0cmVhbS5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgLy8gICBpZiAoc3RyZWFtKSB7XG4gICAgICAgIC8vICAgICBkZWJ1ZyhQSVBFX1NZTUJPTCArICdEZWJ1Z2dpbmcgc3RyZWFtIGV2ZW50OicsIHR5cGUpXG4gICAgICAgIC8vICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcbiAgICAgICAgLy8gICAgIHJldHVybiBzdHJlYW0ub3JpZ2luYWxFbWl0LmFwcGx5KHN0cmVhbSwgYXJncylcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGRlYnVnKFBJUEVfU1lNQk9MICsgJ1N0cmVhbSBoYXMgY2xvc2VkJylcblxuICAgICAgICAgIGNvbm5lY3RpbmcgPSBjb25uZWN0ZWQgPSBmYWxzZVxuXG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXJyIHx8ICdVbmhhbmRsZWQgd2Vic29ja2V0IGVycm9yJylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5ESVNDT05ORUNURUQpXG5cbiAgICAgICAgICAgIC8vIHByZXZlbnRzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLmlvL2lzc3Vlcy8yOTcgaGFwcGVuaW5nXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWJ1ZyhQSVBFX1NZTUJPTCArICdTdHJlYW0gKmNvbm5lY3QqIGV2ZW50IGVtaXR0ZWQnKVxuXG4gICAgICAgICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbm5lY3RlZCA9IHRydWVcbiAgICAgICAgICAgIGNvbm5lY3RpbmcgPSB1bmxvYWRlZCA9IGZhbHNlXG5cbiAgICAgICAgICAgIHNlbGYuZW1pdChFdmVudHMuQ09OTkVDVEVEKVxuXG4gICAgICAgICAgICBkZWJ1ZygnR29pbmcgdG8gYXNrIGZvciB3ZWJjYW0gcGVybWlzc29ucyBub3cgLi4uJylcblxuICAgICAgICAgICAgY2IgJiYgY2IoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIGRlYnVnKFBJUEVfU1lNQk9MICsgJ1N0cmVhbSAqZGF0YSogZXZlbnQgZW1pdHRlZCcpXG5cbiAgICAgICAgICB2YXIgY29tbWFuZFxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1hbmQgPSBKU09OLnBhcnNlKGRhdGEudG9TdHJpbmcoKSlcbiAgICAgICAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgICAgICAgIGRlYnVnKCdGYWlsZWQgdG8gcGFyc2UgY29tbWFuZDonLCBleGMpXG5cbiAgICAgICAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIFZpZGVvbWFpbEVycm9yLmNyZWF0ZShcbiAgICAgICAgICAgICAgJ0ludmFsaWQgc2VydmVyIGNvbW1hbmQnLFxuICAgICAgICAgICAgICAvLyB0b1N0cmluZygpIHNpbmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC5pby9pc3N1ZXMvMjg4XG4gICAgICAgICAgICAgICdDb250YWN0IHVzIGFzYXAuIEJhZCBjb21tbWFuZCB3YXMgJyArIGRhdGEudG9TdHJpbmcoKSArICcuICcsXG4gICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGV4ZWN1dGVDb21tYW5kLmNhbGwoc2VsZiwgY29tbWFuZClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBkZWJ1ZyhQSVBFX1NZTUJPTCArICdTdHJlYW0gKmVycm9yKiBldmVudCBlbWl0dGVkJywgZXJyKVxuXG4gICAgICAgICAgY29ubmVjdGluZyA9IGNvbm5lY3RlZCA9IGZhbHNlXG5cbiAgICAgICAgICAvLyBzZXR0aW5nIGN1c3RvbSB0ZXh0IHNpbmNlIHRoYXQgZXJyIG9iamVjdCBpc24ndCByZWFsbHkgYW4gZXJyb3JcbiAgICAgICAgICAvLyBvbiBpcGhvbmVzIHdoZW4gbG9ja2VkLCBhbmQgdW5sb2NrZWQsIHRoaXMgZXJyIGlzIGFjdHVhbGx5XG4gICAgICAgICAgLy8gYW4gZXZlbnQgb2JqZWN0IHdpdGggc3R1ZmYgd2UgY2FuJ3QgdXNlIGF0IGFsbCAoYW4gZXh0ZXJuYWwgYnVnKVxuICAgICAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIFZpZGVvbWFpbEVycm9yLmNyZWF0ZShcbiAgICAgICAgICAgICdDb25uZWN0aW9uIGVycm9yJyxcbiAgICAgICAgICAgICdEYXRhIGV4Y2hhbmdlIGhhcyBiZWVuIGludGVycnVwdGVkLiBQbGVhc2UgcmVsb2FkLicsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKSlcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBqdXN0IGV4cGVyaW1lbnRhbFxuXG4gICAgICAgIHN0cmVhbS5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVidWcoUElQRV9TWU1CT0wgKyAnU3RyZWFtICpkcmFpbiogZXZlbnQgZW1pdHRlZCAoc2hvdWxkIG5vdCBoYXBwZW4hKScpXG4gICAgICAgIH0pXG5cbiAgICAgICAgc3RyZWFtLm9uKCdwcmVlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVidWcoUElQRV9TWU1CT0wgKyAnU3RyZWFtICpwcmVlbmQqIGV2ZW50IGVtaXR0ZWQnKVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlYnVnKFBJUEVfU1lNQk9MICsgJ1N0cmVhbSAqZW5kKiBldmVudCBlbWl0dGVkJylcbiAgICAgICAgfSlcblxuICAgICAgICBzdHJlYW0ub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlYnVnKFBJUEVfU1lNQk9MICsgJ1N0cmVhbSAqZHJhaW4qIGV2ZW50IGVtaXR0ZWQnKVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbigncGlwZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWJ1ZyhQSVBFX1NZTUJPTCArICdTdHJlYW0gKnBpcGUqIGV2ZW50IGVtaXR0ZWQnKVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbigndW5waXBlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlYnVnKFBJUEVfU1lNQk9MICsgJ1N0cmVhbSAqdW5waXBlKiBldmVudCBlbWl0dGVkJylcbiAgICAgICAgfSlcblxuICAgICAgICBzdHJlYW0ub24oJ3Jlc3VtZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWJ1ZyhQSVBFX1NZTUJPTCArICdTdHJlYW0gKnJlc3VtZSogZXZlbnQgZW1pdHRlZCcpXG4gICAgICAgIH0pXG5cbiAgICAgICAgc3RyZWFtLm9uKCd1bmNvcmsnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVidWcoUElQRV9TWU1CT0wgKyAnU3RyZWFtICp1bmNvcmsqIGV2ZW50IGVtaXR0ZWQnKVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbigncmVhZGFibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVidWcoUElQRV9TWU1CT0wgKyAnU3RyZWFtICpwcmVlbmQqIGV2ZW50IGVtaXR0ZWQnKVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbigncHJlZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlYnVnKFBJUEVfU1lNQk9MICsgJ1N0cmVhbSAqcHJlZW5kKiBldmVudCBlbWl0dGVkJylcbiAgICAgICAgfSlcblxuICAgICAgICBzdHJlYW0ub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWJ1ZyhQSVBFX1NZTUJPTCArICdTdHJlYW0gKnByZWVuZCogZXZlbnQgZW1pdHRlZCcpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2hvd1VzZXJNZWRpYSAoKSB7XG4gICAgLy8gdXNlIGNvbm5lY3RlZCBmbGFnIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZ1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC5pby9pc3N1ZXMvMzIzXG4gICAgcmV0dXJuIGNvbm5lY3RlZCAmJiAoaXNOb3RpZnlpbmcoKSB8fCAhaXNIaWRkZW4oKSB8fCBibG9ja2luZylcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZXJNZWRpYUVycm9yQ2FsbGJhY2sgKGVycikge1xuICAgIHVzZXJNZWRpYUxvYWRpbmcgPSBmYWxzZVxuICAgIGNsZWFyVXNlck1lZGlhVGltZW91dCgpXG5cbiAgICBkZWJ1ZyhcbiAgICAgICdSZWNvcmRlcjogdXNlck1lZGlhRXJyb3JDYWxsYmFjaygpJyxcbiAgICAgICcsIFdlYmNhbSBjaGFyYWN0ZXJpc3RpY3M6JyxcbiAgICAgIHVzZXJNZWRpYS5nZXRDaGFyYWN0ZXJpc3RpY3MoKVxuICAgIClcblxuICAgIGNvbnN0IGVycm9yTGlzdGVuZXJzID0gc2VsZi5saXN0ZW5lcnMoRXZlbnRzLkVSUk9SKVxuXG4gICAgaWYgKGVycm9yTGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgaWYgKGVyci5uYW1lICE9PSBWaWRlb21haWxFcnJvci5NRURJQV9ERVZJQ0VfTk9UX1NVUFBPUlRFRCkge1xuICAgICAgICBzZWxmLmVtaXQoRXZlbnRzLkVSUk9SLCBWaWRlb21haWxFcnJvci5jcmVhdGUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvIG5vdCBlbWl0IGJ1dCByZXRyeSBzaW5jZSBNRURJQV9ERVZJQ0VfTk9UX1NVUFBPUlRFRCBjYW4gYmUgYSByYWNlIGNvbmRpdGlvblxuICAgICAgICBkZWJ1ZygnUmVjb3JkZXI6IGlnbm9yZSB1c2VyIG1lZGlhIGVycm9yJywgZXJyKVxuICAgICAgfVxuXG4gICAgICAvLyByZXRyeSBhZnRlciBhIHdoaWxlXG4gICAgICByZXRyeVRpbWVvdXQgPSBzZXRUaW1lb3V0KGluaXRTb2NrZXQsIG9wdGlvbnMudGltZW91dHMudXNlck1lZGlhKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodW5sb2FkZWQpIHtcbiAgICAgICAgLy8gY2FuIGhhcHBlbiB0aGF0IGNvbnRhaW5lciBpcyB1bmxvYWRlZCBidXQgc29tZSB1c2VyIG1lZGlhIHJlbGF0ZWQgY2FsbGJhY2tzXG4gICAgICAgIC8vIGFyZSBzdGlsbCBpbiBwcm9jZXNzLiBpbiB0aGF0IGNhc2UgaWdub3JlIGVycm9yLlxuICAgICAgICBkZWJ1ZygnUmVjb3JkZXI6IGFscmVhZHkgdW5sb2FkZWQuIE5vdCBnb2luZyB0byB0aHJvdyBlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdSZWNvcmRlcjogbm8gZXJyb3IgbGlzdGVuZXJzIGF0dGFjaGVkIGJ1dCB0aHJvd2luZyBlcnJvcicsIGVycilcblxuICAgICAgICAvLyB3ZWlyZCBzaXR1YXRpb24sIHRocm93IGl0IGluc3RlYWQgb2YgZW1pdHRpbmcgc2luY2UgdGhlcmUgYXJlIG5vIGVycm9yIGxpc3RlbmVyc1xuICAgICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgICdVbmFibGUgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHNpbmNlIHRoZXJlIGFyZSBubyBlcnJvciBsaXN0ZW5lcnMgYW55bW9yZS4nLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVzZXJNZWRpYUNhbGxiYWNrIChsb2NhbFN0cmVhbSwgcGFyYW1zKSB7XG4gICAgZGVidWcoJ1JlY29yZGVyOiBnZXRVc2VyTWVkaWFDYWxsYmFjaygpJywgcGFyYW1zKVxuXG4gICAgaWYgKHNob3dVc2VyTWVkaWEoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2xlYXJVc2VyTWVkaWFUaW1lb3V0KClcblxuICAgICAgICB1c2VyTWVkaWEuaW5pdChcbiAgICAgICAgICBsb2NhbFN0cmVhbSxcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvblVzZXJNZWRpYVJlYWR5KHBhcmFtcylcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQXVkaW9TYW1wbGUuYmluZChzZWxmKSxcbiAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoRXZlbnRzLkVSUk9SLCBlcnIpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXJhbXNcbiAgICAgICAgKVxuICAgICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGV4YylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkR2VudWluZVVzZXJNZWRpYSAocGFyYW1zKSB7XG4gICAgaWYgKCFuYXZpZ2F0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmF2aWdhdG9yIGlzIG1pc3NpbmchJylcbiAgICB9XG5cbiAgICBkZWJ1ZygnUmVjb3JkZXI6IGxvYWRHZW51aW5lVXNlck1lZGlhKCknKVxuXG4gICAgc2VsZi5lbWl0KEV2ZW50cy5BU0tJTkdfV0VCQ0FNX1BFUk1JU1NJT04pXG5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFEZXZpY2VzL2dldFVzZXJNZWRpYVxuICAgIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgICAvLyBwcmVmZXIgdGhlIGZyb250IGNhbWVyYSAoaWYgb25lIGlzIGF2YWlsYWJsZSkgb3ZlciB0aGUgcmVhciBvbmVcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0ge1xuICAgICAgICB2aWRlbzoge1xuICAgICAgICAgIGZhY2luZ01vZGU6IGZhY2luZ01vZGUsXG4gICAgICAgICAgZnJhbWVSYXRlOiB7IGlkZWFsOiBvcHRpb25zLnZpZGVvLmZwcyB9XG4gICAgICAgIH0sXG4gICAgICAgIGF1ZGlvOiBvcHRpb25zLmlzQXVkaW9FbmFibGVkKClcbiAgICAgIH1cblxuICAgICAgaWYgKGJyb3dzZXIuaXNPa1NhZmFyaSgpKSB7XG4gICAgICAgIC8vIGRvIG5vdCB1c2UgdGhvc2Ugd2lkdGgvaGVpZ2h0IGNvbnN0cmFpbnRzIHlldCxcbiAgICAgICAgLy8gY3VycmVudCBzYWZhcmkgd291bGQgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gdG9kbyBpbiBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwtY2xpZW50L2lzc3Vlcy8xNDJcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzRGVmaW5lZFdpZHRoKCkpIHtcbiAgICAgICAgICBjb25zdHJhaW50cy52aWRlby53aWR0aCA9IHsgaWRlYWw6IG9wdGlvbnMudmlkZW8ud2lkdGggfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSB0cnkgdG8gYXBwbHkgdGhlIHNhbWUgd2lkdGggYXMgdGhlIGVsZW1lbnQgaXMgaGF2aW5nXG4gICAgICAgICAgLy8gYnV0IHRoZXJlIGlzIG5vIDEwMCUgZ3VhcmFudGVlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbi4gbm90XG4gICAgICAgICAgLy8gYWxsIHdlYmNhbSBkcml2ZXJzIGJlaGF2ZSB0aGUgc2FtZSB3YXlcbiAgICAgICAgICBjb25zdHJhaW50cy52aWRlby53aWR0aCA9IHsgaWRlYWw6IHNlbGYubGltaXRXaWR0aCgpIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmhhc0RlZmluZWRIZWlnaHQoKSkge1xuICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLmhlaWdodCA9IHsgaWRlYWw6IG9wdGlvbnMudmlkZW8uaGVpZ2h0IH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZWJ1ZygnUmVjb3JkZXI6IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKCknLCBjb25zdHJhaW50cylcblxuICAgICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMpIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgJ1JlY29yZGVyOiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCknLFxuICAgICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdlbnVpbmVVc2VyTWVkaWFSZXF1ZXN0ID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG5cbiAgICAgIGlmIChnZW51aW5lVXNlck1lZGlhUmVxdWVzdCkge1xuICAgICAgICBnZW51aW5lVXNlck1lZGlhUmVxdWVzdFxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChsb2NhbFN0cmVhbSkge1xuICAgICAgICAgICAgZ2V0VXNlck1lZGlhQ2FsbGJhY2sobG9jYWxTdHJlYW0sIHBhcmFtcylcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCh1c2VyTWVkaWFFcnJvckNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyB0byB0cmFwIGVycm9ycyBsaWtlIHRoZXNlXG4gICAgICAgIC8vIENhbm5vdCByZWFkIHByb3BlcnR5ICd0aGVuJyBvZiB1bmRlZmluZWRcblxuICAgICAgICAvLyB0b2RvIHJldHJ5IHdpdGggbmF2aWdhdG9yLmdldFVzZXJNZWRpYV8oKSBtYXliZT9cbiAgICAgICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgICAgICdTb3JyeSwgeW91ciBicm93c2VyIGlzIHVuYWJsZSB0byB1c2UgY2FtZXJhcy4nLFxuICAgICAgICAgICdUcnkgYSBkaWZmZXJlbnQgYnJvd3NlciB3aXRoIGJldHRlciB1c2VyIG1lZGlhIGZ1bmN0aW9uYWxpdGllcy4nLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnUmVjb3JkZXI6IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEoKScpXG5cbiAgICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWFfKHtcbiAgICAgICAgdmlkZW86IHRydWUsXG4gICAgICAgIGF1ZGlvOiBvcHRpb25zLmlzQXVkaW9FbmFibGVkKClcbiAgICAgIH0sIGdldFVzZXJNZWRpYUNhbGxiYWNrLCB1c2VyTWVkaWFFcnJvckNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvYWRVc2VyTWVkaWEgKCkge1xuICAgIGlmICh1c2VyTWVkaWFMb2FkZWQpIHtcbiAgICAgIGRlYnVnKCdSZWNvcmRlcjogc2tpcHBpbmcgbG9hZFVzZXJNZWRpYSgpIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSBsb2FkZWQnKVxuICAgICAgb25Vc2VyTWVkaWFSZWFkeSgpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKHVzZXJNZWRpYUxvYWRpbmcpIHtcbiAgICAgIGRlYnVnKCdSZWNvcmRlcjogc2tpcHBpbmcgbG9hZFVzZXJNZWRpYSgpIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSBhc2tpbmcgZm9yIHBlcm1pc3Npb24nKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgZGVidWcoJ1JlY29yZGVyOiBsb2FkVXNlck1lZGlhKCknKVxuXG4gICAgc2VsZi5lbWl0KEV2ZW50cy5MT0FESU5HX1VTRVJfTUVESUEpXG5cbiAgICB0cnkge1xuICAgICAgdXNlck1lZGlhVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNlbGYuaXNSZWFkeSgpKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgYnJvd3Nlci5nZXROb0FjY2Vzc0lzc3VlKCkpXG4gICAgICAgIH1cbiAgICAgIH0sIG9wdGlvbnMudGltZW91dHMudXNlck1lZGlhKVxuXG4gICAgICB1c2VyTWVkaWFMb2FkaW5nID0gdHJ1ZVxuXG4gICAgICBsb2FkR2VudWluZVVzZXJNZWRpYSgpXG4gICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICBkZWJ1ZygnUmVjb3JkZXI6IGZhaWxlZCB0byBsb2FkIGdlbnVpbmUgdXNlciBtZWRpYScpXG5cbiAgICAgIHVzZXJNZWRpYUxvYWRpbmcgPSBmYWxzZVxuXG4gICAgICBjb25zdCBlcnJvckxpc3RlbmVycyA9IHNlbGYubGlzdGVuZXJzKEV2ZW50cy5FUlJPUilcblxuICAgICAgaWYgKGVycm9yTGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICBzZWxmLmVtaXQoRXZlbnRzLkVSUk9SLCBleGMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnUmVjb3JkZXI6IG5vIGVycm9yIGxpc3RlbmVycyBhdHRhY2hlZCBidXQgdGhyb3dpbmcgZXhjZXB0aW9uJywgZXhjKVxuICAgICAgICB0aHJvdyBleGMgLy8gdGhyb3cgaXQgZnVydGhlclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4ZWN1dGVDb21tYW5kIChjb21tYW5kKSB7XG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKFxuICAgICAgICAnU2VydmVyIGNvbW1hbmRlZDogJXMnLFxuICAgICAgICBjb21tYW5kLmNvbW1hbmQsXG4gICAgICAgIGNvbW1hbmQuYXJncyA/ICcsICcgKyBzdHJpbmdpZnkoY29tbWFuZC5hcmdzKSA6ICcnXG4gICAgICApXG5cbiAgICAgIHN3aXRjaCAoY29tbWFuZC5jb21tYW5kKSB7XG4gICAgICAgIGNhc2UgJ3JlYWR5JzpcbiAgICAgICAgICBpZiAoIXVzZXJNZWRpYVRpbWVvdXQpIHsgbG9hZFVzZXJNZWRpYSgpIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwcmV2aWV3JzpcbiAgICAgICAgICBwcmV2aWV3KGNvbW1hbmQuYXJncylcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgdGhpcy5lbWl0KEV2ZW50cy5FUlJPUiwgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgICAgICAgJ09oIG5vLCBzZXJ2ZXIgZXJyb3IhJyxcbiAgICAgICAgICAgIGNvbW1hbmQuYXJncy5lcnIudG9TdHJpbmcoKSB8fCAnKE5vIGV4cGxhbmF0aW9uIGdpdmVuKScsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdjb25maXJtRnJhbWUnOlxuICAgICAgICAgIHVwZGF0ZUZyYW1lUHJvZ3Jlc3MoY29tbWFuZC5hcmdzKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2NvbmZpcm1TYW1wbGUnOlxuICAgICAgICAgIHVwZGF0ZVNhbXBsZVByb2dyZXNzKGNvbW1hbmQuYXJncylcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdiZWdpbkF1ZGlvRW5jb2RpbmcnOlxuICAgICAgICAgIHRoaXMuZW1pdChFdmVudHMuQkVHSU5fQVVESU9fRU5DT0RJTkcpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnYmVnaW5WaWRlb0VuY29kaW5nJzpcbiAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkJFR0lOX1ZJREVPX0VOQ09ESU5HKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5lbWl0KEV2ZW50cy5FUlJPUiwgJ1Vua25vd24gc2VydmVyIGNvbW1hbmQ6ICcgKyBjb21tYW5kLmNvbW1hbmQpXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGV4YylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc05vdGlmeWluZyAoKSB7XG4gICAgcmV0dXJuIHZpc3VhbHMuaXNOb3RpZnlpbmcoKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNIaWRkZW4gKCkge1xuICAgIHJldHVybiAhcmVjb3JkZXJFbGVtZW50IHx8IGhpZGRlbihyZWNvcmRlckVsZW1lbnQpXG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZUNvbW1hbmQgKGNvbW1hbmQsIGFyZ3MsIGNiKSB7XG4gICAgaWYgKCFjYiAmJiBhcmdzICYmIGFyZ3MuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XG4gICAgICBjYiA9IGFyZ3NcbiAgICAgIGFyZ3MgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgIGRlYnVnKCdSZWNvbm5lY3RpbmcgZm9yIHRoZSBjb21tYW5kJywgY29tbWFuZCwgJ+KApicpXG5cbiAgICAgIGluaXRTb2NrZXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB3cml0ZUNvbW1hbmQoY29tbWFuZCwgYXJncylcbiAgICAgICAgY2IgJiYgY2IoKVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKHN0cmVhbSkge1xuICAgICAgZGVidWcoJyQgJXMnLCBjb21tYW5kLCBhcmdzID8gc3RyaW5naWZ5KGFyZ3MpIDogJycpXG5cbiAgICAgIGNvbnN0IGNvbW1hbmRPYmogPSB7XG4gICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgIH1cblxuICAgICAgLy8gdG9kbyBjb21tZW50ZWQgb3V0IGJlY2F1c2UgZm9yIHNvbWUgcmVhc29ucyBzZXJ2ZXIgZG9lcyBub3QgYWNjZXB0IHN1Y2ggYSBsb25nXG4gICAgICAvLyBhcnJheSBvZiBtYW55IGxvZyBsaW5lcy4gdG8gZXhhbWluZSBsYXRlci5cbiAgICAgIC8vXG4gICAgICAvLyBhZGQgc29tZSB1c2VmdWwgZGVidWcgaW5mbyB0byBleGFtaW5lIHdlaXJkIHN0dWZmIGxpa2UgdGhpcyBvbmVcbiAgICAgIC8vIFVucHJvY2Vzc2FibGVFcnJvcjogVW5hYmxlIHRvIGVuY29kZSBhIHZpZGVvIHdpdGggRlBTIG5lYXIgemVyby5cbiAgICAgIC8vIHRvZG8gY29uc2lkZXIgcmVtb3ZpbmcgdGhpcyBsYXRlciBvciBoYXZlIGl0IGZvciBkZWJ1Zz0xIG9ubHk/XG4gICAgICAvL1xuICAgICAgLy8gaWYgKG9wdGlvbnMubG9nZ2VyICYmIG9wdGlvbnMubG9nZ2VyLmdldExpbmVzKSB7XG4gICAgICAvLyAgIGNvbW1hbmRPYmoubG9nTGluZXMgPSBvcHRpb25zLmxvZ2dlci5nZXRMaW5lcygpXG4gICAgICAvLyB9XG5cbiAgICAgIHdyaXRlU3RyZWFtKEJ1ZmZlci5mcm9tKHN0cmluZ2lmeShjb21tYW5kT2JqKSkpXG5cbiAgICAgIGlmIChjYikge1xuICAgICAgICAvLyBrZWVwIGFsbCBjYWxsYmFja3MgYXN5bmNcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2IoKVxuICAgICAgICB9LCAwKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2Nvbm5lY3QgKCkge1xuICAgIGlmIChjb25uZWN0ZWQpIHtcbiAgICAgIGRlYnVnKCdSZWNvcmRlcjogZGlzY29ubmVjdCgpJylcblxuICAgICAgaWYgKHVzZXJNZWRpYSkge1xuICAgICAgICAvLyBwcmV2ZW50cyBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwtY2xpZW50L2lzc3Vlcy8xMTRcbiAgICAgICAgdXNlck1lZGlhLnVubG9hZFJlbWFpbmluZ0V2ZW50TGlzdGVuZXJzKClcbiAgICAgIH1cblxuICAgICAgaWYgKHN1Ym1pdHRpbmcpIHtcbiAgICAgICAgLy8gc2VydmVyIHdpbGwgZGlzY29ubmVjdCBzb2NrZXQgYXV0b21hdGljYWxseSBhZnRlciBzdWJtaXR0aW5nXG4gICAgICAgIGNvbm5lY3RpbmcgPSBjb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmIChzdHJlYW0pIHtcbiAgICAgICAgLy8gZm9yY2UgdG8gZGlzY29ubmVjdCBzb2NrZXQgcmlnaHQgbm93IHRvIGNsZWFuIHRlbXAgZmlsZXMgb24gc2VydmVyXG4gICAgICAgIC8vIGV2ZW50IGxpc3RlbmVycyB3aWxsIGRvIHRoZSByZXN0XG4gICAgICAgIHN0cmVhbS5lbmQoKVxuICAgICAgICBzdHJlYW0gPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWxBbmltYXRpb25GcmFtZSAoKSB7XG4gICAgbG9vcCAmJiBsb29wLmRpc3Bvc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW50ZXJ2YWxTdW0gKCkge1xuICAgIHJldHVybiBsb29wLmdldEVsYXBzZWRUaW1lKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEF2Z0ludGVydmFsICgpIHtcbiAgICByZXR1cm4gKGdldEludGVydmFsU3VtKCkgLyBmcmFtZXNDb3VudClcbiAgfVxuXG4gIHRoaXMuZ2V0UmVjb3JkaW5nU3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlY29yZGluZ1N0YXRzXG4gIH1cblxuICB0aGlzLmdldEF1ZGlvU2FtcGxlUmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXNlck1lZGlhLmdldEF1ZGlvU2FtcGxlUmF0ZSgpXG4gIH1cblxuICB0aGlzLnN0b3AgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgZGVidWcoJ3N0b3AoKScsIHBhcmFtcylcblxuICAgIGNvbnN0IGxpbWl0UmVhY2hlZCA9IHBhcmFtcy5saW1pdFJlYWNoZWRcblxuICAgIHRoaXMuZW1pdChFdmVudHMuU1RPUFBJTkcsIGxpbWl0UmVhY2hlZClcblxuICAgIGxvb3AuY29tcGxldGUoKVxuXG4gICAgc3RvcFRpbWUgPSBEYXRlLm5vdygpXG5cbiAgICByZWNvcmRpbmdTdGF0cyA9IHtcbiAgICAgIGF2Z0ZwczogbG9vcC5nZXRGUFMoKSxcbiAgICAgIHdhbnRlZEZwczogb3B0aW9ucy52aWRlby5mcHMsXG4gICAgICBhdmdJbnRlcnZhbDogZ2V0QXZnSW50ZXJ2YWwoKSxcbiAgICAgIHdhbnRlZEludGVydmFsOiAxZTMgLyBvcHRpb25zLnZpZGVvLmZwcyxcblxuICAgICAgaW50ZXJ2YWxTdW06IGdldEludGVydmFsU3VtKCksXG4gICAgICBmcmFtZXNDb3VudDogZnJhbWVzQ291bnQsXG4gICAgICB2aWRlb1R5cGU6IHJlcGxheS5nZXRWaWRlb1R5cGUoKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmlzQXVkaW9FbmFibGVkKCkpIHtcbiAgICAgIHJlY29yZGluZ1N0YXRzLnNhbXBsZXNDb3VudCA9IHNhbXBsZXNDb3VudFxuICAgICAgcmVjb3JkaW5nU3RhdHMuc2FtcGxlUmF0ZSA9IHVzZXJNZWRpYS5nZXRBdWRpb1NhbXBsZVJhdGUoKVxuICAgIH1cblxuICAgIHdyaXRlQ29tbWFuZCgnc3RvcCcsIHJlY29yZGluZ1N0YXRzKVxuXG4gICAgLy8gYmV3YXJlLCByZXNldHRpbmcgd2lsbCBzZXQgZnJhbWVzQ291bnQgdG8gemVybywgc28gbGVhdmUgdGhpcyBoZXJlXG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICB0aGlzLmJhY2sgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB0aGlzLmVtaXQoRXZlbnRzLkdPSU5HX0JBQ0spXG5cbiAgICBzaG93KClcbiAgICB0aGlzLnJlc2V0KClcblxuICAgIHdyaXRlQ29tbWFuZCgnYmFjaycsIGNiKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVJbml0aWFsaXNlQXVkaW8gKCkge1xuICAgIGRlYnVnKCdSZWNvcmRlcjogcmVJbml0aWFsaXNlQXVkaW8oKScpXG5cbiAgICBjbGVhclVzZXJNZWRpYVRpbWVvdXQoKVxuXG4gICAgLy8gaW1wb3J0YW50IHRvIGZyZWUgbWVtb3J5XG4gICAgdXNlck1lZGlhICYmIHVzZXJNZWRpYS5zdG9wKClcblxuICAgIHVzZXJNZWRpYUxvYWRlZCA9IGtleSA9IGNhbnZhcyA9IGN0eCA9IG51bGxcblxuICAgIGxvYWRVc2VyTWVkaWEoKVxuICB9XG5cbiAgdGhpcy51bmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghdW5sb2FkZWQpIHtcbiAgICAgIHZhciBjYXVzZVxuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBjYXVzZSA9IGUubmFtZSB8fCBlLnN0YXR1c1RleHQgfHwgZS50b1N0cmluZygpXG4gICAgICB9XG5cbiAgICAgIGRlYnVnKCdSZWNvcmRlcjogdW5sb2FkKCknICsgKGNhdXNlID8gJywgY2F1c2U6ICcgKyBjYXVzZSA6ICcnKSlcblxuICAgICAgdGhpcy5yZXNldCgpXG5cbiAgICAgIGNsZWFyVXNlck1lZGlhVGltZW91dCgpXG5cbiAgICAgIGRpc2Nvbm5lY3QoKVxuXG4gICAgICB1bmxvYWRlZCA9IHRydWVcblxuICAgICAgYnVpbHQgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbm8gbmVlZCB0byByZXNldCB3aGVuIGFscmVhZHkgdW5sb2FkZWRcbiAgICBpZiAoIXVubG9hZGVkKSB7XG4gICAgICBkZWJ1ZygnUmVjb3JkZXI6IHJlc2V0KCknKVxuXG4gICAgICB0aGlzLmVtaXQoRXZlbnRzLlJFU0VUVElORylcblxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoKVxuXG4gICAgICAvLyBpbXBvcnRhbnQgdG8gZnJlZSBtZW1vcnlcbiAgICAgIHVzZXJNZWRpYSAmJiB1c2VyTWVkaWEuc3RvcCgpXG5cbiAgICAgIHJlcGxheS5yZXNldCgpXG5cbiAgICAgIHVzZXJNZWRpYUxvYWRlZCA9IGtleSA9IGNhbnZhcyA9IGN0eCA9IHdhaXRpbmdUaW1lID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHRoaXMudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbm5lY3RlZCAmJiBmcmFtZXNDb3VudCA+IDAgJiYgY2FudmFzID09PSBudWxsXG4gIH1cblxuICB0aGlzLmlzUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVzZXJNZWRpYS5pc1JlYWR5KClcbiAgfVxuXG4gIHRoaXMucGF1c2UgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgY29uc3QgZSA9IHBhcmFtcyAmJiBwYXJhbXMuZXZlbnRcblxuICAgIGlmIChlIGluc3RhbmNlb2Ygd2luZG93LkV2ZW50KSB7XG4gICAgICBwYXJhbXMuZXZlbnRUeXBlID0gZS50eXBlXG4gICAgfVxuXG4gICAgZGVidWcoJ3BhdXNlKCknLCBwYXJhbXMpXG5cbiAgICB1c2VyTWVkaWEucGF1c2UoKVxuICAgIGxvb3Auc3RvcCgpXG5cbiAgICB0aGlzLmVtaXQoRXZlbnRzLlBBVVNFRClcblxuICAgIHNlbmRQaW5ncygpXG4gIH1cblxuICB0aGlzLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1c2VyTWVkaWEgJiYgdXNlck1lZGlhLmlzUGF1c2VkKClcbiAgfVxuXG4gIHRoaXMucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCdSZWNvcmRlcjogcmVzdW1lKCknKVxuXG4gICAgc3RvcFBpbmdzKClcblxuICAgIHRoaXMuZW1pdChFdmVudHMuUkVTVU1JTkcpXG5cbiAgICB1c2VyTWVkaWEucmVzdW1lKClcbiAgICBsb29wLnN0YXJ0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRmx1c2hlZCAob3B0cykge1xuICAgIGNvbnN0IGZyYW1lTnVtYmVyID0gb3B0cyAmJiBvcHRzLmZyYW1lTnVtYmVyXG5cbiAgICBpZiAoZnJhbWVOdW1iZXIgPT09IDEpIHtcbiAgICAgIHNlbGYuZW1pdChFdmVudHMuRklSU1RfRlJBTUVfU0VOVClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVMb29wICgpIHtcbiAgICBjb25zdCBuZXdMb29wID0gYW5pbWl0dGVyKHsgZnBzOiBvcHRpb25zLnZpZGVvLmZwcyB9LCBkcmF3KVxuXG4gICAgLy8gcmVtZW1iZXIgaXQgZmlyc3RcbiAgICBvcmlnaW5hbEFuaW1hdGlvbkZyYW1lT2JqZWN0ID0gbmV3TG9vcC5nZXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVPYmplY3QoKVxuXG4gICAgcmV0dXJuIG5ld0xvb3BcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXcgKGRlbHRhVGltZSwgZWxhcHNlZFRpbWUpIHtcbiAgICB0cnkge1xuICAgICAgLy8gY3R4IGFuZCBzdHJlYW0gbWlnaHQgYmVjb21lIG51bGwgd2hpbGUgdW5sb2FkaW5nXG4gICAgICBpZiAoIXNlbGYuaXNQYXVzZWQoKSAmJiBzdHJlYW0gJiYgY3R4KSB7XG4gICAgICAgIGlmIChmcmFtZXNDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHNlbGYuZW1pdChFdmVudHMuU0VORElOR19GSVJTVF9GUkFNRSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lc0NvdW50KytcblxuICAgICAgICBjdHguZHJhd0ltYWdlKFxuICAgICAgICAgIHVzZXJNZWRpYS5nZXRSYXdWaXN1YWxzKCksXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGNhbnZhcy53aWR0aCxcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0XG4gICAgICAgIClcblxuICAgICAgICByZWNvcmRpbmdCdWZmZXIgPSBmcmFtZS50b0J1ZmZlcigpXG4gICAgICAgIHJlY29yZGluZ0J1ZmZlckxlbmd0aCA9IHJlY29yZGluZ0J1ZmZlci5sZW5ndGhcblxuICAgICAgICBpZiAocmVjb3JkaW5nQnVmZmVyTGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnRmFpbGVkIHRvIGV4dHJhY3Qgd2ViY2FtIGRhdGEuJywgb3B0aW9ucylcbiAgICAgICAgfVxuXG4gICAgICAgIGJ5dGVzU3VtICs9IHJlY29yZGluZ0J1ZmZlckxlbmd0aFxuXG4gICAgICAgIHdyaXRlU3RyZWFtKHJlY29yZGluZ0J1ZmZlciwge1xuICAgICAgICAgIGZyYW1lTnVtYmVyOiBmcmFtZXNDb3VudCxcbiAgICAgICAgICBvbkZsdXNoZWRDYWxsYmFjazogb25GbHVzaGVkXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gaWYgKG9wdGlvbnMudmVyYm9zZSkge1xuICAgICAgICAvLyAgIGRlYnVnKFxuICAgICAgICAvLyAgICAgJ0ZyYW1lICMnICsgZnJhbWVzQ291bnQgKyAnICgnICsgcmVjb3JkaW5nQnVmZmVyTGVuZ3RoICsgJyBieXRlcyk6JyxcbiAgICAgICAgLy8gICAgICcgZGVsdGE9JyArIGRlbHRhVGltZSArICdtcywgJyArXG4gICAgICAgIC8vICAgICAnIGVsYXBzZWQ9JyArIGVsYXBzZWRUaW1lICsgJ21zJ1xuICAgICAgICAvLyAgIClcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHZpc3VhbHMuY2hlY2tUaW1lcih7IGludGVydmFsU3VtOiBlbGFwc2VkVGltZSB9KVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXhjKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMucmVjb3JkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh1bmxvYWRlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gcmVjb25uZWN0IHdoZW4gbmVlZGVkXG4gICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgIGRlYnVnKCdSZWNvcmRlcjogcmVjb25uZWN0aW5nIGJlZm9yZSByZWNvcmRpbmcgLi4uJylcblxuICAgICAgaW5pdFNvY2tldChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25jZShFdmVudHMuVVNFUl9NRURJQV9SRUFEWSwgc2VsZi5yZWNvcmQpXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY2FudmFzID0gdXNlck1lZGlhLmNyZWF0ZUNhbnZhcygpXG4gICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICBzZWxmLmVtaXQoXG4gICAgICAgIEV2ZW50cy5FUlJPUixcbiAgICAgICAgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKGV4Yywgb3B0aW9ucylcbiAgICAgIClcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIGlmICghY2FudmFzLndpZHRoKSB7XG4gICAgICBzZWxmLmVtaXQoXG4gICAgICAgIEV2ZW50cy5FUlJPUixcbiAgICAgICAgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdDYW52YXMgaGFzIGFuIGludmFsaWQgd2lkdGguJywgb3B0aW9ucylcbiAgICAgIClcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCFjYW52YXMuaGVpZ2h0KSB7XG4gICAgICBzZWxmLmVtaXQoXG4gICAgICAgIEV2ZW50cy5FUlJPUixcbiAgICAgICAgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdDYW52YXMgaGFzIGFuIGludmFsaWQgaGVpZ2h0LicsIG9wdGlvbnMpXG4gICAgICApXG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGJ5dGVzU3VtID0gMFxuXG4gICAgZnJhbWUgPSBuZXcgRnJhbWUoY2FudmFzLCBvcHRpb25zKVxuXG4gICAgZGVidWcoJ1JlY29yZGVyOiByZWNvcmQoKScpXG4gICAgdXNlck1lZGlhLnJlY29yZCgpXG5cbiAgICBzZWxmLmVtaXQoRXZlbnRzLlJFQ09SRElORywgZnJhbWVzQ291bnQpXG5cbiAgICBsb29wLnN0YXJ0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEFuaW1hdGlvbkZyYW1lT2JqZWN0IChuZXdPYmopIHtcbiAgICAvLyBtdXN0IHN0b3AgYW5kIHRoZW4gc3RhcnQgdG8gbWFrZSBpdCBiZWNvbWUgZWZmZWN0aXZlLCBzZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaGFwdGljZGF0YS9hbmltaXR0ZXIvaXNzdWVzLzUjaXNzdWVjb21tZW50LTI5MjAxOTE2OFxuICAgIGlmIChsb29wKSB7XG4gICAgICBjb25zdCBpc1JlY29yZGluZyA9IHNlbGYuaXNSZWNvcmRpbmcoKVxuXG4gICAgICBsb29wLnN0b3AoKVxuICAgICAgbG9vcC5zZXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVPYmplY3QobmV3T2JqKVxuXG4gICAgICBpZiAoaXNSZWNvcmRpbmcpIHtcbiAgICAgICAgbG9vcC5zdGFydCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZUFuaW1hdGlvbkZyYW1lT2JqZWN0ICgpIHtcbiAgICBkZWJ1ZygnUmVjb3JkZXI6IHJlc3RvcmVBbmltYXRpb25GcmFtZU9iamVjdCgpJylcblxuICAgIHNldEFuaW1hdGlvbkZyYW1lT2JqZWN0KG9yaWdpbmFsQW5pbWF0aW9uRnJhbWVPYmplY3QpXG4gIH1cblxuICBmdW5jdGlvbiBsb29wV2l0aFRpbWVvdXRzICgpIHtcbiAgICBkZWJ1ZygnUmVjb3JkZXI6IGxvb3BXaXRoVGltZW91dHMoKScpXG5cbiAgICBjb25zdCB3YW50ZWRJbnRlcnZhbCA9IDFlMyAvIG9wdGlvbnMudmlkZW8uZnBzXG5cbiAgICB2YXIgcHJvY2Vzc2luZ1RpbWUgPSAwXG4gICAgdmFyIHN0YXJ0XG5cbiAgICBmdW5jdGlvbiByYWYgKGZuKSB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgICAgICAgIGZuKClcbiAgICAgICAgICBwcm9jZXNzaW5nVGltZSA9IERhdGUubm93KCkgLSBzdGFydFxuICAgICAgICB9LFxuICAgICAgICAvLyByZWR1Y2luZyB3YW50ZWQgaW50ZXJ2YWwgYnkgcmVzcGVjdGluZyB0aGUgdGltZSBpdCB0YWtlcyB0b1xuICAgICAgICAvLyBjb21wdXRlIGludGVybmFsbHkgc2luY2UgdGhpcyBpcyBub3QgbXVsdGktdGhyZWFkZWQgbGlrZVxuICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgd2FudGVkSW50ZXJ2YWwgLSBwcm9jZXNzaW5nVGltZVxuICAgICAgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbmNlbCAoaWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpZClcbiAgICB9XG5cbiAgICBzZXRBbmltYXRpb25GcmFtZU9iamVjdCh7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IHJhZixcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lOiBjYW5jZWxcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRFbGVtZW50ICgpIHtcbiAgICByZWNvcmRlckVsZW1lbnQgPSBoKCd2aWRlby4nICsgb3B0aW9ucy5zZWxlY3RvcnMudXNlck1lZGlhQ2xhc3MpXG4gICAgdmlzdWFscy5hcHBlbmRDaGlsZChyZWNvcmRlckVsZW1lbnQpXG4gIH1cblxuICBmdW5jdGlvbiBjb3JyZWN0RGltZW5zaW9ucyAoKSB7XG4gICAgaWYgKG9wdGlvbnMuaGFzRGVmaW5lZFdpZHRoKCkpIHtcbiAgICAgIHJlY29yZGVyRWxlbWVudC53aWR0aCA9IHNlbGYuZ2V0UmVjb3JkZXJXaWR0aCh0cnVlKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhc0RlZmluZWRIZWlnaHQoKSkge1xuICAgICAgcmVjb3JkZXJFbGVtZW50LmhlaWdodCA9IHNlbGYuZ2V0UmVjb3JkZXJIZWlnaHQodHJ1ZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzd2l0Y2hGYWNpbmdNb2RlICgpIHtcbiAgICBpZiAoIWJyb3dzZXIuaXNNb2JpbGUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGZhY2luZ01vZGUgPT09ICd1c2VyJykge1xuICAgICAgZmFjaW5nTW9kZSA9ICdlbnZpcm9ubWVudCdcbiAgICB9IGVsc2UgaWYgKGZhY2luZ01vZGUgPT09ICdlbnZpcm9ubWVudCcpIHtcbiAgICAgIGZhY2luZ01vZGUgPSAndXNlcidcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ1JlY29yZGVyOiB1bnNwcG9ydGVkIGZhY2luZyBtb2RlJywgZmFjaW5nTW9kZSlcbiAgICB9XG5cbiAgICBsb2FkR2VudWluZVVzZXJNZWRpYSh7IHN3aXRjaGluZ0ZhY2luZ01vZGU6IHRydWUgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRFdmVudHMgKCkge1xuICAgIGRlYnVnKCdSZWNvcmRlcjogaW5pdEV2ZW50cygpJylcblxuICAgIHNlbGZcbiAgICAgIC5vbihFdmVudHMuU1VCTUlUVElORywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzdWJtaXR0aW5nID0gdHJ1ZVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuU1VCTUlUVEVELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN1Ym1pdHRpbmcgPSBmYWxzZVxuICAgICAgICBzZWxmLnVubG9hZCgpXG4gICAgICB9KVxuICAgICAgLm9uKEV2ZW50cy5CTE9DS0lORywgZnVuY3Rpb24gKCkge1xuICAgICAgICBibG9ja2luZyA9IHRydWVcbiAgICAgICAgY2xlYXJVc2VyTWVkaWFUaW1lb3V0KClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLkhJREUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5oaWRlKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLkxPQURFRF9NRVRBX0RBVEEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29ycmVjdERpbWVuc2lvbnMoKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuRElTQUJMSU5HX0FVRElPLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlSW5pdGlhbGlzZUF1ZGlvKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLkVOQUJMSU5HX0FVRElPLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlSW5pdGlhbGlzZUF1ZGlvKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLklOVklTSUJMRSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBsb29wV2l0aFRpbWVvdXRzKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLlZJU0lCTEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzdG9yZUFuaW1hdGlvbkZyYW1lT2JqZWN0KClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLlNXSVRDSF9GQUNJTkdfTU9ERSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2hGYWNpbmdNb2RlKClcbiAgICAgIH0pXG4gIH1cblxuICB0aGlzLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlcnIgPSBicm93c2VyLmNoZWNrUmVjb3JkaW5nQ2FwYWJpbGl0aWVzKClcblxuICAgIGlmICghZXJyKSB7XG4gICAgICBlcnIgPSBicm93c2VyLmNoZWNrQnVmZmVyVHlwZXMoKVxuICAgIH1cblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXMuZW1pdChFdmVudHMuRVJST1IsIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb3JkZXJFbGVtZW50ID0gdmlzdWFscy5xdWVyeVNlbGVjdG9yKCd2aWRlby4nICsgb3B0aW9ucy5zZWxlY3RvcnMudXNlck1lZGlhQ2xhc3MpXG5cbiAgICAgIGlmICghcmVjb3JkZXJFbGVtZW50KSB7XG4gICAgICAgIGJ1aWxkRWxlbWVudCgpXG4gICAgICB9XG5cbiAgICAgIGNvcnJlY3REaW1lbnNpb25zKClcblxuICAgICAgLy8gcHJldmVudCBhdWRpbyBmZWVkYmFjaywgc2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwtY2xpZW50L2lzc3Vlcy8zNVxuICAgICAgcmVjb3JkZXJFbGVtZW50Lm11dGVkID0gdHJ1ZVxuXG4gICAgICAvLyBmb3IgaXBob25lcywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGMvc2FtcGxlcy9pc3N1ZXMvOTI5XG4gICAgICByZWNvcmRlckVsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsIHRydWUpXG4gICAgICByZWNvcmRlckVsZW1lbnQuc2V0QXR0cmlidXRlKCd3ZWJraXQtcGxheXNpbmxpbmUnLCAnd2Via2l0LXBsYXlzaW5saW5lJylcblxuICAgICAgaWYgKCF1c2VyTWVkaWEpIHtcbiAgICAgICAgdXNlck1lZGlhID0gbmV3IFVzZXJNZWRpYSh0aGlzLCBvcHRpb25zKVxuICAgICAgfVxuXG4gICAgICBzaG93KClcblxuICAgICAgaWYgKCFidWlsdCkge1xuICAgICAgICBpbml0RXZlbnRzKClcblxuICAgICAgICBpZiAoIWNvbm5lY3RlZCkge1xuICAgICAgICAgIGluaXRTb2NrZXQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvYWRVc2VyTWVkaWEoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkVXNlck1lZGlhKClcbiAgICAgIH1cblxuICAgICAgYnVpbHQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgdGhpcy5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXNlck1lZGlhICYmIHVzZXJNZWRpYS5pc1BhdXNlZCgpICYmICFsb29wLmlzUnVubmluZygpXG4gIH1cblxuICB0aGlzLmlzUmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGNoZWNraW5nIGZvciBzdHJlYW0uZGVzdHJveWVkIG5lZWRlZCBzaW5jZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC5pby9pc3N1ZXMvMjk2XG4gICAgcmV0dXJuIGxvb3AgJiYgbG9vcC5pc1J1bm5pbmcoKSAmJiAhdGhpcy5pc1BhdXNlZCgpICYmICFpc05vdGlmeWluZygpICYmIHN0cmVhbSAmJiAhc3RyZWFtLmRlc3Ryb3llZFxuICB9XG5cbiAgdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNIaWRkZW4oKSkge1xuICAgICAgcmVjb3JkZXJFbGVtZW50ICYmIGhpZGRlbihyZWNvcmRlckVsZW1lbnQsIHRydWUpXG5cbiAgICAgIGNsZWFyVXNlck1lZGlhVGltZW91dCgpXG4gICAgICBjbGVhclJldHJ5VGltZW91dCgpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5pc1VubG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1bmxvYWRlZFxuICB9XG5cbiAgLy8gdGhlc2UgdHdvIHJldHVybiB0aGUgdHJ1ZSBkaW1lbnNpb25zIG9mIHRoZSB3ZWJjYW0gYXJlYS5cbiAgLy8gbmVlZGVkIGJlY2F1c2Ugb24gbW9iaWxlcyB0aGV5IG1pZ2h0IGJlIGRpZmZlcmVudC5cblxuICB0aGlzLmdldFJlY29yZGVyV2lkdGggPSBmdW5jdGlvbiAocmVzcG9uc2l2ZSkge1xuICAgIGlmICh1c2VyTWVkaWEgJiYgdXNlck1lZGlhLmhhc1ZpZGVvV2lkdGgoKSkge1xuICAgICAgcmV0dXJuIHVzZXJNZWRpYS5nZXRSYXdXaWR0aChyZXNwb25zaXZlKVxuICAgIH0gZWxzZSBpZiAocmVzcG9uc2l2ZSAmJiBvcHRpb25zLmhhc0RlZmluZWRXaWR0aCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saW1pdFdpZHRoKG9wdGlvbnMudmlkZW8ud2lkdGgpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5nZXRSZWNvcmRlckhlaWdodCA9IGZ1bmN0aW9uIChyZXNwb25zaXZlKSB7XG4gICAgaWYgKHVzZXJNZWRpYSkge1xuICAgICAgcmV0dXJuIHVzZXJNZWRpYS5nZXRSYXdIZWlnaHQocmVzcG9uc2l2ZSlcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNpdmUgJiYgb3B0aW9ucy5oYXNEZWZpbmVkSGVpZ2h0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUhlaWdodChyZXNwb25zaXZlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhdGlvICgpIHtcbiAgICB2YXIgcmF0aW9cblxuICAgIGlmICh1c2VyTWVkaWEpIHtcbiAgICAgIGNvbnN0IHVzZXJNZWRpYVZpZGVvV2lkdGggPSB1c2VyTWVkaWEuZ2V0VmlkZW9XaWR0aCgpXG5cbiAgICAgIC8vIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm9cbiAgICAgIGlmICh1c2VyTWVkaWFWaWRlb1dpZHRoIDwgMSkge1xuICAgICAgICAvLyB1c2UgYXMgYSBsYXN0IHJlc29ydCBmYWxsYmFjayBjb21wdXRhdGlvbiAobmVlZGVkIGZvciBzYWZhcmkgMTEpXG4gICAgICAgIHJhdGlvID0gdmlzdWFscy5nZXRSYXRpbygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYXRpbyA9IHVzZXJNZWRpYS5nZXRWaWRlb0hlaWdodCgpIC8gdXNlck1lZGlhVmlkZW9XaWR0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYXRpbyA9IG9wdGlvbnMuZ2V0UmF0aW8oKVxuICAgIH1cblxuICAgIHJldHVybiByYXRpb1xuICB9XG5cbiAgdGhpcy5jYWxjdWxhdGVXaWR0aCA9IGZ1bmN0aW9uIChyZXNwb25zaXZlKSB7XG4gICAgdmFyIHZpZGVvSGVpZ2h0XG5cbiAgICBpZiAodXNlck1lZGlhKSB7XG4gICAgICB2aWRlb0hlaWdodCA9IHVzZXJNZWRpYS5nZXRWaWRlb0hlaWdodCgpXG4gICAgfSBlbHNlIGlmIChyZWNvcmRlckVsZW1lbnQpIHtcbiAgICAgIHZpZGVvSGVpZ2h0ID0gcmVjb3JkZXJFbGVtZW50LnZpZGVvSGVpZ2h0IHx8IHJlY29yZGVyRWxlbWVudC5oZWlnaHRcbiAgICB9XG5cbiAgICByZXR1cm4gdmlzdWFscy5jYWxjdWxhdGVXaWR0aCh7XG4gICAgICByZXNwb25zaXZlOiByZXNwb25zaXZlLFxuICAgICAgcmF0aW86IGdldFJhdGlvKCksXG4gICAgICB2aWRlb0hlaWdodDogdmlkZW9IZWlnaHRcbiAgICB9KVxuICB9XG5cbiAgdGhpcy5jYWxjdWxhdGVIZWlnaHQgPSBmdW5jdGlvbiAocmVzcG9uc2l2ZSkge1xuICAgIHZhciB2aWRlb1dpZHRoXG5cbiAgICBpZiAodXNlck1lZGlhKSB7XG4gICAgICB2aWRlb1dpZHRoID0gdXNlck1lZGlhLmdldFZpZGVvV2lkdGgoKVxuICAgIH0gZWxzZSBpZiAocmVjb3JkZXJFbGVtZW50KSB7XG4gICAgICB2aWRlb1dpZHRoID0gcmVjb3JkZXJFbGVtZW50LnZpZGVvV2lkdGggfHwgcmVjb3JkZXJFbGVtZW50LndpZHRoXG4gICAgfVxuXG4gICAgcmV0dXJuIHZpc3VhbHMuY2FsY3VsYXRlSGVpZ2h0KHtcbiAgICAgIHJlc3BvbnNpdmU6IHJlc3BvbnNpdmUsXG4gICAgICByYXRpbzogZ2V0UmF0aW8oKSxcbiAgICAgIHZpZGVvV2lkdGg6IHZpZGVvV2lkdGhcbiAgICB9KVxuICB9XG5cbiAgdGhpcy5nZXRSYXdWaXN1YWxVc2VyTWVkaWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlY29yZGVyRWxlbWVudFxuICB9XG5cbiAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29ubmVjdGVkXG4gIH1cblxuICB0aGlzLmlzQ29ubmVjdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29ubmVjdGluZ1xuICB9XG5cbiAgdGhpcy5saW1pdFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgcmV0dXJuIHZpc3VhbHMubGltaXRXaWR0aCh3aWR0aClcbiAgfVxuXG4gIHRoaXMubGltaXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHZpc3VhbHMubGltaXRIZWlnaHQoaGVpZ2h0KVxuICB9XG5cbiAgdGhpcy5pc1VzZXJNZWRpYUxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXNlck1lZGlhTG9hZGVkXG4gIH1cbn1cblxudXRpbC5pbmhlcml0cyhSZWNvcmRlciwgRXZlbnRFbWl0dGVyKVxuXG5leHBvcnQgZGVmYXVsdCBSZWNvcmRlclxuIiwiaW1wb3J0IHV0aWwgZnJvbSAndXRpbCdcbmltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IGhpZGRlbiBmcm9tICdoaWRkZW4nXG5pbXBvcnQgYWRkRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zIGZyb20gJ2FkZC1ldmVudGxpc3RlbmVyLXdpdGgtb3B0aW9ucydcblxuaW1wb3J0IEV2ZW50cyBmcm9tICcuLy4uLy4uL2V2ZW50cydcbmltcG9ydCBCcm93c2VyIGZyb20gJy4vLi4vLi4vdXRpbC9icm93c2VyJ1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLy4uLy4uL3V0aWwvZXZlbnRFbWl0dGVyJ1xuaW1wb3J0IFZpZGVvbWFpbEVycm9yIGZyb20gJy4vLi4vLi4vdXRpbC92aWRlb21haWxFcnJvcidcblxuaW1wb3J0IGVuYWJsZUlubGluZVZpZGVvIGZyb20gJ2lwaG9uZS1pbmxpbmUtdmlkZW8nXG5cbmNvbnN0IFJlcGxheSA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCBvcHRpb25zKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMsIG9wdGlvbnMsICdSZXBsYXknKVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGNvbnN0IGJyb3dzZXIgPSBuZXcgQnJvd3NlcihvcHRpb25zKVxuICBjb25zdCBkZWJ1ZyA9IG9wdGlvbnMuZGVidWdcblxuICB2YXIgYnVpbHRcbiAgdmFyIHJlcGxheUVsZW1lbnRcbiAgdmFyIHZpZGVvbWFpbFxuXG4gIGZ1bmN0aW9uIGJ1aWxkRWxlbWVudCAoKSB7XG4gICAgZGVidWcoJ1JlcGxheTogYnVpbGRFbGVtZW50KCknKVxuXG4gICAgcmVwbGF5RWxlbWVudCA9IGgoJ3ZpZGVvLicgKyBvcHRpb25zLnNlbGVjdG9ycy5yZXBsYXlDbGFzcylcblxuICAgIGlmICghcmVwbGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnUGxlYXNlIHVwZ3JhZGUgYnJvd3NlcicsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChyZXBsYXlFbGVtZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTdGFuZGFsb25lICgpIHtcbiAgICByZXR1cm4gcGFyZW50RWxlbWVudC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnSFRNTERpdkVsZW1lbnQnXG4gIH1cblxuICBmdW5jdGlvbiBjb3B5QXR0cmlidXRlcyAobmV3VmlkZW9tYWlsKSB7XG4gICAgdmFyIGF0dHJpYnV0ZUNvbnRhaW5lclxuXG4gICAgT2JqZWN0LmtleXMobmV3VmlkZW9tYWlsKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgIGF0dHJpYnV0ZUNvbnRhaW5lciA9IHBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignLicgKyBhdHRyaWJ1dGUpXG5cbiAgICAgIGlmIChhdHRyaWJ1dGVDb250YWluZXIpIHtcbiAgICAgICAgYXR0cmlidXRlQ29udGFpbmVyLmlubmVySFRNTCA9IG5ld1ZpZGVvbWFpbFthdHRyaWJ1dGVdXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcnJlY3REaW1lbnNpb25zIChvcHRpb25zKSB7XG4gICAgdmFyIHdpZHRoLCBoZWlnaHRcblxuICAgIGlmICh2aWRlb21haWwgJiYgdmlkZW9tYWlsLnBsYXllcldpZHRoKSB7XG4gICAgICB3aWR0aCA9IHZpZGVvbWFpbC5wbGF5ZXJXaWR0aFxuICAgIH0gZWxzZSBpZiAocGFyZW50RWxlbWVudC5jYWxjdWxhdGVXaWR0aCkge1xuICAgICAgd2lkdGggPSBwYXJlbnRFbGVtZW50LmNhbGN1bGF0ZVdpZHRoKG9wdGlvbnMpXG4gICAgfVxuXG4gICAgaWYgKHZpZGVvbWFpbCAmJiB2aWRlb21haWwucGxheWVySGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSB2aWRlb21haWwucGxheWVySGVpZ2h0XG4gICAgfSBlbHNlIGlmIChwYXJlbnRFbGVtZW50LmNhbGN1bGF0ZUhlaWdodCkge1xuICAgICAgaGVpZ2h0ID0gcGFyZW50RWxlbWVudC5jYWxjdWxhdGVIZWlnaHQob3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICByZXBsYXlFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxheUVsZW1lbnQuc3R5bGUud2lkdGggPSAnYXV0bydcbiAgICB9XG5cbiAgICBpZiAoaGVpZ2h0ID4gMCkge1xuICAgICAgcmVwbGF5RWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxheUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nXG4gICAgfVxuICB9XG5cbiAgdGhpcy5zZXRWaWRlb21haWwgPSBmdW5jdGlvbiAobmV3VmlkZW9tYWlsKSB7XG4gICAgdmlkZW9tYWlsID0gbmV3VmlkZW9tYWlsXG5cbiAgICBpZiAodmlkZW9tYWlsKSB7XG4gICAgICBpZiAodmlkZW9tYWlsLndlYm0pIHtcbiAgICAgICAgdGhpcy5zZXRXZWJNU291cmNlKHZpZGVvbWFpbC53ZWJtKVxuICAgICAgfVxuXG4gICAgICBpZiAodmlkZW9tYWlsLm1wNCkge1xuICAgICAgICB0aGlzLnNldE1wNFNvdXJjZSh2aWRlb21haWwubXA0KVxuICAgICAgfVxuXG4gICAgICBpZiAodmlkZW9tYWlsLnBvc3Rlcikge1xuICAgICAgICByZXBsYXlFbGVtZW50LnNldEF0dHJpYnV0ZSgncG9zdGVyJywgdmlkZW9tYWlsLnBvc3RlcilcbiAgICAgIH1cblxuICAgICAgY29weUF0dHJpYnV0ZXModmlkZW9tYWlsKVxuICAgIH1cblxuICAgIGNvbnN0IGhhc0F1ZGlvID0gdmlkZW9tYWlsICYmIHZpZGVvbWFpbC5yZWNvcmRpbmdTdGF0cyAmJiB2aWRlb21haWwucmVjb3JkaW5nU3RhdHMuc2FtcGxlUmF0ZSA+IDBcblxuICAgIHRoaXMuc2hvdyhcbiAgICAgIHZpZGVvbWFpbCAmJiB2aWRlb21haWwud2lkdGgsXG4gICAgICB2aWRlb21haWwgJiYgdmlkZW9tYWlsLmhlaWdodCxcbiAgICAgIGhhc0F1ZGlvXG4gICAgKVxuICB9XG5cbiAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKHJlY29yZGVyV2lkdGgsIHJlY29yZGVySGVpZ2h0LCBoYXNBdWRpbykge1xuICAgIGlmICh2aWRlb21haWwpIHtcbiAgICAgIGNvcnJlY3REaW1lbnNpb25zKHtcbiAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAgICAgLy8gYmV3YXJlIHRoYXQgcmVjb3JkZXJXaWR0aCBhbmQgcmVjb3JkZXJIZWlnaHQgY2FuIGJlIG51bGwgc29tZXRpbWVzXG4gICAgICAgIHZpZGVvV2lkdGg6IHJlY29yZGVyV2lkdGggfHwgcmVwbGF5RWxlbWVudC52aWRlb1dpZHRoLFxuICAgICAgICB2aWRlb0hlaWdodDogcmVjb3JkZXJIZWlnaHQgfHwgcmVwbGF5RWxlbWVudC52aWRlb0hlaWdodFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBoaWRkZW4ocmVwbGF5RWxlbWVudCwgZmFsc2UpXG5cbiAgICAvLyBwYXJlbnQgZWxlbWVudCBjYW4gYmUgYW55IG9iamVjdCwgYmUgY2FyZWZ1bCFcbiAgICBpZiAocGFyZW50RWxlbWVudCkge1xuICAgICAgaWYgKHBhcmVudEVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgaGlkZGVuKHBhcmVudEVsZW1lbnQsIGZhbHNlKVxuICAgICAgfSBlbHNlIGlmIChwYXJlbnRFbGVtZW50LnNob3cpIHtcbiAgICAgICAgcGFyZW50RWxlbWVudC5zaG93KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzQXVkaW8pIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC1jbGllbnQvaXNzdWVzLzExNVxuICAgICAgLy8gZG8gbm90IHNldCBtdXRlIHRvIGZhbHNlIGFzIHRoaXMgd2lsbCBtZXNzIHVwLiBqdXN0IGRvIG5vdCBtZW50aW9uIHRoaXMgYXR0cmlidXRlIGF0IGFsbFxuICAgICAgcmVwbGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZvbHVtZScsIDEpXG4gICAgfSBlbHNlIGlmICghb3B0aW9ucy5pc0F1ZGlvRW5hYmxlZCgpKSB7XG4gICAgICByZXBsYXlFbGVtZW50LnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCB0cnVlKVxuICAgIH1cblxuICAgIC8vIHRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgc2V0dGluZyB0aGUgc291cmNlcyBhbmQgd2hlbiBiZWNvbWluZyB2aXNpYmxlXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iZnJlZC1pdC9pcGhvbmUtaW5saW5lLXZpZGVvL2lzc3Vlcy8xNlxuICAgIGVuYWJsZUlubGluZVZpZGVvICYmIGVuYWJsZUlubGluZVZpZGVvKHJlcGxheUVsZW1lbnQsIHtcbiAgICAgIGlQYWQ6IHRydWVcbiAgICB9KVxuXG4gICAgLy8gdGhpcyBmb3JjZXMgdG8gYWN0dWFsbHkgZmV0Y2ggdGhlIHZpZGVvcyBmcm9tIHRoZSBzZXJ2ZXJcbiAgICByZXBsYXlFbGVtZW50LmxvYWQoKVxuXG4gICAgaWYgKCF2aWRlb21haWwpIHtcbiAgICAgIHNlbGYuZW1pdChFdmVudHMuUFJFVklFV19TSE9XTilcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5SRVBMQVlfU0hPV04pXG4gICAgfVxuICB9XG5cbiAgdGhpcy5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1ZygnUmVwbGF5OiBidWlsZCgpJylcblxuICAgIHJlcGxheUVsZW1lbnQgPSBwYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvLicgKyBvcHRpb25zLnNlbGVjdG9ycy5yZXBsYXlDbGFzcylcblxuICAgIGlmICghcmVwbGF5RWxlbWVudCkge1xuICAgICAgYnVpbGRFbGVtZW50KClcbiAgICB9XG5cbiAgICB0aGlzLmhpZGUoKVxuXG4gICAgcmVwbGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgdHJ1ZSlcbiAgICByZXBsYXlFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXV0b3N0YXJ0JywgdHJ1ZSlcbiAgICByZXBsYXlFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXV0b2J1ZmZlcicsIHRydWUpXG4gICAgcmVwbGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgdHJ1ZSlcbiAgICByZXBsYXlFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2Via2l0LXBsYXlzaW5saW5lJywgJ3dlYmtpdC1wbGF5c2lubGluZScpXG4gICAgcmVwbGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRyb2xzJywgJ2NvbnRyb2xzJylcbiAgICByZXBsYXlFbGVtZW50LnNldEF0dHJpYnV0ZSgncHJlbG9hZCcsICdhdXRvJylcblxuICAgIGlmICghYnVpbHQpIHtcbiAgICAgIGlmICghaXNTdGFuZGFsb25lKCkpIHtcbiAgICAgICAgdGhpcy5vbihFdmVudHMuUFJFVklFVywgZnVuY3Rpb24gKGtleSwgcmVjb3JkZXJXaWR0aCwgcmVjb3JkZXJIZWlnaHQpIHtcbiAgICAgICAgICBzZWxmLnNob3cocmVjb3JkZXJXaWR0aCwgcmVjb3JkZXJIZWlnaHQpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2VzIHVzZSBvZiBwYXNzaXZlIG9wdGlvbiBhdXRvbWF0aWNhbGx5IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAgIC8vIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2FkZC1ldmVudGxpc3RlbmVyLXdpdGgtb3B0aW9uc1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zKHJlcGxheUVsZW1lbnQsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGxpa2VcbiAgICAgICAgICAvLyBVbmFibGUgdG8gcHJldmVudERlZmF1bHQgaW5zaWRlIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXIgaW52b2NhdGlvbi5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgIHBsYXkoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdXNlKClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcmVwbGF5RWxlbWVudC5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KClcblxuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICBwbGF5KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXVzZSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWlsdCA9IHRydWVcblxuICAgIGRlYnVnKCdSZXBsYXk6IGJ1aWx0LicpXG4gIH1cblxuICB0aGlzLnVubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBidWlsdCA9IGZhbHNlXG4gIH1cblxuICB0aGlzLmdldFZpZGVvU291cmNlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBjb25zdCBzb3VyY2VzID0gcmVwbGF5RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJylcbiAgICBjb25zdCBsID0gc291cmNlcy5sZW5ndGhcbiAgICBjb25zdCB2aWRlb1R5cGUgPSAndmlkZW8vJyArIHR5cGVcblxuICAgIHZhciBzb3VyY2VcblxuICAgIGlmIChsKSB7XG4gICAgICB2YXIgaVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbCAmJiAhc291cmNlOyBpKyspIHtcbiAgICAgICAgaWYgKHNvdXJjZXNbaV0uZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09IHZpZGVvVHlwZSkge1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFZpZGVvU291cmNlICh0eXBlLCBzcmMsIGJ1c3RDYWNoZSkge1xuICAgIHZhciBzb3VyY2UgPSBzZWxmLmdldFZpZGVvU291cmNlKHR5cGUpXG5cbiAgICBpZiAoc3JjICYmIGJ1c3RDYWNoZSkge1xuICAgICAgc3JjICs9ICc/JyArIERhdGUubm93KClcbiAgICB9XG5cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICBzb3VyY2UgPSBoKCdzb3VyY2UnLCB7XG4gICAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgICAgdHlwZTogJ3ZpZGVvLycgKyB0eXBlXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVwbGF5RWxlbWVudC5hcHBlbmRDaGlsZChzb3VyY2UpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgc291cmNlLnNldEF0dHJpYnV0ZSgnc3JjJywgc3JjKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbGF5RWxlbWVudC5yZW1vdmVDaGlsZChzb3VyY2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zZXRNcDRTb3VyY2UgPSBmdW5jdGlvbiAoc3JjLCBidXN0Q2FjaGUpIHtcbiAgICBzZXRWaWRlb1NvdXJjZSgnbXA0Jywgc3JjLCBidXN0Q2FjaGUpXG4gIH1cblxuICB0aGlzLnNldFdlYk1Tb3VyY2UgPSBmdW5jdGlvbiAoc3JjLCBidXN0Q2FjaGUpIHtcbiAgICBzZXRWaWRlb1NvdXJjZSgnd2VibScsIHNyYywgYnVzdENhY2hlKVxuICB9XG5cbiAgdGhpcy5nZXRWaWRlb1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGJyb3dzZXIuZ2V0VmlkZW9UeXBlKHJlcGxheUVsZW1lbnQpXG4gIH1cblxuICBmdW5jdGlvbiBwYXVzZSAoY2IpIHtcbiAgICAvLyBhdm9pZHMgcmFjZSBjb25kaXRpb24sIGluc3BpcmVkIGJ5XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNjgwMzE3Ni9ob3ctdG8tcHJldmVudC10aGUtcGxheS1yZXF1ZXN0LXdhcy1pbnRlcnJ1cHRlZC1ieS1hLWNhbGwtdG8tcGF1c2UtZXJyb3JcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcGxheUVsZW1lbnQucGF1c2UoKVxuICAgICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAgIC8vIGp1c3QgaWdub3JlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLmlvL2lzc3Vlcy8zODZcbiAgICAgICAgb3B0aW9ucy5sb2dnZXIud2FybihleGMpXG4gICAgICB9XG5cbiAgICAgIGNiICYmIGNiKClcbiAgICB9LCAxNSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYXkgKCkge1xuICAgIGlmIChyZXBsYXlFbGVtZW50ICYmIHJlcGxheUVsZW1lbnQucGxheSkge1xuICAgICAgdmFyIHBcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcCA9IHJlcGxheUVsZW1lbnQucGxheSgpXG4gICAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgICAgLy8gdGhpcyBpbiB0aGUgaG9wZSB0byBjYXRjaCBJbnZhbGlkU3RhdGVFcnJvciwgc2VlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC1jbGllbnQvaXNzdWVzLzE0OVxuICAgICAgICBvcHRpb25zLmxvZ2dlci53YXJuKCdDYXVnaHQgcmVwbGF5IGV4Y2VwdGlvbjonLCBleGMpXG4gICAgICB9XG5cbiAgICAgIGlmIChwICYmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpICYmIChwIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgcC5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgICAgb3B0aW9ucy5sb2dnZXIud2FybignQ2F1Z2h0IHBlbmRpbmcgcmVwbGF5IHByb21pc2UgZXhjZXB0aW9uOiAlcycsIHJlYXNvbilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgLy8gcGF1c2UgdmlkZW8gdG8gbWFrZSBzdXJlIGl0IHdvbid0IGNvbnN1bWUgYW55IG1lbW9yeVxuICAgIHBhdXNlKCgpID0+IHtcbiAgICAgIGlmIChyZXBsYXlFbGVtZW50KSB7XG4gICAgICAgIHNlbGYuc2V0TXA0U291cmNlKG51bGwpXG4gICAgICAgIHNlbGYuc2V0V2ViTVNvdXJjZShudWxsKVxuICAgICAgfVxuXG4gICAgICBjYiAmJiBjYigpXG4gICAgfSlcbiAgfVxuXG4gIHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNTdGFuZGFsb25lKCkpIHtcbiAgICAgIGhpZGRlbihwYXJlbnRFbGVtZW50LCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYXlFbGVtZW50ICYmIGhpZGRlbihyZXBsYXlFbGVtZW50LCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaXNTaG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVwbGF5RWxlbWVudCAmJiAhaGlkZGVuKHJlcGxheUVsZW1lbnQpXG4gIH1cblxuICB0aGlzLmdldFBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcmVudEVsZW1lbnRcbiAgfVxufVxuXG51dGlsLmluaGVyaXRzKFJlcGxheSwgRXZlbnRFbWl0dGVyKVxuXG5leHBvcnQgZGVmYXVsdCBSZXBsYXlcbiIsImltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICdzYWZlLWpzb24tc3RyaW5naWZ5J1xuXG5pbXBvcnQgQXVkaW9SZWNvcmRlciBmcm9tICcuLy4uLy4uL3V0aWwvYXVkaW9SZWNvcmRlcidcbmltcG9ydCBWaWRlb21haWxFcnJvciBmcm9tICcuLy4uLy4uL3V0aWwvdmlkZW9tYWlsRXJyb3InXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vLi4vLi4vdXRpbC9ldmVudEVtaXR0ZXInXG5pbXBvcnQgTUVESUFfRVZFTlRTIGZyb20gJy4vLi4vLi4vdXRpbC9tZWRpYUV2ZW50cydcbmltcG9ydCBwcmV0dHkgZnJvbSAnLi8uLi8uLi91dGlsL3ByZXR0eSdcbmltcG9ydCBCcm93c2VyIGZyb20gJy4vLi4vLi4vdXRpbC9icm93c2VyJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLy4uLy4uL2V2ZW50cydcblxuY29uc3QgRVZFTlRfQVNDSUkgPSAnfOKAlE/igJR8J1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAocmVjb3JkZXIsIG9wdGlvbnMpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgb3B0aW9ucywgJ1VzZXJNZWRpYScpXG5cbiAgY29uc3QgcmF3VmlzdWFsVXNlck1lZGlhID0gcmVjb3JkZXIgJiYgcmVjb3JkZXIuZ2V0UmF3VmlzdWFsVXNlck1lZGlhKClcbiAgY29uc3QgYnJvd3NlciA9IG5ldyBCcm93c2VyKG9wdGlvbnMpXG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgdmFyIHBhdXNlZCA9IGZhbHNlXG4gIHZhciByZWNvcmQgPSBmYWxzZVxuXG4gIHZhciBhdWRpb1JlY29yZGVyXG4gIHZhciBjdXJyZW50VmlzdWFsU3RyZWFtXG5cbiAgZnVuY3Rpb24gYXR0YWNoTWVkaWFTdHJlYW0gKHN0cmVhbSkge1xuICAgIGN1cnJlbnRWaXN1YWxTdHJlYW0gPSBzdHJlYW1cblxuICAgIGlmICh0eXBlb2YgcmF3VmlzdWFsVXNlck1lZGlhLnNyY09iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5zcmNPYmplY3QgPSBzdHJlYW1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByYXdWaXN1YWxVc2VyTWVkaWEuc3JjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMXG4gICAgICByYXdWaXN1YWxVc2VyTWVkaWEuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pIHx8IHN0cmVhbVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoXG4gICAgICAgICdFcnJvciBhdHRhY2hpbmcgc3RyZWFtIHRvIGVsZW1lbnQuJyxcbiAgICAgICAgJ0NvbnRhY3QgdGhlIGRldmVsb3BlciBhYm91dCB0aGlzJyxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFZpc3VhbFN0cmVhbSAobG9jYWxNZWRpYVN0cmVhbSkge1xuICAgIGlmIChsb2NhbE1lZGlhU3RyZWFtKSB7XG4gICAgICBhdHRhY2hNZWRpYVN0cmVhbShsb2NhbE1lZGlhU3RyZWFtKVxuICAgIH0gZWxzZSB7XG4gICAgICByYXdWaXN1YWxVc2VyTWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzcmNPYmplY3QnKVxuICAgICAgcmF3VmlzdWFsVXNlck1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJylcblxuICAgICAgY3VycmVudFZpc3VhbFN0cmVhbSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWaXN1YWxTdHJlYW0gKCkge1xuICAgIGlmIChyYXdWaXN1YWxVc2VyTWVkaWEubW96U3JjT2JqZWN0KSB7XG4gICAgICByZXR1cm4gcmF3VmlzdWFsVXNlck1lZGlhLm1velNyY09iamVjdFxuICAgIH0gZWxzZSBpZiAocmF3VmlzdWFsVXNlck1lZGlhLnNyY09iamVjdCkge1xuICAgICAgcmV0dXJuIHJhd1Zpc3VhbFVzZXJNZWRpYS5zcmNPYmplY3RcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWaXN1YWxTdHJlYW1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNFbmRlZCAoKSB7XG4gICAgaWYgKHJhd1Zpc3VhbFVzZXJNZWRpYS5lbmRlZCkge1xuICAgICAgcmV0dXJuIHJhd1Zpc3VhbFVzZXJNZWRpYS5lbmRlZFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2aXN1YWxTdHJlYW0gPSBnZXRWaXN1YWxTdHJlYW0oKVxuICAgICAgcmV0dXJuIHZpc3VhbFN0cmVhbSAmJiB2aXN1YWxTdHJlYW0uZW5kZWRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNJbnZhbGlkRGltZW5zaW9ucyAoKSB7XG4gICAgaWYgKChyYXdWaXN1YWxVc2VyTWVkaWEudmlkZW9XaWR0aCAmJiByYXdWaXN1YWxVc2VyTWVkaWEudmlkZW9XaWR0aCA8IDMpIHx8XG4gICAgICAgIChyYXdWaXN1YWxVc2VyTWVkaWEuaGVpZ2h0ICYmIHJhd1Zpc3VhbFVzZXJNZWRpYS5oZWlnaHQgPCAzKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUcmFja3MgKGxvY2FsTWVkaWFTdHJlYW0pIHtcbiAgICB2YXIgdHJhY2tzXG5cbiAgICBpZiAobG9jYWxNZWRpYVN0cmVhbSAmJiBsb2NhbE1lZGlhU3RyZWFtLmdldFRyYWNrcykge1xuICAgICAgdHJhY2tzID0gbG9jYWxNZWRpYVN0cmVhbS5nZXRUcmFja3MoKVxuICAgIH1cblxuICAgIHJldHVybiB0cmFja3NcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFZpZGVvVHJhY2tzIChsb2NhbE1lZGlhU3RyZWFtKSB7XG4gICAgdmFyIHZpZGVvVHJhY2tzXG5cbiAgICBpZiAobG9jYWxNZWRpYVN0cmVhbSAmJiBsb2NhbE1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKSB7XG4gICAgICB2aWRlb1RyYWNrcyA9IGxvY2FsTWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVxuICAgIH1cblxuICAgIHJldHVybiB2aWRlb1RyYWNrc1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Rmlyc3RWaWRlb1RyYWNrIChsb2NhbE1lZGlhU3RyZWFtKSB7XG4gICAgY29uc3QgdmlkZW9UcmFja3MgPSBnZXRWaWRlb1RyYWNrcyhsb2NhbE1lZGlhU3RyZWFtKVxuICAgIHZhciB2aWRlb1RyYWNrXG5cbiAgICBpZiAodmlkZW9UcmFja3MgJiYgdmlkZW9UcmFja3NbMF0pIHtcbiAgICAgIHZpZGVvVHJhY2sgPSB2aWRlb1RyYWNrc1swXVxuICAgIH1cblxuICAgIHJldHVybiB2aWRlb1RyYWNrXG4gIH1cblxuICBmdW5jdGlvbiBsb2dFdmVudCAoZXZlbnQsIHBhcmFtcykge1xuICAgIG9wdGlvbnMuZGVidWcoJ1VzZXJNZWRpYTogLi4uJywgRVZFTlRfQVNDSUksICdldmVudCcsIGV2ZW50LCBzdHJpbmdpZnkocGFyYW1zKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUHJvbWlzZSAoYW55dGhpbmcpIHtcbiAgICByZXR1cm4gKGFueXRoaW5nICYmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpICYmIChhbnl0aGluZyBpbnN0YW5jZW9mIFByb21pc2UpKVxuICB9XG5cbiAgZnVuY3Rpb24gb3V0cHV0RXZlbnQgKGUpIHtcbiAgICBsb2dFdmVudChlLnR5cGUsIHsgcmVhZHlTdGF0ZTogcmF3VmlzdWFsVXNlck1lZGlhLnJlYWR5U3RhdGUgfSlcblxuICAgIC8vIHJlbW92ZSBteXNlbGZcbiAgICByYXdWaXN1YWxVc2VyTWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJlxuICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKGUudHlwZSwgb3V0cHV0RXZlbnQpXG4gIH1cblxuICB0aGlzLnVubG9hZFJlbWFpbmluZ0V2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIG9wdGlvbnMuZGVidWcoJ1VzZXJNZWRpYTogdW5sb2FkUmVtYWluaW5nRXZlbnRMaXN0ZW5lcnMoKScpXG5cbiAgICBNRURJQV9FVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICByYXdWaXN1YWxVc2VyTWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIG91dHB1dEV2ZW50KVxuICAgIH0pXG4gIH1cblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbiAoXG4gICAgbG9jYWxNZWRpYVN0cmVhbSxcbiAgICB2aWRlb0NhbGxiYWNrLFxuICAgIGF1ZGlvQ2FsbGJhY2ssXG4gICAgZW5kZWRFYXJseUNhbGxiYWNrLFxuICAgIHBhcmFtcyA9IHt9KSB7XG4gICAgdGhpcy5zdG9wKGxvY2FsTWVkaWFTdHJlYW0sIHtcbiAgICAgIGFib3V0VG9Jbml0aWFsaXplOiB0cnVlLFxuICAgICAgc3dpdGNoaW5nRmFjaW5nTW9kZTogcGFyYW1zLnN3aXRjaGluZ0ZhY2luZ01vZGVcbiAgICB9KVxuXG4gICAgdmFyIG9uUGxheVJlYWNoZWQgPSBmYWxzZVxuICAgIHZhciBvbkxvYWRlZE1ldGFEYXRhUmVhY2hlZCA9IGZhbHNlXG4gICAgdmFyIHBsYXlpbmdQcm9taXNlUmVhY2hlZCA9IGZhbHNlXG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmlzQXVkaW9FbmFibGVkKCkpIHtcbiAgICAgIGF1ZGlvUmVjb3JkZXIgPSBhdWRpb1JlY29yZGVyIHx8IG5ldyBBdWRpb1JlY29yZGVyKHRoaXMsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXVkaW9SZWNvcmQgKCkge1xuICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihFdmVudHMuU0VORElOR19GSVJTVF9GUkFNRSwgYXVkaW9SZWNvcmQpXG4gICAgICBhdWRpb1JlY29yZGVyICYmIGF1ZGlvUmVjb3JkZXIucmVjb3JkKGF1ZGlvQ2FsbGJhY2spXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5sb2FkQWxsRXZlbnRMaXN0ZW5lcnMgKCkge1xuICAgICAgb3B0aW9ucy5kZWJ1ZygnVXNlck1lZGlhOiB1bmxvYWRBbGxFdmVudExpc3RlbmVycygpJylcblxuICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihFdmVudHMuU0VORElOR19GSVJTVF9GUkFNRSwgYXVkaW9SZWNvcmQpXG5cbiAgICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyICYmXG4gICAgICByYXdWaXN1YWxVc2VyTWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheScsIG9uUGxheSlcblxuICAgICAgcmF3VmlzdWFsVXNlck1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiZcbiAgICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIG9uTG9hZGVkTWV0YURhdGEpXG5cbiAgICAgIHNlbGYudW5sb2FkUmVtYWluaW5nRXZlbnRMaXN0ZW5lcnMoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBsYXkgKCkge1xuICAgICAgLy8gUmVzZXRzIHRoZSBtZWRpYSBlbGVtZW50IGFuZCByZXN0YXJ0cyB0aGUgbWVkaWEgcmVzb3VyY2UuIEFueSBwZW5kaW5nIGV2ZW50cyBhcmUgZGlzY2FyZGVkLlxuICAgICAgdHJ5IHtcbiAgICAgICAgcmF3VmlzdWFsVXNlck1lZGlhLmxvYWQoKVxuXG4gICAgICAgIC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC5pby9pc3N1ZXMvNDAxXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0RWRnZS9EZW1vcy9ibG9iL21hc3Rlci9waG90b2NhcHR1cmUvc2NyaXB0cy9kZW1vLmpzI0wyN1xuICAgICAgICBpZiAocmF3VmlzdWFsVXNlck1lZGlhLnBhdXNlZCkge1xuICAgICAgICAgIG9wdGlvbnMuZGVidWcoXG4gICAgICAgICAgICAnVXNlck1lZGlhOiBwbGF5KCknLFxuICAgICAgICAgICAgJ21lZGlhLnJlYWR5U3RhdGU9JyArIHJhd1Zpc3VhbFVzZXJNZWRpYS5yZWFkeVN0YXRlLFxuICAgICAgICAgICAgJ21lZGlhLnBhdXNlZD0nICsgcmF3VmlzdWFsVXNlck1lZGlhLnBhdXNlZCxcbiAgICAgICAgICAgICdtZWRpYS5lbmRlZD0nICsgcmF3VmlzdWFsVXNlck1lZGlhLmVuZGVkLFxuICAgICAgICAgICAgJ21lZGlhLnBsYXllZD0nICsgcHJldHR5KHJhd1Zpc3VhbFVzZXJNZWRpYS5wbGF5ZWQpXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdmFyIHBcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwID0gcmF3VmlzdWFsVXNlck1lZGlhLnBsYXkoKVxuICAgICAgICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgICAgICAgLy8gdGhpcyBpbiB0aGUgaG9wZSB0byBjYXRjaCBJbnZhbGlkU3RhdGVFcnJvciwgc2VlXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwtY2xpZW50L2lzc3Vlcy8xNDlcbiAgICAgICAgICAgIG9wdGlvbnMubG9nZ2VyLndhcm4oJ0NhdWdodCByYXcgdXNlcm1lZGlhIHBsYXkgZXhjZXB0aW9uOicsIGV4YylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1c2luZyB0aGUgcHJvbWlzZSBoZXJlIGp1c3QgZXhwZXJpbWVudGFsIGZvciBub3dcbiAgICAgICAgICAvLyBhbmQgdGhpcyB0byBjYXRjaCBhbnkgd2VpcmQgZXJyb3JzIGVhcmx5IGlmIHBvc3NpYmxlXG4gICAgICAgICAgaWYgKGlzUHJvbWlzZShwKSkge1xuICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKCFwbGF5aW5nUHJvbWlzZVJlYWNoZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRlYnVnKCdVc2VyTWVkaWE6IHBsYXkgcHJvbWlzZSBzdWNjZXNzZnVsLiBQbGF5aW5nIG5vdy4nKVxuICAgICAgICAgICAgICAgIHBsYXlpbmdQcm9taXNlUmVhY2hlZCA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAvLyBwcm9taXNlIGNhbiBiZSBpbnRlcnJ1cHRlZCwgaS5FLiB3aGVuIHN3aXRjaGluZyB0YWJzXG4gICAgICAgICAgICAgIC8vIGFuZCBwcm9taXNlIGNhbiBnZXQgcmVzdW1lZCB3aGVuIHN3aXRjaGluZyBiYWNrIHRvIHRhYiwgaGVuY2VcbiAgICAgICAgICAgICAgLy8gZG8gbm90IHRyZWF0IHRoaXMgbGlrZSBhbiBlcnJvclxuICAgICAgICAgICAgICBvcHRpb25zLmxvZ2dlci53YXJuKCdDYXVnaHQgcGVuZGluZyB1c2VybWVkaWEgcHJvbWlzZSBleGNlcHRpb246ICVzJywgcmVhc29uLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAgIHVubG9hZEFsbEV2ZW50TGlzdGVuZXJzKClcbiAgICAgICAgZW5kZWRFYXJseUNhbGxiYWNrKGV4YylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXJlQ2FsbGJhY2tzICgpIHtcbiAgICAgIGNvbnN0IHJlYWR5U3RhdGUgPSByYXdWaXN1YWxVc2VyTWVkaWEucmVhZHlTdGF0ZVxuXG4gICAgICAvLyByZWFkeSBzdGF0ZSwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L3JlYWR5U3RhdGVcbiAgICAgIG9wdGlvbnMuZGVidWcoXG4gICAgICAgICdVc2VyTWVkaWE6IGZpcmVDYWxsYmFja3MoJyArXG4gICAgICAgICdyZWFkeVN0YXRlPScgKyByZWFkeVN0YXRlICsgJywgJyArXG4gICAgICAgICdvblBsYXlSZWFjaGVkPScgKyBvblBsYXlSZWFjaGVkICsgJywgJyArXG4gICAgICAgICdvbkxvYWRlZE1ldGFEYXRhUmVhY2hlZD0nICsgb25Mb2FkZWRNZXRhRGF0YVJlYWNoZWQgKyAnKSdcbiAgICAgIClcblxuICAgICAgaWYgKG9uUGxheVJlYWNoZWQgJiYgb25Mb2FkZWRNZXRhRGF0YVJlYWNoZWQpIHtcbiAgICAgICAgdmlkZW9DYWxsYmFjaygpXG5cbiAgICAgICAgaWYgKGF1ZGlvUmVjb3JkZXIgJiYgYXVkaW9DYWxsYmFjaykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhdWRpb1JlY29yZGVyLmluaXQobG9jYWxNZWRpYVN0cmVhbSlcbiAgICAgICAgICAgIHNlbGYub24oRXZlbnRzLlNFTkRJTkdfRklSU1RfRlJBTUUsIGF1ZGlvUmVjb3JkKVxuICAgICAgICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgICAgICAgdW5sb2FkQWxsRXZlbnRMaXN0ZW5lcnMoKVxuICAgICAgICAgICAgZW5kZWRFYXJseUNhbGxiYWNrKGV4YylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblBsYXkgKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nRXZlbnQoJ3BsYXknLCB7XG4gICAgICAgICAgcmVhZHlTdGF0ZTogcmF3VmlzdWFsVXNlck1lZGlhLnJlYWR5U3RhdGUsXG4gICAgICAgICAgYXVkaW86IG9wdGlvbnMuaXNBdWRpb0VuYWJsZWQoKSxcbiAgICAgICAgICB3aWR0aDogcmF3VmlzdWFsVXNlck1lZGlhLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogcmF3VmlzdWFsVXNlck1lZGlhLmhlaWdodCxcbiAgICAgICAgICB2aWRlb1dpZHRoOiByYXdWaXN1YWxVc2VyTWVkaWEudmlkZW9XaWR0aCxcbiAgICAgICAgICB2aWRlb0hlaWdodDogcmF3VmlzdWFsVXNlck1lZGlhLnZpZGVvSGVpZ2h0XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmF3VmlzdWFsVXNlck1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiZcbiAgICAgICAgcmF3VmlzdWFsVXNlck1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXknLCBvblBsYXkpXG5cbiAgICAgICAgaWYgKGhhc0VuZGVkKCkgfHwgaGFzSW52YWxpZERpbWVuc2lvbnMoKSkge1xuICAgICAgICAgIGVuZGVkRWFybHlDYWxsYmFjayhcbiAgICAgICAgICAgIFZpZGVvbWFpbEVycm9yLmNyZWF0ZShcbiAgICAgICAgICAgICAgJ0FscmVhZHkgYnVzeScsXG4gICAgICAgICAgICAgICdQcm9iYWJseSBhbm90aGVyIGJyb3dzZXIgd2luZG93IGlzIHVzaW5nIHlvdXIgd2ViY2FtPycsXG4gICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25QbGF5UmVhY2hlZCA9IHRydWVcbiAgICAgICAgICBmaXJlQ2FsbGJhY2tzKClcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAgIHVubG9hZEFsbEV2ZW50TGlzdGVuZXJzKClcbiAgICAgICAgZW5kZWRFYXJseUNhbGxiYWNrKGV4YylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwbGF5ZXIgbW9kaWZpY2F0aW9ucyB0byBwZXJmb3JtIHRoYXQgbXVzdCB3YWl0IHVudGlsIGBsb2FkZWRtZXRhZGF0YWAgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgZnVuY3Rpb24gb25Mb2FkZWRNZXRhRGF0YSAoKSB7XG4gICAgICBsb2dFdmVudCgnbG9hZGVkbWV0YWRhdGEnLCB7XG4gICAgICAgIHJlYWR5U3RhdGU6IHJhd1Zpc3VhbFVzZXJNZWRpYS5yZWFkeVN0YXRlLFxuICAgICAgICBwYXVzZWQ6IHJhd1Zpc3VhbFVzZXJNZWRpYS5wYXVzZWQsXG4gICAgICAgIHdpZHRoOiByYXdWaXN1YWxVc2VyTWVkaWEud2lkdGgsXG4gICAgICAgIGhlaWdodDogcmF3VmlzdWFsVXNlck1lZGlhLmhlaWdodCxcbiAgICAgICAgdmlkZW9XaWR0aDogcmF3VmlzdWFsVXNlck1lZGlhLnZpZGVvV2lkdGgsXG4gICAgICAgIHZpZGVvSGVpZ2h0OiByYXdWaXN1YWxVc2VyTWVkaWEudmlkZW9IZWlnaHRcbiAgICAgIH0pXG5cbiAgICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyICYmXG4gICAgICByYXdWaXN1YWxVc2VyTWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCBvbkxvYWRlZE1ldGFEYXRhKVxuXG4gICAgICBpZiAoIWhhc0VuZGVkKCkgJiYgIWhhc0ludmFsaWREaW1lbnNpb25zKCkpIHtcbiAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5MT0FERURfTUVUQV9EQVRBKVxuXG4gICAgICAgIC8vIGZvciBhbmRyb2lkIGRldmljZXMsIHdlIGNhbm5vdCBjYWxsIHBsYXkoKSB1bmxlc3MgbWV0YSBkYXRhIGhhcyBiZWVuIGxvYWRlZCFcbiAgICAgICAgLy8gdG9kbyBjb25zaWRlciByZW1vdmluZyB0aGF0IGlmIGl0J3Mgbm90IHRoZSBjYXNlIGFueW1vcmUgKGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UpXG4gICAgICAgIGlmIChicm93c2VyLmlzQW5kcm9pZCgpKSB7XG4gICAgICAgICAgcGxheSgpXG4gICAgICAgIH1cblxuICAgICAgICBvbkxvYWRlZE1ldGFEYXRhUmVhY2hlZCA9IHRydWVcbiAgICAgICAgZmlyZUNhbGxiYWNrcygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSBnZXRGaXJzdFZpZGVvVHJhY2sobG9jYWxNZWRpYVN0cmVhbSlcblxuICAgICAgaWYgKCF2aWRlb1RyYWNrKSB7XG4gICAgICAgIG9wdGlvbnMuZGVidWcoJ1VzZXJNZWRpYTogZGV0ZWN0ZWQgKGJ1dCBubyB2aWRlbyB0cmFja3MgZXhpc3QnKVxuICAgICAgfSBlbHNlIGlmICghdmlkZW9UcmFjay5lbmFibGVkKSB7XG4gICAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZShcbiAgICAgICAgICAnV2ViY2FtIGlzIGRpc2FibGVkJyxcbiAgICAgICAgICAnVGhlIHZpZGVvIHRyYWNrIHNlZW1zIHRvIGJlIGRpc2FibGVkLiBFbmFibGUgaXQgaW4geW91ciBzeXN0ZW0uJyxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZXNjcmlwdGlvblxuXG4gICAgICAgIGlmICh2aWRlb1RyYWNrLmxhYmVsICYmIHZpZGVvVHJhY2subGFiZWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRlc2NyaXB0aW9uID0gdmlkZW9UcmFjay5sYWJlbFxuICAgICAgICB9XG5cbiAgICAgICAgZGVzY3JpcHRpb24gKz0gJyB3aXRoIGVuYWJsZWQ9JyArIHZpZGVvVHJhY2suZW5hYmxlZFxuICAgICAgICBkZXNjcmlwdGlvbiArPSAnLCBtdXRlZD0nICsgdmlkZW9UcmFjay5tdXRlZFxuICAgICAgICBkZXNjcmlwdGlvbiArPSAnLCByZW1vdGU9JyArIHZpZGVvVHJhY2sucmVtb3RlXG4gICAgICAgIGRlc2NyaXB0aW9uICs9ICcsIHJlYWR5U3RhdGU9JyArIHZpZGVvVHJhY2sucmVhZHlTdGF0ZVxuICAgICAgICBkZXNjcmlwdGlvbiArPSAnLCBlcnJvcj0nICsgdmlkZW9UcmFjay5lcnJvclxuXG4gICAgICAgIG9wdGlvbnMuZGVidWcoXG4gICAgICAgICAgJ1VzZXJNZWRpYTogJyArIHZpZGVvVHJhY2sua2luZCArICcgZGV0ZWN0ZWQuJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbiB8fCAnJ1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIHZlcnkgdXNlZnVsIGkgdGhpbmssIHNvIGxlYXZlIHRoaXMgYW5kIGp1c3QgdXNlIG9wdGlvbnMuZGVidWcoKVxuICAgICAgY29uc3QgaGVhdnlEZWJ1Z2dpbmcgPSB0cnVlXG5cbiAgICAgIGlmIChoZWF2eURlYnVnZ2luZykge1xuICAgICAgICBNRURJQV9FVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgcmF3VmlzdWFsVXNlck1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBvdXRwdXRFdmVudCwgZmFsc2UpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIG9uTG9hZGVkTWV0YURhdGEpXG4gICAgICByYXdWaXN1YWxVc2VyTWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigncGxheScsIG9uUGxheSlcblxuICAgICAgLy8gZXhwZXJpbWVudGFsLCBub3Qgc3VyZSBpZiB0aGlzIGlzIGV2ZXIgbmVlZGVkL2NhbGxlZD8gc2luY2UgMiBhcHIgMjAxN1xuICAgICAgLy8gQW4gZXJyb3Igb2NjdXJzIHdoaWxlIGZldGNoaW5nIHRoZSBtZWRpYSBkYXRhLlxuICAgICAgLy8gRXJyb3IgY2FuIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBjb2RlIE1FRElBX0VSUl9ORVRXT1JLIG9yIGhpZ2hlci5cbiAgICAgIC8vIG5ldHdvcmtTdGF0ZSBlcXVhbHMgZWl0aGVyIE5FVFdPUktfRU1QVFkgb3IgTkVUV09SS19JRExFLCBkZXBlbmRpbmcgb24gd2hlbiB0aGUgZG93bmxvYWQgd2FzIGFib3J0ZWQuXG4gICAgICByYXdWaXN1YWxVc2VyTWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIG9wdGlvbnMubG9nZ2VyLndhcm4oXG4gICAgICAgICAgJ0NhdWdodCB2aWRlbyBlbGVtZW50IGVycm9yIGV2ZW50OiAlcycsXG4gICAgICAgICAgcHJldHR5KGVycilcbiAgICAgICAgKVxuICAgICAgfSlcblxuICAgICAgc2V0VmlzdWFsU3RyZWFtKGxvY2FsTWVkaWFTdHJlYW0pXG5cbiAgICAgIHBsYXkoKVxuICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXhjKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaXNSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISFyYXdWaXN1YWxVc2VyTWVkaWEuc3JjXG4gIH1cblxuICB0aGlzLnN0b3AgPSBmdW5jdGlvbiAodmlzdWFsU3RyZWFtLCBwYXJhbXMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBkbyBub3Qgc3RvcCBcInRvbyBtdWNoXCIgd2hlbiBnb2luZyB0byBpbml0aWFsaXplIGFueXdheVxuICAgICAgY29uc3QgYWJvdXRUb0luaXRpYWxpemUgPSBwYXJhbXMuYWJvdXRUb0luaXRpYWxpemVcbiAgICAgIGNvbnN0IHN3aXRjaGluZ0ZhY2luZ01vZGUgPSBwYXJhbXMuc3dpdGNoaW5nRmFjaW5nTW9kZVxuXG4gICAgICBpZiAoIWFib3V0VG9Jbml0aWFsaXplKSB7XG4gICAgICAgIGlmICghdmlzdWFsU3RyZWFtKSB7XG4gICAgICAgICAgdmlzdWFsU3RyZWFtID0gZ2V0VmlzdWFsU3RyZWFtKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IGdldFRyYWNrcyh2aXN1YWxTdHJlYW0pXG4gICAgICAgIHZhciBuZXdTdG9wQXBpRm91bmQgPSBmYWxzZVxuXG4gICAgICAgIGlmICh0cmFja3MpIHtcbiAgICAgICAgICB0cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgIGlmICh0cmFjay5zdG9wKSB7XG4gICAgICAgICAgICAgIG5ld1N0b3BBcGlGb3VuZCA9IHRydWVcbiAgICAgICAgICAgICAgdHJhY2suc3RvcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdpbGwgcHJvYmFibHkgYmVjb21lIG9ic29sZXRlIGluIG9uZSB5ZWFyIChhZnRlciBqdW5lIDIwMTcpXG4gICAgICAgICFuZXdTdG9wQXBpRm91bmQgJiYgdmlzdWFsU3RyZWFtICYmIHZpc3VhbFN0cmVhbS5zdG9wICYmIHZpc3VhbFN0cmVhbS5zdG9wKClcblxuICAgICAgICBzZXRWaXN1YWxTdHJlYW0obnVsbClcblxuICAgICAgICBhdWRpb1JlY29yZGVyICYmIGF1ZGlvUmVjb3JkZXIuc3RvcCgpXG5cbiAgICAgICAgYXVkaW9SZWNvcmRlciA9IG51bGxcbiAgICAgIH1cblxuICAgICAgLy8gZG9udCBoYXZlIHRvIHJlc2V0IHRoZXNlIHN0YXRlcyB3aGVuIGp1c3Qgc3dpdGNoaW5nIGNhbWVyYVxuICAgICAgLy8gd2hpbGUgc3RpbGwgcmVjb3JkaW5nIG9yIHBhdXNpbmdcbiAgICAgIGlmICghc3dpdGNoaW5nRmFjaW5nTW9kZSkge1xuICAgICAgICBwYXVzZWQgPSByZWNvcmQgPSBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXhjKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoKCdjYW52YXMnLCB7XG4gICAgICB3aWR0aDogdGhpcy5nZXRSYXdXaWR0aCh0cnVlKSxcbiAgICAgIGhlaWdodDogdGhpcy5nZXRSYXdIZWlnaHQodHJ1ZSlcbiAgICB9KVxuICB9XG5cbiAgdGhpcy5nZXRWaWRlb0hlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmF3VmlzdWFsVXNlck1lZGlhLnZpZGVvSGVpZ2h0XG4gIH1cblxuICB0aGlzLmdldFZpZGVvV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJhd1Zpc3VhbFVzZXJNZWRpYS52aWRlb1dpZHRoXG4gIH1cblxuICB0aGlzLmhhc1ZpZGVvV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmlkZW9XaWR0aCgpID4gMFxuICB9XG5cbiAgdGhpcy5nZXRSYXdXaWR0aCA9IGZ1bmN0aW9uIChyZXNwb25zaXZlKSB7XG4gICAgdmFyIHJhd1dpZHRoID0gdGhpcy5nZXRWaWRlb1dpZHRoKClcbiAgICBjb25zdCB3aWR0aERlZmluZWQgPSBvcHRpb25zLmhhc0RlZmluZWRXaWR0aCgpXG5cbiAgICBpZiAod2lkdGhEZWZpbmVkIHx8IG9wdGlvbnMuaGFzRGVmaW5lZEhlaWdodCgpKSB7XG4gICAgICBpZiAoIXJlc3BvbnNpdmUgJiYgd2lkdGhEZWZpbmVkKSB7XG4gICAgICAgIHJhd1dpZHRoID0gb3B0aW9ucy52aWRlby53aWR0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmF3V2lkdGggPSByZWNvcmRlci5jYWxjdWxhdGVXaWR0aChyZXNwb25zaXZlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXNwb25zaXZlKSB7XG4gICAgICByYXdXaWR0aCA9IHJlY29yZGVyLmxpbWl0V2lkdGgocmF3V2lkdGgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd1dpZHRoXG4gIH1cblxuICB0aGlzLmdldFJhd0hlaWdodCA9IGZ1bmN0aW9uIChyZXNwb25zaXZlKSB7XG4gICAgdmFyIHJhd0hlaWdodFxuXG4gICAgaWYgKG9wdGlvbnMuaGFzRGVmaW5lZERpbWVuc2lvbigpKSB7XG4gICAgICByYXdIZWlnaHQgPSByZWNvcmRlci5jYWxjdWxhdGVIZWlnaHQocmVzcG9uc2l2ZSlcblxuICAgICAgaWYgKHJhd0hlaWdodCA8IDEpIHtcbiAgICAgICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgICAgICdCYWQgZGltZW5zaW9ucycsXG4gICAgICAgICAgJ0NhbGN1bGF0ZWQgcmF3IGhlaWdodCBjYW5ub3QgYmUgbGVzcyB0aGFuIDEhJyxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmF3SGVpZ2h0ID0gdGhpcy5nZXRWaWRlb0hlaWdodCgpXG5cbiAgICAgIGlmIChyYXdIZWlnaHQgPCAxKSB7XG4gICAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZShcbiAgICAgICAgICAnQmFkIGRpbWVuc2lvbnMnLFxuICAgICAgICAgICdSYXcgdmlkZW8gaGVpZ2h0IGZyb20gRE9NIGVsZW1lbnQgY2Fubm90IGJlIGxlc3MgdGhhbiAxIScsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNpdmUpIHtcbiAgICAgIHJhd0hlaWdodCA9IHJlY29yZGVyLmxpbWl0SGVpZ2h0KHJhd0hlaWdodClcbiAgICB9XG5cbiAgICByZXR1cm4gcmF3SGVpZ2h0XG4gIH1cblxuICB0aGlzLmdldFJhd1Zpc3VhbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJhd1Zpc3VhbFVzZXJNZWRpYVxuICB9XG5cbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYXVzZWQgPSB0cnVlXG4gIH1cblxuICB0aGlzLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXVzZWRcbiAgfVxuXG4gIHRoaXMucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlXG4gIH1cblxuICB0aGlzLnJlY29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZWNvcmQgPSB0cnVlXG4gIH1cblxuICB0aGlzLmlzUmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWNvcmRcbiAgfVxuXG4gIHRoaXMuZ2V0QXVkaW9TYW1wbGVSYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhdWRpb1JlY29yZGVyKSB7XG4gICAgICByZXR1cm4gYXVkaW9SZWNvcmRlci5nZXRTYW1wbGVSYXRlKClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICB9XG5cbiAgdGhpcy5nZXRDaGFyYWN0ZXJpc3RpY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvU2FtcGxlUmF0ZTogdGhpcy5nZXRBdWRpb1NhbXBsZVJhdGUoKSxcbiAgICAgIG11dGVkOiByYXdWaXN1YWxVc2VyTWVkaWEgJiYgcmF3VmlzdWFsVXNlck1lZGlhLm11dGVkLFxuICAgICAgd2lkdGg6IHJhd1Zpc3VhbFVzZXJNZWRpYSAmJiByYXdWaXN1YWxVc2VyTWVkaWEud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJhd1Zpc3VhbFVzZXJNZWRpYSAmJiByYXdWaXN1YWxVc2VyTWVkaWEuaGVpZ2h0LFxuICAgICAgdmlkZW9XaWR0aDogcmF3VmlzdWFsVXNlck1lZGlhICYmIHJhd1Zpc3VhbFVzZXJNZWRpYS52aWRlb1dpZHRoLFxuICAgICAgdmlkZW9IZWlnaHQ6IHJhd1Zpc3VhbFVzZXJNZWRpYSAmJiByYXdWaXN1YWxVc2VyTWVkaWEudmlkZW9IZWlnaHRcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBzdGFuZGFyZGl6ZSBmcm9tICcuL3V0aWwvc3RhbmRhcmRpemUnXG5pbXBvcnQgQ2xpZW50IGZyb20gJy4vY2xpZW50J1xuXG5pZiAoIW5hdmlnYXRvcikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05hdmlnYXRvciBpcyBtaXNzaW5nIScpXG59IGVsc2Uge1xuICAvLyBFbnN1cmVzIFZpZGVvbWFpbCBmdW5jdGlvbmFsaXR5IGlzIG5vdCBicm9rZW4gb24gZXhvdGljIGJyb3dzZXJzIHdpdGggc2hpbXMuXG4gIHN0YW5kYXJkaXplKHdpbmRvdywgbmF2aWdhdG9yKVxufVxuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRcblxuLy8gYWxzbyBhZGQgdGhhdCBzbyB0aGF0IHdlIGNhbiByZXF1aXJlKCkgaXQgdGhlIG5vcm1hbCBFUzUgd2F5XG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudFxuIl19
