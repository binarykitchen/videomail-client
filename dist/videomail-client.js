(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.VideomailClient = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["add-eventlistener-with-options"] = factory();
	else
		root["add-eventlistener-with-options"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = addEventListenerWithOptions;

	var _checkSupport = __webpack_require__(1);

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	/**
	 * Add event listener with additional options
	 * @param {EventTarget} target - The EventTarget element
	 * @param {string} name - The name of the event
	 * @param {function} listener - The event listener callback
	 * @param {object} options - The options explicitly passed from caller
	 * @param {string} optionName - The additioanl option to add to the event listener 
	 */
	function addEventListenerWithOptions(target, name, listener, options) {
	    var optionName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'passive';

	    if (target.addEventListener !== undefined) {
	        var listenerOptions = _checkSupport.SupportMap[optionName] ? Object.assign({}, options, _defineProperty({}, optionName, true)) : options;
	        target.addEventListener(name, listener, listenerOptions);
	    }
	}

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.SupportMap = undefined;

	var _OptionsMap;

	var _constants = __webpack_require__(2);

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var OptionsMap = (_OptionsMap = {}, _defineProperty(_OptionsMap, _constants.PASSIVE, false), _defineProperty(_OptionsMap, _constants.CAPTURE, false), _defineProperty(_OptionsMap, _constants.ONCE, false), _OptionsMap);

	var getOptionsMap = function getOptionsMap() {
	    Object.keys(OptionsMap).forEach(function (k, i) {
	        OptionsMap[k] = checkSupportForProperty(k);
	    });

	    return OptionsMap;
	};

	function checkSupportForProperty(property) {
	    if (!!OptionsMap[property]) {
	        return OptionsMap[property];
	    }

	    try {
	        var opts = Object.defineProperty({}, property, {
	            get: function get() {
	                OptionsMap[property] = true;
	            }
	        });
	        window.addEventListener("test", null, opts);
	        window.removeListener("test", null);
	    } catch (e) {}

	    return OptionsMap[property];
	}

	var SupportMap = exports.SupportMap = getOptionsMap();

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var PASSIVE = exports.PASSIVE = 'passive';
	var CAPTURE = exports.CAPTURE = 'capture';
	var ONCE = exports.ONCE = 'once';

/***/ }
/******/ ])
});
;
},{}],2:[function(_dereq_,module,exports){
var EventEmitter          = _dereq_('events').EventEmitter,
    inherits              = _dereq_('inherits'),
    raf                   = _dereq_('raf'),
    methods;


//the same as off window unless polyfilled or in node
var defaultRAFObject = {
    requestAnimationFrame: raf,
    cancelAnimationFrame: raf.cancel
};

function returnTrue(){ return true; }

//manage FPS if < 60, else return true;
function makeThrottle(fps){
    var delay = 1000/fps;
    var lastTime = Date.now();


    if( fps<=0 || fps === Infinity ){
        return returnTrue;
    }

    //if an fps throttle has been set then we'll assume
    //it natively runs at 60fps,
    var half = Math.ceil(1000 / 60) / 2;

    return function(){
        //if a custom fps is requested
        var now = Date.now();
        //is this frame within 8.5ms of the target?
        //if so then next frame is gonna be too late
        if(now - lastTime < delay - half){
            return false;
        }
        lastTime = now;
        return true;
    };
}


/**
 * Animitter provides event-based loops for the browser and node,
 * using `requestAnimationFrame`
 * @param {Object} [opts]
 * @param {Number} [opts.fps=Infinity] the framerate requested, defaults to as fast as it can (60fps on window)
 * @param {Number} [opts.delay=0] milliseconds delay between invoking `start` and initializing the loop
 * @param {Object} [opts.requestAnimationFrameObject=global] the object on which to find `requestAnimationFrame` and `cancelAnimationFrame` methods
 * @param {Boolean} [opts.fixedDelta=false] if true, timestamps will pretend to be executed at fixed intervals always
 * @constructor
 */
function Animitter( opts ){
    opts = opts || {};

    this.__delay = opts.delay || 0;

    /** @expose */
    this.fixedDelta = !!opts.fixedDelta;

    /** @expose */
    this.frameCount = 0;
    /** @expose */
    this.deltaTime = 0;
    /** @expose */
    this.elapsedTime = 0;

    /** @private */
    this.__running = false;
    /** @private */
    this.__completed = false;

    this.setFPS(opts.fps || Infinity);
    this.setRequestAnimationFrameObject(opts.requestAnimationFrameObject || defaultRAFObject);
}

inherits(Animitter, EventEmitter);

function onStart(scope){
    var now = Date.now();
    var rAFID;
    //dont let a second animation start on the same object
    //use *.on('update',fn)* instead
    if(scope.__running){
        return scope;
    }

    exports.running += 1;
    scope.__running = true;
    scope.__lastTime = now;
    scope.deltaTime = 0;

    //emit **start** once at the beginning
    scope.emit('start', scope.deltaTime, 0, scope.frameCount);

    var lastRAFObject = scope.requestAnimationFrameObject;

    var drawFrame = function(){
        if(lastRAFObject !== scope.requestAnimationFrameObject){
            //if the requestAnimationFrameObject switched in-between,
            //then re-request with the new one to ensure proper update execution context
            //i.e. VRDisplay#submitFrame() may only be requested through VRDisplay#requestAnimationFrame(drawFrame)
            lastRAFObject = scope.requestAnimationFrameObject;
            scope.requestAnimationFrameObject.requestAnimationFrame(drawFrame);
            return;
        }
        if(scope.__isReadyForUpdate()){
            scope.update();
        }
        if(scope.__running){
            rAFID = scope.requestAnimationFrameObject.requestAnimationFrame(drawFrame);
        } else {
            scope.requestAnimationFrameObject.cancelAnimationFrame(rAFID);
        }
    };

    scope.requestAnimationFrameObject.requestAnimationFrame(drawFrame);

    return scope;
}

methods = {
    //EventEmitter Aliases
    off     : EventEmitter.prototype.removeListener,
    trigger : EventEmitter.prototype.emit,

    /**
     * stops the animation and marks it as completed
     * @emit Animitter#complete
     * @returns {Animitter}
     */
    complete: function(){
        this.stop();
        this.__completed = true;
        this.emit('complete', this.frameCount, this.deltaTime);
        return this;
    },

    /**
     * stops the animation and removes all listeners
     * @emit Animitter#stop
     * @returns {Animitter}
     */
    dispose: function(){
        this.stop();
        this.removeAllListeners();
        return this;
    },

    /**
     * get milliseconds between the last 2 updates
     *
     * @return {Number}
     */
    getDeltaTime: function(){
        return this.deltaTime;
    },

    /**
     * get the total milliseconds that the animation has ran.
     * This is the cumlative value of the deltaTime between frames
     *
     * @return {Number}
     */
    getElapsedTime: function(){
        return this.elapsedTime;
    },

    /**
     * get the instances frames per second as calculated by the last delta
     *
     * @return {Number}
     */
    getFPS: function(){
        return this.deltaTime > 0 ? 1000 / this.deltaTime : 0;
        if(this.deltaTime){
            return 1000 / this.deltaTime;
        }
    },

    /**
     * get the explicit FPS limit set via `Animitter#setFPS(fps)` or
     * via the initial `options.fps` property
     *
     * @returns {Number} either as set or Infinity
     */
    getFPSLimit: function(){
        return this.__fps;
    },

    /**
     * get the number of frames that have occurred
     *
     * @return {Number}
     */
    getFrameCount: function(){
        return this.frameCount;
    },


    /**
     * get the object providing `requestAnimationFrame`
     * and `cancelAnimationFrame` methods
     * @return {Object}
     */
    getRequestAnimationFrameObject: function(){
        return this.requestAnimationFrameObject;
    },

    /**
     * is the animation loop active
     *
     * @return {boolean}
     */
    isRunning: function(){
        return this.__running;
    },

    /**
     * is the animation marked as completed
     *
     * @return {boolean}
     */
    isCompleted: function(){
        return this.__completed;
    },

    /**
     * reset the animation loop, marks as incomplete,
     * leaves listeners intact
     *
     * @emit Animitter#reset
     * @return {Animitter}
     */
    reset: function(){
        this.stop();
        this.__completed = false;
        this.__lastTime = 0;
        this.deltaTime = 0;
        this.elapsedTime = 0;
        this.frameCount = 0;

        this.emit('reset', 0, 0, this.frameCount);
        return this;
    },

    /**
     * set the framerate for the animation loop
     *
     * @param {Number} fps
     * @return {Animitter}
     */
    setFPS: function(fps){
        this.__fps = fps;
        this.__isReadyForUpdate = makeThrottle(fps);
        return this;
    },

    /**
     * set the object that will provide `requestAnimationFrame`
     * and `cancelAnimationFrame` methods to this instance
     * @param {Object} object
     * @return {Animitter}
     */
    setRequestAnimationFrameObject: function(object){
        if(typeof object.requestAnimationFrame !== 'function' || typeof object.cancelAnimationFrame !== 'function'){
            throw new Error("Invalid object provide to `setRequestAnimationFrameObject`");
        }
        this.requestAnimationFrameObject = object;
        return this;
    },

    /**
     * start an animation loop
     * @emit Animitter#start
     * @return {Animitter}
     */
    start: function(){
        var self = this;
        if(this.__delay){
            setTimeout(function(){
                onStart(self);
            }, this.__delay);
        } else {
            onStart(this);
        }
        return this;
    },

    /**
     * stops the animation loop, does not mark as completed
     *
     * @emit Animitter#stop
     * @return {Animitter}
     */
    stop: function(){
        if( this.__running ){
            this.__running = false;
            exports.running -= 1;
            this.emit('stop', this.deltaTime, this.elapsedTime, this.frameCount);
        }
        return this;
    },

    /**
     * update the animation loop once
     *
     * @emit Animitter#update
     * @return {Animitter}
     */
    update: function(){
        this.frameCount++;
        /** @private */
        var now = Date.now();
        this.__lastTime = this.__lastTime || now;
        this.deltaTime = (this.fixedDelta || exports.globalFixedDelta) ? 1000/Math.min(60, this.__fps) : now - this.__lastTime;
        this.elapsedTime += this.deltaTime;
        this.__lastTime = now;

        this.emit('update', this.deltaTime, this.elapsedTime, this.frameCount);
        return this;
    }
};



for(var method in methods){
    Animitter.prototype[method] = methods[method];
}


/**
 * create an animitter instance,
 * @param {Object} [options]
 * @param {Function} fn( deltaTime:Number, elapsedTime:Number, frameCount:Number )
 * @returns {Animitter}
 */
function createAnimitter(options, fn){

    if( arguments.length === 1 && typeof options === 'function'){
        fn = options;
        options = {};
    }

    var _instance = new Animitter( options );

    if( fn ){
        _instance.on('update', fn);
    }

    return _instance;
}

module.exports = exports = createAnimitter;

/**
 * create an animitter instance,
 * where the scope is bound in all functions
 * @param {Object} [options]
 * @param {Function} fn( deltaTime:Number, elapsedTime:Number, frameCount:Number )
 * @returns {Animitter}
 */
exports.bound = function(options, fn){

    var loop = createAnimitter(options, fn),
        functionKeys = functions(Animitter.prototype),
        hasBind = !!Function.prototype.bind,
        fnKey;

    for(var i=0; i<functionKeys.length; i++){
        fnKey = functionKeys[i];
        loop[fnKey] = hasBind ? loop[fnKey].bind(loop) : bind(loop[fnKey], loop);
    }

    return loop;
};


exports.Animitter = Animitter;

/**
 * if true, all `Animitter` instances will behave as if `options.fixedDelta = true`
 */
exports.globalFixedDelta = false;

//helpful to inherit from when using bundled
exports.EventEmitter = EventEmitter;
//keep a global counter of all loops running, helpful to watch in dev tools
exports.running = 0;

function bind(fn, scope){
    if(typeof fn.bind === 'function'){
        return fn.bind(scope);
    }
    return function(){
        return fn.apply(scope, arguments);
    };
}

function functions(obj){
    var keys = Object.keys(obj);
    var arr = [];
    for(var i=0; i<keys.length; i++){
        if(typeof obj[keys[i]] === 'function'){
            arr.push(keys[i]);
        }
    }
    return arr;
}



//polyfill Date.now for real-old browsers
Date.now = Date.now || function now() {
    return new Date().getTime();
};

},{"events":23,"inherits":35,"raf":51}],3:[function(_dereq_,module,exports){
var toBuffer       = _dereq_('typedarray-to-buffer'),
    isFloat32Array = _dereq_('validate.io-float32array')

module.exports = function(float32Array) {

    if (!float32Array)
        throw new Error('A Float32Array parameter is missing.')

    if (!isFloat32Array(float32Array))
        throw new Error('The parameter is not a Float32Array.')

    this.toBuffer = function() {

        var l   = float32Array.length,
            arr = new Int16Array(l),
            i

        for (i = 0; i < l; i++) {
            arr[i] = Math.min(1, float32Array[i]) * 0x7FFF
        }

        return toBuffer(arr)
    }
}

},{"typedarray-to-buffer":74,"validate.io-float32array":80}],4:[function(_dereq_,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],5:[function(_dereq_,module,exports){

},{}],6:[function(_dereq_,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],7:[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],8:[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (value instanceof ArrayBuffer) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || string instanceof ArrayBuffer) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":4,"ieee754":33}],9:[function(_dereq_,module,exports){
var toBuffer  = _dereq_('typedarray-to-buffer'),
    isBrowser = typeof(document) !== 'undefined' && typeof(document.createElement) === 'function',

    // cached, used only once for browser environments
    verifiedImageType

module.exports = function(canvas, options) {

    var self = this, quality

    options             = options               ? options :             {}
    options.image       = options.image         ? options.image :       {}
    options.image.types = options.image.types   ? options.image.types : []

    // validate some options this class needs
    if (options.image.types.length > 2)
        throw new Error('Too many image types are specified!')

    else if (options.image.types.length < 1) {

        // Set a default image type, just to be robust
        options.image.types = isBrowser ? ['webp', 'jpeg'] : ['png']
    }

    if (!options.image.quality)
        options.image.quality = .5 // default

    quality = parseFloat(options.image.quality)

    function composeImageType(index) {
        var imageType

        if (options.image.types[index])
            imageType = 'image/' + options.image.types[index]

        return imageType
    }

    function isMatch(uri, imageType) {
        var match = uri && uri.match(imageType)

        match && options.debug && options.debug('Image type %s verified', imageType)

        return match
    }

    // Performance tweak, we do not need a big canvas for finding out the supported image type
    function getTestCanvas() {

        var testCanvas

        if (isBrowser) {
            testCanvas = document.createElement('canvas')
            testCanvas.width = testCanvas.height = 1
        } else
            testCanvas = canvas

        return testCanvas
    }

    function canvasSupportsImageTypeAsync(imageType, cb) {
        try {
            getTestCanvas().toDataURL(imageType, function(err, uri) {
                if (err)
                    cb(err)
                else
                    cb(null, isMatch(uri, imageType))
            })
        } catch (exc) {
            cb(null, false)
        }
    }

    function canvasSupportsImageTypeSync(imageType) {
        var match

        try {
            var testCanvas = getTestCanvas(),
                uri        = testCanvas.toDataURL && testCanvas.toDataURL(imageType)

            match = isMatch(uri, imageType)
        } catch (exc) {

            // Can happen when i.E. a spider is coming. Just be robust here and continue.
            options.debug &&
            options.logger.debug('Failed to call toDataURL() on canvas for image type %s', imageType)
        }

        return match
    }

    function verifyImageTypeAsync(imageType, cb) {
        canvasSupportsImageTypeAsync(imageType, function(err, match) {
            if (err)
                cb(err)
            else {

                if (match)
                    cb(null, imageType)
                else {
                    imageType = composeImageType(1)

                    canvasSupportsImageTypeAsync(imageType, function(err, match) {
                        if (err)
                            cb(err)
                        else
                            cb(null, match ? imageType: null)
                    })
                }
            }
        })
    }

    function verifyImageTypeSync(imageType) {
        if (!canvasSupportsImageTypeSync(imageType)) {

            if (options.image.types[1]) {
                imageType = composeImageType(1)

                if (!canvasSupportsImageTypeSync(imageType))
                    imageType = null
            } else
                imageType = null
        }

        !imageType && options.debug && options.logger.debug('Unable to verify image type')

        return imageType
    }

    // callbacks are needed for server side tests
    function verifyImageType(cb) {
        var imageType = composeImageType(0)

        if (cb) {
            verifyImageTypeAsync(imageType, cb)
        } else {
            return verifyImageTypeSync(imageType)
        }
    }

    // this method is proven to be fast, see
    // http://jsperf.com/data-uri-to-buffer-performance/3
    function uriToBuffer(uri) {

        var uri = uri.split(',')[1],
            bytes

        // Beware that the atob function might be a static one for server side tests
        if (typeof(atob) === 'function')
            bytes = atob(uri)
        else if (typeof(self.constructor.atob) === 'function')
            bytes = self.constructor.atob(uri)
        else
            throw new Error('atob function is missing')

        var arr = new Uint8Array(bytes.length)

        // http://mrale.ph/blog/2014/12/24/array-length-caching.html
        for (var i = 0, l = bytes.length; i < l; i++) {
            arr[i] = bytes.charCodeAt(i)
        }

        return toBuffer(arr)
    }

    function toBufferSync() {
        var imageType = self.getImageType(),
            buffer

        if (imageType) {
            var uri = canvas.toDataURL(imageType, quality)
            buffer = uriToBuffer(uri)
        }

        return buffer
    }

    function toBufferAsync(cb) {
        self.getImageType(function(err, imageType) {
            if (err)
                cb(err)
            else if (!imageType)
                cb()
            else
                canvas.toDataURL(imageType, function(err, uri) {
                    if (err)
                        cb(err)
                    else
                        cb(null, uriToBuffer(uri))
                })
        })
    }

    this.toBuffer = function(cb) {
        if (cb)
            toBufferAsync(cb)
        else
            return toBufferSync()
    }

    // browsers do not need a callback, but tests do
    this.getImageType = function(cb) {

        // only run for the first time this constructor is called and
        // cache result for the next calls

        if (cb) {
            if (!verifiedImageType || !isBrowser)
                verifyImageType(function(err, newVerifiedImageType) {
                    if (err)
                        cb(err)
                    else {
                        verifiedImageType = newVerifiedImageType
                        cb(null, verifiedImageType)
                    }
                })
            else
                cb(null, verifiedImageType)

        } else {
            // on the browser side we do cache it for speed
            if (!verifiedImageType || !isBrowser)
                verifiedImageType = verifyImageType()

            return verifiedImageType
        }
    }
}

},{"typedarray-to-buffer":74}],10:[function(_dereq_,module,exports){
// contains, add, remove, toggle
var indexof = _dereq_('indexof')

module.exports = ClassList

function ClassList(elem) {
    var cl = elem.classList

    if (cl) {
        return cl
    }

    var classList = {
        add: add
        , remove: remove
        , contains: contains
        , toggle: toggle
        , toString: $toString
        , length: 0
        , item: item
    }

    return classList

    function add(token) {
        var list = getTokens()
        if (indexof(list, token) > -1) {
            return
        }
        list.push(token)
        setTokens(list)
    }

    function remove(token) {
        var list = getTokens()
            , index = indexof(list, token)

        if (index === -1) {
            return
        }

        list.splice(index, 1)
        setTokens(list)
    }

    function contains(token) {
        return indexof(getTokens(), token) > -1
    }

    function toggle(token) {
        if (contains(token)) {
            remove(token)
            return false
        } else {
            add(token)
            return true
        }
    }

    function $toString() {
        return elem.className
    }

    function item(index) {
        var tokens = getTokens()
        return tokens[index] || null
    }

    function getTokens() {
        var className = elem.className

        return filter(className.split(" "), isTruthy)
    }

    function setTokens(list) {
        var length = list.length

        elem.className = list.join(" ")
        classList.length = length

        for (var i = 0; i < list.length; i++) {
            classList[i] = list[i]
        }

        delete list[length]
    }
}

function filter (arr, fn) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i])) ret.push(arr[i])
    }
    return ret
}

function isTruthy(value) {
    return !!value
}

},{"indexof":34}],11:[function(_dereq_,module,exports){
/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_")) 
	|| document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
	  classListProp = "classList"
	, protoProp = "prototype"
	, elemCtrProto = view.Element[protoProp]
	, objCtr = Object
	, strTrim = String[protoProp].trim || function () {
		return this.replace(/^\s+|\s+$/g, "");
	}
	, arrIndexOf = Array[protoProp].indexOf || function (item) {
		var
			  i = 0
			, len = this.length
		;
		for (; i < len; i++) {
			if (i in this && this[i] === item) {
				return i;
			}
		}
		return -1;
	}
	// Vendors: please allow content code to instantiate DOMExceptions
	, DOMEx = function (type, message) {
		this.name = type;
		this.code = DOMException[type];
		this.message = message;
	}
	, checkTokenAndGetIndex = function (classList, token) {
		if (token === "") {
			throw new DOMEx(
				  "SYNTAX_ERR"
				, "An invalid or illegal string was specified"
			);
		}
		if (/\s/.test(token)) {
			throw new DOMEx(
				  "INVALID_CHARACTER_ERR"
				, "String contains an invalid character"
			);
		}
		return arrIndexOf.call(classList, token);
	}
	, ClassList = function (elem) {
		var
			  trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
			, classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
			, i = 0
			, len = classes.length
		;
		for (; i < len; i++) {
			this.push(classes[i]);
		}
		this._updateClassName = function () {
			elem.setAttribute("class", this.toString());
		};
	}
	, classListProto = ClassList[protoProp] = []
	, classListGetter = function () {
		return new ClassList(this);
	}
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
	return this[i] || null;
};
classListProto.contains = function (token) {
	token += "";
	return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
	;
	do {
		token = tokens[i] + "";
		if (checkTokenAndGetIndex(this, token) === -1) {
			this.push(token);
			updated = true;
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.remove = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
		, index
	;
	do {
		token = tokens[i] + "";
		index = checkTokenAndGetIndex(this, token);
		while (index !== -1) {
			this.splice(index, 1);
			updated = true;
			index = checkTokenAndGetIndex(this, token);
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.toggle = function (token, force) {
	token += "";

	var
		  result = this.contains(token)
		, method = result ?
			force !== true && "remove"
		:
			force !== false && "add"
	;

	if (method) {
		this[method](token);
	}

	if (force === true || force === false) {
		return force;
	} else {
		return !result;
	}
};
classListProto.toString = function () {
	return this.join(" ");
};

if (objCtr.defineProperty) {
	var classListPropDesc = {
		  get: classListGetter
		, enumerable: true
		, configurable: true
	};
	try {
		objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
	} catch (ex) { // IE 8 doesn't support enumerable:true
		if (ex.number === -0x7FF5EC54) {
			classListPropDesc.enumerable = false;
			objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
		}
	}
} else if (objCtr[protoProp].__defineGetter__) {
	elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(self));

} else {
// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
	"use strict";

	var testElement = document.createElement("_");

	testElement.classList.add("c1", "c2");

	// Polyfill for IE 10/11 and Firefox <26, where classList.add and
	// classList.remove exist but support only one argument at a time.
	if (!testElement.classList.contains("c2")) {
		var createMethod = function(method) {
			var original = DOMTokenList.prototype[method];

			DOMTokenList.prototype[method] = function(token) {
				var i, len = arguments.length;

				for (i = 0; i < len; i++) {
					token = arguments[i];
					original.call(this, token);
				}
			};
		};
		createMethod('add');
		createMethod('remove');
	}

	testElement.classList.toggle("c3", false);

	// Polyfill for IE 10 and Firefox <24, where classList.toggle does not
	// support the second argument.
	if (testElement.classList.contains("c3")) {
		var _toggle = DOMTokenList.prototype.toggle;

		DOMTokenList.prototype.toggle = function(token, force) {
			if (1 in arguments && !this.contains(token) === !force) {
				return force;
			} else {
				return _toggle.call(this, token);
			}
		};

	}

	testElement = null;
}());

}

}


},{}],12:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],13:[function(_dereq_,module,exports){
var DOCUMENT_POSITION_CONTAINED_BY = 16

module.exports = contains

function contains(container, elem) {
    if (container.contains) {
        return container.contains(elem)
    }

    var comparison = container.compareDocumentPosition(elem)

    return comparison === 0 || comparison & DOCUMENT_POSITION_CONTAINED_BY
}

},{}],14:[function(_dereq_,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":_dereq_("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":39}],15:[function(_dereq_,module,exports){
//     create-error.js 0.3.1
//     (c) 2013 Tim Griesser
//     This source may be freely distributed under the MIT license.
(function(factory) {

"use strict";

// A simple utility for subclassing the "Error"
// object in multiple environments, while maintaining
// relevant stack traces, messages, and prototypes.
factory(function() {

var toString = Object.prototype.toString;

// Creates an new error type with a "name",
// and any additional properties that should be set
// on the error instance.
return function() {
  var args = new Array(arguments.length);
  for (var i = 0; i < args.length; ++i) {
    args[i] = arguments[i];
  }
  var name       = getName(args);
  var target     = getTarget(args);
  var properties = getProps(args);
  function ErrorCtor(message, obj) {
    attachProps(this, properties);
    attachProps(this, obj);
    this.message = (message || this.message);
    if (message instanceof Error) {
      this.message = message.message;
      this.stack = message.stack;
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  function Err() { this.constructor = ErrorCtor; }
  Err.prototype = target['prototype'];
  ErrorCtor.prototype = new Err();
  ErrorCtor.prototype.name = ('' + name) || 'CustomError';
  return ErrorCtor;
};

// Just a few helpers to clean up the function above
// https://github.com/petkaantonov/bluebird/wiki/Optimization-killers
function getName(args) {
  if (args.length === 0) return '';
  return isError(args[0]) ? (args[1] || '') : args[0];
}
function getTarget(args) {
  if (args.length === 0) return Error;
  return isError(args[0]) ? args[0] : Error;
}
function getProps(args) {
  if (args.length === 0) return null;
  return isError(args[0]) ? args[2] : args[1];
}
function inheritedKeys(obj) {
  var ret = [];
  for (var key in obj) {
    ret.push(key);
  }
  return ret;
}

// Right now we're just assuming that a function in the first argument is an error.
function isError(obj) {
  return (typeof obj === "function");
}

// We don't need the full underscore check here, since it should either be
// an object-literal, or nothing at all.
function isObject(obj) {
  return (obj && typeof obj === "object" && toString.call(obj) === "[object Object]");
}

// Used to attach attributes to the error object in the constructor.
function attachProps(context, target) {
  if (isObject(target)) {
    var keys = inheritedKeys(target);
    for (var i = 0, l = keys.length; i < l; ++i) {
      context[keys[i]] = clone(target[keys[i]]);
    }
  }
}

// Don't need the full-out "clone" mechanism here, since if you're
// trying to set things other than empty arrays/objects on your
// sub-classed `Error` object, you're probably doing it wrong.
function clone(target) {
  if (target == null || typeof target !== "object") return target;
  var cloned = target.constructor ? target.constructor() : Object.create(null);
  for (var attr in target) {
    if (target.hasOwnProperty(attr)) {
      cloned[attr] = target[attr];
    }
  }
  return cloned;
}

});

// Boilerplate UMD definition block...
})(function(createErrorLib) {
  if (typeof define === "function" && define.amd) {
    define(createErrorLib);
  } else if (typeof exports === 'object') {
    module.exports = createErrorLib();
  } else {
    var root = this;
    var lastcreateError = root.createError;
    var createError = root.createError = createErrorLib();
    createError.noConflict = function() {
      root.createError = lastcreateError;
      return createError;
    };
  }
});

},{}],16:[function(_dereq_,module,exports){
module.exports = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) return arguments[i];
    }
};

},{}],17:[function(_dereq_,module,exports){
var util = _dereq_('util')
var global = _dereq_('global')
var EventEmitter = _dereq_('events')

var makeDespot = function () {
  var Despot = function () {
    if (global._singletonDespotInstance) {
      return global._singletonDespotInstance
    } else {
      global._singletonDespotInstance = this
      EventEmitter.call(this)
    }
  }

  util.inherits(Despot, EventEmitter)

  return new Despot()
}

module.exports = makeDespot()

},{"events":23,"global":29,"util":79}],18:[function(_dereq_,module,exports){
'use strict'

var document = _dereq_('global/document')
var Event = _dereq_('geval')
var Keys = _dereq_('./keys')

module.exports = Visibility

function Visibility () {
  var keys = Keys(document)
  if (!keys) return noopShim()

  return {
    visible: visible,
    onChange: Event(listen)
  }

  function visible () {
    return !document[keys.hidden]
  }

  function listen (broadcast) {
    document.addEventListener(keys.event, function onVisibilityChange () {
      broadcast(visible())
    })
  }
}

function noopShim () {
  return {
    visible: function () {
      return true
    },
    onChange: noop
  }
}

function noop () {}

},{"./keys":19,"geval":27,"global/document":28}],19:[function(_dereq_,module,exports){
'use strict'

module.exports = keys

function keys (document) {
  var prefix = detectPrefix(document)
  if (prefix == null) return
  return {
    hidden: lowercaseFirst(prefix + 'Hidden'),
    event: prefix + 'visibilitychange'
  }
}

function detectPrefix (document) {
  if (document.hidden != null) return ''
  if (document.mozHidden != null) return 'moz'
  if (document.msHidden != null) return 'ms'
  if (document.webkitHidden != null) return 'webkit'
}

function lowercaseFirst (string) {
  return string.substring(0, 1).toLowerCase() + string.substring(1)
}

},{}],20:[function(_dereq_,module,exports){
(function (process,Buffer){
var stream = _dereq_('readable-stream')
var eos = _dereq_('end-of-stream')
var inherits = _dereq_('inherits')
var shift = _dereq_('stream-shift')

var SIGNAL_FLUSH = new Buffer([0])

var onuncork = function(self, fn) {
  if (self._corked) self.once('uncork', fn)
  else fn()
}

var destroyer = function(self, end) {
  return function(err) {
    if (err) self.destroy(err.message === 'premature close' ? null : err)
    else if (end && !self._ended) self.end()
  }
}

var end = function(ws, fn) {
  if (!ws) return fn()
  if (ws._writableState && ws._writableState.finished) return fn()
  if (ws._writableState) return ws.end(fn)
  ws.end()
  fn()
}

var toStreams2 = function(rs) {
  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)
}

var Duplexify = function(writable, readable, opts) {
  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)
  stream.Duplex.call(this, opts)

  this._writable = null
  this._readable = null
  this._readable2 = null

  this._forwardDestroy = !opts || opts.destroy !== false
  this._forwardEnd = !opts || opts.end !== false
  this._corked = 1 // start corked
  this._ondrain = null
  this._drained = false
  this._forwarding = false
  this._unwrite = null
  this._unread = null
  this._ended = false

  this.destroyed = false

  if (writable) this.setWritable(writable)
  if (readable) this.setReadable(readable)
}

inherits(Duplexify, stream.Duplex)

Duplexify.obj = function(writable, readable, opts) {
  if (!opts) opts = {}
  opts.objectMode = true
  opts.highWaterMark = 16
  return new Duplexify(writable, readable, opts)
}

Duplexify.prototype.cork = function() {
  if (++this._corked === 1) this.emit('cork')
}

Duplexify.prototype.uncork = function() {
  if (this._corked && --this._corked === 0) this.emit('uncork')
}

Duplexify.prototype.setWritable = function(writable) {
  if (this._unwrite) this._unwrite()

  if (this.destroyed) {
    if (writable && writable.destroy) writable.destroy()
    return
  }

  if (writable === null || writable === false) {
    this.end()
    return
  }

  var self = this
  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))

  var ondrain = function() {
    var ondrain = self._ondrain
    self._ondrain = null
    if (ondrain) ondrain()
  }

  var clear = function() {
    self._writable.removeListener('drain', ondrain)
    unend()
  }

  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks

  this._writable = writable
  this._writable.on('drain', ondrain)
  this._unwrite = clear

  this.uncork() // always uncork setWritable
}

Duplexify.prototype.setReadable = function(readable) {
  if (this._unread) this._unread()

  if (this.destroyed) {
    if (readable && readable.destroy) readable.destroy()
    return
  }

  if (readable === null || readable === false) {
    this.push(null)
    this.resume()
    return
  }

  var self = this
  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))

  var onreadable = function() {
    self._forward()
  }

  var onend = function() {
    self.push(null)
  }

  var clear = function() {
    self._readable2.removeListener('readable', onreadable)
    self._readable2.removeListener('end', onend)
    unend()
  }

  this._drained = true
  this._readable = readable
  this._readable2 = readable._readableState ? readable : toStreams2(readable)
  this._readable2.on('readable', onreadable)
  this._readable2.on('end', onend)
  this._unread = clear

  this._forward()
}

Duplexify.prototype._read = function() {
  this._drained = true
  this._forward()
}

Duplexify.prototype._forward = function() {
  if (this._forwarding || !this._readable2 || !this._drained) return
  this._forwarding = true

  var data

  while (this._drained && (data = shift(this._readable2)) !== null) {
    if (this.destroyed) continue
    this._drained = this.push(data)
  }

  this._forwarding = false
}

Duplexify.prototype.destroy = function(err) {
  if (this.destroyed) return
  this.destroyed = true

  var self = this
  process.nextTick(function() {
    self._destroy(err)
  })
}

Duplexify.prototype._destroy = function(err) {
  if (err) {
    var ondrain = this._ondrain
    this._ondrain = null
    if (ondrain) ondrain(err)
    else this.emit('error', err)
  }

  if (this._forwardDestroy) {
    if (this._readable && this._readable.destroy) this._readable.destroy()
    if (this._writable && this._writable.destroy) this._writable.destroy()
  }

  this.emit('close')
}

Duplexify.prototype._write = function(data, enc, cb) {
  if (this.destroyed) return cb()
  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))
  if (data === SIGNAL_FLUSH) return this._finish(cb)
  if (!this._writable) return cb()

  if (this._writable.write(data) === false) this._ondrain = cb
  else cb()
}


Duplexify.prototype._finish = function(cb) {
  var self = this
  this.emit('preend')
  onuncork(this, function() {
    end(self._forwardEnd && self._writable, function() {
      // haxx to not emit prefinish twice
      if (self._writableState.prefinished === false) self._writableState.prefinished = true
      self.emit('prefinish')
      onuncork(self, cb)
    })
  })
}

Duplexify.prototype.end = function(data, enc, cb) {
  if (typeof data === 'function') return this.end(null, null, data)
  if (typeof enc === 'function') return this.end(data, null, enc)
  this._ended = true
  if (data) this.write(data)
  if (!this._writableState.ending) this.write(SIGNAL_FLUSH)
  return stream.Writable.prototype.end.call(this, cb)
}

module.exports = Duplexify

}).call(this,_dereq_('_process'),_dereq_("buffer").Buffer)

},{"_process":7,"buffer":8,"end-of-stream":22,"inherits":35,"readable-stream":60,"stream-shift":65}],21:[function(_dereq_,module,exports){
// element-closest | CC0-1.0 | github.com/jonathantneal/closest

(function (ElementProto) {
	if (typeof ElementProto.matches !== 'function') {
		ElementProto.matches = ElementProto.msMatchesSelector || ElementProto.mozMatchesSelector || ElementProto.webkitMatchesSelector || function matches(selector) {
			var element = this;
			var elements = (element.document || element.ownerDocument).querySelectorAll(selector);
			var index = 0;

			while (elements[index] && elements[index] !== element) {
				++index;
			}

			return Boolean(elements[index]);
		};
	}

	if (typeof ElementProto.closest !== 'function') {
		ElementProto.closest = function closest(selector) {
			var element = this;

			while (element && element.nodeType === 1) {
				if (element.matches(selector)) {
					return element;
				}

				element = element.parentNode;
			}

			return null;
		};
	}
})(window.Element.prototype);

},{}],22:[function(_dereq_,module,exports){
var once = _dereq_('once');

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback();
	};

	var onend = function() {
		readable = false;
		if (!writable) callback();
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', callback);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('end', onend);
		stream.removeListener('error', callback);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;
},{"once":48}],23:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],24:[function(_dereq_,module,exports){
(function (global){
"use strict";

/**
 * filesize
 *
 * @copyright 2017 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 3.5.10
 */
(function (global) {
	var b = /^(b|B)$/,
	    symbol = {
		iec: {
			bits: ["b", "Kib", "Mib", "Gib", "Tib", "Pib", "Eib", "Zib", "Yib"],
			bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
		},
		jedec: {
			bits: ["b", "Kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Yb"],
			bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
		}
	},
	    fullform = {
		iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
		jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
	};

	/**
  * filesize
  *
  * @method filesize
  * @param  {Mixed}   arg        String, Int or Float to transform
  * @param  {Object}  descriptor [Optional] Flags
  * @return {String}             Readable file size String
  */
	function filesize(arg) {
		var descriptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		var result = [],
		    val = 0,
		    e = void 0,
		    base = void 0,
		    bits = void 0,
		    ceil = void 0,
		    full = void 0,
		    fullforms = void 0,
		    neg = void 0,
		    num = void 0,
		    output = void 0,
		    round = void 0,
		    unix = void 0,
		    spacer = void 0,
		    standard = void 0,
		    symbols = void 0;

		if (isNaN(arg)) {
			throw new Error("Invalid arguments");
		}

		bits = descriptor.bits === true;
		unix = descriptor.unix === true;
		base = descriptor.base || 2;
		round = descriptor.round !== undefined ? descriptor.round : unix ? 1 : 2;
		spacer = descriptor.spacer !== undefined ? descriptor.spacer : unix ? "" : " ";
		symbols = descriptor.symbols || descriptor.suffixes || {};
		standard = base === 2 ? descriptor.standard || "jedec" : "jedec";
		output = descriptor.output || "string";
		full = descriptor.fullform === true;
		fullforms = descriptor.fullforms instanceof Array ? descriptor.fullforms : [];
		e = descriptor.exponent !== undefined ? descriptor.exponent : -1;
		num = Number(arg);
		neg = num < 0;
		ceil = base > 2 ? 1000 : 1024;

		// Flipping a negative number to determine the size
		if (neg) {
			num = -num;
		}

		// Determining the exponent
		if (e === -1 || isNaN(e)) {
			e = Math.floor(Math.log(num) / Math.log(ceil));

			if (e < 0) {
				e = 0;
			}
		}

		// Exceeding supported length, time to reduce & multiply
		if (e > 8) {
			e = 8;
		}

		// Zero is now a special case because bytes divide by 1
		if (num === 0) {
			result[0] = 0;
			result[1] = unix ? "" : symbol[standard][bits ? "bits" : "bytes"][e];
		} else {
			val = num / (base === 2 ? Math.pow(2, e * 10) : Math.pow(1000, e));

			if (bits) {
				val = val * 8;

				if (val >= ceil && e < 8) {
					val = val / ceil;
					e++;
				}
			}

			result[0] = Number(val.toFixed(e > 0 ? round : 0));
			result[1] = base === 10 && e === 1 ? bits ? "kb" : "kB" : symbol[standard][bits ? "bits" : "bytes"][e];

			if (unix) {
				result[1] = standard === "jedec" ? result[1].charAt(0) : e > 0 ? result[1].replace(/B$/, "") : result[1];

				if (b.test(result[1])) {
					result[0] = Math.floor(result[0]);
					result[1] = "";
				}
			}
		}

		// Decorating a 'diff'
		if (neg) {
			result[0] = -result[0];
		}

		// Applying custom symbol
		result[1] = symbols[result[1]] || result[1];

		// Returning Array, Object, or String (default)
		if (output === "array") {
			return result;
		}

		if (output === "exponent") {
			return e;
		}

		if (output === "object") {
			return { value: result[0], suffix: result[1], symbol: result[1] };
		}

		if (full) {
			result[1] = fullforms[e] ? fullforms[e] : fullform[standard][e] + (bits ? "bit" : "byte") + (result[0] === 1 ? "" : "s");
		}

		return result.join(spacer);
	}

	// Partial application for functional programming
	filesize.partial = function (opt) {
		return function (arg) {
			return filesize(arg, opt);
		};
	};

	// CommonJS, AMD, script tag
	if (typeof exports !== "undefined") {
		module.exports = filesize;
	} else if (typeof define === "function" && define.amd) {
		define(function () {
			return filesize;
		});
	} else {
		global.filesize = filesize;
	}
})(typeof window !== "undefined" ? window : global);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],25:[function(_dereq_,module,exports){
'use strict';

exports.__esModule = true;
var NODE_LIST_CLASSES = {
  '[object HTMLCollection]': true,
  '[object NodeList]': true,
  '[object RadioNodeList]': true
};

// .type values for elements which can appear in .elements and should be ignored
var IGNORED_ELEMENT_TYPES = {
  'button': true,
  'fieldset': true,
  // 'keygen': true,
  // 'output': true,
  'reset': true,
  'submit': true
};

var CHECKED_INPUT_TYPES = {
  'checkbox': true,
  'radio': true
};

var TRIM_RE = /^\s+|\s+$/g;

var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * @param {HTMLFormElement} form
 * @param {Object} options
 * @return {Object.<string,(string|Array.<string>)>} an object containing
 *   submittable value(s) held in the form's .elements collection, with
 *   properties named as per element names or ids.
 */
function getFormData(form) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? { trim: false } : arguments[1];

  if (!form) {
    throw new Error('A form is required by getFormData, was given form=' + form);
  }

  var data = {};
  var elementName = undefined;
  var elementNames = [];
  var elementNameLookup = {};

  // Get unique submittable element names for the form
  for (var i = 0, l = form.elements.length; i < l; i++) {
    var element = form.elements[i];
    if (IGNORED_ELEMENT_TYPES[element.type] || element.disabled) {
      continue;
    }
    elementName = element.name || element.id;
    if (elementName && !elementNameLookup[elementName]) {
      elementNames.push(elementName);
      elementNameLookup[elementName] = true;
    }
  }

  // Extract element data name-by-name for consistent handling of special cases
  // around elements which contain multiple inputs.
  for (var i = 0, l = elementNames.length; i < l; i++) {
    elementName = elementNames[i];
    var value = getNamedFormElementData(form, elementName, options);
    if (value != null) {
      data[elementName] = value;
    }
  }

  return data;
}

/**
 * @param {HTMLFormElement} form
 * @param {string} elementName
 * @param {Object} options
 * @return {(string|Array.<string>)} submittable value(s) in the form for a
 *   named element from its .elements collection, or null if there was no
 *   element with that name or the element had no submittable value(s).
 */
function getNamedFormElementData(form, elementName) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? { trim: false } : arguments[2];

  if (!form) {
    throw new Error('A form is required by getNamedFormElementData, was given form=' + form);
  }
  if (!elementName && toString.call(elementName) !== '[object String]') {
    throw new Error('A form element name is required by getNamedFormElementData, was given elementName=' + elementName);
  }

  var element = form.elements[elementName];
  if (!element || element.disabled) {
    return null;
  }

  if (!NODE_LIST_CLASSES[toString.call(element)]) {
    return getFormElementValue(element, options.trim);
  }

  // Deal with multiple form controls which have the same name
  var data = [];
  var allRadios = true;
  for (var i = 0, l = element.length; i < l; i++) {
    if (element[i].disabled) {
      continue;
    }
    if (allRadios && element[i].type !== 'radio') {
      allRadios = false;
    }
    var value = getFormElementValue(element[i], options.trim);
    if (value != null) {
      data = data.concat(value);
    }
  }

  // Special case for an element with multiple same-named inputs which were all
  // radio buttons: if there was a selected value, only return the value.
  if (allRadios && data.length === 1) {
    return data[0];
  }

  return data.length > 0 ? data : null;
}

/**
 * @param {HTMLElement} element a form element.
 * @param {booleam} trim should values for text entry inputs be trimmed?
 * @return {(string|Array.<string>|File|Array.<File>)} the element's submittable
 *   value(s), or null if it had none.
 */
function getFormElementValue(element, trim) {
  var value = null;
  var type = element.type;

  if (type === 'select-one') {
    if (element.options.length) {
      value = element.options[element.selectedIndex].value;
    }
    return value;
  }

  if (type === 'select-multiple') {
    value = [];
    for (var i = 0, l = element.options.length; i < l; i++) {
      if (element.options[i].selected) {
        value.push(element.options[i].value);
      }
    }
    if (value.length === 0) {
      value = null;
    }
    return value;
  }

  // If a file input doesn't have a files attribute, fall through to using its
  // value attribute.
  if (type === 'file' && 'files' in element) {
    if (element.multiple) {
      value = slice.call(element.files);
      if (value.length === 0) {
        value = null;
      }
    } else {
      // Should be null if not present, according to the spec
      value = element.files[0];
    }
    return value;
  }

  if (!CHECKED_INPUT_TYPES[type]) {
    value = trim ? element.value.replace(TRIM_RE, '') : element.value;
  } else if (element.checked) {
    value = element.value;
  }

  return value;
}

getFormData.getNamedFormElementData = getNamedFormElementData;

exports['default'] = getFormData;
module.exports = exports['default'];
},{}],26:[function(_dereq_,module,exports){
module.exports = Event

function Event() {
    var listeners = []

    return { broadcast: broadcast, listen: event }

    function broadcast(value) {
        for (var i = 0; i < listeners.length; i++) {
            listeners[i](value)
        }
    }

    function event(listener) {
        listeners.push(listener)

        return removeListener

        function removeListener() {
            var index = listeners.indexOf(listener)
            if (index !== -1) {
                listeners.splice(index, 1)
            }
        }
    }
}

},{}],27:[function(_dereq_,module,exports){
var Event = _dereq_('./event.js')

module.exports = Source

function Source(broadcaster) {
    var tuple = Event()

    broadcaster(tuple.broadcast)

    return tuple.listen
}

},{"./event.js":26}],28:[function(_dereq_,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = _dereq_('min-document');

var doccy;

if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}

module.exports = doccy;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":5}],29:[function(_dereq_,module,exports){
(function (global){
var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],30:[function(_dereq_,module,exports){
module.exports = shim

function shim (element, value) {
    if (value === undefined) {
        return element.style.display === 'none'
    }

    element.style.display = value ? 'none' : ''
}

},{}],31:[function(_dereq_,module,exports){
// HumanizeDuration.js - http://git.io/j0HgmQ

;(function () {
  var languages = {
    ar: {
      y: function (c) { return c === 1 ? '' : '' },
      mo: function (c) { return c === 1 ? '' : '' },
      w: function (c) { return c === 1 ? '' : '' },
      d: function (c) { return c === 1 ? '' : '' },
      h: function (c) { return c === 1 ? '' : '' },
      m: function (c) { return c === 1 ? '' : '' },
      s: function (c) { return c === 1 ? '' : '' },
      ms: function (c) { return c === 1 ? '  ' : '  ' },
      decimal: ','
    },
    ca: {
      y: function (c) { return 'any' + (c === 1 ? '' : 's') },
      mo: function (c) { return 'mes' + (c === 1 ? '' : 'os') },
      w: function (c) { return 'setman' + (c === 1 ? 'a' : 'es') },
      d: function (c) { return 'di' + (c === 1 ? 'a' : 'es') },
      h: function (c) { return 'hor' + (c === 1 ? 'a' : 'es') },
      m: function (c) { return 'minut' + (c === 1 ? '' : 's') },
      s: function (c) { return 'segon' + (c === 1 ? '' : 's') },
      ms: function (c) { return 'milisegon' + (c === 1 ? '' : 's') },
      decimal: ','
    },
    cs: {
      y: function (c) { return ['rok', 'roku', 'roky', 'let'][getCzechForm(c)] },
      mo: function (c) { return ['msc', 'msce', 'msce', 'msc'][getCzechForm(c)] },
      w: function (c) { return ['tden', 'tdne', 'tdny', 'tdn'][getCzechForm(c)] },
      d: function (c) { return ['den', 'dne', 'dny', 'dn'][getCzechForm(c)] },
      h: function (c) { return ['hodina', 'hodiny', 'hodiny', 'hodin'][getCzechForm(c)] },
      m: function (c) { return ['minuta', 'minuty', 'minuty', 'minut'][getCzechForm(c)] },
      s: function (c) { return ['sekunda', 'sekundy', 'sekundy', 'sekund'][getCzechForm(c)] },
      ms: function (c) { return ['milisekunda', 'milisekundy', 'milisekundy', 'milisekund'][getCzechForm(c)] },
      decimal: ','
    },
    da: {
      y: 'r',
      mo: function (c) { return 'mned' + (c === 1 ? '' : 'er') },
      w: function (c) { return 'uge' + (c === 1 ? '' : 'r') },
      d: function (c) { return 'dag' + (c === 1 ? '' : 'e') },
      h: function (c) { return 'time' + (c === 1 ? '' : 'r') },
      m: function (c) { return 'minut' + (c === 1 ? '' : 'ter') },
      s: function (c) { return 'sekund' + (c === 1 ? '' : 'er') },
      ms: function (c) { return 'millisekund' + (c === 1 ? '' : 'er') },
      decimal: ','
    },
    de: {
      y: function (c) { return 'Jahr' + (c === 1 ? '' : 'e') },
      mo: function (c) { return 'Monat' + (c === 1 ? '' : 'e') },
      w: function (c) { return 'Woche' + (c === 1 ? '' : 'n') },
      d: function (c) { return 'Tag' + (c === 1 ? '' : 'e') },
      h: function (c) { return 'Stunde' + (c === 1 ? '' : 'n') },
      m: function (c) { return 'Minute' + (c === 1 ? '' : 'n') },
      s: function (c) { return 'Sekunde' + (c === 1 ? '' : 'n') },
      ms: function (c) { return 'Millisekunde' + (c === 1 ? '' : 'n') },
      decimal: ','
    },
    en: {
      y: function (c) { return 'year' + (c === 1 ? '' : 's') },
      mo: function (c) { return 'month' + (c === 1 ? '' : 's') },
      w: function (c) { return 'week' + (c === 1 ? '' : 's') },
      d: function (c) { return 'day' + (c === 1 ? '' : 's') },
      h: function (c) { return 'hour' + (c === 1 ? '' : 's') },
      m: function (c) { return 'minute' + (c === 1 ? '' : 's') },
      s: function (c) { return 'second' + (c === 1 ? '' : 's') },
      ms: function (c) { return 'millisecond' + (c === 1 ? '' : 's') },
      decimal: '.'
    },
    es: {
      y: function (c) { return 'ao' + (c === 1 ? '' : 's') },
      mo: function (c) { return 'mes' + (c === 1 ? '' : 'es') },
      w: function (c) { return 'semana' + (c === 1 ? '' : 's') },
      d: function (c) { return 'da' + (c === 1 ? '' : 's') },
      h: function (c) { return 'hora' + (c === 1 ? '' : 's') },
      m: function (c) { return 'minuto' + (c === 1 ? '' : 's') },
      s: function (c) { return 'segundo' + (c === 1 ? '' : 's') },
      ms: function (c) { return 'milisegundo' + (c === 1 ? '' : 's') },
      decimal: ','
    },
    fi: {
      y: function (c) { return c === 1 ? 'vuosi' : 'vuotta' },
      mo: function (c) { return c === 1 ? 'kuukausi' : 'kuukautta' },
      w: function (c) { return 'viikko' + (c === 1 ? '' : 'a') },
      d: function (c) { return 'piv' + (c === 1 ? '' : '') },
      h: function (c) { return 'tunti' + (c === 1 ? '' : 'a') },
      m: function (c) { return 'minuutti' + (c === 1 ? '' : 'a') },
      s: function (c) { return 'sekunti' + (c === 1 ? '' : 'a') },
      ms: function (c) { return 'millisekunti' + (c === 1 ? '' : 'a') },
      decimal: ','
    },
    fr: {
      y: function (c) { return 'an' + (c >= 2 ? 's' : '') },
      mo: 'mois',
      w: function (c) { return 'semaine' + (c >= 2 ? 's' : '') },
      d: function (c) { return 'jour' + (c >= 2 ? 's' : '') },
      h: function (c) { return 'heure' + (c >= 2 ? 's' : '') },
      m: function (c) { return 'minute' + (c >= 2 ? 's' : '') },
      s: function (c) { return 'seconde' + (c >= 2 ? 's' : '') },
      ms: function (c) { return 'milliseconde' + (c >= 2 ? 's' : '') },
      decimal: ','
    },
    gr: {
      y: function (c) { return c === 1 ? '' : '' },
      mo: function (c) { return c === 1 ? '' : '' },
      w: function (c) { return c === 1 ? '' : '' },
      d: function (c) { return c === 1 ? '' : '' },
      h: function (c) { return c === 1 ? '' : '' },
      m: function (c) { return c === 1 ? '' : '' },
      s: function (c) { return c === 1 ? '' : '' },
      ms: function (c) { return c === 1 ? '  ' : '  ' },
      decimal: ','
    },
    hu: {
      y: 'v',
      mo: 'hnap',
      w: 'ht',
      d: 'nap',
      h: 'ra',
      m: 'perc',
      s: 'msodperc',
      ms: 'ezredmsodperc',
      decimal: ','
    },
    id: {
      y: 'tahun',
      mo: 'bulan',
      w: 'minggu',
      d: 'hari',
      h: 'jam',
      m: 'menit',
      s: 'detik',
      ms: 'milidetik',
      decimal: '.'
    },
    is: {
      y: 'r',
      mo: function (c) { return 'mnu' + (c === 1 ? 'ur' : 'ir') },
      w: function (c) { return 'vik' + (c === 1 ? 'a' : 'ur') },
      d: function (c) { return 'dag' + (c === 1 ? 'ur' : 'ar') },
      h: function (c) { return 'klukkutm' + (c === 1 ? 'i' : 'ar') },
      m: function (c) { return 'mnt' + (c === 1 ? 'a' : 'ur') },
      s: function (c) { return 'seknd' + (c === 1 ? 'a' : 'ur') },
      ms: function (c) { return 'milliseknd' + (c === 1 ? 'a' : 'ur') },
      decimal: '.'
    },
    it: {
      y: function (c) { return 'ann' + (c === 1 ? 'o' : 'i') },
      mo: function (c) { return 'mes' + (c === 1 ? 'e' : 'i') },
      w: function (c) { return 'settiman' + (c === 1 ? 'a' : 'e') },
      d: function (c) { return 'giorn' + (c === 1 ? 'o' : 'i') },
      h: function (c) { return 'or' + (c === 1 ? 'a' : 'e') },
      m: function (c) { return 'minut' + (c === 1 ? 'o' : 'i') },
      s: function (c) { return 'second' + (c === 1 ? 'o' : 'i') },
      ms: function (c) { return 'millisecond' + (c === 1 ? 'o' : 'i') },
      decimal: ','
    },
    ja: {
      y: '',
      mo: '',
      w: '',
      d: '',
      h: '',
      m: '',
      s: '',
      ms: '',
      decimal: '.'
    },
    ko: {
      y: '',
      mo: '',
      w: '',
      d: '',
      h: '',
      m: '',
      s: '',
      ms: ' ',
      decimal: '.'
    },
    lt: {
      y: function (c) { return ((c % 10 === 0) || (c % 100 >= 10 && c % 100 <= 20)) ? 'met' : 'metai' },
      mo: function (c) { return ['mnuo', 'mnesiai', 'mnesi'][getLithuanianForm(c)] },
      w: function (c) { return ['savait', 'savaits', 'savaii'][getLithuanianForm(c)] },
      d: function (c) { return ['diena', 'dienos', 'dien'][getLithuanianForm(c)] },
      h: function (c) { return ['valanda', 'valandos', 'valand'][getLithuanianForm(c)] },
      m: function (c) { return ['minut', 'minuts', 'minui'][getLithuanianForm(c)] },
      s: function (c) { return ['sekund', 'sekunds', 'sekundi'][getLithuanianForm(c)] },
      ms: function (c) { return ['milisekund', 'milisekunds', 'milisekundi'][getLithuanianForm(c)] },
      decimal: ','
    },
    ms: {
      y: 'tahun',
      mo: 'bulan',
      w: 'minggu',
      d: 'hari',
      h: 'jam',
      m: 'minit',
      s: 'saat',
      ms: 'milisaat',
      decimal: '.'
    },
    nl: {
      y: 'jaar',
      mo: function (c) { return c === 1 ? 'maand' : 'maanden' },
      w: function (c) { return c === 1 ? 'week' : 'weken' },
      d: function (c) { return c === 1 ? 'dag' : 'dagen' },
      h: 'uur',
      m: function (c) { return c === 1 ? 'minuut' : 'minuten' },
      s: function (c) { return c === 1 ? 'seconde' : 'seconden' },
      ms: function (c) { return c === 1 ? 'milliseconde' : 'milliseconden' },
      decimal: ','
    },
    no: {
      y: 'r',
      mo: function (c) { return 'mned' + (c === 1 ? '' : 'er') },
      w: function (c) { return 'uke' + (c === 1 ? '' : 'r') },
      d: function (c) { return 'dag' + (c === 1 ? '' : 'er') },
      h: function (c) { return 'time' + (c === 1 ? '' : 'r') },
      m: function (c) { return 'minutt' + (c === 1 ? '' : 'er') },
      s: function (c) { return 'sekund' + (c === 1 ? '' : 'er') },
      ms: function (c) { return 'millisekund' + (c === 1 ? '' : 'er') },
      decimal: ','
    },
    pl: {
      y: function (c) { return ['rok', 'roku', 'lata', 'lat'][getPolishForm(c)] },
      mo: function (c) { return ['miesic', 'miesica', 'miesice', 'miesicy'][getPolishForm(c)] },
      w: function (c) { return ['tydzie', 'tygodnia', 'tygodnie', 'tygodni'][getPolishForm(c)] },
      d: function (c) { return ['dzie', 'dnia', 'dni', 'dni'][getPolishForm(c)] },
      h: function (c) { return ['godzina', 'godziny', 'godziny', 'godzin'][getPolishForm(c)] },
      m: function (c) { return ['minuta', 'minuty', 'minuty', 'minut'][getPolishForm(c)] },
      s: function (c) { return ['sekunda', 'sekundy', 'sekundy', 'sekund'][getPolishForm(c)] },
      ms: function (c) { return ['milisekunda', 'milisekundy', 'milisekundy', 'milisekund'][getPolishForm(c)] },
      decimal: ','
    },
    pt: {
      y: function (c) { return 'ano' + (c === 1 ? '' : 's') },
      mo: function (c) { return c !== 1 ? 'meses' : 'ms' },
      w: function (c) { return 'semana' + (c === 1 ? '' : 's') },
      d: function (c) { return 'dia' + (c === 1 ? '' : 's') },
      h: function (c) { return 'hora' + (c === 1 ? '' : 's') },
      m: function (c) { return 'minuto' + (c === 1 ? '' : 's') },
      s: function (c) { return 'segundo' + (c === 1 ? '' : 's') },
      ms: function (c) { return 'milissegundo' + (c === 1 ? '' : 's') },
      decimal: ','
    },
    ru: {
      y: function (c) { return ['', '', ''][getSlavicForm(c)] },
      mo: function (c) { return ['', '', ''][getSlavicForm(c)] },
      w: function (c) { return ['', '', ''][getSlavicForm(c)] },
      d: function (c) { return ['', '', ''][getSlavicForm(c)] },
      h: function (c) { return ['', '', ''][getSlavicForm(c)] },
      m: function (c) { return ['', '', ''][getSlavicForm(c)] },
      s: function (c) { return ['', '', ''][getSlavicForm(c)] },
      ms: function (c) { return ['', '', ''][getSlavicForm(c)] },
      decimal: ','
    },
    uk: {
      y: function (c) { return ['', '', ''][getSlavicForm(c)] },
      mo: function (c) { return ['', '', ''][getSlavicForm(c)] },
      w: function (c) { return ['', '', ''][getSlavicForm(c)] },
      d: function (c) { return ['', '', ''][getSlavicForm(c)] },
      h: function (c) { return ['', '', ''][getSlavicForm(c)] },
      m: function (c) { return ['', '', ''][getSlavicForm(c)] },
      s: function (c) { return ['', '', ''][getSlavicForm(c)] },
      ms: function (c) { return ['', '', ''][getSlavicForm(c)] },
      decimal: ','
    },
    sv: {
      y: 'r',
      mo: function (c) { return 'mnad' + (c === 1 ? '' : 'er') },
      w: function (c) { return 'veck' + (c === 1 ? 'a' : 'or') },
      d: function (c) { return 'dag' + (c === 1 ? '' : 'ar') },
      h: function (c) { return 'timm' + (c === 1 ? 'e' : 'ar') },
      m: function (c) { return 'minut' + (c === 1 ? '' : 'er') },
      s: function (c) { return 'sekund' + (c === 1 ? '' : 'er') },
      ms: function (c) { return 'millisekund' + (c === 1 ? '' : 'er') },
      decimal: ','
    },
    tr: {
      y: 'yl',
      mo: 'ay',
      w: 'hafta',
      d: 'gn',
      h: 'saat',
      m: 'dakika',
      s: 'saniye',
      ms: 'milisaniye',
      decimal: ','
    },
    vi: {
      y: 'nm',
      mo: 'thng',
      w: 'tun',
      d: 'ngy',
      h: 'gi',
      m: 'pht',
      s: 'giy',
      ms: 'mili giy',
      decimal: ','
    },
    zh_CN: {
      y: '',
      mo: '',
      w: '',
      d: '',
      h: '',
      m: '',
      s: '',
      ms: '',
      decimal: '.'
    },
    zh_TW: {
      y: '',
      mo: '',
      w: '',
      d: '',
      h: '',
      m: '',
      s: '',
      ms: '',
      decimal: '.'
    }
  }

  // You can create a humanizer, which returns a function with default
  // parameters.
  function humanizer (passedOptions) {
    var result = function humanizer (ms, humanizerOptions) {
      var options = extend({}, result, humanizerOptions || {})
      return doHumanization(ms, options)
    }

    return extend(result, {
      language: 'en',
      delimiter: ', ',
      spacer: ' ',
      conjunction: '',
      serialComma: true,
      units: ['y', 'mo', 'w', 'd', 'h', 'm', 's'],
      languages: {},
      round: false,
      unitMeasures: {
        y: 31557600000,
        mo: 2629800000,
        w: 604800000,
        d: 86400000,
        h: 3600000,
        m: 60000,
        s: 1000,
        ms: 1
      }
    }, passedOptions)
  }

  // The main function is just a wrapper around a default humanizer.
  var humanizeDuration = humanizer({})

  // doHumanization does the bulk of the work.
  function doHumanization (ms, options) {
    var i, len, piece

    // Make sure we have a positive number.
    // Has the nice sideffect of turning Number objects into primitives.
    ms = Math.abs(ms)

    var dictionary = options.languages[options.language] || languages[options.language]
    if (!dictionary) {
      throw new Error('No language ' + dictionary + '.')
    }

    var pieces = []

    // Start at the top and keep removing units, bit by bit.
    var unitName, unitMS, unitCount
    for (i = 0, len = options.units.length; i < len; i++) {
      unitName = options.units[i]
      unitMS = options.unitMeasures[unitName]

      // What's the number of full units we can fit?
      if (i + 1 === len) {
        unitCount = ms / unitMS
      } else {
        unitCount = Math.floor(ms / unitMS)
      }

      // Add the string.
      pieces.push({
        unitCount: unitCount,
        unitName: unitName
      })

      // Remove what we just figured out.
      ms -= unitCount * unitMS
    }

    var firstOccupiedUnitIndex = 0
    for (i = 0; i < pieces.length; i++) {
      if (pieces[i].unitCount) {
        firstOccupiedUnitIndex = i
        break
      }
    }

    if (options.round) {
      var ratioToLargerUnit, previousPiece
      for (i = pieces.length - 1; i >= 0; i--) {
        piece = pieces[i]
        piece.unitCount = Math.round(piece.unitCount)

        if (i === 0) { break }

        previousPiece = pieces[i - 1]

        ratioToLargerUnit = options.unitMeasures[previousPiece.unitName] / options.unitMeasures[piece.unitName]
        if ((piece.unitCount % ratioToLargerUnit) === 0 || (options.largest && ((options.largest - 1) < (i - firstOccupiedUnitIndex)))) {
          previousPiece.unitCount += piece.unitCount / ratioToLargerUnit
          piece.unitCount = 0
        }
      }
    }

    var result = []
    for (i = 0, pieces.length; i < len; i++) {
      piece = pieces[i]
      if (piece.unitCount) {
        result.push(render(piece.unitCount, piece.unitName, dictionary, options))
      }

      if (result.length === options.largest) { break }
    }

    if (result.length) {
      if (!options.conjunction || result.length === 1) {
        return result.join(options.delimiter)
      } else if (result.length === 2) {
        return result.join(options.conjunction)
      } else if (result.length > 2) {
        return result.slice(0, -1).join(options.delimiter) + (options.serialComma ? ',' : '') + options.conjunction + result.slice(-1)
      }
    } else {
      return render(0, options.units[options.units.length - 1], dictionary, options)
    }
  }

  function render (count, type, dictionary, options) {
    var decimal
    if (options.decimal === void 0) {
      decimal = dictionary.decimal
    } else {
      decimal = options.decimal
    }

    var countStr = count.toString().replace('.', decimal)

    var dictionaryValue = dictionary[type]
    var word
    if (typeof dictionaryValue === 'function') {
      word = dictionaryValue(count)
    } else {
      word = dictionaryValue
    }

    return countStr + options.spacer + word
  }

  function extend (destination) {
    var source
    for (var i = 1; i < arguments.length; i++) {
      source = arguments[i]
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          destination[prop] = source[prop]
        }
      }
    }
    return destination
  }

  // Internal helper function for Czech language.
  function getCzechForm (c) {
    if (c === 1) {
      return 0
    } else if (Math.floor(c) !== c) {
      return 1
    } else if (c % 10 >= 2 && c % 10 <= 4 && c % 100 < 10) {
      return 2
    } else {
      return 3
    }
  }

  // Internal helper function for Polish language.
  function getPolishForm (c) {
    if (c === 1) {
      return 0
    } else if (Math.floor(c) !== c) {
      return 1
    } else if (c % 10 >= 2 && c % 10 <= 4 && !(c % 100 > 10 && c % 100 < 20)) {
      return 2
    } else {
      return 3
    }
  }

  // Internal helper function for Russian and Ukranian languages.
  function getSlavicForm (c) {
    if (Math.floor(c) !== c) {
      return 2
    } else if ((c % 100 >= 5 && c % 100 <= 20) || (c % 10 >= 5 && c % 10 <= 9) || c % 10 === 0) {
      return 0
    } else if (c % 10 === 1) {
      return 1
    } else if (c > 1) {
      return 2
    } else {
      return 0
    }
  }

  // Internal helper function for Lithuanian language.
  function getLithuanianForm (c) {
    if (c === 1 || (c % 10 === 1 && c % 100 > 20)) {
      return 0
    } else if (Math.floor(c) !== c || (c % 10 >= 2 && c % 100 > 20) || (c % 10 >= 2 && c % 100 < 10)) {
      return 1
    } else {
      return 2
    }
  }

  humanizeDuration.getSupportedLanguages = function getSupportedLanguages () {
    var result = []
    for (var language in languages) {
      if (languages.hasOwnProperty(language)) {
        result.push(language)
      }
    }
    return result
  }

  humanizeDuration.humanizer = humanizer

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return humanizeDuration
    })
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = humanizeDuration
  } else {
    this.humanizeDuration = humanizeDuration
  }
})();  // eslint-disable-line semi

},{}],32:[function(_dereq_,module,exports){
var split = _dereq_('browser-split')
var ClassList = _dereq_('class-list')

var w = typeof window === 'undefined' ? _dereq_('html-element') : window
var document = w.document
var Text = w.Text

function context () {

  var cleanupFuncs = []

  function h() {
    var args = [].slice.call(arguments), e = null
    function item (l) {
      var r
      function parseClass (string) {
        // Our minimal parser doesnt understand escaping CSS special
        // characters like `#`. Dont use them. More reading:
        // https://mathiasbynens.be/notes/css-escapes .

        var m = split(string, /([\.#]?[^\s#.]+)/)
        if(/^\.|#/.test(m[1]))
          e = document.createElement('div')
        forEach(m, function (v) {
          var s = v.substring(1,v.length)
          if(!v) return
          if(!e)
            e = document.createElement(v)
          else if (v[0] === '.')
            ClassList(e).add(s)
          else if (v[0] === '#')
            e.setAttribute('id', s)
        })
      }

      if(l == null)
        ;
      else if('string' === typeof l) {
        if(!e)
          parseClass(l)
        else
          e.appendChild(r = document.createTextNode(l))
      }
      else if('number' === typeof l
        || 'boolean' === typeof l
        || l instanceof Date
        || l instanceof RegExp ) {
          e.appendChild(r = document.createTextNode(l.toString()))
      }
      //there might be a better way to handle this...
      else if (isArray(l))
        forEach(l, item)
      else if(isNode(l))
        e.appendChild(r = l)
      else if(l instanceof Text)
        e.appendChild(r = l)
      else if ('object' === typeof l) {
        for (var k in l) {
          if('function' === typeof l[k]) {
            if(/^on\w+/.test(k)) {
              (function (k, l) { // capture k, l in the closure
                if (e.addEventListener){
                  e.addEventListener(k.substring(2), l[k], false)
                  cleanupFuncs.push(function(){
                    e.removeEventListener(k.substring(2), l[k], false)
                  })
                }else{
                  e.attachEvent(k, l[k])
                  cleanupFuncs.push(function(){
                    e.detachEvent(k, l[k])
                  })
                }
              })(k, l)
            } else {
              // observable
              e[k] = l[k]()
              cleanupFuncs.push(l[k](function (v) {
                e[k] = v
              }))
            }
          }
          else if(k === 'style') {
            if('string' === typeof l[k]) {
              e.style.cssText = l[k]
            }else{
              for (var s in l[k]) (function(s, v) {
                if('function' === typeof v) {
                  // observable
                  e.style.setProperty(s, v())
                  cleanupFuncs.push(v(function (val) {
                    e.style.setProperty(s, val)
                  }))
                } else
                  var match = l[k][s].match(/(.*)\W+!important\W*$/);
                  if (match) {
                    e.style.setProperty(s, match[1], 'important')
                  } else {
                    e.style.setProperty(s, l[k][s])
                  }
              })(s, l[k][s])
            }
          } else if(k === 'attrs') {
            for (var v in l[k]) {
              e.setAttribute(v, l[k][v])
            }
          }
          else if (k.substr(0, 5) === "data-") {
            e.setAttribute(k, l[k])
          } else {
            e[k] = l[k]
          }
        }
      } else if ('function' === typeof l) {
        //assume it's an observable!
        var v = l()
        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))

        cleanupFuncs.push(l(function (v) {
          if(isNode(v) && r.parentElement)
            r.parentElement.replaceChild(v, r), r = v
          else
            r.textContent = v
        }))
      }

      return r
    }
    while(args.length)
      item(args.shift())

    return e
  }

  h.cleanup = function () {
    for (var i = 0; i < cleanupFuncs.length; i++){
      cleanupFuncs[i]()
    }
    cleanupFuncs.length = 0
  }

  return h
}

var h = module.exports = context()
h.context = context

function isNode (el) {
  return el && el.nodeName && el.nodeType
}

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function isArray (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}



},{"browser-split":6,"class-list":10,"html-element":5}],33:[function(_dereq_,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],34:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],35:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],36:[function(_dereq_,module,exports){
var containers = []; // will store container HTMLElement references
var styleElements = []; // will store {prepend: HTMLElement, append: HTMLElement}

var usage = 'insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).';

function insertCss(css, options) {
    options = options || {};

    if (css === undefined) {
        throw new Error(usage);
    }

    var position = options.prepend === true ? 'prepend' : 'append';
    var container = options.container !== undefined ? options.container : document.querySelector('head');
    var containerId = containers.indexOf(container);

    // first time we see this container, create the necessary entries
    if (containerId === -1) {
        containerId = containers.push(container) - 1;
        styleElements[containerId] = {};
    }

    // try to get the correponding container + position styleElement, create it otherwise
    var styleElement;

    if (styleElements[containerId] !== undefined && styleElements[containerId][position] !== undefined) {
        styleElement = styleElements[containerId][position];
    } else {
        styleElement = styleElements[containerId][position] = createStyleElement();

        if (position === 'prepend') {
            container.insertBefore(styleElement, container.childNodes[0]);
        } else {
            container.appendChild(styleElement);
        }
    }

    // strip potential UTF-8 BOM if css was read from a file
    if (css.charCodeAt(0) === 0xFEFF) { css = css.substr(1, css.length); }

    // actually add the stylesheet
    if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText += css
    } else {
        styleElement.textContent += css;
    }

    return styleElement;
};

function createStyleElement() {
    var styleElement = document.createElement('style');
    styleElement.setAttribute('type', 'text/css');
    return styleElement;
}

module.exports = insertCss;
module.exports.insertCss = insertCss;

},{}],37:[function(_dereq_,module,exports){
/*! npm.im/intervalometer */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function intervalometer(cb, request, cancel, requestParameter) {
	var requestId;
	var previousLoopTime;
	function loop(now) {
		// must be requested before cb() because that might call .stop()
		requestId = request(loop, requestParameter);

		// called with "ms since last call". 0 on start()
		cb(now - (previousLoopTime || now));

		previousLoopTime = now;
	}
	return {
		start: function start() {
			if (!requestId) { // prevent double starts
				loop(0);
			}
		},
		stop: function stop() {
			cancel(requestId);
			requestId = null;
			previousLoopTime = 0;
		}
	};
}

function frameIntervalometer(cb) {
	return intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);
}

function timerIntervalometer(cb, delay) {
	return intervalometer(cb, setTimeout, clearTimeout, delay);
}

exports.intervalometer = intervalometer;
exports.frameIntervalometer = frameIntervalometer;
exports.timerIntervalometer = timerIntervalometer;
},{}],38:[function(_dereq_,module,exports){
/*! npm.im/iphone-inline-video 2.2.2 */
'use strict';

var intervalometer = _dereq_('intervalometer');

function preventEvent(element, eventName, test) {
	function handler(e) {
		if (!test || test(element, eventName)) {
			e.stopImmediatePropagation();
			// // console.log(eventName, 'prevented on', element);
		}
	}
	element.addEventListener(eventName, handler);

	// Return handler to allow to disable the prevention. Usage:
	// const preventionHandler = preventEvent(el, 'click');
	// el.removeEventHandler('click', preventionHandler);
	return handler;
}

function proxyProperty(object, propertyName, sourceObject, copyFirst) {
	function get() {
		return sourceObject[propertyName];
	}
	function set(value) {
		sourceObject[propertyName] = value;
	}

	if (copyFirst) {
		set(object[propertyName]);
	}

	Object.defineProperty(object, propertyName, {get: get, set: set});
}

function proxyEvent(object, eventName, sourceObject) {
	sourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });
}

function dispatchEventAsync(element, type) {
	Promise.resolve().then(function () {
		element.dispatchEvent(new Event(type));
	});
}

var iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;

var IIV = 'bfred-it:iphone-inline-video';
var IIVEvent = 'bfred-it:iphone-inline-video:event';
var IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';
var IIVPause = 'bfred-it:iphone-inline-video:nativepause';

/**
 * UTILS
 */

function getAudioFromVideo(video) {
	var audio = new Audio();
	proxyEvent(video, 'play', audio);
	proxyEvent(video, 'playing', audio);
	proxyEvent(video, 'pause', audio);
	audio.crossOrigin = video.crossOrigin;

	// 'data:' causes audio.networkState > 0
	// which then allows to keep <audio> in a resumable playing state
	// i.e. once you set a real src it will keep playing if it was if .play() was called
	audio.src = video.src || video.currentSrc || 'data:';

	// // if (audio.src === 'data:') {
	//   TODO: wait for video to be selected
	// // }
	return audio;
}

var lastRequests = [];
var requestIndex = 0;
var lastTimeupdateEvent;

function setTime(video, time, rememberOnly) {
	// Allow one timeupdate event every 200+ ms
	if ((lastTimeupdateEvent || 0) + 200 < Date.now()) {
		video[IIVEvent] = true;
		lastTimeupdateEvent = Date.now();
	}
	if (!rememberOnly) {
		video.currentTime = time;
	}
	lastRequests[++requestIndex % 3] = time * 100 | 0 / 100;
}

function isPlayerEnded(player) {
	return player.driver.currentTime >= player.video.duration;
}

function update(timeDiff) {
	var player = this;
	// // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);
	if (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {
		if (!player.hasAudio) {
			player.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);
			if (player.video.loop && isPlayerEnded(player)) {
				player.driver.currentTime = 0;
			}
		}
		setTime(player.video, player.driver.currentTime);
	} else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {
		// This should happen when the source is available but:
		// - it's potentially playing (.paused === false)
		// - it's not ready to play
		// - it's not loading
		// If it hasAudio, that will be loaded in the 'emptied' handler below
		player.video.load();
		// // console.log('Will load');
	}

	// // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');

	if (player.video.ended) {
		delete player.video[IIVEvent]; // Allow timeupdate event
		player.video.pause(true);
	}
}

/**
 * METHODS
 */

function play() {
	// // console.log('play');
	var video = this;
	var player = video[IIV];

	// If it's fullscreen, use the native player
	if (video.webkitDisplayingFullscreen) {
		video[IIVPlay]();
		return;
	}

	if (player.driver.src !== 'data:' && player.driver.src !== video.src) {
		// // console.log('src changed on play', video.src);
		setTime(video, 0, true);
		player.driver.src = video.src;
	}

	if (!video.paused) {
		return;
	}
	player.paused = false;

	if (video.buffered.length === 0) {
		// .load() causes the emptied event
		// the alternative is .play()+.pause() but that triggers play/pause events, even worse
		// possibly the alternative is preventing this event only once
		video.load();
	}

	player.driver.play();
	player.updater.start();

	if (!player.hasAudio) {
		dispatchEventAsync(video, 'play');
		if (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {
			// // console.log('onplay');
			dispatchEventAsync(video, 'playing');
		}
	}
}
function pause(forceEvents) {
	// // console.log('pause');
	var video = this;
	var player = video[IIV];

	player.driver.pause();
	player.updater.stop();

	// If it's fullscreen, the developer the native player.pause()
	// This is at the end of pause() because it also
	// needs to make sure that the simulation is paused
	if (video.webkitDisplayingFullscreen) {
		video[IIVPause]();
	}

	if (player.paused && !forceEvents) {
		return;
	}

	player.paused = true;
	if (!player.hasAudio) {
		dispatchEventAsync(video, 'pause');
	}

	// Handle the 'ended' event only if it's not fullscreen
	if (video.ended && !video.webkitDisplayingFullscreen) {
		video[IIVEvent] = true;
		dispatchEventAsync(video, 'ended');
	}
}

/**
 * SETUP
 */

function addPlayer(video, hasAudio) {
	var player = {};
	video[IIV] = player;
	player.paused = true; // Track whether 'pause' events have been fired
	player.hasAudio = hasAudio;
	player.video = video;
	player.updater = intervalometer.frameIntervalometer(update.bind(player));

	if (hasAudio) {
		player.driver = getAudioFromVideo(video);
	} else {
		video.addEventListener('canplay', function () {
			if (!video.paused) {
				// // console.log('oncanplay');
				dispatchEventAsync(video, 'playing');
			}
		});
		player.driver = {
			src: video.src || video.currentSrc || 'data:',
			muted: true,
			paused: true,
			pause: function () {
				player.driver.paused = true;
			},
			play: function () {
				player.driver.paused = false;
				// Media automatically goes to 0 if .play() is called when it's done
				if (isPlayerEnded(player)) {
					setTime(video, 0);
				}
			},
			get ended() {
				return isPlayerEnded(player);
			}
		};
	}

	// .load() causes the emptied event
	video.addEventListener('emptied', function () {
		// // console.log('driver src is', player.driver.src);
		var wasEmpty = !player.driver.src || player.driver.src === 'data:';
		if (player.driver.src && player.driver.src !== video.src) {
			// // console.log('src changed to', video.src);
			setTime(video, 0, true);
			player.driver.src = video.src;
			// Playing videos will only keep playing if no src was present when .play()ed
			if (wasEmpty || (!hasAudio && video.autoplay)) {
				player.driver.play();
			} else {
				player.updater.stop();
			}
		}
	}, false);

	// Stop programmatic player when OS takes over
	video.addEventListener('webkitbeginfullscreen', function () {
		if (!video.paused) {
			// Make sure that the <audio> and the syncer/updater are stopped
			video.pause();

			// Play video natively
			video[IIVPlay]();
		} else if (hasAudio && player.driver.buffered.length === 0) {
			// If the first play is native,
			// the <audio> needs to be buffered manually
			// so when the fullscreen ends, it can be set to the same current time
			player.driver.load();
		}
	});
	if (hasAudio) {
		video.addEventListener('webkitendfullscreen', function () {
			// Sync audio to new video position
			player.driver.currentTime = video.currentTime;
			// // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');
		});

		// Allow seeking
		video.addEventListener('seeking', function () {
			if (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {
				// // console.log('User-requested seeking');
				player.driver.currentTime = video.currentTime;
			}
		});
	}
}

function preventWithPropOrFullscreen(el) {
	var isAllowed = el[IIVEvent];
	delete el[IIVEvent];
	return !el.webkitDisplayingFullscreen && !isAllowed;
}

function overloadAPI(video) {
	var player = video[IIV];
	video[IIVPlay] = video.play;
	video[IIVPause] = video.pause;
	video.play = play;
	video.pause = pause;
	proxyProperty(video, 'paused', player.driver);
	proxyProperty(video, 'muted', player.driver, true);
	proxyProperty(video, 'playbackRate', player.driver, true);
	proxyProperty(video, 'ended', player.driver);
	proxyProperty(video, 'loop', player.driver, true);

	// IIV works by seeking 60 times per second.
	// These events are now useless.
	preventEvent(video, 'seeking', function (el) { return !el.webkitDisplayingFullscreen; });
	preventEvent(video, 'seeked', function (el) { return !el.webkitDisplayingFullscreen; });

	// Limit timeupdate events
	preventEvent(video, 'timeupdate', preventWithPropOrFullscreen);

	// Prevent occasional native ended events
	preventEvent(video, 'ended', preventWithPropOrFullscreen);
}

function enableInlineVideo(video, opts) {
	if ( opts === void 0 ) opts = {};

	// Stop if already enabled
	if (video[IIV]) {
		return;
	}

	// Allow the user to skip detection
	if (!opts.everywhere) {
		// Only iOS8 and 9 are supported
		if (!iOS8or9) {
			return;
		}

		// Stop if it's not an allowed device
		if (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {
			return;
		}
	}

	// Try to pause
	video.pause();

	// Prevent autoplay.
	// An non-started autoplaying video can't be .pause()'d
	var willAutoplay = video.autoplay;
	video.autoplay = false;

	addPlayer(video, !video.muted);
	overloadAPI(video);
	video.classList.add('IIV');

	// Autoplay
	if (video.muted && willAutoplay) {
		video.play();
		video.addEventListener('playing', function restoreAutoplay() {
			video.autoplay = true;
			video.removeEventListener('playing', restoreAutoplay);
		});
	}

	if (!/iPhone|iPod|iPad/.test(navigator.platform)) {
		console.warn('iphone-inline-video is not guaranteed to work in emulated environments');
	}
}

module.exports = enableInlineVideo;

},{"intervalometer":37}],39:[function(_dereq_,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],40:[function(_dereq_,module,exports){
'use strict';
var numberIsNan = _dereq_('number-is-nan');

module.exports = Number.isFinite || function (val) {
	return !(typeof val !== 'number' || numberIsNan(val) || val === Infinity || val === -Infinity);
};

},{"number-is-nan":47}],41:[function(_dereq_,module,exports){
module.exports = isPowerOfTwo

function isPowerOfTwo(n) {
  return n !== 0 && (n & (n - 1)) === 0
}
},{}],42:[function(_dereq_,module,exports){
module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}

},{}],43:[function(_dereq_,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],44:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

"use strict";

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function(obj) {
  var ret = {};
  var key;
  if (!(obj instanceof Object && !Array.isArray(obj))) {
    throw new Error('keyMirror(...): Argument must be an object.');
  }
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;

},{}],45:[function(_dereq_,module,exports){

// Flat merge
module.exports = exports = function(host) {
	var donors = slice(arguments, 1);
	donors.forEach(function(donor) {
		Object.keys(donor).forEach(function(key) {
			host[key] = donor[key];
		});
	});
	return host;
};

// Flat, selective merge
exports.selective = function(keys, host) {
	var donors = slice(arguments, 1);
	donors.forEach(function(donor) {
		keys.forEach(function(key) {
			host[key] = donor[key];
		});
	});
	return host;
};

// Recursive merge
exports.recursive = function(host) {
	var donors = slice(arguments, 1);
	donors.forEach(function(donor) {
		Object.keys(donor).forEach(recurser(host, donor));
	});
	return host;
};

// Recursive, selective merge
exports.selective.recursive = function(keys, host) {
	var donors = slice(arguments, 1);
	donors.forEach(function(donor) {
		keys.forEach(recurser(host, donor));
	});
	return host;
};

// Helpers

function slice(arr, i) {
	return Array.prototype.slice.call(arr, i);
}

function isObj(value) {
	return !! (typeof value === 'object' && value);
}

function getType(value) {
	return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
}

function recurser(host, donor) {
	return function(key) {
		if (isObj(donor[key])) {
			if (isObj(host[key])) {
				exports.recursive(host[key], donor[key]);
			} else {
				var base = Array.isArray(donor[key]) ? [ ] : { };
				host[key] = exports.recursive(base, donor[key]);
			}
		} else {
			host[key] = donor[key];
		}
	};
}

/* End of file index.js */
/* Location: ./lib/index.js */

},{}],46:[function(_dereq_,module,exports){
'use strict';
var numberIsFinite = _dereq_('is-finite');

module.exports = Number.isInteger || function (x) {
	return numberIsFinite(x) && Math.floor(x) === x;
};

},{"is-finite":40}],47:[function(_dereq_,module,exports){
'use strict';
module.exports = Number.isNaN || function (x) {
	return x !== x;
};

},{}],48:[function(_dereq_,module,exports){
var wrappy = _dereq_('wrappy')
module.exports = wrappy(once)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

},{"wrappy":83}],49:[function(_dereq_,module,exports){
(function (process){
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);



}).call(this,_dereq_('_process'))

},{"_process":7}],50:[function(_dereq_,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,_dereq_('_process'))

},{"_process":7}],51:[function(_dereq_,module,exports){
(function (global){
var now = _dereq_('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function() {
  root.requestAnimationFrame = raf
  root.cancelAnimationFrame = caf
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":49}],52:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Readable = _dereq_('./_stream_readable');
var Writable = _dereq_('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":54,"./_stream_writable":56,"core-util-is":14,"inherits":35,"process-nextick-args":50}],53:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = _dereq_('./_stream_transform');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":55,"core-util-is":14,"inherits":35}],54:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = _dereq_('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = _dereq_('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = _dereq_('./internal/streams/stream');
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = _dereq_('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = _dereq_('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = _dereq_('./internal/streams/BufferList');
var destroyImpl = _dereq_('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":52,"./internal/streams/BufferList":57,"./internal/streams/destroy":58,"./internal/streams/stream":59,"_process":7,"core-util-is":14,"events":23,"inherits":35,"isarray":43,"process-nextick-args":50,"safe-buffer":64,"string_decoder/":66,"util":5}],55:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = _dereq_('./_stream_duplex');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":52,"core-util-is":14,"inherits":35}],56:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: _dereq_('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = _dereq_('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/
var Buffer = _dereq_('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = _dereq_('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":52,"./internal/streams/destroy":58,"./internal/streams/stream":59,"_process":7,"core-util-is":14,"inherits":35,"process-nextick-args":50,"safe-buffer":64,"util-deprecate":76}],57:[function(_dereq_,module,exports){
'use strict';

/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = _dereq_('safe-buffer').Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();
},{"safe-buffer":64}],58:[function(_dereq_,module,exports){
'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":50}],59:[function(_dereq_,module,exports){
module.exports = _dereq_('events').EventEmitter;

},{"events":23}],60:[function(_dereq_,module,exports){
exports = module.exports = _dereq_('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = _dereq_('./lib/_stream_writable.js');
exports.Duplex = _dereq_('./lib/_stream_duplex.js');
exports.Transform = _dereq_('./lib/_stream_transform.js');
exports.PassThrough = _dereq_('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":52,"./lib/_stream_passthrough.js":53,"./lib/_stream_readable.js":54,"./lib/_stream_transform.js":55,"./lib/_stream_writable.js":56}],61:[function(_dereq_,module,exports){
'use strict';

var readystate = module.exports = _dereq_('./readystate')
  , win = (new Function('return this'))()
  , complete = 'complete'
  , root = true
  , doc = win.document
  , html = doc.documentElement;

(function wrapper() {
  //
  // Bail out early if the document is already fully loaded. This means that this
  // script is loaded after the onload event.
  //
  if (complete === doc.readyState) {
    return readystate.change(complete);
  }

  //
  // Use feature detection to see what kind of browser environment we're dealing
  // with. Old versions of Internet Explorer do not support the addEventListener
  // interface so we can also safely assume that we need to fall back to polling.
  //
  var modern = !!doc.addEventListener
    , prefix = modern ? '' : 'on'
    , on = modern ? 'addEventListener' : 'attachEvent'
    , off = modern ? 'removeEventListener' : 'detachEvent';

  if (!modern && 'function' === typeof html.doScroll) {
    try { root = !win.frameElement; }
    catch (e) {}

    if (root) (function polling() {
      try { html.doScroll('left'); }
      catch (e) { return setTimeout(polling, 50); }

      readystate.change('interactive');
    }());
  }

  /**
   * Handle the various of event listener calls.
   *
   * @param {Event} evt Simple DOM event.
   * @api private
   */
  function change(evt) {
    evt = evt || win.event;

    if ('readystatechange' === evt.type) {
      readystate.change(doc.readyState);
      if (complete !== doc.readyState) return;
    }

    if ('load' === evt.type) readystate.change('complete');
    else readystate.change('interactive');

    //
    // House keeping, remove our assigned event listeners.
    //
    (evt.type === 'load' ? win : doc)[off](evt.type, change, false);
  }

  //
  // Assign a shit load of event listeners so we can update our internal state.
  //
  doc[on](prefix +'DOMContentLoaded', change, false);
  doc[on](prefix +'readystatechange', change, false);
  win[on](prefix +'load', change, false);
} ());


},{"./readystate":62}],62:[function(_dereq_,module,exports){
'use strict';

/**
 * Generate a new prototype method which will the given function once the
 * desired state has been reached. The returned function accepts 2 arguments:
 *
 * - fn: The assigned function which needs to be called.
 * - context: Context/this value of the function we need to execute.
 *
 * @param {String} state The state we need to operate upon.
 * @returns {Function}
 * @api private
 */
function generate(state) {
  return function proxy(fn, context) {
    var rs = this;

    if (rs.is(state)) {
      setTimeout(function () {
        fn.call(context, rs.readyState);
      }, 0);
    } else {
      if (!rs._events[state]) rs._events[state] = [];
      rs._events[state].push({ fn: fn, context: context });
    }

    return rs;
  };
}

/**
 * RS (readyState) instance.
 *
 * @constructor
 * @api public
 */
function RS() {
  this.readyState = RS.UNKNOWN;
  this._events = {};
}

/**
 * The environment can be in different states. The following states are
 * generated:
 *
 * - ALL:         The I don't really give a fuck state.
 * - UNKNOWN:     We got an unknown readyState we should start listening for events.
 * - LOADING:     Environment is currently loading.
 * - INTERACTIVE: Environment is ready for modification.
 * - COMPLETE:    All resources have been loaded.
 *
 * Please note that the order of the `states` string/array is of vital
 * importance as it's used in the readyState check.
 *
 * @type {Number}
 * @private
 */
RS.states = 'ALL,UNKNOWN,LOADING,INTERACTIVE,COMPLETE'.split(',');

for (var s = 0, state; s < RS.states.length; s++) {
  state = RS.states[s];

  RS[state] = RS.prototype[state] = s;
  RS.prototype[state.toLowerCase()] = generate(state);
}

/**
 * A change in the environment has been detected so we need to change our
 * readyState and call assigned event listeners and those of the previous
 * states.
 *
 * @param {Number} state The new readyState that we detected.
 * @returns {RS}
 * @api private
 */
RS.prototype.change = function change(state) {
  state = this.clean(state, true);

  var j
    , name
    , i = 0
    , listener
    , rs = this
    , previously = rs.readyState;

  if (previously >= state) return rs;

  rs.readyState = state;

  for (; i < RS.states.length; i++) {
    if (i > state) break;
    name = RS.states[i];

    if (name in rs._events) {
      for (j = 0; j < rs._events[name].length; j++) {
        listener = rs._events[name][j];
        listener.fn.call(listener.context || rs, previously);
      }

      delete rs._events[name];
    }
  }

  return rs;
};

/**
 * Check if we're currently in a given readyState.
 *
 * @param {String|Number} state The required readyState.
 * @returns {Boolean} Indication if this state has been reached.
 * @api public
 */
RS.prototype.is = function is(state) {
  return this.readyState >= this.clean(state, true);
};

/**
 * Transform a state to a number or toUpperCase.
 *
 * @param {Mixed} state State to transform.
 * @param {Boolean} nr Change to number.
 * @returns {Mixed}
 * @api public
 */
RS.prototype.clean = function transform(state, nr) {
  var type = typeof state;

  if (nr) return 'number' !== type
  ? +RS[state.toUpperCase()] || 0
  : state;

  return ('number' === type ? RS.states[state] : state).toUpperCase();
};

/**
 * Removes all event listeners. Useful when you want to unload readystatechange
 * completely so that it won't react to any events anymore. See
 * https://github.com/unshiftio/readystate/issues/8
 *
 * @returns {Function} rs so that calls can be chained.
 * @api public
 */
RS.prototype.removeAllListeners = function removeAllListeners() {
  this._events = {};
  return this;
}

//
// Expose the module.
//
module.exports = new RS();

},{}],63:[function(_dereq_,module,exports){
/**
 * request-frame - requestAnimationFrame & cancelAnimationFrame polyfill for optimal cross-browser development.
 * @version v1.5.3
 * @license MIT
 * Copyright Julien Etienne 2015 All Rights Reserved.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.requestFrame = factory());
}(this, (function () { 'use strict';

/**
 * @param  {String} type - request | cancel | native.
 * @return {Function} Timing function.
 */
function requestFrame(type) {
    // The only vendor prefixes required.
    var vendors = ['moz', 'webkit'];

    // Disassembled timing function abbreviations.
    var aF = 'AnimationFrame';
    var rqAF = 'Request' + aF;

    // Checks for firefox 4 - 10 function pair mismatch.
    var mozRAF = window.mozRequestAnimationFrame;
    var mozCAF = window.mozCancelAnimationFrame;
    var hasMozMismatch = mozRAF && !mozCAF;

    // Final assigned functions.
    var assignedRequestAnimationFrame;
    var assignedCancelAnimationFrame;

    // Initial time of the timing lapse.
    var previousTime = 0;

    var requestFrameMain;

    // Date.now polyfill, mainly for legacy IE versions.
    if (!Date.now) {
        Date.now = function () {
            return new Date().getTime();
        };
    }

    /**
     * hasIOS6RequestAnimationFrameBug.
     * @See {@Link https://gist.github.com/julienetie/86ac394ec41f1271ff0a}
     * - for Commentary.
     * @Copyright 2015 - Julien Etienne. 
     * @License: MIT.
     */
    function hasIOS6RequestAnimationFrameBug() {
        var webkitRAF = window.webkitRequestAnimationFrame;
        var rAF = window.requestAnimationFrame;

        // CSS/ Device with max for iOS6 Devices.
        var hasMobileDeviceWidth = screen.width <= 768 ? true : false;

        // Only supports webkit prefixed requestAnimtionFrane.
        var requiresWebkitprefix = !(webkitRAF && rAF);

        // iOS6 webkit browsers don't support performance now.
        var hasNoNavigationTiming = window.performance ? false : true;

        var iOS6Notice = 'setTimeout is being used as a substitiue for \n            requestAnimationFrame due to a bug within iOS 6 builds';

        var hasIOS6Bug = requiresWebkitprefix && hasMobileDeviceWidth && hasNoNavigationTiming;

        var bugCheckresults = function bugCheckresults(timingFnA, timingFnB, notice) {
            if (timingFnA || timingFnB) {
                console.warn(notice);
                return true;
            } else {
                return false;
            }
        };

        var displayResults = function displayResults(hasBug, hasBugNotice, webkitFn, nativeFn) {
            if (hasBug) {
                return bugCheckresults(webkitFn, nativeFn, hasBugNotice);
            } else {
                return false;
            }
        };

        return displayResults(hasIOS6Bug, iOS6Notice, webkitRAF, rAF);
    }

    /**
     * Native clearTimeout function.
     * @return {Function}
     */
    function clearTimeoutWithId(id) {
        clearTimeout(id);
    }

    /**
     * Based on a polyfill by Erik, introduced by Paul Irish & 
     * further improved by Darius Bacon.
     * @see  {@link http://www.paulirish.com/2011/
     * requestanimationframe-for-smart-animating}
     * @see  {@link https://github.com/darius/requestAnimationFrame/blob/
     * master/requestAnimationFrame.js}
     * @callback {Number} Timestamp.
     * @return {Function} setTimeout Function.
     */
    function setTimeoutWithTimestamp(callback) {
        var immediateTime = Date.now();
        var lapsedTime = Math.max(previousTime + 16, immediateTime);
        return setTimeout(function () {
            callback(previousTime = lapsedTime);
        }, lapsedTime - immediateTime);
    }

    /**
     * Queries the native function, prefixed function 
     * or use the setTimeoutWithTimestamp function.
     * @return {Function}
     */
    function queryRequestAnimationFrame() {
        if (Array.prototype.filter) {
            assignedRequestAnimationFrame = window['request' + aF] || window[vendors.filter(function (vendor) {
                if (window[vendor + rqAF] !== undefined) return vendor;
            }) + rqAF] || setTimeoutWithTimestamp;
        } else {
            return setTimeoutWithTimestamp;
        }
        if (!hasIOS6RequestAnimationFrameBug()) {
            return assignedRequestAnimationFrame;
        } else {
            return setTimeoutWithTimestamp;
        }
    }

    /**
     * Queries the native function, prefixed function 
     * or use the clearTimeoutWithId function.
     * @return {Function}
     */
    function queryCancelAnimationFrame() {
        var cancellationNames = [];
        if (Array.prototype.map) {
            vendors.map(function (vendor) {
                return ['Cancel', 'CancelRequest'].map(function (cancellationNamePrefix) {
                    cancellationNames.push(vendor + cancellationNamePrefix + aF);
                });
            });
        } else {
            return clearTimeoutWithId;
        }

        /**
         * Checks for the prefixed cancelAnimationFrame implementation.
         * @param  {Array} prefixedNames - An array of the prefixed names. 
         * @param  {Number} i - Iteration start point.
         * @return {Function} prefixed cancelAnimationFrame function.
         */
        function prefixedCancelAnimationFrame(prefixedNames, i) {
            var cancellationFunction = void 0;
            for (; i < prefixedNames.length; i++) {
                if (window[prefixedNames[i]]) {
                    cancellationFunction = window[prefixedNames[i]];
                    break;
                }
            }
            return cancellationFunction;
        }

        // Use truthly function
        assignedCancelAnimationFrame = window['cancel' + aF] || prefixedCancelAnimationFrame(cancellationNames, 0) || clearTimeoutWithId;

        // Check for iOS 6 bug
        if (!hasIOS6RequestAnimationFrameBug()) {
            return assignedCancelAnimationFrame;
        } else {
            return clearTimeoutWithId;
        }
    }

    function getRequestFn() {
        if (hasMozMismatch) {
            return setTimeoutWithTimestamp;
        } else {
            return queryRequestAnimationFrame();
        }
    }

    function getCancelFn() {
        return queryCancelAnimationFrame();
    }

    function setNativeFn() {
        if (hasMozMismatch) {
            window.requestAnimationFrame = setTimeoutWithTimestamp;
            window.cancelAnimationFrame = clearTimeoutWithId;
        } else {
            window.requestAnimationFrame = queryRequestAnimationFrame();
            window.cancelAnimationFrame = queryCancelAnimationFrame();
        }
    }

    /**
     * The type value "request" singles out firefox 4 - 10 and 
     * assigns the setTimeout function if plausible.
     */

    switch (type) {
        case 'request':
        case '':
            requestFrameMain = getRequestFn();
            break;

        case 'cancel':
            requestFrameMain = getCancelFn();
            break;

        case 'native':
            setNativeFn();
            break;
        default:
            throw new Error('RequestFrame parameter is not a type.');
    }
    return requestFrameMain;
}

return requestFrame;

})));

},{}],64:[function(_dereq_,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = _dereq_('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":8}],65:[function(_dereq_,module,exports){
module.exports = shift

function shift (stream) {
  var rs = stream._readableState
  if (!rs) return null
  return rs.objectMode ? stream.read() : stream.read(getStateLength(rs))
}

function getStateLength (state) {
  if (state.buffer.length) {
    // Since node 6.3.0 state.buffer is a BufferList not an array
    if (state.buffer.head) {
      return state.buffer.head.data.length
    }

    return state.buffer[0].length
  }

  return state.length
}

},{}],66:[function(_dereq_,module,exports){
'use strict';

var Buffer = _dereq_('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":64}],67:[function(_dereq_,module,exports){
/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = _dereq_('component-emitter');
var RequestBase = _dereq_('./request-base');
var isObject = _dereq_('./is-object');
var isFunction = _dereq_('./is-function');
var ResponseBase = _dereq_('./response-base');
var shouldRetry = _dereq_('./should-retry');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
}

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only verison of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  return /[\/+]json\b/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
      status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str){
  var parse = request.parse[this.type];
  if(this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
        new_err.original = err;
        new_err.response = res;
        new_err.status = res.status;
      }
    } catch(e) {
      new_err = e; // #985 touching res may cause INVALID_STATE_ERR on old Android
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can substitute for options
    options = pass;
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    }
  }

  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + btoa(user + ':' + pass));
    break;

    case 'auto':
      this.username = user;
      this.password = pass;
    break;
      
    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
    break;  
  }
  return this;
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  // console.log(this._retries, this._maxRetries)
  if (this._maxRetries && this._retries++ < this._maxRetries && shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = function(){
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */

Request.prototype._appendQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }

  if (this._sort) {
    var index = this.url.indexOf('?');
    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');
      if (isFunction(this._sort)) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._appendQueryString();

  return this._end();
};

Request.prototype._end = function() {
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = function(){
    var readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  }
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn){
  var req = request('OPTIONS', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn){
  var req = request('DELETE', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./is-function":68,"./is-object":69,"./request-base":70,"./response-base":71,"./should-retry":72,"component-emitter":12}],68:[function(_dereq_,module,exports){
/**
 * Check if `fn` is a function.
 *
 * @param {Function} fn
 * @return {Boolean}
 * @api private
 */
var isObject = _dereq_('./is-object');

function isFunction(fn) {
  var tag = isObject(fn) ? Object.prototype.toString.call(fn) : '';
  return tag === '[object Function]';
}

module.exports = isFunction;

},{"./is-object":69}],69:[function(_dereq_,module,exports){
/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],70:[function(_dereq_,module,exports){
/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = _dereq_('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, read, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(var option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  return this;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {
  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject){
      self.end(function(err, res){
        if (err) innerReject(err); else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
}

RequestBase.prototype.catch = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
}

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};


/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {

  // name should be either a string or an object.
  if (null === name ||  undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on){
  // This is browser-only functionality. Node side is no-op.
  if(on==undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function(){
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};


/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};


/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  var self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function(){
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
}

},{"./is-object":69}],71:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var utils = _dereq_('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field){
    return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    var ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    var params = utils.params(ct);
    for (var key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    var type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
};

},{"./utils":73}],72:[function(_dereq_,module,exports){
var ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
module.exports = function shouldRetry(err, res) {
  if (err && err.code && ~ERROR_CODES.indexOf(err.code)) return true;
  if (res && res.status && res.status >= 500) return true;
  // Superagent timeout
  if (err && 'timeout' in err && err.code == 'ECONNABORTED') return true;
  if (err && 'crossDomain' in err) return true;
  return false;
};

},{}],73:[function(_dereq_,module,exports){

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = function(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = function(str){
  return str.split(/ *, */).reduce(function(obj, str){
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = function(header, shouldStripCookie){
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  if (shouldStripCookie) {
    delete header['cookie'];
  }
  return header;
};
},{}],74:[function(_dereq_,module,exports){
(function (Buffer){
/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = _dereq_('is-typedarray').strict

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = new Buffer(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to the `Buffer` constructor
    return new Buffer(arr)
  }
}

}).call(this,_dereq_("buffer").Buffer)

},{"buffer":8,"is-typedarray":42}],75:[function(_dereq_,module,exports){
/**
 * UAParser.js v0.7.14
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright  2012-2016 Faisal Salman <fyzlman@gmail.com>
 * Dual licensed under GPLv2 & MIT
 */

(function (window, undefined) {

    'use strict';

    //////////////
    // Constants
    /////////////


    var LIBVERSION  = '0.7.14',
        EMPTY       = '',
        UNKNOWN     = '?',
        FUNC_TYPE   = 'function',
        UNDEF_TYPE  = 'undefined',
        OBJ_TYPE    = 'object',
        STR_TYPE    = 'string',
        MAJOR       = 'major', // deprecated
        MODEL       = 'model',
        NAME        = 'name',
        TYPE        = 'type',
        VENDOR      = 'vendor',
        VERSION     = 'version',
        ARCHITECTURE= 'architecture',
        CONSOLE     = 'console',
        MOBILE      = 'mobile',
        TABLET      = 'tablet',
        SMARTTV     = 'smarttv',
        WEARABLE    = 'wearable',
        EMBEDDED    = 'embedded';


    ///////////
    // Helper
    //////////


    var util = {
        extend : function (regexes, extensions) {
            var margedRegexes = {};
            for (var i in regexes) {
                if (extensions[i] && extensions[i].length % 2 === 0) {
                    margedRegexes[i] = extensions[i].concat(regexes[i]);
                } else {
                    margedRegexes[i] = regexes[i];
                }
            }
            return margedRegexes;
        },
        has : function (str1, str2) {
          if (typeof str1 === "string") {
            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
          } else {
            return false;
          }
        },
        lowerize : function (str) {
            return str.toLowerCase();
        },
        major : function (version) {
            return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g,'').split(".")[0] : undefined;
        },
        trim : function (str) {
          return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
        }
    };


    ///////////////
    // Map helper
    //////////////


    var mapper = {

        rgx : function (ua, arrays) {

            //var result = {},
            var i = 0, j, k, p, q, matches, match;//, args = arguments;

            /*// construct object barebones
            for (p = 0; p < args[1].length; p++) {
                q = args[1][p];
                result[typeof q === OBJ_TYPE ? q[0] : q] = undefined;
            }*/

            // loop through all regexes maps
            while (i < arrays.length && !matches) {

                var regex = arrays[i],       // even sequence (0,2,4,..)
                    props = arrays[i + 1];   // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {

                    matches = regex[j++].exec(ua);

                    if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            // check if given property is actually array
                            if (typeof q === OBJ_TYPE && q.length > 0) {
                                if (q.length == 2) {
                                    if (typeof q[1] == FUNC_TYPE) {
                                        // assign modified match
                                        this[q[0]] = q[1].call(this, match);
                                    } else {
                                        // assign given value, ignore regex match
                                        this[q[0]] = q[1];
                                    }
                                } else if (q.length == 3) {
                                    // check whether function or regex
                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                        // call function (usually string mapper)
                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                    } else {
                                        // sanitize match using given regex
                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                    }
                                } else if (q.length == 4) {
                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                }
                            } else {
                                this[q] = match ? match : undefined;
                            }
                        }
                    }
                }
                i += 2;
            }
            //console.log(this);
            //return this;
        },

        str : function (str, map) {

            for (var i in map) {
                // check if array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                    for (var j = 0; j < map[i].length; j++) {
                        if (util.has(map[i][j], str)) {
                            return (i === UNKNOWN) ? undefined : i;
                        }
                    }
                } else if (util.has(map[i], str)) {
                    return (i === UNKNOWN) ? undefined : i;
                }
            }
            return str;
        }
    };


    ///////////////
    // String map
    //////////////


    var maps = {

        browser : {
            oldsafari : {
                version : {
                    '1.0'   : '/8',
                    '1.2'   : '/1',
                    '1.3'   : '/3',
                    '2.0'   : '/412',
                    '2.0.2' : '/416',
                    '2.0.3' : '/417',
                    '2.0.4' : '/419',
                    '?'     : '/'
                }
            }
        },

        device : {
            amazon : {
                model : {
                    'Fire Phone' : ['SD', 'KF']
                }
            },
            sprint : {
                model : {
                    'Evo Shift 4G' : '7373KT'
                },
                vendor : {
                    'HTC'       : 'APA',
                    'Sprint'    : 'Sprint'
                }
            }
        },

        os : {
            windows : {
                version : {
                    'ME'        : '4.90',
                    'NT 3.11'   : 'NT3.51',
                    'NT 4.0'    : 'NT4.0',
                    '2000'      : 'NT 5.0',
                    'XP'        : ['NT 5.1', 'NT 5.2'],
                    'Vista'     : 'NT 6.0',
                    '7'         : 'NT 6.1',
                    '8'         : 'NT 6.2',
                    '8.1'       : 'NT 6.3',
                    '10'        : ['NT 6.4', 'NT 10.0'],
                    'RT'        : 'ARM'
                }
            }
        }
    };


    //////////////
    // Regex map
    /////////////


    var regexes = {

        browser : [[

            // Presto based
            /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
            /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
            /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80
            ], [NAME, VERSION], [

            /(opios)[\/\s]+([\w\.]+)/i                                          // Opera mini on iphone >= 8.0
            ], [[NAME, 'Opera Mini'], VERSION], [

            /\s(opr)\/([\w\.]+)/i                                               // Opera Webkit
            ], [[NAME, 'Opera'], VERSION], [

            // Mixed
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]+)*/i,
                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer

            // Trident based
            /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,
                                                                                // Avant/IEMobile/SlimBrowser/Baidu
            /(?:ms|\()(ie)\s([\w\.]+)/i,                                        // Internet Explorer

            // Webkit/KHTML based
            /(rekonq)\/([\w\.]+)*/i,                                            // Rekonq
            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser)\/([\w\.-]+)/i
                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser
            ], [NAME, VERSION], [

            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
            ], [[NAME, 'IE'], VERSION], [

            /(edge)\/((\d+)?[\w\.]+)/i                                          // Microsoft Edge
            ], [NAME, VERSION], [

            /(yabrowser)\/([\w\.]+)/i                                           // Yandex
            ], [[NAME, 'Yandex'], VERSION], [

            /(puffin)\/([\w\.]+)/i                                              // Puffin
            ], [[NAME, 'Puffin'], VERSION], [

            /((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i
                                                                                // UCBrowser
            ], [[NAME, 'UCBrowser'], VERSION], [

            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
            ], [[NAME, /_/g, ' '], VERSION], [

            /(micromessenger)\/([\w\.]+)/i                                      // WeChat
            ], [[NAME, 'WeChat'], VERSION], [

            /(QQ)\/([\d\.]+)/i                                                  // QQ, aka ShouQ
            ], [NAME, VERSION], [

            /m?(qqbrowser)[\/\s]?([\w\.]+)/i                                    // QQBrowser
            ], [NAME, VERSION], [

            /xiaomi\/miuibrowser\/([\w\.]+)/i                                   // MIUI Browser
            ], [VERSION, [NAME, 'MIUI Browser']], [

            /;fbav\/([\w\.]+);/i                                                // Facebook App for iOS & Android
            ], [VERSION, [NAME, 'Facebook']], [

            /(headlesschrome) ([\w\.]+)/i                                       // Chrome Headless
            ], [VERSION, [NAME, 'Chrome Headless']], [

            /\swv\).+(chrome)\/([\w\.]+)/i                                      // Chrome WebView
            ], [[NAME, /(.+)/, '$1 WebView'], VERSION], [

            /((?:oculus|samsung)browser)\/([\w\.]+)/i
            ], [[NAME, /(.+(?:g|us))(.+)/, '$1 $2'], VERSION], [                // Oculus / Samsung Browser

            /android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i        // Android Browser
            ], [VERSION, [NAME, 'Android Browser']], [

            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i
                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION], [

            /(dolfin)\/([\w\.]+)/i                                              // Dolphin
            ], [[NAME, 'Dolphin'], VERSION], [

            /((?:android.+)crmo|crios)\/([\w\.]+)/i                             // Chrome for Android/iOS
            ], [[NAME, 'Chrome'], VERSION], [

            /(coast)\/([\w\.]+)/i                                               // Opera Coast
            ], [[NAME, 'Opera Coast'], VERSION], [

            /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
            ], [VERSION, [NAME, 'Firefox']], [

            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
            ], [VERSION, [NAME, 'Mobile Safari']], [

            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
            ], [VERSION, NAME], [

            /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
            ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [

            /(konqueror)\/([\w\.]+)/i,                                          // Konqueror
            /(webkit|khtml)\/([\w\.]+)/i
            ], [NAME, VERSION], [

            // Gecko based
            /(navigator|netscape)\/([\w\.-]+)/i                                 // Netscape
            ], [[NAME, 'Netscape'], VERSION], [
            /(swiftfox)/i,                                                      // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/([\w\.-]+)/i,
                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla

            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir
            /(links)\s\(([\w\.]+)/i,                                            // Links
            /(gobrowser)\/?([\w\.]+)*/i,                                        // GoBrowser
            /(ice\s?browser)\/v?([\w\._]+)/i,                                   // ICE Browser
            /(mosaic)[\/\s]([\w\.]+)/i                                          // Mosaic
            ], [NAME, VERSION]

            /* /////////////////////
            // Media players BEGIN
            ////////////////////////

            , [

            /(apple(?:coremedia|))\/((\d+)[\w\._]+)/i,                          // Generic Apple CoreMedia
            /(coremedia) v((\d+)[\w\._]+)/i
            ], [NAME, VERSION], [

            /(aqualung|lyssna|bsplayer)\/((\d+)?[\w\.-]+)/i                     // Aqualung/Lyssna/BSPlayer
            ], [NAME, VERSION], [

            /(ares|ossproxy)\s((\d+)[\w\.-]+)/i                                 // Ares/OSSProxy
            ], [NAME, VERSION], [

            /(audacious|audimusicstream|amarok|bass|core|dalvik|gnomemplayer|music on console|nsplayer|psp-internetradioplayer|videos)\/((\d+)[\w\.-]+)/i,
                                                                                // Audacious/AudiMusicStream/Amarok/BASS/OpenCORE/Dalvik/GnomeMplayer/MoC
                                                                                // NSPlayer/PSP-InternetRadioPlayer/Videos
            /(clementine|music player daemon)\s((\d+)[\w\.-]+)/i,               // Clementine/MPD
            /(lg player|nexplayer)\s((\d+)[\d\.]+)/i,
            /player\/(nexplayer|lg player)\s((\d+)[\w\.-]+)/i                   // NexPlayer/LG Player
            ], [NAME, VERSION], [
            /(nexplayer)\s((\d+)[\w\.-]+)/i                                     // Nexplayer
            ], [NAME, VERSION], [

            /(flrp)\/((\d+)[\w\.-]+)/i                                          // Flip Player
            ], [[NAME, 'Flip Player'], VERSION], [

            /(fstream|nativehost|queryseekspider|ia-archiver|facebookexternalhit)/i
                                                                                // FStream/NativeHost/QuerySeekSpider/IA Archiver/facebookexternalhit
            ], [NAME], [

            /(gstreamer) souphttpsrc (?:\([^\)]+\)){0,1} libsoup\/((\d+)[\w\.-]+)/i
                                                                                // Gstreamer
            ], [NAME, VERSION], [

            /(htc streaming player)\s[\w_]+\s\/\s((\d+)[\d\.]+)/i,              // HTC Streaming Player
            /(java|python-urllib|python-requests|wget|libcurl)\/((\d+)[\w\.-_]+)/i,
                                                                                // Java/urllib/requests/wget/cURL
            /(lavf)((\d+)[\d\.]+)/i                                             // Lavf (FFMPEG)
            ], [NAME, VERSION], [

            /(htc_one_s)\/((\d+)[\d\.]+)/i                                      // HTC One S
            ], [[NAME, /_/g, ' '], VERSION], [

            /(mplayer)(?:\s|\/)(?:(?:sherpya-){0,1}svn)(?:-|\s)(r\d+(?:-\d+[\w\.-]+){0,1})/i
                                                                                // MPlayer SVN
            ], [NAME, VERSION], [

            /(mplayer)(?:\s|\/|[unkow-]+)((\d+)[\w\.-]+)/i                      // MPlayer
            ], [NAME, VERSION], [

            /(mplayer)/i,                                                       // MPlayer (no other info)
            /(yourmuze)/i,                                                      // YourMuze
            /(media player classic|nero showtime)/i                             // Media Player Classic/Nero ShowTime
            ], [NAME], [

            /(nero (?:home|scout))\/((\d+)[\w\.-]+)/i                           // Nero Home/Nero Scout
            ], [NAME, VERSION], [

            /(nokia\d+)\/((\d+)[\w\.-]+)/i                                      // Nokia
            ], [NAME, VERSION], [

            /\s(songbird)\/((\d+)[\w\.-]+)/i                                    // Songbird/Philips-Songbird
            ], [NAME, VERSION], [

            /(winamp)3 version ((\d+)[\w\.-]+)/i,                               // Winamp
            /(winamp)\s((\d+)[\w\.-]+)/i,
            /(winamp)mpeg\/((\d+)[\w\.-]+)/i
            ], [NAME, VERSION], [

            /(ocms-bot|tapinradio|tunein radio|unknown|winamp|inlight radio)/i  // OCMS-bot/tap in radio/tunein/unknown/winamp (no other info)
                                                                                // inlight radio
            ], [NAME], [

            /(quicktime|rma|radioapp|radioclientapplication|soundtap|totem|stagefright|streamium)\/((\d+)[\w\.-]+)/i
                                                                                // QuickTime/RealMedia/RadioApp/RadioClientApplication/
                                                                                // SoundTap/Totem/Stagefright/Streamium
            ], [NAME, VERSION], [

            /(smp)((\d+)[\d\.]+)/i                                              // SMP
            ], [NAME, VERSION], [

            /(vlc) media player - version ((\d+)[\w\.]+)/i,                     // VLC Videolan
            /(vlc)\/((\d+)[\w\.-]+)/i,
            /(xbmc|gvfs|xine|xmms|irapp)\/((\d+)[\w\.-]+)/i,                    // XBMC/gvfs/Xine/XMMS/irapp
            /(foobar2000)\/((\d+)[\d\.]+)/i,                                    // Foobar2000
            /(itunes)\/((\d+)[\d\.]+)/i                                         // iTunes
            ], [NAME, VERSION], [

            /(wmplayer)\/((\d+)[\w\.-]+)/i,                                     // Windows Media Player
            /(windows-media-player)\/((\d+)[\w\.-]+)/i
            ], [[NAME, /-/g, ' '], VERSION], [

            /windows\/((\d+)[\w\.-]+) upnp\/[\d\.]+ dlnadoc\/[\d\.]+ (home media server)/i
                                                                                // Windows Media Server
            ], [VERSION, [NAME, 'Windows']], [

            /(com\.riseupradioalarm)\/((\d+)[\d\.]*)/i                          // RiseUP Radio Alarm
            ], [NAME, VERSION], [

            /(rad.io)\s((\d+)[\d\.]+)/i,                                        // Rad.io
            /(radio.(?:de|at|fr))\s((\d+)[\d\.]+)/i
            ], [[NAME, 'rad.io'], VERSION]

            //////////////////////
            // Media players END
            ////////////////////*/

        ],

        cpu : [[

            /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i                     // AMD64
            ], [[ARCHITECTURE, 'amd64']], [

            /(ia32(?=;))/i                                                      // IA32 (quicktime)
            ], [[ARCHITECTURE, util.lowerize]], [

            /((?:i[346]|x)86)[;\)]/i                                            // IA32
            ], [[ARCHITECTURE, 'ia32']], [

            // PocketPC mistakenly identified as PowerPC
            /windows\s(ce|mobile);\sppc;/i
            ], [[ARCHITECTURE, 'arm']], [

            /((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i                           // PowerPC
            ], [[ARCHITECTURE, /ower/, '', util.lowerize]], [

            /(sun4\w)[;\)]/i                                                    // SPARC
            ], [[ARCHITECTURE, 'sparc']], [

            /((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+;))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i
                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ], [[ARCHITECTURE, util.lowerize]]
        ],

        device : [[

            /\((ipad|playbook);[\w\s\);-]+(rim|apple)/i                         // iPad/PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [

            /applecoremedia\/[\w\.]+ \((ipad)/                                  // iPad
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [

            /(apple\s{0,1}tv)/i                                                 // Apple TV
            ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple']], [

            /(archos)\s(gamepad2?)/i,                                           // Archos
            /(hp).+(touchpad)/i,                                                // HP TouchPad
            /(hp).+(tablet)/i,                                                  // HP Tablet
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /\s(nook)[\w\s]+build\/(\w+)/i,                                     // Nook
            /(dell)\s(strea[kpr\s\d]*[\dko])/i                                  // Dell Streak
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(kf[A-z]+)\sbuild\/[\w\.]+.*silk\//i                               // Kindle Fire HD
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
            /(sd|kf)[0349hijorstuw]+\sbuild\/[\w\.]+.*silk\//i                  // Fire Phone
            ], [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [

            /\((ip[honed|\s\w*]+);.+(apple)/i                                   // iPod/iPhone
            ], [MODEL, VENDOR, [TYPE, MOBILE]], [
            /\((ip[honed|\s\w*]+);/i                                            // iPod/iPhone
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [

            /(blackberry)[\s-]?(\w+)/i,                                         // BlackBerry
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]+)*/i,
                                                                                // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
            /(hp)\s([\w\s]+\w)/i,                                               // HP iPAQ
            /(asus)-?(\w+)/i                                                    // Asus
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /\(bb10;\s(\w+)/i                                                   // BlackBerry 10
            ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [
                                                                                // Asus Tablets
            /android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i
            ], [MODEL, [VENDOR, 'Asus'], [TYPE, TABLET]], [

            /(sony)\s(tablet\s[ps])\sbuild\//i,                                  // Sony
            /(sony)?(?:sgp.+)\sbuild\//i
            ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Tablet'], [TYPE, TABLET]], [
            /android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i
            ], [MODEL, [VENDOR, 'Sony'], [TYPE, MOBILE]], [

            /\s(ouya)\s/i,                                                      // Ouya
            /(nintendo)\s([wids3u]+)/i                                          // Nintendo
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [

            /android.+;\s(shield)\sbuild/i                                      // Nvidia
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [

            /(playstation\s[34portablevi]+)/i                                   // Playstation
            ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [

            /(sprint\s(\w+))/i                                                  // Sprint Phones
            ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [

            /(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i                         // Lenovo tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,                               // HTC
            /(zte)-(\w+)*/i,                                                    // ZTE
            /(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]+)*/i
                                                                                // Alcatel/GeeksPhone/Lenovo/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

            /(nexus\s9)/i                                                       // HTC Nexus 9
            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [

            /d\/huawei([\w\s-]+)[;\)]/i,
            /(nexus\s6p)/i                                                      // Huawei
            ], [MODEL, [VENDOR, 'Huawei'], [TYPE, MOBILE]], [

            /(microsoft);\s(lumia[\s\w]+)/i                                     // Microsoft Lumia
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /[\s\(;](xbox(?:\sone)?)[\s\);]/i                                   // Microsoft Xbox
            ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [
            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
            ], [[MODEL, /\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [

                                                                                // Motorola
            /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?(:?\s4g)?)[\w\s]+build\//i,
            /mot[\s-]?(\w+)*/i,
            /(XT\d{3,4}) build\//i,
            /(nexus\s6)/i
            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [
            /android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i
            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [

            /hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i            // HbbTV devices
            ], [[VENDOR, util.trim], [MODEL, util.trim], [TYPE, SMARTTV]], [

            /hbbtv.+maple;(\d+)/i
            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, 'Samsung'], [TYPE, SMARTTV]], [

            /\(dtv[\);].+(aquos)/i                                              // Sharp
            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [

            /android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,
            /((SM-T\w+))/i
            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [                  // Samsung
            /smart-tv.+(samsung)/i
            ], [VENDOR, [TYPE, SMARTTV], MODEL], [
            /((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,
            /(sam[sung]*)[\s-]*(\w+-?[\w-]*)*/i,
            /sec-((sgh\w+))/i
            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [

            /sie-(\w+)*/i                                                       // Siemens
            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [

            /(maemo|nokia).*(n900|lumia\s\d+)/i,                                // Nokia
            /(nokia)[\s_-]?([\w-]+)*/i
            ], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [

            /android\s3\.[\s\w;-]{10}(a\d{3})/i                                 // Acer
            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

            /android.+([vl]k\-?\d{3})\s+build/i                                 // LG Tablet
            ], [MODEL, [VENDOR, 'LG'], [TYPE, TABLET]], [
            /android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i                     // LG Tablet
            ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [
            /(lg) netcast\.tv/i                                                 // LG SmartTV
            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
            /(nexus\s[45])/i,                                                   // LG
            /lg[e;\s\/-]+(\w+)*/i,
            /android.+lg(\-?[\d\w]+)\s+build/i
            ], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [

            /android.+(ideatab[a-z0-9\-\s]+)/i                                  // Lenovo
            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [

            /linux;.+((jolla));/i                                               // Jolla
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /((pebble))app\/[\d\.]+\s/i                                         // Pebble
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [

            /android.+;\s(oppo)\s?([\w\s]+)\sbuild/i                            // OPPO
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /crkey/i                                                            // Google Chromecast
            ], [[MODEL, 'Chromecast'], [VENDOR, 'Google']], [

            /android.+;\s(glass)\s\d/i                                          // Google Glass
            ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [

            /android.+;\s(pixel c)\s/i                                          // Google Pixel C
            ], [MODEL, [VENDOR, 'Google'], [TYPE, TABLET]], [

            /android.+;\s(pixel xl|pixel)\s/i                                   // Google Pixel
            ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [

            /android.+(\w+)\s+build\/hm\1/i,                                    // Xiaomi Hongmi 'numeric' models
            /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
            /android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d\w)?)\s+build/i    // Xiaomi Mi
            ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [

            /android.+;\s(m[1-5]\snote)\sbuild/i                                // Meizu Tablet
            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, TABLET]], [

            /android.+a000(1)\s+build/i                                         // OnePlus
            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

            /android.+[;\/]\s*(RCT[\d\w]+)\s+build/i                            // RCA Tablets
            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Venue[\d\s]*)\s+build/i                          // Dell Venue Tablets
            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i                         // Verizon Tablet
            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [

            /android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i     // Barnes & Noble Tablet
            ], [[VENDOR, 'Barnes & Noble'], MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i                           // Barnes & Noble Tablet
            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(zte)?.+(k\d{2})\s+build/i                        // ZTE K Series Tablet
            ], [[VENDOR, 'ZTE'], MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*(gen\d{3})\s+build.*49h/i                         // Swiss GEN Mobile
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [

            /android.+[;\/]\s*(zur\d{3})\s+build/i                              // Swiss ZUR Tablet
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [

            /android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i                         // Zeki Tablets
            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [

            /(android).+[;\/]\s+([YR]\d{2}x?.*)\s+build/i,
            /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(.+)\s+build/i          // Dragon Touch Tablet
            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*(NS-?.+)\s+build/i                                // Insignia Tablets
            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [

            /android.+[;\/]\s*((NX|Next)-?.+)\s+build/i                         // NextBook Tablets
            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Xtreme\_?)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i
            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [                    // Voice Xtreme Phones

            /android.+[;\/]\s*(LVTEL\-?)?(V1[12])\s+build/i                     // LvTel Phones
            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [

            /android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i          // Envizen Tablets
            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(.*\b)\s+build/i             // Le Pan Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i                         // MachSpeed Tablets
            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i                // Trinity Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*TU_(1491)\s+build/i                               // Rotor Tablets
            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [

            /android.+(KS(.+))\s+build/i                                        // Amazon Kindle Tablets
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [

            /android.+(Gigaset)[\s\-]+(Q.+)\s+build/i                           // Gigaset Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /\s(tablet|tab)[;\/]/i,                                             // Unidentifiable Tablet
            /\s(mobile)(?:[;\/]|\ssafari)/i                                     // Unidentifiable Mobile
            ], [[TYPE, util.lowerize], VENDOR, MODEL], [

            /(android.+)[;\/].+build/i                                          // Generic Android Device
            ], [MODEL, [VENDOR, 'Generic']]


        /*//////////////////////////
            // TODO: move to string map
            ////////////////////////////

            /(C6603)/i                                                          // Sony Xperia Z C6603
            ], [[MODEL, 'Xperia Z C6603'], [VENDOR, 'Sony'], [TYPE, MOBILE]], [
            /(C6903)/i                                                          // Sony Xperia Z 1
            ], [[MODEL, 'Xperia Z 1'], [VENDOR, 'Sony'], [TYPE, MOBILE]], [

            /(SM-G900[F|H])/i                                                   // Samsung Galaxy S5
            ], [[MODEL, 'Galaxy S5'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-G7102)/i                                                       // Samsung Galaxy Grand 2
            ], [[MODEL, 'Galaxy Grand 2'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-G530H)/i                                                       // Samsung Galaxy Grand Prime
            ], [[MODEL, 'Galaxy Grand Prime'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-G313HZ)/i                                                      // Samsung Galaxy V
            ], [[MODEL, 'Galaxy V'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-T805)/i                                                        // Samsung Galaxy Tab S 10.5
            ], [[MODEL, 'Galaxy Tab S 10.5'], [VENDOR, 'Samsung'], [TYPE, TABLET]], [
            /(SM-G800F)/i                                                       // Samsung Galaxy S5 Mini
            ], [[MODEL, 'Galaxy S5 Mini'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
            /(SM-T311)/i                                                        // Samsung Galaxy Tab 3 8.0
            ], [[MODEL, 'Galaxy Tab 3 8.0'], [VENDOR, 'Samsung'], [TYPE, TABLET]], [

            /(T3C)/i                                                            // Advan Vandroid T3C
            ], [MODEL, [VENDOR, 'Advan'], [TYPE, TABLET]], [
            /(ADVAN T1J\+)/i                                                    // Advan Vandroid T1J+
            ], [[MODEL, 'Vandroid T1J+'], [VENDOR, 'Advan'], [TYPE, TABLET]], [
            /(ADVAN S4A)/i                                                      // Advan Vandroid S4A
            ], [[MODEL, 'Vandroid S4A'], [VENDOR, 'Advan'], [TYPE, MOBILE]], [

            /(V972M)/i                                                          // ZTE V972M
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [

            /(i-mobile)\s(IQ\s[\d\.]+)/i                                        // i-mobile IQ
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /(IQ6.3)/i                                                          // i-mobile IQ IQ 6.3
            ], [[MODEL, 'IQ 6.3'], [VENDOR, 'i-mobile'], [TYPE, MOBILE]], [
            /(i-mobile)\s(i-style\s[\d\.]+)/i                                   // i-mobile i-STYLE
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /(i-STYLE2.1)/i                                                     // i-mobile i-STYLE 2.1
            ], [[MODEL, 'i-STYLE 2.1'], [VENDOR, 'i-mobile'], [TYPE, MOBILE]], [

            /(mobiistar touch LAI 512)/i                                        // mobiistar touch LAI 512
            ], [[MODEL, 'Touch LAI 512'], [VENDOR, 'mobiistar'], [TYPE, MOBILE]], [

            /////////////
            // END TODO
            ///////////*/

        ],

        engine : [[

            /windows.+\sedge\/([\w\.]+)/i                                       // EdgeHTML
            ], [VERSION, [NAME, 'EdgeHTML']], [

            /(presto)\/([\w\.]+)/i,                                             // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,     // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m
            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
            ], [NAME, VERSION], [

            /rv\:([\w\.]+).*(gecko)/i                                           // Gecko
            ], [VERSION, NAME]
        ],

        os : [[

            // Windows based
            /microsoft\s(windows)\s(vista|xp)/i                                 // Windows (iTunes)
            ], [NAME, VERSION], [
            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
            /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s]+\w)*/i,                  // Windows Phone
            /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

            // Mobile/Embedded OS
            /\((bb)(10);/i                                                      // BlackBerry 10
            ], [[NAME, 'BlackBerry'], VERSION], [
            /(blackberry)\w*\/?([\w\.]+)*/i,                                    // Blackberry
            /(tizen)[\/\s]([\w\.]+)/i,                                          // Tizen
            /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]+)*/i,
                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki
            /linux;.+(sailfish);/i                                              // Sailfish OS
            ], [NAME, VERSION], [
            /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i                 // Symbian
            ], [[NAME, 'Symbian'], VERSION], [
            /\((series40);/i                                                    // Series 40
            ], [NAME], [
            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
            ], [[NAME, 'Firefox OS'], VERSION], [

            // Console
            /(nintendo|playstation)\s([wids34portablevu]+)/i,                   // Nintendo/Playstation

            // GNU/Linux based
            /(mint)[\/\s\(]?(\w+)*/i,                                           // Mint
            /(mageia|vectorlinux)[;\s]/i,                                       // Mageia/VectorLinux
            /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]+)*/i,
                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus
            /(hurd|linux)\s?([\w\.]+)*/i,                                       // Hurd/Linux
            /(gnu)\s?([\w\.]+)*/i                                               // GNU
            ], [NAME, VERSION], [

            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
            ], [[NAME, 'Chromium OS'], VERSION],[

            // Solaris
            /(sunos)\s?([\w\.]+\d)*/i                                           // Solaris
            ], [[NAME, 'Solaris'], VERSION], [

            // BSD based
            /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i                   // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
            ], [NAME, VERSION],[

            /(haiku)\s(\w+)/i                                                  // Haiku
            ], [NAME, VERSION],[

            /cfnetwork\/.+darwin/i,
            /ip[honead]+(?:.*os\s([\w]+)*\slike\smac|;\sopera)/i                // iOS
            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [

            /(mac\sos\sx)\s?([\w\s\.]+\w)*/i,
            /(macintosh|mac(?=_powerpc)\s)/i                                    // Mac OS
            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

            // Other
            /((?:open)?solaris)[\/\s-]?([\w\.]+)*/i,                            // Solaris
            /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i,                               // AIX
            /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i,
                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS
            /(unix)\s?([\w\.]+)*/i                                              // UNIX
            ], [NAME, VERSION]
        ]
    };


    /////////////////
    // Constructor
    ////////////////

    var Browser = function (name, version) {
        this[NAME] = name;
        this[VERSION] = version;
    };
    var CPU = function (arch) {
        this[ARCHITECTURE] = arch;
    };
    var Device = function (vendor, model, type) {
        this[VENDOR] = vendor;
        this[MODEL] = model;
        this[TYPE] = type;
    };
    var Engine = Browser;
    var OS = Browser;

    var UAParser = function (uastring, extensions) {

        if (typeof uastring === 'object') {
            extensions = uastring;
            uastring = undefined;
        }

        if (!(this instanceof UAParser)) {
            return new UAParser(uastring, extensions).getResult();
        }

        var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
        var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;
        var browser = new Browser();
        var cpu = new CPU();
        var device = new Device();
        var engine = new Engine();
        var os = new OS();

        this.getBrowser = function () {
            mapper.rgx.call(browser, ua, rgxmap.browser);
            browser.major = util.major(browser.version); // deprecated
            return browser;
        };
        this.getCPU = function () {
            mapper.rgx.call(cpu, ua, rgxmap.cpu);
            return cpu;
        };
        this.getDevice = function () {
            mapper.rgx.call(device, ua, rgxmap.device);
            return device;
        };
        this.getEngine = function () {
            mapper.rgx.call(engine, ua, rgxmap.engine);
            return engine;
        };
        this.getOS = function () {
            mapper.rgx.call(os, ua, rgxmap.os);
            return os;
        };
        this.getResult = function () {
            return {
                ua      : this.getUA(),
                browser : this.getBrowser(),
                engine  : this.getEngine(),
                os      : this.getOS(),
                device  : this.getDevice(),
                cpu     : this.getCPU()
            };
        };
        this.getUA = function () {
            return ua;
        };
        this.setUA = function (uastring) {
            ua = uastring;
            browser = new Browser();
            cpu = new CPU();
            device = new Device();
            engine = new Engine();
            os = new OS();
            return this;
        };
        return this;
    };

    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER = {
        NAME    : NAME,
        MAJOR   : MAJOR, // deprecated
        VERSION : VERSION
    };
    UAParser.CPU = {
        ARCHITECTURE : ARCHITECTURE
    };
    UAParser.DEVICE = {
        MODEL   : MODEL,
        VENDOR  : VENDOR,
        TYPE    : TYPE,
        CONSOLE : CONSOLE,
        MOBILE  : MOBILE,
        SMARTTV : SMARTTV,
        TABLET  : TABLET,
        WEARABLE: WEARABLE,
        EMBEDDED: EMBEDDED
    };
    UAParser.ENGINE = {
        NAME    : NAME,
        VERSION : VERSION
    };
    UAParser.OS = {
        NAME    : NAME,
        VERSION : VERSION
    };
    //UAParser.Utils = util;

    ///////////
    // Export
    //////////


    // check js environment
    if (typeof(exports) !== UNDEF_TYPE) {
        // nodejs env
        if (typeof module !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
    } else {
        // requirejs env (optional)
        if (typeof(define) === FUNC_TYPE && define.amd) {
            define(function () {
                return UAParser;
            });
        } else if (window) {
            // browser env
            window.UAParser = UAParser;
        }
    }

    // jQuery/Zepto specific (optional)
    // Note:
    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
    //   and we should catch that.
    var $ = window && (window.jQuery || window.Zepto);
    if (typeof $ !== UNDEF_TYPE) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function () {
            return parser.getUA();
        };
        $.ua.set = function (uastring) {
            parser.setUA(uastring);
            var result = parser.getResult();
            for (var prop in result) {
                $.ua[prop] = result[prop];
            }
        };
    }

})(typeof window === 'object' ? window : this);

},{}],76:[function(_dereq_,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],77:[function(_dereq_,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],78:[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],79:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":78,"_process":7,"inherits":77}],80:[function(_dereq_,module,exports){
'use strict';

// FUNCTIONS //

var isStr = Object.prototype.toString;


// IS FLOAT32ARRAY //

/**
* FUNCTION: isFloat32Array( value )
*	Validates if a value is a Float32Array.
*
* @param {*} value - value to validate
* @returns {Boolean} boolean indicating if a value is a Float32Array
*/
function isFloat32Array( value ) {
	return isStr.call( value ) === '[object Float32Array]';
} // end FUNCTION isFloat32Array()


// EXPORTS //

module.exports = isFloat32Array;

},{}],81:[function(_dereq_,module,exports){
(function (process,global){
'use strict'

var Transform = _dereq_('readable-stream').Transform
var duplexify = _dereq_('duplexify')
var WS = _dereq_('ws')
var Buffer = _dereq_('safe-buffer').Buffer

module.exports = WebSocketStream

function buildProxy (options, socketWrite, socketEnd) {
  var proxy = new Transform({
    objectMode: options.objectMode
  })

  proxy._destroyed = false
  proxy._write = socketWrite
  proxy._flush = socketEnd

  proxy.destroy = function(err) {
    if (this._destroyed) return
      this._destroyed = true

    var self = this
    process.nextTick(function() {
      if (err)
        self.emit('error', err)
      self.emit('close')
    })
  }

  return proxy
}

function WebSocketStream(target, protocols, options) {
  var stream, socket

  var isBrowser = process.title === 'browser'
  var isNative = !!global.WebSocket
  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode

  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {
    // accept the "options" Object as the 2nd argument
    options = protocols
    protocols = null

    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {
      protocols = options.protocol;
    }
  }

  if (!options) options = {}

  if (options.objectMode === undefined) {
    options.objectMode = !(options.binary === true || options.binary === undefined)
  }

  var proxy = buildProxy(options, socketWrite, socketEnd)

  if (!options.objectMode) {
    proxy._writev = writev
  }

  // browser only: sets the maximum socket buffer size before throttling
  var bufferSize = options.browserBufferSize || 1024 * 512

  // browser only: how long to wait when throttling
  var bufferTimeout = options.browserBufferTimeout || 1000

  // use existing WebSocket object that was passed in
  if (typeof target === 'object') {
    socket = target
  // otherwise make a new one
  } else {
    // special constructor treatment for native websockets in browsers, see
    // https://github.com/maxogden/websocket-stream/issues/82
    if (isNative && isBrowser) {
      socket = new WS(target, protocols)
    } else {
      socket = new WS(target, protocols, options)
    }

    socket.binaryType = 'arraybuffer'
  }

  // was already open when passed in
  if (socket.readyState === socket.OPEN) {
    stream = proxy
  } else {
    stream = duplexify.obj()
    socket.onopen = onopen
  }

  stream.socket = socket

  socket.onclose = onclose
  socket.onerror = onerror
  socket.onmessage = onmessage

  proxy.on('close', destroy)

  var coerceToBuffer = !options.objectMode

  function socketWriteNode(chunk, enc, next) {
    // avoid errors, this never happens unless
    // destroy() is called
    if (socket.readyState !== socket.OPEN) {
      next()
      return
    }

    if (coerceToBuffer && typeof chunk === 'string') {
      chunk = new Buffer(chunk, 'utf8')
    }
    socket.send(chunk, next)
  }

  function socketWriteBrowser(chunk, enc, next) {
    if (socket.bufferedAmount > bufferSize) {
      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)
      return
    }

    if (coerceToBuffer && typeof chunk === 'string') {
      chunk = new Buffer(chunk, 'utf8')
    }

    try {
      socket.send(chunk)
    } catch(err) {
      return next(err)
    }

    next()
  }

  function socketEnd(done) {
    socket.close()
    done()
  }

  function onopen() {
    stream.setReadable(proxy)
    stream.setWritable(proxy)
    stream.emit('connect')
  }

  function onclose() {
    stream.end()
    stream.destroy()
  }

  function onerror(err) {
    stream.destroy(err)
  }

  function onmessage(event) {
    var data = event.data
    if (data instanceof ArrayBuffer) data = Buffer.from(new Uint8Array(data))
    else data = Buffer.from(data, 'utf8')
    proxy.push(data)
  }

  function destroy() {
    socket.close()
  }

  // this is to be enabled only if objectMode is false
  function writev (chunks, cb) {
    var buffers = new Array(chunks.length)
    for (var i = 0; i < chunks.length; i++) {
      if (typeof chunks[i].chunk === 'string') {
        buffers[i] = Buffer.from(chunks[i], 'utf8')
      } else {
        buffers[i] = chunks[i].chunk
      }
    }

    this._write(Buffer.concat(buffers), 'binary', cb)
  }

  return stream
}

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":7,"duplexify":20,"readable-stream":60,"safe-buffer":64,"ws":82}],82:[function(_dereq_,module,exports){

var ws = null

if (typeof WebSocket !== 'undefined') {
  ws = WebSocket
} else if (typeof MozWebSocket !== 'undefined') {
  ws = MozWebSocket
} else if (typeof window !== 'undefined') {
  ws = window.WebSocket || window.MozWebSocket
}

module.exports = ws

},{}],83:[function(_dereq_,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],84:[function(_dereq_,module,exports){
module.exports={
  "name": "videomail-client",
  "version": "2.0.10",
  "description": "A wicked npm package to record videos directly in the browser, wohooo!",
  "author": "Michael Heuberger <michael.heuberger@binarykitchen.com>",
  "contributors": [
    {
      "name": "Michael Heuberger",
      "email": "michael.heuberger@binarykitchen.com"
    }
  ],
  "homepage": "https://videomail.io",
  "repository": {
    "type": "git",
    "url": "https://github.com/binarykitchen/videomail-client.git"
  },
  "license": "CC0-1.0",
  "readmeFilename": "README.md",
  "module": "src/index.js",
  "main": "dist/videomail-client.js",
  "scripts": {
    "test": "gulp test",
    "start": "gulp examples",
    "patch": "./env/dev/release.sh --importance=patch",
    "minor": "./env/dev/release.sh --importance=minor",
    "major": "./env/dev/release.sh --importance=major"
  },
  "engines": {
    "node": ">=8.1.0",
    "yarn": ">=0.27.5",
    "npm": ">=5.2.0"
  },
  "keywords": [
    "webcam",
    "video",
    "videomail",
    "encoder",
    "getusermedia",
    "audio",
    "recorder"
  ],
  "dependencies": {
    "add-eventlistener-with-options": "1.25.0",
    "animitter": "3.0.0",
    "audio-sample": "1.0.3",
    "canvas-to-buffer": "1.0.9",
    "classlist.js": "1.1.20150312",
    "contains": "0.1.1",
    "create-error": "0.3.1",
    "defined": "1.0.0",
    "despot": "1.1.3",
    "document-visibility": "1.0.1",
    "element-closest": "2.0.2",
    "filesize": "3.5.10",
    "get-form-data": "1.2.5",
    "hidden": "1.1.1",
    "humanize-duration": "3.10.1",
    "hyperscript": "2.0.2",
    "insert-css": "2.0.0",
    "iphone-inline-video": "2.2.2",
    "is-power-of-two": "1.0.0",
    "keymirror": "0.1.1",
    "merge-recursive": "0.0.3",
    "number-is-integer": "1.0.1",
    "readystate": "0.3.0",
    "request-frame": "1.5.3",
    "superagent": "3.5.2",
    "ua-parser-js": "0.7.14",
    "websocket-stream": "5.0.1"
  },
  "devDependencies": {
    "babel-polyfill": "6.23.0",
    "babel-preset-env": "1.6.0",
    "babelify": "7.3.0",
    "body-parser": "1.17.2",
    "browserify": "14.4.0",
    "connect-send-json": "1.0.0",
    "del": "3.0.0",
    "glob": "7.1.2",
    "gulp": "3.9.1",
    "gulp-autoprefixer": "4.0.0",
    "gulp-bump": "2.7.0",
    "gulp-bytediff": "1.0.0",
    "gulp-concat": "2.6.1",
    "gulp-connect": "5.0.0",
    "gulp-cssnano": "2.1.2",
    "gulp-derequire": "2.1.0",
    "gulp-if": "2.0.2",
    "gulp-inject-string": "1.1.0",
    "gulp-load-plugins": "1.5.0",
    "gulp-plumber": "1.1.0",
    "gulp-rename": "1.2.2",
    "gulp-sourcemaps": "2.6.0",
    "gulp-standard": "10.0.0",
    "gulp-stylus": "2.6.0",
    "gulp-todo": "5.4.0",
    "gulp-uglify": "3.0.0",
    "gulp-util": "3.0.8",
    "minimist": "1.2.0",
    "nib": "1.1.2",
    "router": "1.3.1",
    "ssl-root-cas": "1.2.3",
    "standard": "10.0.3",
    "tap-spec": "4.1.1",
    "tape": "4.8.0",
    "tape-run": "3.0.0",
    "vinyl-buffer": "1.0.0",
    "vinyl-source-stream": "1.1.0",
    "watchify": "3.9.0"
  }
}

},{}],85:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mergeRecursive = _dereq_('merge-recursive');

var _mergeRecursive2 = _interopRequireDefault(_mergeRecursive);

var _readystate = _dereq_('readystate');

var _readystate2 = _interopRequireDefault(_readystate);

var _util = _dereq_('util');

var _util2 = _interopRequireDefault(_util);

var _options = _dereq_('./options');

var _options2 = _interopRequireDefault(_options);

var _constants = _dereq_('./constants');

var _constants2 = _interopRequireDefault(_constants);

var _events = _dereq_('./events');

var _events2 = _interopRequireDefault(_events);

var _collectLogger = _dereq_('./util/collectLogger');

var _collectLogger2 = _interopRequireDefault(_collectLogger);

var _eventEmitter = _dereq_('./util/eventEmitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _container = _dereq_('./wrappers/container');

var _container2 = _interopRequireDefault(_container);

var _optionsWrapper = _dereq_('./wrappers/optionsWrapper');

var _optionsWrapper2 = _interopRequireDefault(_optionsWrapper);

var _replay = _dereq_('./wrappers/visuals/replay');

var _replay2 = _interopRequireDefault(_replay);

var _browser = _dereq_('./util/browser');

var _browser2 = _interopRequireDefault(_browser);

var _resource = _dereq_('./resource');

var _resource2 = _interopRequireDefault(_resource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var collectLogger;
var browser;

function adjustOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var localOptions = _mergeRecursive2.default.recursive(_options2.default, options);

  collectLogger = collectLogger || new _collectLogger2.default(localOptions);

  localOptions.logger = collectLogger;
  localOptions.debug = localOptions.logger.debug;

  _optionsWrapper2.default.addFunctions(localOptions);

  return localOptions;
}

function getBrowser(localOptions) {
  if (!browser) {
    browser = new _browser2.default(localOptions);
  }

  return browser;
}

var VideomailClient = function VideomailClient(options) {
  var _this = this;

  var localOptions = adjustOptions(options);
  var container = new _container2.default(localOptions);
  var debug = localOptions.debug;

  var replay;

  _eventEmitter2.default.call(this, localOptions, 'VideomailClient');

  // expose all possible events
  this.events = _events2.default;

  function build() {
    var building = false;

    _readystate2.default.interactive(function (previousState) {
      debug('Client: interactive(),', 'previousState =', previousState + ',', '!building =', !building + ',', '!isBuilt() =', !container.isBuilt());

      // it can happen that it gets called twice, i.E. when an error is thrown
      // in the middle of the build() fn
      if (!building && !container.isBuilt()) {
        building = true;
        try {
          container.build();
        } catch (exc) {
          throw exc;
        } finally {
          building = false;
        }
      }
    });
  }

  this.show = function () {
    if (container.isBuilt()) {
      container.show();
    } else {
      _this.once(_events2.default.BUILT, container.show);
    }
  };

  // automatically adds a <video> element inside the given parentElement and loads
  // it with the videomail
  this.replay = function (videomail, parentElement) {
    function buildReplay() {
      if (typeof parentElement === 'string') {
        parentElement = document.getElementById(parentElement);
      }

      // if there is none, use the automatically generated one
      if (!parentElement) {
        if (!container.hasElement()) {
          _readystate2.default.removeAllListeners();
          throw new Error('Unable to replay video without a container or parent element.');
        }

        replay = container.getReplay();
        parentElement = replay.getParentElement();
      } else {
        replay = new _replay2.default(parentElement, localOptions);
        replay.build();
      }

      videomail = container.addPlayerDimensions(videomail, parentElement);

      if (videomail) {
        if (container.isOutsideElementOf(parentElement)) {
          // replay element must be outside of the container
          container.hideForm();
        } else {
          container.loadForm(videomail);
        }

        // slight delay needed to avoid HTTP 416 errors (request range unavailable)
        setTimeout(function () {
          replay.setVideomail(videomail);

          container.showReplayOnly();
        }, 2e3);
      }
    }

    _readystate2.default.interactive(buildReplay);
  };

  this.startOver = function () {
    replay && replay.hide();
    container.startOver();
  };

  this.unload = function (e) {
    _readystate2.default.removeAllListeners();
    container.unload(e);
  };

  this.hide = function () {
    container.hide();
  };

  this.get = function (key, cb) {
    new _resource2.default(localOptions).get(key, function (err, videomail) {
      if (err) {
        cb(err);
      } else {
        cb(null, container.addPlayerDimensions(videomail));
      }
    });
  };

  this.canRecord = function () {
    return getBrowser(localOptions).canRecord();
  };

  // return true when a video has been recorded but is not sent yet
  this.isDirty = function () {
    return container.isDirty();
  };

  this.submit = function () {
    container.submit();
  };

  this.getLogLines = function () {
    if (localOptions.logger && localOptions.logger.getLines) {
      return localOptions.logger.getLines();
    }
  };

  build();
};

_util2.default.inherits(VideomailClient, _eventEmitter2.default);

Object.keys(_constants2.default.public).forEach(function (name) {
  VideomailClient[name] = _constants2.default.public[name];
});

// just another convenient thing
VideomailClient.events = _events2.default;

exports.default = VideomailClient;

},{"./constants":86,"./events":87,"./options":88,"./resource":89,"./util/browser":92,"./util/collectLogger":93,"./util/eventEmitter":94,"./wrappers/container":101,"./wrappers/optionsWrapper":104,"./wrappers/visuals/replay":113,"merge-recursive":45,"readystate":61,"util":79}],86:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
// constants (changing these only break down functionality, so be careful)

exports.default = {
  SITE_NAME_LABEL: 'x-videomail-site-name',

  public: {
    ENC_TYPE_APP_JSON: 'application/json',
    ENC_TYPE_FORM: 'application/x-www-form-urlencoded'
  }
};

},{}],87:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keymirror = _dereq_('keymirror');

var _keymirror2 = _interopRequireDefault(_keymirror);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _keymirror2.default)({
  BUILT: null, // all dom elements are ready, are in the DOM
  FORM_READY: null, // form is ready, available in the DOM
  LOADING_USER_MEDIA: null, // asking for webcam access
  USER_MEDIA_READY: null, // user media (= webcam) is ready, loaded
  CONNECTING: null, // socket is connecting to server
  CONNECTED: null, // socket is connected to server
  DISCONNECTED: null, // socket to server is disconnected
  COUNTDOWN: null, // countdown for recording has started
  RECORDING: null, // webcam is recording
  STOPPING: null, // recording is being stopped (= preview)
  PROGRESS: null, // start sending
  BEGIN_AUDIO_ENCODING: null, // encoding video
  BEGIN_VIDEO_ENCODING: null, // encoding video
  RESETTING: null, // resetting everything to go back to initial state
  PAUSED: null, // recording is being paused
  RESUMING: null, // recording is resumed
  PREVIEW: null, // video preview is set
  PREVIEW_SHOWN: null, // video preview is shown
  REPLAY_SHOWN: null, // submitted video is shown
  INVALID: null, // form is invalid
  VALIDATING: null, // form is being validated
  VALID: null, // form is valid
  SUBMITTING: null, // form is being submitted
  SUBMITTED: null, // form has been successfully submitted
  ERROR: null, // an error occured
  BLOCKING: null, // something serious, most likely an error, is shown and blocks
  SENDING_FIRST_FRAME: null, // emitted before the first frame is being computed
  FIRST_FRAME_SENT: null, // emitted once when fist frame has been sent to server
  HIDE: null, // emitted when hidden
  NOTIFYING: null, // notifies user about something (not blocking)
  ENABLING_AUDIO: null, // about to enable audio
  DISABLING_AUDIO: null, // about to disable audio
  LOADED_META_DATA: null, // raised when webcam knows its dimensions
  EVENT_EMITTED: null, // for debugging only, is emitted when an event is emitted lol,
  GOING_BACK: null, // going back, starting all over again,
  ASKING_WEBCAM_PERMISSION: null, // when about to ask for webcam permissions
  VISIBLE: null, // document just became visible
  INVISIBLE: null // document just became INvisible
});

},{"keymirror":44}],88:[function(_dereq_,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _package = _dereq_('../package.json');

var PRODUCTION = process.env.NODE_ENV === 'production';

exports.default = {
  logger: null, // define logging instance. leave null for default, console.
  logStackSize: 30, // limits the stack size of log outputs to collect
  verbose: !PRODUCTION, // set true to log more info
  baseUrl: 'https://videomail.io', // leave as it, permanent url to post videos
  socketUrl: 'wss://videomail.io', // leave as it, permanent url to send frames
  siteName: 'videomail-client-demo', // Required for the API. If you change it, contact me
  cache: true, // reduces GET queries when loading videos
  insertCss: true, // inserts predefined CSS, see examples
  enablePause: true, // enable pause/resume button
  enableAutoPause: true, // automatically pauses when window becomes inactive
  enableSpace: true, // hitting space can pause recording
  disableSubmit: false, // set this to true if you do not want to submit videos,
  // but just want to record and replay these temporarily
  enableAutoValidation: true, // automatically validates all form inputs if any exist and
  // does not /enable disable submit button after recording
  // when something else seems invalid.

  enctype: 'application/json', // enctype for the form submission. currently implemented are:
  // 'application/json' and 'application/x-www-form-urlencoded'

  // default CSS selectors you can alter, see examples
  selectors: {
    containerId: 'videomail',
    replayClass: 'replay',
    userMediaClass: 'userMedia',
    visualsClass: 'visuals',
    buttonClass: null, // can also be used as a default class for all buttons
    buttonsClass: 'buttons',

    recordButtonClass: 'record',
    pauseButtonClass: 'pause',
    resumeButtonClass: 'resume',
    previewButtonClass: 'preview',
    recordAgainButtonClass: 'recordAgain',
    submitButtonClass: 'submit',

    subjectInputName: 'subject', // the form input name for subject
    fromInputName: 'from', // the form input name for the from email
    toInputName: 'to', // the form input name for the to email
    bodyInputName: 'body', // the form input name for the message (body)

    keyInputName: 'videomail_key',
    parentKeyInputName: 'videomail_parent_key',
    aliasInputName: 'videomail_alias',

    formId: null, // automatically detects form if any
    submitButtonId: null, // semi-automatically detects submit button in the form
    // but if that does not work, try using the
    submitButtonSelector: null // submitButtonSelector
  },

  audio: {
    enabled: false, // set to true for experimential audio recording
    'switch': false, // enables a switcher for audio recording (on/off)
    volume: 0.2, // must be between 0 .. 1 but 0.20 is recommeded to avoid
    // distorting at the higher volume peaks
    bufferSize: 1024 // decides how often the audio is being sampled, must be a power of two.
    // the higher the less traffic, but harder to adjust with rubberband
    // to match with the video length on server side during encoding
  },

  video: {
    fps: 15, // depends on your connection
    limitSeconds: 30, // recording automatically stops after that limit
    countdown: 3, // set it to 0 or false to disable it

    // it is recommended to set one dimension only and leave the other one to auto
    // because each webcam has a different aspect ratio

    width: 'auto', // or use an integer for exact pixels
    height: 'auto' // or use an integer for exact pixels
  },

  image: {
    quality: 0.4,
    types: ['webp', 'jpeg'] // recommended settings to make most of all browsers
  },

  // alter these text for internationalisation
  text: {
    pausedHeader: 'Paused',
    pausedHint: null,
    sending: 'Teleporting',
    encoding: 'Encoding',
    limitReached: 'Limit reached',
    buttons: {
      'record': 'Record video',
      'recordAgain': 'Record again',
      'resume': 'Resume',
      'pause': 'Pause',
      'preview': 'Preview'
    }
  },

  notifier: {
    entertain: false, // when true, user is entertained while waiting, see examples
    entertainClass: 'bg',
    entertainLimit: 6,
    entertainInterval: 9000
  },

  timeouts: {
    userMedia: 11e3, // in milliseconds, increase if you want user give more time to enable webcam
    connection: 1e4, // in seconds, increase if api is slow
    pingInterval: 45e3 // in milliseconds, keeps webstream (connection) alive when pausing
  },

  callbacks: {
    // a custom callback to tweak form data before posting to server
    // this is for advanced use only and shouldn't be used if possible
    adjustFormDataBeforePosting: null
  },

  defaults: {
    from: null, // define default FROM email address
    to: null, // define default TO email address
    subject: null, // define default subject line
    body: null // define default body content
  },

  // show errors inside the container?
  displayErrors: true,

  // true = all form inputs get disabled and disappear when browser can't record
  adjustFormOnBrowserError: false,

  // when true, any errors will be sent to the videomail server for analysis
  // ps: can be a function too returning a boolean
  reportErrors: false,

  // just for testing purposes to simulate browser agent handling
  fakeUaString: null,

  // todo pass on version to server
  version: _package.version
};

}).call(this,_dereq_('_process'))

},{"../package.json":84,"_process":7}],89:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (options) {
  var cache = {};

  function applyDefaultValue(videomail, name) {
    if (options.defaults[name] && !videomail[name]) {
      videomail[name] = options.defaults[name];
    }

    return videomail;
  }

  function applyDefaultValues(videomail) {
    if (options.defaults) {
      videomail = applyDefaultValue(videomail, 'from');
      videomail = applyDefaultValue(videomail, 'to');
      videomail = applyDefaultValue(videomail, 'subject');
      videomail = applyDefaultValue(videomail, 'body');
    }

    return videomail;
  }

  function packError(err, res) {
    if (res && res.body && res.body.error) {
      // use the server generated text instead of the superagent's default text
      err = res.body.error;

      if (!err.message && res.text) {
        err.message = res.text;
      }
    }

    return err;
  }

  function fetch(alias, cb) {
    _superagent2.default.get('/videomail/' + alias + '/snapshot').set('Accept', 'application/json').set(_constants2.default.SITE_NAME_LABEL, options.siteName).timeout(options.timeouts.connection).end(function (err, res) {
      err = packError(err, res);

      if (err) {
        cb(err);
      } else {
        var videomail = res.body;

        if (options.cache) {
          cache[CACHE_KEY] = videomail;
        }

        cb(null, videomail);
      }
    });
  }

  function write(method, videomail, identifier, cb) {
    if (!cb) {
      cb = identifier;
      identifier = null;
    }

    var queryParams = {};

    var url = options.baseUrl + '/videomail/';
    var request;

    if (identifier) {
      url += identifier;
    }

    request = (0, _superagent2.default)(method, url);

    queryParams[_constants2.default.SITE_NAME_LABEL] = options.siteName;

    request.query(queryParams).send(videomail).timeout(options.timeout).end(function (err, res) {
      err = packError(err, res);

      if (err) {
        cb(err);
      } else {
        if (options.cache && videomail[CACHE_KEY]) {
          cache[videomail[CACHE_KEY]] = res.body.videomail;
        }

        cb(null, res.body.videomail, res.body);
      }
    });
  }

  this.get = function (alias, cb) {
    if (options.cache && cache[alias]) {
      // keep all callbacks async
      setTimeout(function () {
        cb(null, cache[alias]);
      }, 0);
    } else {
      fetch(alias, cb);
    }
  };

  this.reportError = function (err, cb) {
    var queryParams = {};
    var url = options.baseUrl + '/client-error/';
    var request = (0, _superagent2.default)('post', url);

    queryParams[_constants2.default.SITE_NAME_LABEL] = options.siteName;

    request.query(queryParams).send(err).timeout(options.timeout).end(function (err, res) {
      err = packError(err, res);
      if (err) {
        cb && cb(err);
      } else {
        cb && cb();
      }
    });
  };

  this.post = function (videomail, cb) {
    videomail = applyDefaultValues(videomail);

    if (options.callbacks.adjustFormDataBeforePosting) {
      options.callbacks.adjustFormDataBeforePosting(videomail, function (err, adjustedVideomail) {
        if (err) {
          cb(err);
        } else {
          write('post', adjustedVideomail, cb);
        }
      });
    } else {
      write('post', videomail, cb);
    }
  };

  this.put = function (videomail, cb) {
    write('put', videomail, videomail.key, cb);
  };

  this.form = function (formData, url, cb) {
    var formType;

    switch (options.enctype) {
      case _constants2.default.public.ENC_TYPE_APP_JSON:
        formType = 'json';
        break;
      case _constants2.default.public.ENC_TYPE_FORM:
        formType = 'form';
        break;
      default:
        // keep all callbacks async
        setTimeout(function () {
          cb(new Error('Invalid enctype given: ' + options.enctype));
        }, 0);
    }

    if (formType) {
      _superagent2.default.post(url).type(formType).send(formData).timeout(options.timeout).end(function (err, res) {
        err = packError(err, res);

        if (err) {
          cb(err);
        } else {
          cb(null, res);
        }
      });
    }
  };
};

var _superagent = _dereq_('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _constants = _dereq_('./constants');

var _constants2 = _interopRequireDefault(_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CACHE_KEY = 'alias';

},{"./constants":86,"superagent":67}],90:[function(_dereq_,module,exports){
'use strict';

module.exports = '@-webkit-keyframes a{0%{opacity:.9}35%{opacity:.9}50%{opacity:.1}85%{opacity:.1}to{opacity:.9}}@keyframes a{0%{opacity:.9}35%{opacity:.9}50%{opacity:.1}85%{opacity:.1}to{opacity:.9}}.IIV::-webkit-media-controls-play-button,.IIV::-webkit-media-controls-start-playback-button{opacity:0;pointer-events:none;width:5px}.videomail .visuals{position:relative}.videomail .visuals video.replay{-o-object-fit:scale-down;object-fit:scale-down}.videomail .replay,.videomail .userMedia{width:100%!important}.videomail .countdown,.videomail .pausedHeader,.videomail .pausedHint,.videomail .recordNote,.videomail .recordTimer{margin:0;height:auto}.videomail .countdown,.videomail .paused,.videomail .recordNote,.videomail .recordTimer,.videomail noscript{position:absolute}.videomail .countdown,.videomail .pausedHeader,.videomail .pausedHint,.videomail .recordNote,.videomail .recordTimer,.videomail noscript{font-weight:700}.videomail .countdown,.videomail .paused,.videomail noscript{width:100%;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.videomail .countdown,.videomail .pausedHeader,.videomail .pausedHint{text-align:center;text-shadow:0 0 2px #fff}.videomail .countdown,.videomail .pausedHeader{opacity:.85;font-size:440%}.videomail .pausedHint{font-size:150%}.videomail .recordNote,.videomail .recordTimer{right:.7em;background:hsla(0,0%,4%,.8);padding:.4em .4em .3em;transition:all 1s ease;color:#00d814;font-family:monospace;opacity:.9}.videomail .recordNote.near,.videomail .recordTimer.near{color:#eb9369}.videomail .recordNote.nigh,.videomail .recordTimer.nigh{color:#ea4b2a}.videomail .recordTimer{top:.7em}.videomail .recordNote{top:3.6em}.videomail .recordNote:before{content:"REC";-webkit-animation:a 1s infinite;animation:a 1s infinite}.videomail .notifier{overflow:hidden;box-sizing:border-box;height:100%}.videomail .radioGroup{display:block}.videomail video{margin-bottom:0}';

},{}],91:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (userMedia, options) {
  var scriptProcessor;

  function getAudioContext() {
    // instantiate only once
    if (!window.vcAudioContext) {
      var AudioContext = window.AudioContext || window.webkitAudioContext;
      window.vcAudioContext = new AudioContext();
    }

    return window.vcAudioContext;
  }

  function onAudioProcess(e, cb) {
    if (!userMedia.isRecording() || userMedia.isPaused()) {
      return;
    }

    // Returns a Float32Array containing the PCM data associated with the channel,
    // defined by the channel parameter (with 0 representing the first channel)
    var float32Array = e.inputBuffer.getChannelData(0);

    cb(new _audioSample2.default(float32Array));
  }

  this.init = function (localMediaStream) {
    options.debug('AudioRecorder: init()');

    // creates an audio node from the microphone incoming stream
    var volume = getAudioContext().createGain();

    var audioInput;

    try {
      audioInput = getAudioContext().createMediaStreamSource(localMediaStream);
    } catch (exc) {
      throw _videomailError2.default.create('Webcam has no audio', exc.toString(), options);
    }

    if (!(0, _isPowerOfTwo2.default)(options.audio.bufferSize)) {
      throw _videomailError2.default.create('Audio buffer size must be a power of two.', options);
    } else if (!options.audio.volume || options.audio.volume > 1) {
      throw _videomailError2.default.create('Audio volume must be between zero and one.', options);
    }

    volume.gain.value = options.audio.volume;

    // Create a ScriptProcessorNode with the given bufferSize and
    // a single input and output channel
    scriptProcessor = getAudioContext().createScriptProcessor(options.audio.bufferSize, CHANNELS, CHANNELS);

    // connect stream to our scriptProcessor
    audioInput.connect(scriptProcessor);

    // connect our scriptProcessor to the previous destination
    scriptProcessor.connect(getAudioContext().destination);

    // connect volume
    audioInput.connect(volume);
    volume.connect(scriptProcessor);
  };

  this.record = function (cb) {
    options.debug('AudioRecorder: record()');

    scriptProcessor.onaudioprocess = function (e) {
      onAudioProcess(e, cb);
    };
  };

  this.stop = function () {
    options.debug('AudioRecorder: stop()');

    if (scriptProcessor) {
      scriptProcessor.onaudioprocess = undefined;
    }

    // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/close
    getAudioContext().close().then(function () {
      options.debug('AudioRecorder: audio context is closed');
      delete window.vcAudioContext;
    });
  };

  this.getSampleRate = function () {
    if (getAudioContext()) {
      return getAudioContext().sampleRate;
    } else {
      return -1;
    }
  };
};

var _isPowerOfTwo = _dereq_('is-power-of-two');

var _isPowerOfTwo2 = _interopRequireDefault(_isPowerOfTwo);

var _audioSample = _dereq_('audio-sample');

var _audioSample2 = _interopRequireDefault(_audioSample);

var _videomailError = _dereq_('./videomailError');

var _videomailError2 = _interopRequireDefault(_videomailError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHANNELS = 1;

},{"./videomailError":99,"audio-sample":3,"is-power-of-two":41}],92:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _uaParserJs = _dereq_('ua-parser-js');

var _uaParserJs2 = _interopRequireDefault(_uaParserJs);

var _defined = _dereq_('defined');

var _defined2 = _interopRequireDefault(_defined);

var _videomailError = _dereq_('./videomailError');

var _videomailError2 = _interopRequireDefault(_videomailError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Browser = function Browser(options) {
  options = options || {};

  var firefoxDownload = 'http://www.mozilla.org/firefox/update/';
  var edgeDownload = 'https://www.microsoft.com/en-us/download/details.aspx?id=48126';
  var chromeDownload = 'http://www.google.com/chrome/';
  var chromiumDownload = 'http://www.chromium.org/getting-involved/download-chromium';
  var browseHappyLink = 'http://browsehappy.com';
  var ua = (0, _defined2.default)(options.fakeUaString, typeof window !== 'undefined' && window.navigator && window.navigator.userAgent, '');

  var uaParser = new _uaParserJs2.default(ua).getResult();

  var isIOS = uaParser.os.name === 'iOS';
  var isChrome = uaParser.browser.name === 'Chrome';
  var isChromium = uaParser.browser.name === 'Chromium';
  var firefox = uaParser.browser.name === 'Firefox';
  var osVersion = parseFloat(uaParser.os.version);
  var isWindows = uaParser.os.name === 'Windows';
  var isEdge = uaParser.browser.name === 'Edge' || isWindows && osVersion >= 10;
  var isIE = /IE/.test(uaParser.browser.name);
  var isSafari = /Safari/.test(uaParser.browser.name);
  var isOpera = /Opera/.test(uaParser.browser.name);
  var isAndroid = /Android/.test(uaParser.os.name);
  var chromeBased = isChrome || isChromium;
  var okBrowser = chromeBased || firefox || isAndroid || isOpera || isEdge;

  var self = this;

  var videoType;

  function getRecommendation() {
    var warning;

    if (firefox) {
      warning = 'Probably you need to <a href="' + firefoxDownload + '" target="_blank">' + 'upgrade Firefox</a> to fix this.';
    } else if (isChrome) {
      warning = 'Probably you need to <a href="' + chromeDownload + '" target="_blank">' + 'upgrade Chrome</a> to fix this.';
    } else if (isChromium) {
      warning = '<a href="' + chromiumDownload + '" target="_blank">' + 'Upgrade Chromium</a> to fix this.';
    } else if (isIE) {
      warning = 'Instead of Internet Explorer better pick' + ' <a href="' + chromeDownload + '" target="_blank">Chrome</a>,' + ' <a href="' + firefoxDownload + '" target="_blank">Firefox</a>,' + ' <a href="' + edgeDownload + '" target="_blank">Edge</a> or Android.';
    } else if (isSafari) {
      warning = 'Safari has no webcam support yet.<br/>Better pick' + ' <a href="' + chromeDownload + '" target="_blank">Chrome</a>,' + ' <a href="' + firefoxDownload + '" target="_blank">Firefox</a> or Android.';
    }

    return warning;
  }

  function getUserMediaWarning() {
    var warning;

    if (isIOS) {
      warning = 'On iPads/iPhones this webcam feature is missing.<br/><br/>' + 'For now, we recommend you to use a desktop computer or an Android device.';
    } else {
      warning = getRecommendation();
    }

    if (!warning) {
      if (self.isChromeBased() || self.isFirefox()) {
        warning = 'For the webcam feature, your browser needs an upgrade.';
      } else {
        warning = 'Hence we recommend you to use either ' + '<a href="' + chromeDownload + '" target="_blank">Chrome</a>, ' + '<a href="' + firefoxDownload + '" target="_blank">Firefox</a>, ' + '<a href="' + edgeDownload + '" target="_blank">Edge</a> or Android.';
      }
    }

    return warning;
  }

  function getPlaybackWarning() {
    var warning = getRecommendation();

    if (!warning) {
      warning = '<a href="' + browseHappyLink + '" target="_blank">Upgrading your browser</a> ' + 'might help.';
    }

    return warning;
  }

  function canPlayType(video, type) {
    var canPlayType;

    if (video && video.canPlayType) {
      canPlayType = video.canPlayType('video/' + type);
    }

    return canPlayType;
  }

  // just temporary
  this.canRecord = function () {
    var hasNavigator = typeof navigator !== 'undefined';
    var canRecord = false;

    if (hasNavigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      canRecord = true;
    } else {
      var getUserMediaType = hasNavigator && _typeof(navigator.getUserMedia_);

      canRecord = getUserMediaType === 'function';
    }

    return canRecord;
  };

  this.checkRecordingCapabilities = function () {
    var err;

    if (!okBrowser || !this.canRecord()) {
      var classList = [];

      if (isIOS) {
        classList.push(_videomailError2.default.IOS_PROBLEM);
      } else {
        classList.push(_videomailError2.default.BROWSER_PROBLEM);
      }

      err = _videomailError2.default.create({
        message: 'Sorry, your browser is unable to use webcams'
      }, getUserMediaWarning(), options, {
        classList: classList
      });
    }

    return err;
  };

  this.checkPlaybackCapabilities = function (video) {
    options.debug('Browser: checkPlaybackCapabilities()');

    var err;
    var message;

    if (!video) {
      message = 'No HTML5 support for video tag!';
    } else if (!this.getVideoType(video)) {
      message = 'Your old browser cannot support modern video codecs';
    } else if (!video.setAttribute) {
      // fixes "Not implemented" error on older browsers
      message = 'Unable to set video attributes in your old browser';
    }

    if (message) {
      err = _videomailError2.default.create(message, getPlaybackWarning(), options);
    }

    return err;
  };

  this.checkBufferTypes = function () {
    var err;

    if (typeof window === 'undefined' || typeof window.atob === 'undefined') {
      err = _videomailError2.default.create('atob is not supported', options);
    } else if (typeof window.ArrayBuffer === 'undefined') {
      err = _videomailError2.default.create('ArrayBuffers are not supported', options);
    } else if (typeof window.Uint8Array === 'undefined') {
      err = _videomailError2.default.create('Uint8Arrays are not supported', options);
    }

    return err;
  };

  this.getVideoType = function (video) {
    if (!videoType) {
      // there is a bug in canPlayType within chrome for mp4
      if (canPlayType(video, 'mp4') && !chromeBased) {
        videoType = 'mp4';
      } else if (canPlayType(video, 'webm')) {
        videoType = 'webm';
      }
    }

    return videoType;
  };

  this.getNoAccessIssue = function () {
    var message = 'Unable to access webcam';
    var explanation;

    if (this.isChromeBased()) {
      explanation = 'Click on the allow button to grant access to your webcam.';
    } else if (this.isFirefox()) {
      explanation = 'Please grant Firefox access to your webcam.';
    } else {
      explanation = 'Your system does not let your browser access your webcam.';
    }

    return _videomailError2.default.create(message, explanation, options);
  };

  this.isChromeBased = function () {
    return chromeBased;
  };

  this.isFirefox = function () {
    return firefox;
  };

  this.isEdge = function () {
    return isEdge;
  };

  this.isMobile = function () {
    return uaParser.device.type === 'mobile';
  };

  this.getUsefulData = function () {
    return {
      browser: uaParser.browser,
      device: uaParser.device,
      os: uaParser.os,
      engine: uaParser.engine,
      userAgent: ua
    };
  };
};

exports.default = Browser;

// so that we also can require() it from videomailError.js within

module.exports = Browser;

},{"./videomailError":99,"defined":16,"ua-parser-js":75}],93:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var localOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var browser = new _browser2.default(localOptions);
  var logger = localOptions.logger || console;
  var containerId = localOptions.selectors && localOptions.selectors.containerId || 'undefined container id';
  var stack = [];

  function lifo(level, parameters) {
    var line = _util2.default.format.apply(_util2.default, parameters);

    if (stack.length > localOptions.logStackSize) {
      stack.pop();
    }

    stack.push('[' + level + '] ' + line);

    return line;
  }

  function addContainerId(firstArgument) {
    return '#' + containerId + ' [' + new Date().toLocaleTimeString() + '] > ' + firstArgument;
  }

  // workaround: since we cannot overwrite console.log without having the correct file and line number
  // we'll use groupCollapsed() and trace() instead to get these.
  this.debug = function () {
    // always add it for better client error reports
    var args = [].slice.call(arguments, 0);
    args[0] = addContainerId(args[0]);

    var output = lifo('debug', args);

    if (localOptions.verbose) {
      if (browser.isFirefox()) {
        logger.debug(output);
      } else if (logger.groupCollapsed) {
        logger.groupCollapsed(output);
        logger.trace('Trace');
        logger.groupEnd();
      } else if (logger.debug) {
        logger.debug(output);
      } else {
        // last resort if everything else fails for any weird reasons
        console.log(output);
      }
    }
  };

  this.error = function () {
    var args = [].slice.call(arguments, 0);
    args[0] = addContainerId(args[0]);

    logger.error(lifo('error', args));
  };

  this.warn = function () {
    var args = [].slice.call(arguments, 0);
    args[0] = addContainerId(args[0]);

    logger.warn(lifo('warn', args));
  };

  this.getLines = function () {
    return stack;
  };
};

var _util = _dereq_('util');

var _util2 = _interopRequireDefault(_util);

var _browser = _dereq_('./browser');

var _browser2 = _interopRequireDefault(_browser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./browser":92,"util":79}],94:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (options, name) {
  this.emit = function (event) {
    var args = Array.prototype.slice.call(arguments, 0);

    if (!event) {
      throw _videomailError2.default.create('You cannot emit without an event.', options);
    }

    // Automatically convert errors to videomail errors
    if (event === _events2.default.ERROR) {
      var err = args[1];

      err = _videomailError2.default.create(err, options);

      args[1] = err;
    }

    if (options.debug) {
      if (event !== 'removeListener' && event !== 'newListener') {
        var moreArguments;

        if (args[1]) {
          moreArguments = args.slice(1);
        }

        if (moreArguments) {
          options.debug('%s emits: %s', name, event, moreArguments);
        } else {
          options.debug('%s emits: %s', name, event);
        }
      }
    }

    var result = _despot2.default.emit.apply(_despot2.default, args);

    // Todo: have this emitted through a configuration because it is pretty noisy
    // if (event !== Events.EVENT_EMITTED)
    //     this.emit(Events.EVENT_EMITTED, event)

    return result;
  };

  this.on = function (eventName, cb) {
    return _despot2.default.on(eventName, cb);
  };

  this.once = function (eventName, cb) {
    return _despot2.default.once(eventName, cb);
  };

  this.listeners = function (eventName) {
    return _despot2.default.listeners(eventName);
  };

  this.removeListener = function (eventName, cb) {
    return _despot2.default.removeListener(eventName, cb);
  };

  this.removeAllListeners = function () {
    _despot2.default.removeAllListeners();
  };
};

var _despot = _dereq_('despot');

var _despot2 = _interopRequireDefault(_despot);

var _videomailError = _dereq_('./videomailError');

var _videomailError2 = _interopRequireDefault(_videomailError);

var _events = _dereq_('./../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./../events":87,"./videomailError":99,"despot":17}],95:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _filesize2 = _dereq_('filesize');

var _filesize3 = _interopRequireDefault(_filesize2);

var _humanizeDuration = _dereq_('humanize-duration');

var _humanizeDuration2 = _interopRequireDefault(_humanizeDuration);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// todo get rid of this class and use those imports directly

exports.default = {
  filesize: function filesize(bytes, round) {
    return (0, _filesize3.default)(bytes, {
      round: round
    });
  },

  toTime: function toTime(t) {
    return (0, _humanizeDuration2.default)(t);
  }
};

},{"filesize":24,"humanize-duration":31}],96:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
// taken from
// https://bbc.github.io/tal/jsdoc/events_mediaevent.js.html

exports.default = [
// The user agent begins looking for media data, as part of
// the resource selection algorithm.
'loadstart',

// The user agent is intentionally not currently fetching media data,
// but does not have the entire media resource downloaded. networkState equals NETWORK_IDLE
'suspend',

// Playback has begun. Fired after the play() method has returned,
// or when the autoplay attribute has caused playback to begin.
// paused is newly false.
// 'play', commented out since it has special treatment

// The user agent has just determined the duration and dimensions of the
// media resource and the timed tracks are ready.
// readyState is newly equal to HAVE_METADATA or greater for the first time.
// 'loadedmetadata', commented out since it has special treatment

// The user agent is fetching media data.
'progress',

// The user agent is intentionally not currently fetching media data,
// but does not have the entire media resource downloaded.
// 'suspend', // commented out, we are already listening to it in code

// Event The user agent stops fetching the media data before it is completely downloaded,
// but not due to an error.  error is an object with the code MEDIA_ERR_ABORTED.
'abort',

// A media element whose networkState was previously not in the NETWORK_EMPTY
// state has just switched to that state (either because of a fatal error
// during load that's about to be reported, or because the load() method was
// invoked while the resource selection algorithm was already running).
'emptied',

// The user agent is trying to fetch media data, but data is
// unexpectedly not forthcoming
'stalled',

// Playback has been paused. Fired after the pause() method has returned.
// paused is newly true.
'pause',

// The user agent can render the media data at the current playback position
// for the first time.
// readyState newly increased to HAVE_CURRENT_DATA or greater for the first time.
'loadeddata',

// Playback has stopped because the next frame is not available, but the user
// agent expects that frame to become available in due course.
// readyState is newly equal to or less than HAVE_CURRENT_DATA,
// and paused is false. Either seeking is true, or the current playback
// position is not contained in any of the ranges in buffered.
// It is possible for playback to stop for two other reasons without
// paused being false, but those two reasons do not fire this event:
// maybe playback ended, or playback stopped due to errors.
'waiting',

// Playback has started. readyState is newly equal to or greater than
// HAVE_FUTURE_DATA, paused is false, seeking is false,
// or the current playback position is contained in one of the ranges in buffered.
'playing',

// The user agent can resume playback of the media data,
// but estimates that if playback were to be started now, the media resource
// could not be rendered at the current playback rate up to its end without
// having to stop for further buffering of content.
// readyState newly increased to HAVE_FUTURE_DATA or greater.
'canplay',

// The user agent estimates that if playback were to be started now,
// the media resource could be rendered at the current playback rate
// all the way to its end without having to stop for further buffering.
// readyState is newly equal to HAVE_ENOUGH_DATA.
'canplaythrough',

// The seeking IDL attribute changed to true and the seek operation is
// taking long enough that the user agent has time to fire the event.
'seeking',

// The seeking IDL attribute changed to false.
'seeked',

// Playback has stopped because the end of the media resource was reached.
// currentTime equals the end of the media resource; ended is true.
'ended',

// Either the defaultPlaybackRate or the playbackRate attribute
// has just been updated.
'ratechange',

// The duration attribute has just been updated.
'durationchange',

// Either the volume attribute or the muted attribute has changed.
// Fired after the relevant attribute's setter has returned.
'volumechange'

// commented out, happen too often

// The current playback position changed as part of normal playback or in
// an especially interesting way, for example discontinuously.
// 'timeupdate'
];

},{}],97:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = function (anything, options) {
  if (anything === null) {
    return 'null';
  } else if (typeof anything === 'undefined') {
    return 'undefined';
  } else if (typeof anything === 'string') {
    return anything;
  } else if (Array.isArray(anything)) {
    return arrayToString(anything);
  } else if ((typeof anything === 'undefined' ? 'undefined' : _typeof(anything)) === 'object') {
    return objectToString(anything, options);
  } else {
    return anything.toString();
  }
};

var DASH = '- ';
var SEPARATOR = '<br/>' + DASH;

function arrayToString(array) {
  if (array.length > 0) {
    var lines = [];

    array.forEach(function (element) {
      if (element && element.toString) {
        lines.push(element.toString());
      }
    });

    return DASH + lines.join(SEPARATOR);
  }
}

function objectToString(object, options) {
  var propertyNames = Object.getOwnPropertyNames(object);
  var excludes = options && options.excludes || null;
  var lines = [];
  var sLines;

  if (propertyNames.length > 0) {
    var exclude = false;

    propertyNames.forEach(function (name) {
      if (excludes) {
        exclude = excludes.indexOf(name) >= 0;
      }

      if (!exclude && object[name] && object[name].toString) {
        lines.push(object[name].toString());
      }
    });
  }

  if (lines.length === 1) {
    sLines = lines.join();
  } else if (lines.length > 1) {
    sLines = DASH + lines.join(SEPARATOR);
  }

  return sLines;
}

},{}],98:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var navigator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // https://github.com/julienetie/request-frame/issues/6
  if (!window.screen) {
    window.screen = {};
  }

  (0, _requestFrame2.default)('native');

  // avoids warning "navigator.mozGetUserMedia has been replaced by navigator.mediaDevices.getUserMedia",
  // see https://github.com/binarykitchen/videomail-client/issues/79
  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    // do not shim
  } else {
    navigator.getUserMedia_ = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
  }

  if (!window.AudioContext && window.webkitAudioContext) {
    window.AudioContext = window.webkitAudioContext;
  }

  if (!window.URL) {
    window.URL = window.webkitURL || window.mozURL || window.msURL;
  }

  var methods = ['debug', 'groupCollapsed', 'groupEnd', 'error', 'exception', 'info', 'log', 'trace', 'warn'];

  var console = {};

  if (window.console) {
    console = window.console;
  } else {
    window.console = function () {};
  }

  var method;
  var length = methods.length;

  while (length--) {
    method = methods[length];

    if (!console[method]) {
      console[method] = function () {};
    }
  }
};

_dereq_('classlist.js');

_dereq_('element-closest');

var _requestFrame = _dereq_('request-frame');

var _requestFrame2 = _interopRequireDefault(_requestFrame);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"classlist.js":11,"element-closest":21,"request-frame":63}],99:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; // https://github.com/tgriesser/create-error


var _createError = _dereq_('create-error');

var _createError2 = _interopRequireDefault(_createError);

var _util = _dereq_('util');

var _util2 = _interopRequireDefault(_util);

var _pretty = _dereq_('./pretty');

var _pretty2 = _interopRequireDefault(_pretty);

var _resource = _dereq_('./../resource');

var _resource2 = _interopRequireDefault(_resource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VIDEOMAIL_ERR_NAME = 'Videomail Error';

var VideomailError = (0, _createError2.default)(Error, VIDEOMAIL_ERR_NAME, {
  'explanation': undefined,
  'logLines': undefined,
  'useragent': undefined,
  'url': undefined,
  'stack': undefined
});

// shim pretty to exclude stack always
var pretty = function pretty(anything) {
  return (0, _pretty2.default)(anything, { excludes: ['stack'] });
};

// static and public attribute of this class
VideomailError.PERMISSION_DENIED = 'PERMISSION_DENIED';
VideomailError.NOT_ALLOWED_ERROR = 'NotAllowedError';
VideomailError.NOT_CONNECTED = 'Not connected';
VideomailError.DOM_EXCEPTION = 'DOMException';
VideomailError.STARTING_FAILED = 'Starting video failed';
VideomailError.MEDIA_DEVICE_NOT_SUPPORTED = 'MediaDeviceNotSupported';
VideomailError.BROWSER_PROBLEM = 'browser-problem';
VideomailError.WEBCAM_PROBLEM = 'webcam-problem';
VideomailError.IOS_PROBLEM = 'ios-problem';

// static function to convert an error into a videomail error
VideomailError.create = function (err, explanation, options, parameters) {
  if (err && err.name === VIDEOMAIL_ERR_NAME) {
    return err;
  }

  if (!options && explanation) {
    options = explanation;
    explanation = undefined;
  }

  options = options || {};
  parameters = parameters || {};

  // be super robust
  var debug = options && options.debug || console.log;

  debug('VideomailError: create()');

  var classList = parameters.classList || [];

  // Require Browser here, not at the top of the file to avoid
  // recursion. Because the Browser class is requiring this file as well.
  var Browser = _dereq_('./browser');
  var browser = new Browser(options);

  var errType;
  var message;
  var stack;

  // whole code is ugly because all browsers behave so differently :(

  if ((typeof err === 'undefined' ? 'undefined' : _typeof(err)) === 'object') {
    if (err.code === 1 && err.PERMISSION_DENIED === 1) {
      errType = VideomailError.PERMISSION_DENIED;
    } else if (err.constructor && err.constructor.name === VideomailError.DOM_EXCEPTION) {
      errType = VideomailError.DOM_EXCEPTION;
    } else if (err.message === VideomailError.STARTING_FAILED) {
      errType = err.message;
    } else if (err.name) {
      errType = err.name;
    } else if (err.type === 'error' && err.target.bufferedAmount === 0) {
      errType = VideomailError.NOT_CONNECTED;
    }
  } else if (err === VideomailError.NOT_CONNECTED) {
    errType = VideomailError.NOT_CONNECTED;
  } else {
    errType = err;
  }

  if (err && err.stack) {
    stack = err.stack;
  }

  switch (errType) {
    case 'SourceUnavailableError':
      message = 'Source of your webcam cannot be accessed';
      explanation = 'Probably it is locked from another process or has a hardware error.';

      if (err.message) {
        err.message += ' Details: ' + err.message;
      }

      break;
    case 'NotFoundError':
    case 'NO_DEVICES_FOUND':
      message = 'No webcam found';
      explanation = 'Your browser cannot find a webcam attached to your machine.';
      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case 'PermissionDismissedError':
      message = 'Ooops, you didn\'t give me any permissions?';
      explanation = 'Looks like you skipped the webcam permission dialogue.<br/>' + 'Please grant access next time the dialogue appears.';
      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case VideomailError.NOT_ALLOWED_ERROR:
    case VideomailError.PERMISSION_DENIED:
    case 'PermissionDeniedError':
      message = 'Permission denied';

      if (browser.isChromeBased() || browser.isFirefox() || browser.isEdge()) {
        explanation = 'Permission to access your webcam has been denied. ' + 'This can have two reasons:<br/>' + 'a) you blocked access to webcam; or<br/>' + 'b) your webcam is already in use.';
      } else {
        explanation = 'Permission to access your webcam has been denied.';
      }

      classList.push(VideomailError.WEBCAM_PROBLEM);

      break;

    case 'HARDWARE_UNAVAILABLE':
      message = 'Webcam is unavailable';
      explanation = 'Maybe it is already busy in another window?';

      if (browser.isChromeBased()) {
        explanation += ' Or you have to allow access above?';
      }

      classList.push(VideomailError.WEBCAM_PROBLEM);

      break;

    case VideomailError.NOT_CONNECTED:
      message = 'Unable to transfer data';
      explanation = 'Unable to maintain a websocket to the server. Either server or ' + 'your connection is down. Trying to reconnect every two seconds ';
      break;

    case 'NO_VIDEO_FEED':
      message = 'No video feed found!';
      explanation = 'Your webcam is already used in another browser.';
      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case VideomailError.STARTING_FAILED:
      message = 'Starting video failed';
      explanation = 'Most likely this happens when the webam is already active in another browser.';
      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case 'DevicesNotFoundError':
      message = 'No available webcam could be found';
      explanation = 'Looks like you do not have any webcam attached to your machine; or ' + 'the one you plugged in is already used.';
      classList.push(VideomailError.WEBCAM_PROBLEM);
      break;

    case VideomailError.DOM_EXCEPTION:
      if (err.code === 9) {
        var newUrl = 'https:' + window.location.href.substring(window.location.protocol.length);
        message = 'Security upgrade neded';
        explanation = 'Click <a href="' + newUrl + '">here</a> to switch to HTTPs which is more safe ' + ' and enables encrypted videomail transfers.';
        classList.push(VideomailError.BROWSER_PROBLEM);
      } else {
        message = VideomailError.DOM_EXCEPTION;
        explanation = pretty(err);
      }
      break;

    // Chrome has a weird problem where if you try to do a getUserMedia request too early, it
    // can return a MediaDeviceNotSupported error (even though nothing is wrong and permission
    // has been granted). Look at userMediaErrorCallback() in recorder, there we do not
    // emit those kind of errors further and just retry.
    //
    // but for whatever reasons, if it happens to reach this code, then investigate this further.
    case VideomailError.MEDIA_DEVICE_NOT_SUPPORTED:
      message = 'Media device not supported';
      explanation = pretty(err);
      break;

    default:
      var originalExplanation = explanation;

      if (explanation && (typeof explanation === 'undefined' ? 'undefined' : _typeof(explanation)) === 'object') {
        explanation = pretty(explanation);
      }

      // it can be that explanation itself is an error object
      // error objects can be prettified to undefined sometimes
      if (!explanation && originalExplanation) {
        if (originalExplanation.message) {
          explanation = originalExplanation.message;
        } else {
          // tried toString before but nah
          explanation = _util2.default.inspect(originalExplanation, { showHidden: true });
        }
      }

      if (err && typeof err === 'string') {
        message = err;
      } else {
        if (err) {
          if (err.message) {
            message = pretty(err.message);
          }
        }

        if (err && err.explanation) {
          if (!explanation) {
            explanation = pretty(err.explanation);
          } else {
            explanation += ';<br/>' + pretty(err.explanation);
          }
        }

        if (err && err.details) {
          var details = pretty(err.details);

          if (!explanation) {
            explanation = details;
          } else {
            explanation += ';<br/>' + details;
          }
        }
      }

      // for weird, undefined cases
      if (!message) {
        if (errType) {
          message = errType;
        }

        if (!explanation && err) {
          explanation = pretty(err, { excludes: ['stack'] });
        }

        // avoid dupes
        if (pretty(message) === explanation) {
          explanation = undefined;
        }
      }

      break;
  }

  var logLines = null;

  if (options.logger && options.logger.getLines) {
    logLines = options.logger.getLines();
  }

  if (stack) {
    message = new Error(message);
    message.stack = stack;
  }

  var errCode = 'none';

  if (err) {
    errCode = 'code=' + (err.code ? err.code : 'undefined');
    errCode += ', type=' + (err.type ? err.type : 'undefined');
    errCode += ', name=' + (err.name ? err.name : 'undefined');
  }

  var videomailError = new VideomailError(message, {
    explanation: explanation,
    logLines: logLines,
    client: browser.getUsefulData(),
    url: window.location.href,
    code: errCode,
    stack: stack // have to assign it manually again because it is kinda protected
  });

  var resource;
  var reportErrors = false;

  if (options.reportErrors) {
    if (typeof options.reportErrors === 'function') {
      reportErrors = options.reportErrors(videomailError);
    } else {
      reportErrors = options.reportErrors;
    }
  }

  if (reportErrors) {
    resource = new _resource2.default(options);
  }

  if (resource) {
    resource.reportError(videomailError, function (err2) {
      if (err2) {
        console.error('Unable to report error', err2);
      }
    });
  }

  function hasClass(name) {
    return classList.indexOf(name) >= 0;
  }

  function isBrowserProblem() {
    return hasClass(VideomailError.BROWSER_PROBLEM) || parameters.browserProblem;
  }

  // add some public functions

  // this one is useful so that the notifier can have different css classes
  videomailError.getClassList = function () {
    return classList;
  };

  videomailError.removeDimensions = function () {
    return hasClass(VideomailError.IOS_PROBLEM) || browser.isMobile();
  };

  videomailError.hideButtons = function () {
    return isBrowserProblem() || hasClass(VideomailError.IOS_PROBLEM);
  };

  videomailError.hideForm = function () {
    return hasClass(VideomailError.IOS_PROBLEM);
  };

  return videomailError;
};

exports.default = VideomailError;

},{"./../resource":89,"./browser":92,"./pretty":97,"create-error":15,"util":79}],100:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _util = _dereq_('util');

var _util2 = _interopRequireDefault(_util);

var _hyperscript = _dereq_('hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _hidden = _dereq_('hidden');

var _hidden2 = _interopRequireDefault(_hidden);

var _contains = _dereq_('contains');

var _contains2 = _interopRequireDefault(_contains);

var _events = _dereq_('./../events');

var _events2 = _interopRequireDefault(_events);

var _eventEmitter = _dereq_('./../util/eventEmitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Buttons = function Buttons(container, options) {
  _eventEmitter2.default.call(this, options, 'Buttons');

  var self = this;

  var buttonsElement;
  var recordButton;
  var pauseButton;
  var resumeButton;
  var previewButton;
  var recordAgainButton;
  var submitButton;

  var audioOnRadioPair;
  var audioOffRadioPair;

  var built;

  function hide(elements) {
    if (elements && !Array.isArray(elements)) {
      elements = [elements];
    }

    elements && elements.forEach(function (element) {
      (0, _hidden2.default)(element, true);
    });
  }

  function show(elements) {
    if (elements && !Array.isArray(elements)) {
      elements = [elements];
    }

    elements && elements.forEach(function (element) {
      (0, _hidden2.default)(element, false);
    });
  }

  function isShown(elements) {
    var isShown = elements && true;

    if (elements && !Array.isArray(elements)) {
      elements = [elements];
    }

    elements && elements.forEach(function (element) {
      isShown = isShown && element && !(0, _hidden2.default)(element);
    });

    return isShown;
  }

  function disable(elements) {
    if (elements && !Array.isArray(elements)) {
      elements = [elements];
    }

    elements && elements.forEach(function (element) {
      if (element.tagName === 'INPUT' || element.tagName === 'BUTTON') {
        element.disabled = true;
      } else {
        element.classList.add('disabled');
      }
    });
  }

  function enable(elements) {
    if (elements && !Array.isArray(elements)) {
      elements = [elements];
    }

    elements && elements.forEach(function (element) {
      if (element.tagName === 'INPUT' || element.tagName === 'BUTTON') {
        element.disabled = false;
      } else {
        element.classList.remove('disabled');
      }
    });
  }

  function adjustButton(buttonElement, show, type) {
    disable(buttonElement);

    if (type) {
      buttonElement.type = type;
    } else if (!buttonElement.type) {
      buttonElement.type = 'button';
    }

    !show && hide(buttonElement);

    return buttonElement;
  }

  function replaceClickHandler(element, clickHandler) {
    var wrappedClickHandler = function wrappedClickHandler(e) {
      e && e.preventDefault();

      try {
        clickHandler({ event: e });
      } catch (exc) {
        self.emit(_events2.default.ERROR, exc);
      }
    };

    element.onclick = wrappedClickHandler;
  }

  function makeRadioButtonPair(options) {
    var radioButtonElement;
    var radioButtonGroup;

    if (options.id) {
      radioButtonElement = document.getElementById(options.id);
    }

    if (!radioButtonElement) {
      radioButtonElement = (0, _hyperscript2.default)('input#' + options.id, {
        type: 'radio',
        name: options.name,
        value: options.value,
        checked: options.checked
      });

      radioButtonGroup = (0, _hyperscript2.default)('span.radioGroup', radioButtonElement, (0, _hyperscript2.default)('label', {
        'htmlFor': options.id
      }, options.label));

      // double check that submit button is already in the buttonsElement container as a child?
      if (submitButton && (0, _contains2.default)(buttonsElement, submitButton)) {
        buttonsElement.insertBefore(radioButtonGroup, submitButton);
      } else {
        buttonsElement.appendChild(radioButtonGroup);
      }
    }

    if (options.changeHandler) {
      radioButtonElement.onchange = options.changeHandler;
    }

    disable(radioButtonElement);

    return [radioButtonElement, radioButtonGroup];
  }

  function makeButton(buttonClass, text, clickHandler, show, id, type, selector) {
    var buttonElement;

    if (id) {
      buttonElement = document.getElementById(id);
    } else if (selector) {
      buttonElement = document.querySelector(selector);
    } else {
      buttonElement = buttonsElement.querySelector('.' + buttonClass);
    }

    if (!buttonElement) {
      if (options.selectors.buttonClass) {
        buttonClass += '.' + options.selectors.buttonClass;
      }

      buttonElement = (0, _hyperscript2.default)('button.' + buttonClass);
      buttonElement = adjustButton(buttonElement, show, type);

      buttonElement.innerHTML = text;

      // double check that submit button is already in the buttonsElement container
      if (submitButton && (0, _contains2.default)(buttonsElement, submitButton)) {
        buttonsElement.insertBefore(buttonElement, submitButton);
      } else {
        buttonsElement.appendChild(buttonElement);
      }
    } else {
      buttonElement = adjustButton(buttonElement, show);
    }

    if (clickHandler) {
      replaceClickHandler(buttonElement, clickHandler);
    }

    return buttonElement;
  }

  function buildButtons() {
    if (!options.disableSubmit) {
      if (!submitButton) {
        submitButton = makeButton(options.selectors.submitButtonClass, 'Submit', null, true, options.selectors.submitButtonId, 'submit', options.selectors.submitButtonSelector);
      } else {
        disable(submitButton);
      }

      // no need to listen to the submit event when it's already listened
      // within the form element class
      if (!container.hasForm() && submitButton) {
        replaceClickHandler(submitButton, submit);
      }
    }

    recordButton = makeButton(options.selectors.recordButtonClass, options.text.buttons.record, record, false);

    if (options.enablePause) {
      pauseButton = makeButton(options.selectors.pauseButtonClass, options.text.buttons.pause, container.pause, false);
    }

    if (options.enablePause) {
      resumeButton = makeButton(options.selectors.resumeButtonClass, options.text.buttons.resume, container.resume, false);
    }

    // show stop only when pause is enabled - looks better that way otherwise button
    // move left and right between record and stop (preview)
    previewButton = makeButton(options.selectors.previewButtonClass, options.text.buttons.preview, container.stop, false);

    recordAgainButton = makeButton(options.selectors.recordAgainButtonClass, options.text.buttons.recordAgain, recordAgain, false);

    if (options.audio && options.audio.switch) {
      audioOffRadioPair = makeRadioButtonPair({
        id: 'audioOffOption',
        name: 'audio',
        value: 'off',
        label: 'Audio Off',
        checked: !options.isAudioEnabled(),
        changeHandler: function changeHandler() {
          container.disableAudio();
        }
      });

      audioOnRadioPair = makeRadioButtonPair({
        id: 'audioOnOption',
        name: 'audio',
        value: 'on',
        label: 'Audio On (Beta)',
        checked: options.isAudioEnabled(),
        changeHandler: function changeHandler() {
          container.enableAudio();
        }
      });
    }
  }

  function onFormReady(options) {
    // no need to show record button when doing a record again
    if (!isShown(recordAgainButton)) {
      if (!options.paused) {
        show(recordButton);
      }
    }

    if (!options.paused) {
      disable(previewButton);
      hide(previewButton);
    }
  }

  function onGoingBack() {
    hide(recordAgainButton);
    show(recordButton);
  }

  function onReplayShown() {
    self.hide();
  }

  function onUserMediaReady(options) {
    onFormReady(options);

    if (isShown(recordButton)) {
      enable(recordButton);
    }

    if (isShown(audioOnRadioPair)) {
      enable(audioOnRadioPair);
    }

    if (isShown(audioOffRadioPair)) {
      enable(audioOffRadioPair);
    }

    disable(submitButton);
  }

  function onResetting() {
    disable(submitButton);

    self.reset();
  }

  function onPreview() {
    hide(recordButton);
    hide(previewButton);
    disable(audioOnRadioPair);
    disable(audioOffRadioPair);

    show(recordAgainButton);
    enable(recordAgainButton);

    if (!options.enableAutoValidation) {
      enable(submitButton);
    }
  }

  this.enableSubmit = function () {
    enable(submitButton);
  };

  this.adjustButtonsForPause = function () {
    if (!self.isCountingDown()) {
      pauseButton && hide(pauseButton);
      show(resumeButton);
      enable(resumeButton);
      hide(recordButton);
      show(previewButton);
      enable(previewButton);
    }
  };

  function onFirstFrameSent() {
    hide(recordButton);
    hide(recordAgainButton);

    if (pauseButton) {
      show(pauseButton);
      enable(pauseButton);
    }

    enable(previewButton);
    show(previewButton);
  }

  function onRecording(framesCount) {
    // it is possible to hide while recording, hence
    // check framesCount first (coming from recorder)
    if (framesCount > 1) {
      onFirstFrameSent();
    } else {
      disable(audioOffRadioPair);
      disable(audioOnRadioPair);
      disable(recordAgainButton);
      disable(recordButton);
    }
  }

  function onResuming() {
    hide(resumeButton);
    hide(recordButton);

    if (pauseButton) {
      enable(pauseButton);
      show(pauseButton);
    }
  }

  function onStopping() {
    disable(previewButton);
    hide(pauseButton);
    hide(resumeButton);
  }

  function onCountdown() {
    disable(recordButton);
    disable(audioOffRadioPair);
    disable(audioOnRadioPair);
  }

  function onSubmitting() {
    disable(submitButton);
    disable(recordAgainButton);
  }

  function onSubmitted() {
    disable(previewButton);
    disable(recordAgainButton);
    disable(recordButton);
    disable(submitButton);
  }

  function onInvalid() {
    if (options.enableAutoValidation) {
      disable(submitButton);
    }
  }

  function onValid() {
    if (options.enableAutoValidation) {
      enable(submitButton);
    }
  }

  function onHidden() {
    hide(recordButton);
    hide(previewButton);
    hide(recordAgainButton);
    hide(resumeButton);
  }

  function onEnablingAudio() {
    disable(recordButton);
    disable(audioOnRadioPair);
    disable(audioOffRadioPair);
  }

  function onDisablingAudio() {
    disable(recordButton);
    disable(audioOnRadioPair);
    disable(audioOffRadioPair);
  }

  function recordAgain() {
    disable(recordAgainButton);
    container.beginWaiting();
    container.recordAgain();
  }

  function submit() {
    container.submit();
  }

  function record(params) {
    disable(recordButton);
    container.record(params);
  }

  function initEvents() {
    self.on(_events2.default.USER_MEDIA_READY, function (options) {
      onUserMediaReady(options);
    }).on(_events2.default.PREVIEW, function () {
      onPreview();
    }).on(_events2.default.PAUSED, function () {
      self.adjustButtonsForPause();
    }).on(_events2.default.RECORDING, function (framesCount) {
      onRecording(framesCount);
    }).on(_events2.default.FIRST_FRAME_SENT, function () {
      onFirstFrameSent();
    }).on(_events2.default.RESUMING, function () {
      onResuming();
    }).on(_events2.default.STOPPING, function () {
      onStopping();
    }).on(_events2.default.COUNTDOWN, function () {
      onCountdown();
    }).on(_events2.default.SUBMITTING, function () {
      onSubmitting();
    }).on(_events2.default.RESETTING, function () {
      onResetting();
    }).on(_events2.default.INVALID, function () {
      onInvalid();
    }).on(_events2.default.VALID, function () {
      onValid();
    }).on(_events2.default.SUBMITTED, function () {
      onSubmitted();
    }).on(_events2.default.HIDE, function () {
      onHidden();
    }).on(_events2.default.FORM_READY, function (options) {
      onFormReady(options);
    }).on(_events2.default.REPLAY_SHOWN, function () {
      onReplayShown();
    }).on(_events2.default.GOING_BACK, function () {
      onGoingBack();
    }).on(_events2.default.ENABLING_AUDIO, function () {
      onEnablingAudio();
    }).on(_events2.default.DISABLING_AUDIO, function () {
      onDisablingAudio();
    }).on(_events2.default.ERROR, function (err) {
      // since https://github.com/binarykitchen/videomail-client/issues/60
      // we hide areas to make it easier for the user
      if (err.hideButtons && err.hideButtons() && options.adjustFormOnBrowserError) {
        self.hide();
      }
    });
  }

  this.reset = function () {
    options.debug('Buttons: reset()');

    disable(pauseButton);
    disable(resumeButton);
    disable(recordButton);
    disable(previewButton);
    disable(recordAgainButton);
  };

  this.isRecordAgainButtonEnabled = function () {
    return !recordAgainButton.disabled;
  };

  this.isRecordButtonEnabled = function () {
    return !recordButton.disabled;
  };

  this.setSubmitButton = function (newSubmitButton) {
    submitButton = newSubmitButton;
  };

  this.getSubmitButton = function () {
    return submitButton;
  };

  this.build = function () {
    buttonsElement = container.querySelector('.' + options.selectors.buttonsClass);

    if (!buttonsElement) {
      buttonsElement = (0, _hyperscript2.default)('div.' + options.selectors.buttonsClass);

      container.appendChild(buttonsElement);
    }

    buildButtons();

    !built && initEvents();

    built = true;
  };

  this.unload = function () {
    built = false;
  };

  this.hide = function () {
    hide(buttonsElement);
  };

  this.show = function () {
    show(buttonsElement);
  };

  this.isCountingDown = function () {
    return container.isCountingDown();
  };
};

_util2.default.inherits(Buttons, _eventEmitter2.default);

exports.default = Buttons;

},{"./../events":87,"./../util/eventEmitter":94,"contains":13,"hidden":30,"hyperscript":32,"util":79}],101:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _insertCss = _dereq_('insert-css');

var _insertCss2 = _interopRequireDefault(_insertCss);

var _mergeRecursive = _dereq_('merge-recursive');

var _mergeRecursive2 = _interopRequireDefault(_mergeRecursive);

var _hidden = _dereq_('hidden');

var _hidden2 = _interopRequireDefault(_hidden);

var _util = _dereq_('util');

var _util2 = _interopRequireDefault(_util);

var _documentVisibility = _dereq_('document-visibility');

var _documentVisibility2 = _interopRequireDefault(_documentVisibility);

var _dimension = _dereq_('./dimension');

var _dimension2 = _interopRequireDefault(_dimension);

var _visuals = _dereq_('./visuals');

var _visuals2 = _interopRequireDefault(_visuals);

var _buttons = _dereq_('./buttons');

var _buttons2 = _interopRequireDefault(_buttons);

var _form = _dereq_('./form');

var _form2 = _interopRequireDefault(_form);

var _resource = _dereq_('./../resource');

var _resource2 = _interopRequireDefault(_resource);

var _events = _dereq_('./../events');

var _events2 = _interopRequireDefault(_events);

var _eventEmitter = _dereq_('./../util/eventEmitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _videomailError = _dereq_('./../util/videomailError');

var _videomailError2 = _interopRequireDefault(_videomailError);

var _mainMinCss = _dereq_('./../styles/css/main.min.css.js');

var _mainMinCss2 = _interopRequireDefault(_mainMinCss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Container = function Container(options) {
  _eventEmitter2.default.call(this, options, 'Container');

  var self = this;

  var visibility = (0, _documentVisibility2.default)();
  var visuals = new _visuals2.default(this, options);
  var buttons = new _buttons2.default(this, options);
  var resource = new _resource2.default(options);
  var htmlElement = document && document.querySelector && document.querySelector('html');
  var debug = options.debug;

  var hasError = false;
  var submitted = false;
  var lastValidation = false;

  var containerElement;
  var built;
  var form;

  function prependDefaultCss() {
    (0, _insertCss2.default)(_mainMinCss2.default, { prepend: true });
  }

  // since https://github.com/binarykitchen/videomail-client/issues/87
  function findParentFormElement() {
    return containerElement.closest('form');
  }

  function getFormElement() {
    var formElement;

    if (containerElement.tagName === 'FORM') {
      formElement = containerElement;
    } else if (options.selectors.formId) {
      formElement = document.getElementById(options.selectors.formId);
    } else {
      formElement = findParentFormElement();
    }

    return formElement;
  }

  function buildForm() {
    debug('Container: buildForm()');

    var formElement = getFormElement();

    if (formElement) {
      form = new _form2.default(self, formElement, options);

      var submitButton = form.findSubmitButton();
      submitButton && buttons.setSubmitButton(submitButton);

      form.build();
    }
  }

  function buildChildren() {
    debug('Container: buildChildren()');

    if (!containerElement.classList) {
      self.emit(_events2.default.ERROR, _videomailError2.default.create('Sorry, your browser is too old!', options));
    } else {
      containerElement.classList.add('videomail');

      buttons.build();
      visuals.build();
    }
  }

  function processError(err) {
    hasError = true;

    if (err.stack) {
      options.logger.error(err.stack);
    } else {
      options.logger.error(err);
    }

    if (options.displayErrors) {
      visuals.error(err);
    } else {
      visuals.reset();
    }
  }

  function initEvents() {
    debug('Container: initEvents()');

    window.addEventListener('beforeunload', function (e) {
      self.unload(e);
    });

    visibility.onChange(function (visible) {
      // built? see https://github.com/binarykitchen/videomail.io/issues/326
      if (built) {
        if (visible) {
          if (options.isAutoPauseEnabled() && self.isCountingDown()) {
            self.resume();
          }

          self.emit(_events2.default.VISIBLE);
        } else {
          if (options.isAutoPauseEnabled() && (self.isCountingDown() || self.isRecording())) {
            self.pause('document invisible');
          }

          self.emit(_events2.default.INVISIBLE);
        }
      }
    });

    if (options.enableSpace) {
      window.addEventListener('keypress', function (e) {
        var tagName = e.target.tagName;

        if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {
          var code = e.keyCode ? e.keyCode : e.which;

          if (code === 32) {
            e.preventDefault();

            if (options.enablePause) {
              visuals.pauseOrResume();
            } else {
              visuals.recordOrStop();
            }
          }
        }
      });
    }

    // better to keep the one and only error listeners
    // at one spot, here, because unload() will do a removeAllListeners()
    self.on(_events2.default.ERROR, function (err) {
      processError(err);
      unloadChildren(err);

      if (err.removeDimensions && err.removeDimensions()) {
        removeDimensions();
      }
    }).on(_events2.default.LOADED_META_DATA, function () {
      correctDimensions();
    });
  }

  function validateOptions() {
    if (options.hasDefinedWidth() && options.video.width % 2 !== 0) {
      throw _videomailError2.default.create('Width must be divisible by two.', options);
    }

    if (options.hasDefinedHeight() && options.video.height % 2 !== 0) {
      throw _videomailError2.default.create('Height must be divisible by two.', options);
    }
  }

  // this will just set the width but not the height because
  // it can be a form with more inputs elements
  function correctDimensions() {
    var width = visuals.getRecorderWidth(true);

    if (width < 1) {
      throw _videomailError2.default.create('Recorder width cannot be less than 1!', options);
    } else {
      containerElement.style.width = width + 'px';
    }
  }

  function removeDimensions() {
    containerElement.style.width = 'auto';
  }

  function unloadChildren(e) {
    visuals.unload(e);
    buttons.unload();
    self.endWaiting();
  }

  function hideMySelf() {
    (0, _hidden2.default)(containerElement, true);
  }

  // fixes https://github.com/binarykitchen/videomail-client/issues/71
  function trimEmail(email) {
    return email.replace(/(^[,\s]+)|([,\s]+$)/g, '');
  }

  function submitVideomail(formData, method, cb) {
    var FORM_FIELDS = {
      'subject': options.selectors.subjectInputName,
      'from': options.selectors.fromInputName,
      'to': options.selectors.toInputName,
      'body': options.selectors.bodyInputName,
      'key': options.selectors.keyInputName,
      'parentKey': options.selectors.parentKeyInputName
    };

    var videomailFormData = {};

    Object.keys(FORM_FIELDS).forEach(function (key) {
      if (formData.hasOwnProperty(FORM_FIELDS[key])) {
        videomailFormData[key] = formData[FORM_FIELDS[key]];
      }
    });

    if (videomailFormData.from) {
      videomailFormData.from = trimEmail(videomailFormData.from);
    }

    if (videomailFormData.to) {
      videomailFormData.to = trimEmail(videomailFormData.to);
    }

    // when method is undefined, treat it as a post
    if (isPost(method) || !method) {
      videomailFormData.recordingStats = visuals.getRecordingStats();
      videomailFormData.width = visuals.getRecorderWidth(true);
      videomailFormData.height = visuals.getRecorderHeight(true);

      resource.post(videomailFormData, cb);
    } else if (isPut(method)) {
      resource.put(videomailFormData, cb);
    }
  }

  function submitForm(formData, videomailResponse, url, cb) {
    formData[options.selectors.aliasInputName] = videomailResponse.videomail.alias;

    resource.form(formData, url, cb);
  }

  function finalizeSubmissions(err, method, videomail, response, formResponse) {
    self.endWaiting();

    if (err) {
      self.emit(_events2.default.ERROR, err);
    } else {
      submitted = true;

      // merge two json response bodies to fake as if it were only one request
      if (formResponse && formResponse.body) {
        Object.keys(formResponse.body).forEach(function (key) {
          response[key] = formResponse.body[key];
        });
      }

      self.emit(_events2.default.SUBMITTED, videomail, response);

      if (formResponse && formResponse.type === 'text/html' && formResponse.text) {
        // server replied with HTML contents - display these
        document.body.innerHTML = formResponse.text;

        // todo: figure out how to fire dom's onload event again
        // todo: or how to run all the scripts over again
      }
    }
  }

  this.addPlayerDimensions = function (videomail, element) {
    try {
      videomail.playerHeight = this.calculateHeight({
        responsive: true,
        videoWidth: videomail.width,
        ratio: videomail.height / videomail.width
      }, element);

      videomail.playerWidth = this.calculateWidth({
        responsive: true,
        videoHeight: videomail.playerHeight,
        ratio: videomail.height / videomail.width
      });

      return videomail;
    } catch (exc) {
      self.emit(_events2.default.ERROR, exc);
    }
  };

  this.limitWidth = function (width) {
    return _dimension2.default.limitWidth(containerElement, width, options);
  };

  this.limitHeight = function (height) {
    return _dimension2.default.limitHeight(height, options);
  };

  this.calculateWidth = function (fnOptions) {
    return _dimension2.default.calculateWidth(_mergeRecursive2.default.recursive(options, fnOptions));
  };

  this.calculateHeight = function (fnOptions, element) {
    if (!element) {
      if (containerElement) {
        element = containerElement;
      } else {
        // better than nothing
        element = document.body;
      }
    }

    return _dimension2.default.calculateHeight(element, _mergeRecursive2.default.recursive(options, fnOptions));
  };

  this.areVisualsHidden = function () {
    return visuals.isHidden();
  };

  this.hasElement = function () {
    return !!containerElement;
  };

  this.build = function () {
    debug('Container: build()');

    try {
      containerElement = document.getElementById(options.selectors.containerId);

      // only build when a container element hast been found, otherwise
      // be silent and do nothing
      if (containerElement) {
        options.insertCss && prependDefaultCss();

        !built && initEvents();
        validateOptions();
        correctDimensions();
        buildForm();
        buildChildren();

        if (!hasError) {
          debug('Container: built.');
          built = true;
          self.emit(_events2.default.BUILT);
        } else {
          debug('Container: building failed due to an error.');
        }
      } else {
        debug('Container: no container element with ID ' + options.selectors.containerId + ' found. Do nothing.');
      }
    } catch (exc) {
      if (visuals.isNotifierBuilt()) {
        self.emit(_events2.default.ERROR, exc);
      } else {
        throw exc;
      }
    }
  };

  this.getSubmitButton = function () {
    return buttons.getSubmitButton();
  };

  this.querySelector = function (selector) {
    return containerElement.querySelector(selector);
  };

  this.beginWaiting = function () {
    htmlElement.classList && htmlElement.classList.add('wait');
  };

  this.endWaiting = function () {
    htmlElement.classList && htmlElement.classList.remove('wait');
  };

  this.appendChild = function (child) {
    containerElement.appendChild(child);
  };

  this.insertBefore = function (child, reference) {
    containerElement.insertBefore(child, reference);
  };

  this.unload = function (e) {
    debug('Container: unload()', e);

    try {
      unloadChildren(e);
      this.removeAllListeners();

      built = submitted = false;
    } catch (exc) {
      self.emit(_events2.default.ERROR, exc);
    }
  };

  this.show = function () {
    if (containerElement) {
      (0, _hidden2.default)(containerElement, false);

      visuals.show();

      if (!hasError) {
        var paused = self.isPaused();

        if (paused) {
          buttons.adjustButtonsForPause();
        }

        // since https://github.com/binarykitchen/videomail-client/issues/60
        // we hide areas to make it easier for the user
        buttons.show();

        if (self.isReplayShown()) {
          self.emit(_events2.default.PREVIEW);
        } else {
          self.emit(_events2.default.FORM_READY, { paused: paused });
        }
      }
    }
  };

  this.hide = function () {
    hasError = false;

    this.isRecording() && this.pause();

    visuals.hide();

    if (submitted) {
      buttons.hide();
      hideMySelf();
    }
  };

  this.showReplayOnly = function () {
    hasError = false;

    this.isRecording() && this.pause();

    visuals.showReplayOnly();

    submitted && buttons.hide();
  };

  this.isNotifying = function () {
    return visuals.isNotifying();
  };

  this.isPaused = function () {
    return visuals.isPaused();
  };

  this.pause = function (params) {
    visuals.pause(params);
  };

  this.startOver = function () {
    try {
      submitted = false;
      form.show();
      visuals.back(this.show);
    } catch (exc) {
      self.emit(_events2.default.ERROR, exc);
    }
  };

  // this code needs a good rewrite :(
  this.validate = function (force) {
    var runValidation = true;
    var valid;

    if (!options.enableAutoValidation) {
      runValidation = false;
      lastValidation = true; // needed so that it can be submitted anyway, see submit()
    } else if (force) {
      runValidation = force;
    } else if (self.isNotifying()) {
      runValidation = false;
    } else if (visuals.isConnected()) {
      runValidation = visuals.isUserMediaLoaded() || visuals.isReplayShown();
    } else if (visuals.isConnecting()) {
      runValidation = false;
    }

    if (runValidation) {
      this.emit(_events2.default.VALIDATING);

      var visualsValid = visuals.validate() && buttons.isRecordAgainButtonEnabled();
      var whyInvalid;

      if (form) {
        valid = form.validate();

        if (valid) {
          if (!this.areVisualsHidden() && !visualsValid) {
            if (this.isReady() || this.isRecording() || this.isPaused() || this.isCountingDown()) {
              valid = false;
            }

            if (!valid) {
              whyInvalid = 'Video is not recorded';
            }
          }
        } else {
          var invalidInput = form.getInvalidElement();

          if (invalidInput) {
            whyInvalid = 'Form input named ' + invalidInput.name + ' is invalid';
          } else {
            whyInvalid = 'Form input(s() are invalid';
          }
        }
      } else {
        valid = visualsValid;
      }

      if (valid) {
        this.emit(_events2.default.VALID);
      } else {
        this.emit(_events2.default.INVALID, whyInvalid);
      }

      lastValidation = valid;
    }

    return valid;
  };

  this.disableForm = function (buttonsToo) {
    form && form.disable(buttonsToo);
  };

  this.enableForm = function (buttonsToo) {
    form && form.enable(buttonsToo);
  };

  this.hasForm = function () {
    return !!form;
  };

  this.isReady = function () {
    return buttons.isRecordButtonEnabled();
  };

  function isPost(method) {
    return method && method.toUpperCase() === 'POST';
  }

  function isPut(method) {
    return method && method.toUpperCase() === 'PUT';
  }

  this.submitAll = function (formData, method, url) {
    this.beginWaiting();
    this.disableForm(true);
    this.emit(_events2.default.SUBMITTING);

    var post = isPost(method);

    // a closure so that we can access method
    var submitVideomailCallback = function submitVideomailCallback(err1, videomail, videomailResponse) {
      if (err1) {
        finalizeSubmissions(err1, method, videomail, videomailResponse);
      } else if (post) {
        // for now, accept POSTs only which have an URL unlike null and
        // treat all other submissions as direct submissions

        if (!url || url === '') {
          // figure out URL automatically then
          url = document.baseURI;
        }

        submitForm(formData, videomailResponse, url, function (err2, formResponse) {
          finalizeSubmissions(err2, method, videomail, videomailResponse, formResponse);
        });
      } else {
        // it's a direct submission
        finalizeSubmissions(null, method, videomail, videomailResponse);
      }
    };

    submitVideomail(formData, method, submitVideomailCallback);
  };

  this.isBuilt = function () {
    return built;
  };

  this.isReplayShown = function () {
    return visuals.isReplayShown();
  };

  this.isDirty = function () {
    var isDirty = false;

    if (form) {
      if (visuals.isRecorderUnloaded()) {
        isDirty = false;
      } else if (this.isReplayShown() || this.isPaused()) {
        isDirty = true;
      }
    }

    return isDirty;
  };

  this.getReplay = function () {
    return visuals.getReplay();
  };

  this.isOutsideElementOf = function (element) {
    return element.parentNode !== containerElement && element !== containerElement;
  };

  this.hideForm = function () {
    // form check needed, see https://github.com/binarykitchen/videomail-client/issues/127
    form && form.hide();
  };

  this.loadForm = function (videomail) {
    form.loadVideomail(videomail);
    this.validate();
  };

  this.enableAudio = function () {
    options.setAudioEnabled(true);
    this.emit(_events2.default.ENABLING_AUDIO);
  };

  this.disableAudio = function () {
    options.setAudioEnabled(false);
    this.emit(_events2.default.DISABLING_AUDIO);
  };

  this.submit = function () {
    lastValidation && form && form.doTheSubmit();
  };

  this.isCountingDown = visuals.isCountingDown.bind(visuals);
  this.isRecording = visuals.isRecording.bind(visuals);
  this.record = visuals.record.bind(visuals);
  this.resume = visuals.resume.bind(visuals);
  this.stop = visuals.stop.bind(visuals);
  this.recordAgain = visuals.recordAgain.bind(visuals);
};

_util2.default.inherits(Container, _eventEmitter2.default);

exports.default = Container;

},{"./../events":87,"./../resource":89,"./../styles/css/main.min.css.js":90,"./../util/eventEmitter":94,"./../util/videomailError":99,"./buttons":100,"./dimension":102,"./form":103,"./visuals":105,"document-visibility":18,"hidden":30,"insert-css":36,"merge-recursive":45,"util":79}],102:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _numberIsInteger = _dereq_('number-is-integer');

var _numberIsInteger2 = _interopRequireDefault(_numberIsInteger);

var _videomailError = _dereq_('./../util/videomailError');

var _videomailError2 = _interopRequireDefault(_videomailError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getOuterWidth(element) {
  var rect = element.getBoundingClientRect();

  if (rect) {
    return rect.right - rect.left;
  } else {
    return 0;
  }
}

function figureMinHeight(height, options) {
  if (options.hasDefinedHeight()) {
    if (!height) {
      height = options.video.height;
    } else {
      height = Math.min(options.video.height, height);
    }
  }

  if ((0, _numberIsInteger2.default)(height) && height < 1) {
    throw _videomailError2.default.create('Got a video height less than 1 (' + height + ') while figuring out the minimum!', options);
  }

  // just return it, can be "auto"
  return height;
}

exports.default = {

  limitWidth: function limitWidth(element, width, options) {
    var outerWidth = getOuterWidth(element);
    var limitedWidth = outerWidth > 0 && outerWidth < width ? outerWidth : width;

    if ((0, _numberIsInteger2.default)(limitedWidth) && limitedWidth < 1) {
      throw _videomailError2.default.create('Limited width cannot be less than 1!', options);
    } else {
      return limitedWidth;
    }
  },

  // this is difficult to compute and is not entirely correct.
  // but good enough for now to ensure some stability.
  limitHeight: function limitHeight(height, options) {
    if ((0, _numberIsInteger2.default)(height) && height < 1) {
      throw _videomailError2.default.create('Passed limit-height argument cannot be less than 1!', options);
    } else {
      var limitedHeight = Math.min(height, document.body.scrollHeight, document.documentElement.clientHeight);

      if (limitedHeight < 1) {
        throw _videomailError2.default.create('Limited height cannot be less than 1!', options);
      } else {
        return limitedHeight;
      }
    }
  },

  calculateWidth: function calculateWidth(options) {
    var height = options.videoHeight || null;
    var ratio = options.ratio || options.getRatio();

    height = figureMinHeight(height, options);

    if (options.responsive) {
      height = this.limitHeight(height, options);
    }

    if ((0, _numberIsInteger2.default)(height) && height < 1) {
      throw _videomailError2.default.create('Height cannot be smaller than 1 when calculating width.', options);
    } else {
      var calculatedWidth = parseInt(height / ratio);

      if (calculatedWidth < 1) {
        throw _videomailError2.default.create('Calculated width cannot be smaller than 1!', options);
      } else {
        return calculatedWidth;
      }
    }
  },

  calculateHeight: function calculateHeight(element, options) {
    var width = options.videoWidth || null;
    var height;

    var ratio = options.ratio || options.getRatio();

    if (options.hasDefinedWidth()) {
      width = options.video.width;
    }

    if ((0, _numberIsInteger2.default)(width) && width < 1) {
      throw _videomailError2.default.create('Unable to calculate height when width is less than 1.', options);
    } else if (options.responsive) {
      width = this.limitWidth(element, width, options);
    }

    if (width) {
      height = parseInt(width * ratio);
    }

    if ((0, _numberIsInteger2.default)(height) && height < 1) {
      throw _videomailError2.default.create('Just calculated a height less than 1 which is wrong.', options);
    } else {
      return figureMinHeight(height, options);
    }
  }
};

},{"./../util/videomailError":99,"number-is-integer":46}],103:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = _dereq_('hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _util = _dereq_('util');

var _util2 = _interopRequireDefault(_util);

var _hidden = _dereq_('hidden');

var _hidden2 = _interopRequireDefault(_hidden);

var _getFormData = _dereq_('get-form-data');

var _getFormData2 = _interopRequireDefault(_getFormData);

var _events = _dereq_('./../events');

var _events2 = _interopRequireDefault(_events);

var _eventEmitter = _dereq_('./../util/eventEmitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _videomailError = _dereq_('./../util/videomailError');

var _videomailError2 = _interopRequireDefault(_videomailError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Form = function Form(container, formElement, options) {
  _eventEmitter2.default.call(this, options, 'Form');

  var self = this;

  var disableContainerValidation;
  var keyInput;

  function getData() {
    return (0, _getFormData2.default)(formElement);
  }

  this.loadVideomail = function (videomail) {
    var limit = formElement.elements.length;

    var input;
    var name;

    for (var i = 0; i < limit; i++) {
      input = formElement.elements[i];
      name = input.name;

      if (videomail[name]) {
        input.value = videomail[name];
      }

      if (name === options.selectors.subjectInputName || name === options.selectors.bodyInputName) {
        input.disabled = true;
      }
    }

    formElement.setAttribute('method', 'put');
  };

  function isNotButton(element) {
    return element.tagName !== 'BUTTON' && element.type !== 'submit';
  }

  function setDisabled(disabled, buttonsToo) {
    var limit = formElement.elements.length;

    for (var i = 0; i < limit; i++) {
      if (buttonsToo || !buttonsToo && isNotButton(formElement.elements[i])) {
        formElement.elements[i].disabled = disabled;
      }
    }
  }

  function hideAll() {
    var limit = formElement.elements.length;

    for (var i = 0; i < limit; i++) {
      (0, _hidden2.default)(formElement.elements[i], true);
    }

    (0, _hidden2.default)(formElement, true);
  }

  function getInputElements() {
    return formElement.querySelectorAll('input, textarea');
  }

  function getSelectElements() {
    return formElement.querySelectorAll('select');
  }

  this.disable = function (buttonsToo) {
    setDisabled(true, buttonsToo);
  };

  this.enable = function (buttonsToo) {
    setDisabled(false, buttonsToo);
  };

  this.build = function () {
    if (options.enableAutoValidation) {
      var inputElements = getInputElements();
      var inputElement;

      for (var i = 0, len = inputElements.length; i < len; i++) {
        inputElement = inputElements[i];

        if (inputElement.type === 'radio') {
          inputElement.addEventListener('change', function () {
            container.validate();
          });
        } else {
          inputElement.addEventListener('input', function () {
            container.validate();
          });
        }

        // because of angular's digest cycle, validate again when it became invalid
        inputElement.addEventListener('invalid', function () {
          if (!disableContainerValidation) {
            container.validate();
          }
        });
      }

      var selectElements = getSelectElements();

      for (var j = 0, len2 = selectElements.length; j < len2; j++) {
        selectElements[j].addEventListener('change', function () {
          container.validate();
        });
      }
    }

    keyInput = formElement.querySelector('input[name="' + options.selectors.keyInputName + '"]');

    if (!keyInput) {
      keyInput = (0, _hyperscript2.default)('input', {
        name: options.selectors.keyInputName,
        type: 'hidden'
      });

      formElement.appendChild(keyInput);
    }

    this.on(_events2.default.PREVIEW, function (videomailKey) {
      // beware that preview doesn't always come with a key, i.E.
      // container.show() can emit PREVIEW without a key when a replay already exists
      // (can happen when showing - hiding - showing videomail over again)

      // only emit error if key is missing AND the input has no key (value) yet
      if (!videomailKey && !keyInput.value) {
        self.emit(_events2.default.ERROR, _videomailError2.default.create('Videomail key for preview is missing!', options));
      } else if (videomailKey) {
        keyInput.value = videomailKey;
      }
      // else
      // leave as it and use existing keyInput.value
    });

    // fixes https://github.com/binarykitchen/videomail-client/issues/91
    this.on(_events2.default.GOING_BACK, function () {
      keyInput.value = null;
    });

    this.on(_events2.default.ERROR, function (err) {
      // since https://github.com/binarykitchen/videomail-client/issues/60
      // we hide areas to make it easier for the user to process an error
      // (= less distractions)
      if (err.hideForm && err.hideForm() && options.adjustFormOnBrowserError) {
        hideAll();
      } else if (err.hideButtons && err.hideButtons() && options.adjustFormOnBrowserError) {
        hideSubmitButton();
      }
    });

    this.on(_events2.default.BUILT, function () {
      startListeningToSubmitEvents();
    });
  };

  function hideSubmitButton() {
    var submitButton = self.findSubmitButton();
    (0, _hidden2.default)(submitButton, true);
  }

  function startListeningToSubmitEvents() {
    var submitButton = container.getSubmitButton();
    submitButton.addEventListener('click', self.doTheSubmit.bind(self));
  }

  this.doTheSubmit = function (e) {
    // when videomail-client is hidden, leave the form handling as it and
    // do not mess with it at all
    if (!container.areVisualsHidden()) {
      e && e.preventDefault();

      // only adjust submission when there is a container, otherwise
      // do nothing and leave as it for robustness
      if (container.hasElement()) {
        container.submitAll(getData(), formElement.getAttribute('method'), formElement.getAttribute('action'));
      }

      return false; // important to stop submission
    }
  };

  this.getInvalidElement = function () {
    var inputElements = getInputElements();

    for (var i = 0, len = inputElements.length; i < len; i++) {
      if (!inputElements[i].validity.valid) {
        return inputElements[i];
      }
    }

    var selectElements = getSelectElements();

    for (var j = 0, len2 = selectElements.length; j < len2; j++) {
      if (!selectElements[i].validity.valid) {
        return selectElements[j];
      }
    }

    return null;
  };

  this.validate = function () {
    // prevents endless validation loop
    disableContainerValidation = true;

    var formIsValid = formElement.checkValidity();

    disableContainerValidation = false;

    return formIsValid;
  };

  this.findSubmitButton = function () {
    return formElement.querySelector("[type='submit']");
  };

  this.hide = function () {
    formElement && (0, _hidden2.default)(formElement, true);
  };

  this.show = function () {
    formElement && (0, _hidden2.default)(formElement, false);
  };
};

_util2.default.inherits(Form, _eventEmitter2.default);

exports.default = Form;

},{"./../events":87,"./../util/eventEmitter":94,"./../util/videomailError":99,"get-form-data":25,"hidden":30,"hyperscript":32,"util":79}],104:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
// enhances options with useful functions we can reuse everywhere

exports.default = {
  addFunctions: function addFunctions(options) {
    var audioEnabled = options.audio && options.audio.enabled;

    options.hasDefinedHeight = function () {
      return options.video.height && options.video.height !== 'auto';
    };

    options.hasDefinedWidth = function () {
      return options.video.width && options.video.width !== 'auto';
    };

    options.hasDefinedDimension = function () {
      return options.hasDefinedWidth() || options.hasDefinedHeight();
    };

    options.hasDefinedDimensions = function () {
      return options.hasDefinedWidth() && options.hasDefinedHeight();
    };

    options.getRatio = function () {
      var ratio = 1; // just a default one when no computations are possible

      if (options.hasDefinedDimensions()) {
        ratio = options.video.height / options.video.width;
      }

      return ratio;
    };

    options.isAudioEnabled = function () {
      return audioEnabled;
    };

    options.setAudioEnabled = function (enabled) {
      audioEnabled = enabled;
    };

    options.isAutoPauseEnabled = function () {
      return options.enableAutoPause && options.enablePause;
    };
  }
};

},{}],105:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _util = _dereq_('util');

var _util2 = _interopRequireDefault(_util);

var _hyperscript = _dereq_('hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _hidden = _dereq_('hidden');

var _hidden2 = _interopRequireDefault(_hidden);

var _replay = _dereq_('./visuals/replay');

var _replay2 = _interopRequireDefault(_replay);

var _recorder = _dereq_('./visuals/recorder');

var _recorder2 = _interopRequireDefault(_recorder);

var _notifier = _dereq_('./visuals/notifier');

var _notifier2 = _interopRequireDefault(_notifier);

var _recorderInsides = _dereq_('./visuals/inside/recorderInsides');

var _recorderInsides2 = _interopRequireDefault(_recorderInsides);

var _eventEmitter = _dereq_('./../util/eventEmitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _events = _dereq_('./../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Visuals = function Visuals(container, options) {
  _eventEmitter2.default.call(this, options, 'Visuals');

  var self = this;

  var replay = new _replay2.default(this, options);
  var recorder = new _recorder2.default(this, replay, options);
  var recorderInsides = new _recorderInsides2.default(this, options);

  var notifier = new _notifier2.default(this, options);

  var debug = options.debug;

  var visualsElement;
  var built;

  function buildNoScriptTag() {
    var noScriptElement = container.querySelector('noscript');

    if (!noScriptElement) {
      noScriptElement = (0, _hyperscript2.default)('noscript');
      noScriptElement.innerHTML = 'Please enable Javascript';

      visualsElement.appendChild(noScriptElement);
    }
  }

  function buildChildren() {
    debug('Visuals: buildChildren()');

    buildNoScriptTag();

    notifier.build();
    recorderInsides.build();
    replay.build();

    debug('Visuals: built.');
  }

  function initEvents() {
    self.on(_events2.default.USER_MEDIA_READY, function () {
      built = true;
      self.endWaiting();
      container.enableForm(false);
    }).on(_events2.default.PREVIEW, function () {
      self.endWaiting();
    }).on(_events2.default.BLOCKING, function (blockingOptions) {
      if (!blockingOptions.hideForm && !options.adjustFormOnBrowserError) {
        // do nothing, user still can enter form inputs
        // can be useful when you are on i.E. seeflow's contact page and
        // still want to tick off the webcam option
      } else {
        container.disableForm(true);
      }
    }).on(_events2.default.PREVIEW_SHOWN, function () {
      container.validate(true);
    }).on(_events2.default.LOADED_META_DATA, function () {
      correctDimensions();
    }).on(_events2.default.ERROR, function (err) {
      if (err.removeDimensions && err.removeDimensions()) {
        removeDimensions();
      }
    });
  }

  function correctDimensions() {
    visualsElement.style.width = self.getRecorderWidth(true) + 'px';
    visualsElement.style.height = self.getRecorderHeight(true) + 'px';
  }

  function removeDimensions() {
    visualsElement.style.width = 'auto';
    visualsElement.style.height = 'auto';
  }

  function isRecordable() {
    return !self.isNotifying() && !replay.isShown() && !self.isCountingDown();
  }

  this.isCountingDown = function () {
    return recorderInsides.isCountingDown();
  };

  this.build = function () {
    visualsElement = container.querySelector('.' + options.selectors.visualsClass);

    if (!visualsElement) {
      visualsElement = (0, _hyperscript2.default)('div.' + options.selectors.visualsClass);

      var buttonsElement = container.querySelector('.' + options.selectors.buttonsClass);

      // make sure it's placed before the buttons
      if (buttonsElement) {
        container.insertBefore(visualsElement, buttonsElement);
      } else {
        container.appendChild(visualsElement);
      }
    }

    visualsElement.classList.add('visuals');
    (0, _hidden2.default)(visualsElement, true);

    correctDimensions();

    !built && initEvents();
    buildChildren();

    // needed for replay handling and container.isParentElementOf()
    self.parentNode = visualsElement.parentNode;

    built = true;
  };

  this.querySelector = function (selector) {
    return visualsElement && visualsElement.querySelector(selector);
  };

  this.appendChild = function (child) {
    visualsElement && visualsElement.appendChild(child);
  };

  this.removeChild = function (child) {
    visualsElement.removeChild(child);
  };

  this.reset = function () {
    this.endWaiting();
    recorder.reset();
  };

  this.beginWaiting = function () {
    container.beginWaiting();
  };

  this.endWaiting = function () {
    container.endWaiting();
  };

  this.stop = function (params) {
    recorder.stop(params);
    recorderInsides.hidePause();
  };

  this.back = function (cb) {
    replay.hide();
    notifier.hide();
    recorder.back(cb);
  };

  this.recordAgain = function () {
    this.back(function () {
      self.once(_events2.default.USER_MEDIA_READY, function () {
        self.record();
      });
    });
  };

  this.unload = function (e) {
    try {
      recorder.unload(e);
      recorderInsides.unload(e);
      replay.unload(e);

      built = false;
    } catch (exc) {
      this.emit(_events2.default.ERROR, exc);
    }
  };

  this.isNotifying = function () {
    return notifier.isVisible();
  };

  this.isReplayShown = function () {
    return replay.isShown();
  };

  this.pause = function (params) {
    recorder.pause(params);
    recorderInsides.showPause();
  };

  this.resume = function () {
    if (recorderInsides.isCountingDown()) {
      recorderInsides.resumeCountdown();
    } else {
      recorder.resume();
    }

    recorderInsides.hidePause();
  };

  this.pauseOrResume = function () {
    if (isRecordable.call(this)) {
      if (this.isRecording()) {
        this.pause();
      } else if (recorder.isPaused()) {
        this.resume();
      } else if (recorder.isReady()) {
        this.record();
      }
    }
  };

  this.recordOrStop = function () {
    if (isRecordable()) {
      if (this.isRecording()) {
        this.stop();
      } else if (recorder.isReady()) {
        this.record();
      }
    }
  };

  this.record = function () {
    if (options.video.countdown) {
      this.emit(_events2.default.COUNTDOWN);
      recorderInsides.startCountdown(recorder.record.bind(recorder));
    } else {
      recorder.record();
    }
  };

  this.getRecorder = function () {
    return recorder;
  };

  this.getReplay = function () {
    return replay;
  };

  this.validate = function () {
    return recorder.validate() && this.isReplayShown();
  };

  this.getRecordingStats = function () {
    return recorder.getRecordingStats();
  };

  this.getAudioSampleRate = function () {
    return recorder.getAudioSampleRate();
  };

  this.isPaused = function () {
    return recorder.isPaused();
  };

  this.error = function (err) {
    notifier.error(err);
  };

  this.hide = function () {
    if (visualsElement) {
      (0, _hidden2.default)(visualsElement, true);
      this.emit(_events2.default.HIDE);
    }
  };

  this.isHidden = function () {
    if (!built) {
      return true;
    } else if (visualsElement) {
      return (0, _hidden2.default)(visualsElement);
    }
  };

  this.showVisuals = function () {
    visualsElement && (0, _hidden2.default)(visualsElement, false);
  };

  this.show = function () {
    !this.isReplayShown() && recorder.build();
    this.showVisuals();
  };

  this.showReplayOnly = function () {
    !this.isReplayShown() && replay.show();

    this.show();
    recorder.hide();
    notifier.hide();
  };

  this.isRecorderUnloaded = function () {
    return recorder.isUnloaded();
  };

  this.isConnecting = function () {
    return recorder.isConnecting();
  };

  this.getRecorderWidth = function (responsive) {
    return recorder.getRecorderWidth(responsive);
  };

  this.getRecorderHeight = function (responsive) {
    return recorder.getRecorderHeight(responsive);
  };

  this.limitWidth = function (width) {
    return container.limitWidth(width, options);
  };

  this.limitHeight = function (height) {
    return container.limitHeight(height);
  };

  this.calculateWidth = function (options) {
    return container.calculateWidth(options);
  };

  this.calculateHeight = function (options) {
    return container.calculateHeight(options);
  };

  this.getReplay = function () {
    return replay;
  };

  this.getBoundingClientRect = function () {
    // fixes https://github.com/binarykitchen/videomail-client/issues/126
    return visualsElement && visualsElement.getBoundingClientRect();
  };

  this.checkTimer = function (intervalSum) {
    recorderInsides.checkTimer(intervalSum);
  };

  this.isNotifierBuilt = function () {
    return notifier && notifier.isBuilt();
  };

  this.isReplayShown = replay.isShown.bind(replay);
  this.hideReplay = replay.hide.bind(replay);
  this.hideRecorder = recorder.hide.bind(recorder);
  this.isRecording = recorder.isRecording.bind(recorder);
  this.isUserMediaLoaded = recorder.isUserMediaLoaded.bind(recorder);
  this.isConnected = recorder.isConnected.bind(recorder);
};

_util2.default.inherits(Visuals, _eventEmitter2.default);

exports.default = Visuals;

},{"./../events":87,"./../util/eventEmitter":94,"./visuals/inside/recorderInsides":110,"./visuals/notifier":111,"./visuals/recorder":112,"./visuals/replay":113,"hidden":30,"hyperscript":32,"util":79}],106:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (visuals, options) {
  var self = this;

  var countdownElement;
  var intervalId;
  var countdown;
  var paused;

  function fire(cb) {
    self.unload();
    self.hide();

    // keep all callbacks async
    setTimeout(function () {
      cb();
    }, 0);
  }

  function countBackward(cb) {
    if (!paused) {
      options.debug('Countdown', countdown);
      countdown--;

      if (countdown < 1) {
        fire(cb);
      } else {
        countdownElement.innerHTML = countdown;
      }
    }
  }

  this.start = function (cb) {
    countdownElement.innerHTML = countdown = options.video.countdown;

    this.show();

    intervalId = setInterval(countBackward.bind(this, cb), 950);
  };

  this.pause = function () {
    paused = true;
  };

  this.resume = function () {
    paused = false;
  };

  this.build = function () {
    countdownElement = visuals.querySelector('.countdown');

    if (!countdownElement) {
      countdownElement = (0, _hyperscript2.default)('p.countdown');

      this.hide();

      visuals.appendChild(countdownElement);
    } else {
      this.hide();
    }
  };

  this.show = function () {
    (0, _hidden2.default)(countdownElement, false);
  };

  this.isCountingDown = function () {
    return !!intervalId;
  };

  this.unload = function () {
    clearInterval(intervalId);
    paused = false;
    intervalId = null;
  };

  this.hide = function () {
    (0, _hidden2.default)(countdownElement, true);
    this.unload();
  };
};

var _hyperscript = _dereq_('hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _hidden = _dereq_('hidden');

var _hidden2 = _interopRequireDefault(_hidden);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"hidden":30,"hyperscript":32}],107:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (visuals, options) {
  if (!options.text.pausedHeader) {
    throw _videomailError2.default.create('Paused header cannot be empty', options);
  }

  var pausedBlockElement;
  var pausedHeaderElement;
  var pausedHintElement;

  this.build = function () {
    pausedBlockElement = visuals.querySelector('.paused');
    pausedHeaderElement = visuals.querySelector('.pausedHeader');
    pausedHintElement = visuals.querySelector('.pausedHint');

    if (!pausedHeaderElement) {
      pausedBlockElement = (0, _hyperscript2.default)('div.paused');
      pausedHeaderElement = (0, _hyperscript2.default)('p.pausedHeader');
      pausedHintElement = (0, _hyperscript2.default)('p.pausedHint');

      this.hide();

      pausedHeaderElement.innerHTML = options.text.pausedHeader;
      pausedHintElement.innerHTML = options.text.pausedHint;

      pausedBlockElement.appendChild(pausedHeaderElement);
      pausedBlockElement.appendChild(pausedHintElement);

      visuals.appendChild(pausedBlockElement);
    } else {
      this.hide();

      pausedHeaderElement.innerHTML = options.text.pausedHeader;
      pausedHintElement.innerHTML = options.text.pausedHint;
    }
  };

  this.hide = function () {
    (0, _hidden2.default)(pausedBlockElement, true);
  };

  this.show = function () {
    (0, _hidden2.default)(pausedBlockElement, false);
  };
};

var _hyperscript = _dereq_('hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _hidden = _dereq_('hidden');

var _hidden2 = _interopRequireDefault(_hidden);

var _videomailError = _dereq_('./../../../../util/videomailError');

var _videomailError2 = _interopRequireDefault(_videomailError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./../../../../util/videomailError":99,"hidden":30,"hyperscript":32}],108:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (visuals) {
  var recordNoteElement;

  this.build = function () {
    recordNoteElement = visuals.querySelector('.recordNote');

    if (!recordNoteElement) {
      recordNoteElement = (0, _hyperscript2.default)('p.recordNote');

      this.hide();

      visuals.appendChild(recordNoteElement);
    } else {
      this.hide();
    }
  };

  this.stop = function () {
    this.hide();
    recordNoteElement.classList.remove('near');
    recordNoteElement.classList.remove('nigh');
  };

  this.setNear = function () {
    recordNoteElement.classList.add('near');
  };

  this.setNigh = function () {
    recordNoteElement.classList.add('nigh');
  };

  this.hide = function () {
    (0, _hidden2.default)(recordNoteElement, true);
  };

  this.show = function () {
    (0, _hidden2.default)(recordNoteElement, false);
  };
};

var _hyperscript = _dereq_('hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _hidden = _dereq_('hidden');

var _hidden2 = _interopRequireDefault(_hidden);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"hidden":30,"hyperscript":32}],109:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (visuals, recordNote, options) {
  var recordTimerElement;

  var nearComputed = false;
  var endNighComputed = false;

  var started;
  var countdown;

  function pad(n) {
    return n < 10 ? '0' + n : n;
  }

  function thresholdReached(secs, threshold) {
    return secs >= options.video.limitSeconds * threshold;
  }

  function isNear(secs) {
    if (!nearComputed && thresholdReached(secs, 0.6)) {
      nearComputed = true;
      return true;
    } else {
      return false;
    }
  }

  function endIsNigh(secs) {
    if (!endNighComputed && thresholdReached(secs, 0.8)) {
      endNighComputed = true;
      return true;
    } else {
      return false;
    }
  }

  function setNear() {
    recordTimerElement.classList.add('near');
  }

  function setNigh() {
    recordTimerElement.classList.add('nigh');
  }

  this.check = function (opts) {
    var newCountdown = getStartSeconds() - Math.floor(opts.intervalSum / 1e3);

    // performance optimisation (another reason we need react here!)
    if (newCountdown !== countdown) {
      countdown = newCountdown;
      update();
      countdown < 1 && visuals.stop(true);
    }
  };

  function update() {
    var mins = parseInt(countdown / 60, 10);
    var secs = countdown - mins * 60;

    if (!nearComputed || !endNighComputed) {
      var remainingSeconds = options.video.limitSeconds - countdown;

      if (isNear(remainingSeconds)) {
        recordNote.setNear();
        setNear();

        options.debug('End is near, ' + countdown + ' seconds to go');
      } else if (endIsNigh(remainingSeconds)) {
        recordNote.setNigh();
        setNigh();

        options.debug('End is nigh, ' + countdown + ' seconds to go');
      }
    }

    recordTimerElement.innerHTML = mins + ':' + pad(secs);
  }

  function hide() {
    (0, _hidden2.default)(recordTimerElement, true);
  }

  function show() {
    recordTimerElement.classList.remove('near');
    recordTimerElement.classList.remove('nigh');

    (0, _hidden2.default)(recordTimerElement, false);
  }

  function getSecondsRecorded() {
    return getStartSeconds() - countdown;
  }

  function getStartSeconds() {
    return options.video.limitSeconds;
  }

  this.start = function () {
    countdown = getStartSeconds();
    nearComputed = endNighComputed = false;
    started = true;

    update();

    show();
  };

  this.pause = function () {
    recordNote.hide();
  };

  this.resume = function () {
    recordNote.show();
  };

  function isStopped() {
    return countdown === null;
  }

  this.stop = function () {
    if (!isStopped() && started) {
      options.debug('Stopping record timer. Was recording for about ~' + getSecondsRecorded() + ' seconds.');

      hide();
      recordNote.stop();

      countdown = null;
      started = false;
    }
  };

  this.build = function () {
    recordTimerElement = visuals.querySelector('.recordTimer');

    if (!recordTimerElement) {
      recordTimerElement = (0, _hyperscript2.default)('p.recordTimer');

      hide();

      visuals.appendChild(recordTimerElement);
    } else {
      hide();
    }
  };
};

var _hyperscript = _dereq_('hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _hidden = _dereq_('hidden');

var _hidden2 = _interopRequireDefault(_hidden);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"hidden":30,"hyperscript":32}],110:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _util = _dereq_('util');

var _util2 = _interopRequireDefault(_util);

var _events = _dereq_('./../../../events');

var _events2 = _interopRequireDefault(_events);

var _eventEmitter = _dereq_('./../../../util/eventEmitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _countdown = _dereq_('./recorder/countdown');

var _countdown2 = _interopRequireDefault(_countdown);

var _pausedNote = _dereq_('./recorder/pausedNote');

var _pausedNote2 = _interopRequireDefault(_pausedNote);

var _recordNote = _dereq_('./recorder/recordNote');

var _recordNote2 = _interopRequireDefault(_recordNote);

var _recordTimer = _dereq_('./recorder/recordTimer');

var _recordTimer2 = _interopRequireDefault(_recordTimer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RecorderInsides = function RecorderInsides(visuals, options) {
  _eventEmitter2.default.call(this, options, 'RecorderInsides');

  var self = this;
  var debug = options.debug;

  var recordNote = new _recordNote2.default(visuals);
  var recordTimer = new _recordTimer2.default(visuals, recordNote, options);

  var countdown;
  var pausedNote;
  var built;

  if (options.video.countdown) {
    countdown = new _countdown2.default(visuals, options);
  }

  if (options.enablePause) {
    pausedNote = new _pausedNote2.default(visuals, options);
  }

  function startRecording() {
    recordTimer.start();
  }

  function resumeRecording() {
    recordTimer.resume();
  }

  function stopRecording() {
    recordTimer.stop();
  }

  function pauseRecording() {
    if (self.isCountingDown()) {
      countdown.pause();
    } else {
      recordTimer.pause();
    }
  }

  function onResetting() {
    self.hidePause();
    self.hideCountdown();
    recordTimer.stop();
  }

  function initEvents() {
    self.on(_events2.default.RECORDING, function () {
      startRecording();
    }).on(_events2.default.RESUMING, function () {
      resumeRecording();
    }).on(_events2.default.STOPPING, function () {
      stopRecording();
    }).on(_events2.default.PAUSED, function () {
      pauseRecording();
    }).on(_events2.default.RESETTING, onResetting).on(_events2.default.HIDE, function () {
      self.hideCountdown();
    });
  }

  this.build = function () {
    debug('RecorderInsides: build()');

    countdown && countdown.build();
    pausedNote && pausedNote.build();

    recordNote.build();
    recordTimer.build();

    !built && initEvents();

    built = true;
  };

  this.unload = function () {
    countdown && countdown.unload();

    built = false;
  };

  this.showPause = function () {
    pausedNote && pausedNote.show();
  };

  this.hidePause = function () {
    pausedNote && pausedNote.hide();
  };

  this.hideCountdown = function () {
    countdown && countdown.hide();
  };

  this.startCountdown = function (cb) {
    countdown && countdown.start(cb);
  };

  this.resumeCountdown = function () {
    countdown && countdown.resume();
  };

  this.isCountingDown = function () {
    return countdown && countdown.isCountingDown();
  };

  this.checkTimer = function (intervalSum) {
    recordTimer.check(intervalSum);
  };
};

_util2.default.inherits(RecorderInsides, _eventEmitter2.default);

exports.default = RecorderInsides;

},{"./../../../events":87,"./../../../util/eventEmitter":94,"./recorder/countdown":106,"./recorder/pausedNote":107,"./recorder/recordNote":108,"./recorder/recordTimer":109,"util":79}],111:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _util = _dereq_('util');

var _util2 = _interopRequireDefault(_util);

var _hyperscript = _dereq_('hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _hidden = _dereq_('hidden');

var _hidden2 = _interopRequireDefault(_hidden);

var _eventEmitter = _dereq_('./../../util/eventEmitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _events = _dereq_('./../../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Notifier = function Notifier(visuals, options) {
  _eventEmitter2.default.call(this, options, 'Notifier');

  var self = this;
  var debug = options && options.debug;

  var notifyElement;
  var messageElement;
  var explanationElement;
  var entertainTimeoutId;
  var entertaining;
  var built;

  function onStopping(limitReached) {
    var lead = '';

    visuals.beginWaiting();

    if (limitReached) {
      debug('Limit reached');
      lead += options.text.limitReached + '.<br/>';
    }

    lead += options.text.sending + ' ';

    self.notify(lead, null, {
      stillWait: true,
      entertain: options.notifier.entertain
    });
  }

  function onConnecting() {
    self.notify('Connecting ');
  }

  function onLoadingUserMedia() {
    self.notify('Loading webcam ');
  }

  function onProgress(frameProgress, sampleProgress) {
    var overallProgress;

    if (options.isAudioEnabled()) {
      overallProgress = 'Video: ' + frameProgress;

      if (sampleProgress) {
        overallProgress += ', Audio: ' + sampleProgress;
      }
    } else {
      overallProgress = frameProgress;
    }

    self.setExplanation(overallProgress);
  }

  function onBeginVideoEncoding() {
    visuals.beginWaiting();

    var lead = options.text.encoding + ' ';

    self.notify(lead, null, {
      stillWait: true,
      entertain: options.notifier.entertain
    });

    hideExplanation();
  }

  function initEvents() {
    debug('Notifier: initEvents()');

    self.on(_events2.default.CONNECTING, function () {
      onConnecting();
    }).on(_events2.default.LOADING_USER_MEDIA, function () {
      onLoadingUserMedia();
    }).on(_events2.default.USER_MEDIA_READY, function () {
      self.hide();
    }).on(_events2.default.LOADED_META_DATA, function () {
      correctDimensions();
    }).on(_events2.default.PREVIEW, function () {
      self.hide();
    }).on(_events2.default.STOPPING, function (limitReached) {
      onStopping(limitReached);
    }).on(_events2.default.PROGRESS, function (frameProgress, sampleProgress) {
      onProgress(frameProgress, sampleProgress);
    }).on(_events2.default.BEGIN_VIDEO_ENCODING, function () {
      onBeginVideoEncoding();
    });
  }

  function correctDimensions() {
    notifyElement.style.width = visuals.getRecorderWidth(true) + 'px';
    notifyElement.style.height = visuals.getRecorderHeight(true) + 'px';
  }

  function show() {
    notifyElement && (0, _hidden2.default)(notifyElement, false);
  }

  function runEntertainment() {
    if (options.notifier.entertain) {
      if (!entertaining) {
        var randomBackgroundClass = Math.floor(Math.random() * options.notifier.entertainLimit + 1);

        notifyElement.className = 'notifier entertain ' + options.notifier.entertainClass + randomBackgroundClass;

        entertainTimeoutId = setTimeout(runEntertainment, options.notifier.entertainInterval);
        entertaining = true;
      }
    } else {
      cancelEntertainment();
    }
  }

  function cancelEntertainment() {
    if (notifyElement) {
      notifyElement.classList.remove('entertain');
    }

    clearTimeout(entertainTimeoutId);
    entertainTimeoutId = null;
    entertaining = false;
  }

  function setMessage(message, messageOptions) {
    var problem = messageOptions.problem ? messageOptions.problem : false;

    if (messageElement) {
      messageElement.innerHTML = (problem ? '&#x2639; ' : '') + message;
    } else {
      options.logger.warn('Unable to show following because messageElement is empty:', message);
    }
  }

  this.error = function (err) {
    var message = err.message ? err.message.toString() : err.toString();
    var explanation = err.explanation ? err.explanation.toString() : null;

    if (!message) {
      options.debug('Weird empty message generated for error', err);
    }

    self.notify(message, explanation, {
      blocking: true,
      problem: true,
      hideForm: err.hideForm && err.hideForm(),
      classList: err.getClassList && err.getClassList(),
      removeDimensions: err.removeDimensions && err.removeDimensions()
    });
  };

  this.setExplanation = function (explanation) {
    if (!explanationElement) {
      explanationElement = (0, _hyperscript2.default)('p');

      if (notifyElement) {
        notifyElement.appendChild(explanationElement);
      } else {
        options.logger.warn('Unable to show explanation because notifyElement is empty:', explanation);
      }
    }

    explanationElement.innerHTML = explanation;

    (0, _hidden2.default)(explanationElement, false);
  };

  this.build = function () {
    options.debug('Notifier: build()');

    notifyElement = visuals.querySelector('.notifier');

    if (!notifyElement) {
      notifyElement = (0, _hyperscript2.default)('.notifier'); // defaults to div

      this.hide();

      visuals.appendChild(notifyElement);
    } else {
      this.hide();
    }

    !built && initEvents();

    built = true;
  };

  function hideExplanation() {
    if (explanationElement) {
      explanationElement.innerHTML = null;
      (0, _hidden2.default)(explanationElement, true);
    }
  }

  this.hide = function () {
    cancelEntertainment();

    if (notifyElement) {
      (0, _hidden2.default)(notifyElement, true);
      notifyElement.classList.remove('blocking');
    }

    if (messageElement) {
      messageElement.innerHTML = null;
    }

    hideExplanation();
  };

  this.isVisible = function () {
    if (!built) {
      return false;
    } else {
      return notifyElement && !(0, _hidden2.default)(notifyElement);
    }
  };

  this.isBuilt = function () {
    return built;
  };

  this.notify = function (message, explanation, notifyOptions) {
    options.debug('Notifier: notify()');

    if (!notifyOptions) {
      notifyOptions = {};
    }

    var stillWait = notifyOptions.stillWait ? notifyOptions.stillWait : false;
    var entertain = notifyOptions.entertain ? notifyOptions.entertain : false;
    var blocking = notifyOptions.blocking ? notifyOptions.blocking : false;
    var hideForm = notifyOptions.hideForm ? notifyOptions.hideForm : false;
    var classList = notifyOptions.classList ? notifyOptions.classList : false;
    var removeDimensions = notifyOptions.removeDimensions ? notifyOptions.removeDimensions : false;

    if (!messageElement && notifyElement) {
      messageElement = (0, _hyperscript2.default)('h2');

      if (explanationElement) {
        notifyElement.insertBefore(messageElement, explanationElement);
      } else {
        notifyElement.appendChild(messageElement);
      }
    }

    if (notifyElement) {
      // reset
      if (!entertain) {
        notifyElement.className = 'notifier';
      }

      if (classList) {
        classList.forEach(function (className) {
          notifyElement.classList.add(className);
        });
      }

      if (removeDimensions) {
        notifyElement.style.width = 'auto';
        notifyElement.style.height = 'auto';
      }
    }

    if (blocking) {
      notifyElement && notifyElement.classList.add('blocking');
      this.emit(_events2.default.BLOCKING, { hideForm: hideForm });
    } else {
      this.emit(_events2.default.NOTIFYING);
    }

    visuals.hideReplay();
    visuals.hideRecorder();

    setMessage(message, notifyOptions);

    explanation && this.setExplanation(explanation);

    if (entertain) {
      runEntertainment();
    } else {
      cancelEntertainment();
    }

    // just as a safety in case if an error is thrown in the middle of the build process
    // and visuals aren't built/shown yet.
    visuals.showVisuals();

    show();

    !stillWait && visuals.endWaiting();
  };
};

_util2.default.inherits(Notifier, _eventEmitter2.default);

exports.default = Notifier;

},{"./../../events":87,"./../../util/eventEmitter":94,"hidden":30,"hyperscript":32,"util":79}],112:[function(_dereq_,module,exports){
(function (Buffer){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _websocketStream = _dereq_('websocket-stream');

var _websocketStream2 = _interopRequireDefault(_websocketStream);

var _canvasToBuffer = _dereq_('canvas-to-buffer');

var _canvasToBuffer2 = _interopRequireDefault(_canvasToBuffer);

var _util = _dereq_('util');

var _util2 = _interopRequireDefault(_util);

var _hyperscript = _dereq_('hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _hidden = _dereq_('hidden');

var _hidden2 = _interopRequireDefault(_hidden);

var _animitter = _dereq_('animitter');

var _animitter2 = _interopRequireDefault(_animitter);

var _userMedia = _dereq_('./userMedia');

var _userMedia2 = _interopRequireDefault(_userMedia);

var _events = _dereq_('./../../events');

var _events2 = _interopRequireDefault(_events);

var _constants = _dereq_('./../../constants');

var _constants2 = _interopRequireDefault(_constants);

var _eventEmitter = _dereq_('./../../util/eventEmitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _browser = _dereq_('./../../util/browser');

var _browser2 = _interopRequireDefault(_browser);

var _humanize = _dereq_('./../../util/humanize');

var _humanize2 = _interopRequireDefault(_humanize);

var _pretty = _dereq_('./../../util/pretty');

var _pretty2 = _interopRequireDefault(_pretty);

var _videomailError = _dereq_('./../../util/videomailError');

var _videomailError2 = _interopRequireDefault(_videomailError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// credits http://1lineart.kulaone.com/#/
var PIPE_SYMBOL = ',,`,,,,`, ';

var Recorder = function Recorder(visuals, replay, options) {
  _eventEmitter2.default.call(this, options, 'Recorder');

  // validate some options this class needs
  if (!options || !options.video || !options.video.fps) {
    throw _videomailError2.default.create('FPS must be defined', options);
  }

  var self = this;
  var browser = new _browser2.default(options);
  var debug = options.debug;

  var loop = null;

  var originalAnimationFrameObject;

  var samplesCount = 0;
  var framesCount = 0;

  var recordingStats = {};

  var confirmedFrameNumber = 0;
  var confirmedSampleNumber = 0;

  var recorderElement;
  var userMedia;

  var userMediaTimeout;
  var retryTimeout;

  var bytesSum;

  var frameProgress;
  var sampleProgress;

  var canvas;
  var ctx;

  var userMediaLoaded;
  var userMediaLoading;
  var submitting;
  var unloaded;
  var stopTime;
  var stream;
  var connecting;
  var connected;
  var blocking;
  var built;
  var key;
  var waitingTime;

  var pingInterval;

  var frame;

  var recordingBufferLength;
  var recordingBuffer;

  function writeStream(buffer, opts) {
    if (stream) {
      if (stream.destroyed) {
        self.emit(_events2.default.ERROR, _videomailError2.default.create('Already disconnected', 'Sorry, the connection to the server has been destroyed. Please reload. ' + 'Details of buffer: ' + buffer.toString(), options));
      } else {
        var onFlushedCallback = opts && opts.onFlushedCallback;

        try {
          stream.write(buffer, function () {
            onFlushedCallback && onFlushedCallback(opts);
          });
        } catch (exc) {
          self.emit(_events2.default.ERROR, _videomailError2.default.create('Failed writing to server', 'stream.write() failed because of ' + (0, _pretty2.default)(exc), options));
        }
      }
    }
  }

  function sendPings() {
    pingInterval = window.setInterval(function () {
      debug('Recorder: pinging...');
      writeStream(Buffer.from(''));
    }, options.timeouts.pingInterval);
  }

  function stopPings() {
    clearInterval(pingInterval);
  }

  function onAudioSample(audioSample) {
    samplesCount++;

    var audioBuffer = audioSample.toBuffer();

    // if (options.verbose) {
    //     debug(
    //         'Sample #' + samplesCount + ' (' + audioBuffer.length + ' bytes):'
    //     )
    // }

    writeStream(audioBuffer);
  }

  function show() {
    recorderElement && (0, _hidden2.default)(recorderElement, false);
  }

  function onUserMediaReady() {
    try {
      debug('Recorder: onUserMediaReady()');

      userMediaLoading = blocking = unloaded = submitting = false;
      userMediaLoaded = true;

      loop = createLoop();

      show();
      self.emit(_events2.default.USER_MEDIA_READY, { paused: self.isPaused() });
    } catch (exc) {
      self.emit(_events2.default.ERROR, exc);
    }
  }

  function clearRetryTimeout() {
    debug('Recorder: clearRetryTimeout()');

    retryTimeout && clearTimeout(retryTimeout);
    retryTimeout = null;
  }

  function clearUserMediaTimeout() {
    if (userMediaTimeout) {
      debug('Recorder: clearUserMediaTimeout()');

      userMediaTimeout && clearTimeout(userMediaTimeout);
      userMediaTimeout = null;
    }
  }

  function calculateFrameProgress() {
    return (confirmedFrameNumber / (framesCount || 1) * 100).toFixed(2) + '%';
  }

  function calculateSampleProgress() {
    return (confirmedSampleNumber / (samplesCount || 1) * 100).toFixed(2) + '%';
  }

  function updateOverallProgress() {
    // when progresses aren't initialized,
    // then do a first calculation to avoid `infinite` or `null` displays

    if (!frameProgress) {
      frameProgress = calculateFrameProgress();
    }

    if (!sampleProgress) {
      sampleProgress = calculateSampleProgress();
    }

    self.emit(_events2.default.PROGRESS, frameProgress, sampleProgress);
  }

  function updateFrameProgress(args) {
    confirmedFrameNumber = args.frame ? args.frame : confirmedFrameNumber;

    frameProgress = calculateFrameProgress();

    updateOverallProgress();
  }

  function updateSampleProgress(args) {
    confirmedSampleNumber = args.sample ? args.sample : confirmedSampleNumber;

    sampleProgress = calculateSampleProgress();

    updateOverallProgress();
  }

  function preview(args) {
    confirmedFrameNumber = confirmedSampleNumber = samplesCount = framesCount = 0;

    sampleProgress = frameProgress = null;

    key = args.key;

    if (args.mp4) {
      replay.setMp4Source(args.mp4 + _constants2.default.SITE_NAME_LABEL + '/' + options.siteName + '/videomail.mp4', true);
    }

    if (args.webm) {
      replay.setWebMSource(args.webm + _constants2.default.SITE_NAME_LABEL + '/' + options.siteName + '/videomail.webm', true);
    }

    self.hide();
    self.emit(_events2.default.PREVIEW, key, self.getRecorderWidth(true), self.getRecorderHeight(true));

    // keep it for recording stats
    waitingTime = Date.now() - stopTime;

    recordingStats.waitingTime = waitingTime;

    if (options.debug) {
      debug('While recording, %s have been transferred and waiting time was %s', _humanize2.default.filesize(bytesSum, 2), _humanize2.default.toTime(waitingTime));
    }
  }

  function initSocket(cb) {
    if (!connected) {
      connecting = true;

      debug('Recorder: initialising web socket to %s', options.socketUrl);

      self.emit(_events2.default.CONNECTING);

      // https://github.com/maxogden/websocket-stream#binary-sockets

      // we use query parameters here because we cannot set custom headers in web sockets,
      // see https://github.com/websockets/ws/issues/467

      var url2Connect = options.socketUrl + '?' + encodeURIComponent(_constants2.default.SITE_NAME_LABEL) + '=' + encodeURIComponent(options.siteName);

      try {
        // websocket options cannot be set on client side, only on server, see
        // https://github.com/maxogden/websocket-stream/issues/116#issuecomment-296421077
        stream = (0, _websocketStream2.default)(url2Connect, {
          perMessageDeflate: false,
          // see https://github.com/maxogden/websocket-stream/issues/117#issuecomment-298826011
          objectMode: true
        });
      } catch (exc) {
        connecting = connected = false;

        var err;

        if (typeof _websocketStream2.default === 'undefined') {
          err = _videomailError2.default.create('There is no websocket', 'Cause: ' + (0, _pretty2.default)(exc), options);
        } else {
          err = _videomailError2.default.create('Failed to connect to server', 'Please upgrade your browser. Your current version does not seem to support websockets.', options, {
            browserProblem: true
          });
        }

        self.emit(_events2.default.ERROR, err);
      }

      if (stream) {
        // // useful for debugging streams
        //
        // if (!stream.originalEmit) {
        //   stream.originalEmit = stream.emit
        // }
        //
        // stream.emit = function (type) {
        //   if (stream) {
        //     debug(PIPE_SYMBOL + 'Debugging stream event:', type)
        //     var args = Array.prototype.slice.call(arguments, 0)
        //     return stream.originalEmit.apply(stream, args)
        //   }
        // }

        stream.on('close', function (err) {
          debug(PIPE_SYMBOL + 'Stream has closed');

          connecting = connected = false;

          if (err) {
            self.emit(_events2.default.ERROR, err || 'Unhandled websocket error');
          } else {
            self.emit(_events2.default.DISCONNECTED);

            // prevents from https://github.com/binarykitchen/videomail.io/issues/297 happening
            cancelAnimationFrame();
          }
        });

        stream.on('connect', function () {
          debug(PIPE_SYMBOL + 'Stream *connect* event emitted');

          if (!connected) {
            connected = true;
            connecting = unloaded = false;

            self.emit(_events2.default.CONNECTED);

            debug('Going to ask for webcam permissons now ...');

            cb && cb();
          }
        });

        stream.on('data', function (data) {
          debug(PIPE_SYMBOL + 'Stream *data* event emitted');

          var command;

          try {
            command = JSON.parse(data.toString());
          } catch (exc) {
            debug('Failed to parse command:', exc);

            self.emit(_events2.default.ERROR, _videomailError2.default.create('Invalid server command',
            // toString() since https://github.com/binarykitchen/videomail.io/issues/288
            'Contact us asap. Bad commmand was ' + data.toString() + '. ', options));
          } finally {
            executeCommand.call(self, command);
          }
        });

        stream.on('error', function (err) {
          debug(PIPE_SYMBOL + 'Stream *error* event emitted');

          connecting = connected = false;
          self.emit(_events2.default.ERROR, err);
        });

        // just experimental

        stream.on('drain', function () {
          debug(PIPE_SYMBOL + 'Stream *drain* event emitted (should not happen!)');
        });

        stream.on('preend', function () {
          debug(PIPE_SYMBOL + 'Stream *preend* event emitted');
        });

        stream.on('end', function () {
          debug(PIPE_SYMBOL + 'Stream *end* event emitted');
        });

        stream.on('drain', function () {
          debug(PIPE_SYMBOL + 'Stream *drain* event emitted');
        });

        stream.on('pipe', function () {
          debug(PIPE_SYMBOL + 'Stream *pipe* event emitted');
        });

        stream.on('unpipe', function () {
          debug(PIPE_SYMBOL + 'Stream *unpipe* event emitted');
        });

        stream.on('resume', function () {
          debug(PIPE_SYMBOL + 'Stream *resume* event emitted');
        });

        stream.on('uncork', function () {
          debug(PIPE_SYMBOL + 'Stream *uncork* event emitted');
        });

        stream.on('readable', function () {
          debug(PIPE_SYMBOL + 'Stream *preend* event emitted');
        });

        stream.on('prefinish', function () {
          debug(PIPE_SYMBOL + 'Stream *preend* event emitted');
        });

        stream.on('finish', function () {
          debug(PIPE_SYMBOL + 'Stream *preend* event emitted');
        });
      }
    }
  }

  function showUserMedia() {
    // use connected flag to prevent this from happening
    // https://github.com/binarykitchen/videomail.io/issues/323
    return connected && (isNotifying() || !isHidden() || blocking);
  }

  function userMediaErrorCallback(err) {
    userMediaLoading = false;
    clearUserMediaTimeout();

    debug('Recorder: userMediaErrorCallback()', ', Webcam characteristics:', userMedia.getCharacteristics(), ', temporary err stack:', err && err.stack || '(undefined)');

    var errorListeners = self.listeners(_events2.default.ERROR);

    if (errorListeners.length) {
      if (err.name !== _videomailError2.default.MEDIA_DEVICE_NOT_SUPPORTED) {
        self.emit(_events2.default.ERROR, err);
      } else {
        // do not emit but retry since MEDIA_DEVICE_NOT_SUPPORTED can be a race condition
        debug('Recorder: ignore user media error', err);
      }

      // retry after a while
      retryTimeout = setTimeout(initSocket, options.timeouts.userMedia);
    } else {
      if (unloaded) {
        // can happen that container is unloaded but some user media related callbacks
        // are still in process. in that case ignore error.
        debug('Recorder: already unloaded. Not going to throw error', err);
      } else {
        debug('Recorder: no error listeners attached but throwing error', err);

        // weird situation, throw it instead of emitting since there are no error listeners
        throw _videomailError2.default.create(err, 'Unable to process this error since there are no error listeners anymore.', options);
      }
    }
  }

  function getUserMediaCallback(localStream) {
    debug('Recorder: getUserMediaCallback()');

    if (showUserMedia()) {
      try {
        clearUserMediaTimeout();

        userMedia.init(localStream, onUserMediaReady.bind(self), onAudioSample.bind(self), function (err) {
          self.emit(_events2.default.ERROR, err);
        });
      } catch (exc) {
        self.emit(_events2.default.ERROR, exc);
      }
    }
  }

  function loadGenuineUserMedia() {
    if (!navigator) {
      throw new Error('Navigator is missing!');
    }

    debug('Recorder: loadGenuineUserMedia()');

    self.emit(_events2.default.ASKING_WEBCAM_PERMISSION);

    // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      // prefer the front camera (if one is available) over the rear one
      var constraints = {
        video: {
          facingMode: 'user',
          frameRate: { ideal: options.video.fps }
        },
        audio: options.isAudioEnabled()
      };

      if (options.hasDefinedWidth()) {
        constraints.video.width = { ideal: options.video.width };
      }

      if (options.hasDefinedHeight()) {
        constraints.video.height = { ideal: options.video.height };
      }

      debug('Recorder: navigator.mediaDevices.getUserMedia()');

      navigator.mediaDevices.getUserMedia(constraints).then(getUserMediaCallback).catch(userMediaErrorCallback);
    } else {
      debug('Recorder: navigator.getUserMedia()');

      navigator.getUserMedia_({
        video: true,
        audio: options.isAudioEnabled()
      }, getUserMediaCallback, userMediaErrorCallback);
    }
  }

  function loadUserMedia() {
    if (userMediaLoaded) {
      debug('Recorder: skipping loadUserMedia() because it is already loaded');
      onUserMediaReady();
      return false;
    } else if (userMediaLoading) {
      debug('Recorder: skipping loadUserMedia() because it is already asking for permission');
      return false;
    }

    debug('Recorder: loadUserMedia()');

    self.emit(_events2.default.LOADING_USER_MEDIA);

    try {
      userMediaTimeout = setTimeout(function () {
        if (!self.isReady()) {
          self.emit(_events2.default.ERROR, browser.getNoAccessIssue());
        }
      }, options.timeouts.userMedia);

      userMediaLoading = true;

      loadGenuineUserMedia();
    } catch (exc) {
      debug('Recorder: failed to load genuine user media');

      userMediaLoading = false;

      var errorListeners = self.listeners(_events2.default.ERROR);

      if (errorListeners.length) {
        self.emit(_events2.default.ERROR, exc);
      } else {
        debug('Recorder: no error listeners attached but throwing exception', exc);
        throw exc; // throw it further
      }
    }
  }

  function executeCommand(command) {
    try {
      debug('Server commanded: %s', command.command, command.args ? ', ' + JSON.stringify(command.args) : '');

      switch (command.command) {
        case 'ready':
          if (!userMediaTimeout) {
            loadUserMedia();
          }
          break;
        case 'preview':
          preview(command.args);
          break;
        case 'error':
          this.emit(_events2.default.ERROR, _videomailError2.default.create('Oh no, server error!', command.args.err.toString() || '(No explanation given)', options));
          break;
        case 'confirmFrame':
          updateFrameProgress(command.args);
          break;
        case 'confirmSample':
          updateSampleProgress(command.args);
          break;
        case 'beginAudioEncoding':
          this.emit(_events2.default.BEGIN_AUDIO_ENCODING);
          break;
        case 'beginVideoEncoding':
          this.emit(_events2.default.BEGIN_VIDEO_ENCODING);
          break;
        default:
          this.emit(_events2.default.ERROR, 'Unknown server command: ' + command.command);
          break;
      }
    } catch (exc) {
      self.emit(_events2.default.ERROR, exc);
    }
  }

  function isNotifying() {
    return visuals.isNotifying();
  }

  function isHidden() {
    return !recorderElement || (0, _hidden2.default)(recorderElement);
  }

  function writeCommand(command, args, cb) {
    if (!cb && args && args.constructor === Function) {
      cb = args;
      args = null;
    }

    if (!connected) {
      debug('Reconnecting for the command', command, '');

      initSocket(function () {
        writeCommand(command, args);
        cb && cb();
      });
    } else if (stream) {
      debug('$ %s', command, args ? JSON.stringify(args) : '');

      var commandObj = {
        command: command,
        args: args

        // todo commented out because for some reasons server does not accept such a long
        // array of many log lines. to examine later.
        //
        // add some useful debug info to examine weird stuff like this one
        // UnprocessableError: Unable to encode a video with FPS near zero.
        // todo consider removing this later or have it for debug=1 only?
        //
        // if (options.logger && options.logger.getLines) {
        //   commandObj.logLines = options.logger.getLines()
        // }

      };writeStream(Buffer.from(JSON.stringify(commandObj)));

      if (cb) {
        // keep all callbacks async
        setTimeout(function () {
          cb();
        }, 0);
      }
    }
  }

  function disconnect() {
    if (connected) {
      debug('Recorder: disconnect()');

      if (userMedia) {
        // prevents https://github.com/binarykitchen/videomail-client/issues/114
        userMedia.unloadRemainingEventListeners();
      }

      if (submitting) {
        // server will disconnect socket automatically after submitting
        connecting = connected = false;
      } else if (stream) {
        // force to disconnect socket right now to clean temp files on server
        // event listeners will do the rest
        stream.end();
        stream = undefined;
      }
    }
  }

  function cancelAnimationFrame() {
    loop && loop.dispose();
  }

  function getIntervalSum() {
    return loop.getElapsedTime();
  }

  function getAvgInterval() {
    return getIntervalSum() / framesCount;
  }

  this.getRecordingStats = function () {
    return recordingStats;
  };

  this.getAudioSampleRate = function () {
    return userMedia.getAudioSampleRate();
  };

  this.stop = function (params) {
    debug('stop()', params);

    var limitReached = params.limitReached;

    this.emit(_events2.default.STOPPING, limitReached);

    loop.complete();

    stopTime = Date.now();

    recordingStats = {
      avgFps: loop.getFPS(),
      wantedFps: options.video.fps,
      avgInterval: getAvgInterval(),
      wantedInterval: 1e3 / options.video.fps,

      intervalSum: getIntervalSum(),
      framesCount: framesCount,
      videoType: replay.getVideoType()
    };

    if (options.isAudioEnabled()) {
      recordingStats.samplesCount = samplesCount;
      recordingStats.sampleRate = userMedia.getAudioSampleRate();
    }

    writeCommand('stop', recordingStats);

    // beware, resetting will set framesCount to zero, so leave this here
    this.reset();
  };

  this.back = function (cb) {
    this.emit(_events2.default.GOING_BACK);

    show();
    this.reset();

    writeCommand('back', cb);
  };

  function reInitialiseAudio() {
    debug('Recorder: reInitialiseAudio()');

    clearUserMediaTimeout();

    // important to free memory
    userMedia && userMedia.stop();

    userMediaLoaded = key = canvas = ctx = null;

    loadUserMedia();
  }

  this.unload = function (e) {
    if (!unloaded) {
      var cause;

      if (e) {
        cause = e.name || e.statusText || e.toString();
      }

      debug('Recorder: unload()' + (cause ? ', cause: ' + cause : ''));

      this.reset();

      clearUserMediaTimeout();

      disconnect();

      unloaded = true;

      built = false;
    }
  };

  this.reset = function () {
    // no need to reset when already unloaded
    if (!unloaded) {
      debug('Recorder: reset()');

      this.emit(_events2.default.RESETTING);

      cancelAnimationFrame();

      // important to free memory
      userMedia && userMedia.stop();

      replay.reset();

      userMediaLoaded = key = canvas = ctx = waitingTime = null;
    }
  };

  this.validate = function () {
    return connected && framesCount > 0 && canvas === null;
  };

  this.isReady = function () {
    return userMedia.isReady();
  };

  this.pause = function (params) {
    var e = params && params.event;

    if (e instanceof window.Event) {
      params.eventType = e.type;
    }

    debug('pause()', params);

    userMedia.pause();
    loop.stop();

    this.emit(_events2.default.PAUSED);

    sendPings();
  };

  this.isPaused = function () {
    return userMedia && userMedia.isPaused();
  };

  this.resume = function () {
    debug('Recorder: resume()');

    stopPings();

    this.emit(_events2.default.RESUMING);

    userMedia.resume();
    loop.start();
  };

  function onFlushed(opts) {
    var frameNumber = opts && opts.frameNumber;

    if (frameNumber === 1) {
      self.emit(_events2.default.FIRST_FRAME_SENT);
    }
  }

  function createLoop() {
    var newLoop = (0, _animitter2.default)({ fps: options.video.fps }, draw);

    // remember it first
    originalAnimationFrameObject = newLoop.getRequestAnimationFrameObject();

    return newLoop;
  }

  function draw(deltaTime, elapsedTime) {
    try {
      // ctx and stream might become null while unloading
      if (!self.isPaused() && stream && ctx) {
        if (framesCount === 0) {
          self.emit(_events2.default.SENDING_FIRST_FRAME);
        }

        framesCount++;

        ctx.drawImage(userMedia.getRawVisuals(), 0, 0, canvas.width, canvas.height);

        recordingBuffer = frame.toBuffer();
        recordingBufferLength = recordingBuffer.length;

        if (recordingBufferLength < 1) {
          throw _videomailError2.default.create('Failed to extract webcam data.', options);
        }

        bytesSum += recordingBufferLength;

        writeStream(recordingBuffer, {
          frameNumber: framesCount,
          onFlushedCallback: onFlushed
        });

        // if (options.verbose) {
        //   debug(
        //     'Frame #' + framesCount + ' (' + recordingBufferLength + ' bytes):',
        //     ' delta=' + deltaTime + 'ms, ' +
        //     ' elapsed=' + elapsedTime + 'ms'
        //   )
        // }

        visuals.checkTimer({ intervalSum: elapsedTime });
      }
    } catch (exc) {
      self.emit(_events2.default.ERROR, exc);
    }
  }

  this.record = function () {
    if (unloaded) {
      return false;
    }

    // reconnect when needed
    if (!connected) {
      debug('Recorder: reconnecting before recording ...');

      initSocket(function () {
        self.once(_events2.default.USER_MEDIA_READY, self.record);
      });

      return false;
    }

    try {
      canvas = userMedia.createCanvas();
    } catch (exc) {
      self.emit(_events2.default.ERROR, _videomailError2.default.create('Failed to create canvas.', exc, options));

      return false;
    }

    ctx = canvas.getContext('2d');

    if (!canvas.width) {
      self.emit(_events2.default.ERROR, _videomailError2.default.create('Canvas has an invalid width.', options));

      return false;
    }

    if (!canvas.height) {
      self.emit(_events2.default.ERROR, _videomailError2.default.create('Canvas has an invalid height.', options));

      return false;
    }

    bytesSum = 0;

    frame = new _canvasToBuffer2.default(canvas, options);

    debug('Recorder: record()');
    userMedia.record();

    self.emit(_events2.default.RECORDING, framesCount);

    loop.start();
  };

  function setAnimationFrameObject(newObj) {
    // must stop and then start to make it become effective, see
    // https://github.com/hapticdata/animitter/issues/5#issuecomment-292019168
    if (loop) {
      var isRecording = self.isRecording();

      loop.stop();
      loop.setRequestAnimationFrameObject(newObj);

      if (isRecording) {
        loop.start();
      }
    }
  }

  function restoreAnimationFrameObject() {
    debug('Recorder: restoreAnimationFrameObject()');

    setAnimationFrameObject(originalAnimationFrameObject);
  }

  function loopWithTimeouts() {
    debug('Recorder: loopWithTimeouts()');

    var wantedInterval = 1e3 / options.video.fps;

    var processingTime = 0;
    var start;

    function raf(fn) {
      return setTimeout(function () {
        start = Date.now();
        fn();
        processingTime = Date.now() - start;
      },
      // reducing wanted interval by respecting the time it takes to
      // compute internally since this is not multi-threaded like
      // requestAnimationFrame
      wantedInterval - processingTime);
    }

    function cancel(id) {
      clearTimeout(id);
    }

    setAnimationFrameObject({
      requestAnimationFrame: raf,
      cancelAnimationFrame: cancel
    });
  }

  function buildElement() {
    recorderElement = (0, _hyperscript2.default)('video.' + options.selectors.userMediaClass);
    visuals.appendChild(recorderElement);
  }

  function correctDimensions() {
    if (options.hasDefinedWidth()) {
      recorderElement.width = self.getRecorderWidth(true);
    }

    if (options.hasDefinedHeight()) {
      recorderElement.height = self.getRecorderHeight(true);
    }
  }

  function initEvents() {
    self.on(_events2.default.SUBMITTING, function () {
      submitting = true;
    }).on(_events2.default.SUBMITTED, function () {
      submitting = false;
      self.unload();
    }).on(_events2.default.BLOCKING, function () {
      blocking = true;
      clearUserMediaTimeout();
    }).on(_events2.default.HIDE, function () {
      self.hide();
    }).on(_events2.default.LOADED_META_DATA, function () {
      correctDimensions();
    }).on(_events2.default.DISABLING_AUDIO, function () {
      reInitialiseAudio();
    }).on(_events2.default.ENABLING_AUDIO, function () {
      reInitialiseAudio();
    }).on(_events2.default.INVISIBLE, function () {
      loopWithTimeouts();
    }).on(_events2.default.VISIBLE, function () {
      restoreAnimationFrameObject();
    });
  }

  this.build = function () {
    var err = browser.checkRecordingCapabilities();

    if (!err) {
      err = browser.checkBufferTypes();
    }

    if (err) {
      this.emit(_events2.default.ERROR, err);
    } else {
      recorderElement = visuals.querySelector('video.' + options.selectors.userMediaClass);

      if (!recorderElement) {
        buildElement();
      }

      correctDimensions();

      // prevent audio feedback, see
      // https://github.com/binarykitchen/videomail-client/issues/35
      recorderElement.muted = true;

      if (!userMedia) {
        userMedia = new _userMedia2.default(this, options);
      }

      show();

      if (!built) {
        initEvents();

        if (!connected) {
          initSocket();
        } else {
          loadUserMedia();
        }
      } else {
        loadUserMedia();
      }

      built = true;
    }
  };

  this.isPaused = function () {
    return userMedia && userMedia.isPaused() && !loop.isRunning();
  };

  this.isRecording = function () {
    // checking for stream.destroyed needed since
    // https://github.com/binarykitchen/videomail.io/issues/296
    return loop && loop.isRunning() && !this.isPaused() && !isNotifying() && stream && !stream.destroyed;
  };

  this.hide = function () {
    if (!isHidden()) {
      recorderElement && (0, _hidden2.default)(recorderElement, true);

      clearUserMediaTimeout();
      clearRetryTimeout();
    }
  };

  this.isUnloaded = function () {
    return unloaded;
  };

  // these two return the true dimensions of the webcam area.
  // needed because on mobiles they might be different.

  this.getRecorderWidth = function (responsive) {
    if (userMedia) {
      return userMedia.getRawWidth(responsive);
    } else if (responsive && options.hasDefinedWidth()) {
      return this.limitWidth(options.video.width);
    }
  };

  this.getRecorderHeight = function (responsive) {
    if (userMedia) {
      return userMedia.getRawHeight(responsive);
    } else if (responsive && options.hasDefinedHeight()) {
      return this.calculateHeight(responsive);
    }
  };

  function getRatio() {
    var ratio;

    if (userMedia) {
      var userMediaVideoWidth = userMedia.getVideoWidth();

      // avoid division by zero
      if (userMediaVideoWidth < 1) {
        ratio = 0;
      } else {
        ratio = userMedia.getVideoHeight() / userMediaVideoWidth;
      }
    } else {
      ratio = options.getRatio();
    }

    return ratio;
  }

  this.calculateWidth = function (responsive) {
    var videoHeight;

    if (userMedia) {
      videoHeight = userMedia.getVideoHeight();
    } else if (recorderElement) {
      videoHeight = recorderElement.videoHeight;
    }

    return visuals.calculateWidth({
      responsive: responsive,
      ratio: getRatio(),
      videoHeight: videoHeight
    });
  };

  this.calculateHeight = function (responsive) {
    var videoWidth;

    if (userMedia) {
      videoWidth = userMedia.getVideoWidth();
    } else if (recorderElement) {
      videoWidth = recorderElement.videoWidth;
    }

    return visuals.calculateHeight({
      responsive: responsive,
      ratio: getRatio(),
      videoWidth: videoWidth
    });
  };

  this.getRawVisualUserMedia = function () {
    return recorderElement;
  };

  this.isConnected = function () {
    return connected;
  };

  this.isConnecting = function () {
    return connecting;
  };

  this.limitWidth = function (width) {
    return visuals.limitWidth(width);
  };

  this.limitHeight = function (height) {
    return visuals.limitHeight(height);
  };

  this.isUserMediaLoaded = function () {
    return userMediaLoaded;
  };
};

_util2.default.inherits(Recorder, _eventEmitter2.default);

exports.default = Recorder;

}).call(this,_dereq_("buffer").Buffer)

},{"./../../constants":86,"./../../events":87,"./../../util/browser":92,"./../../util/eventEmitter":94,"./../../util/humanize":95,"./../../util/pretty":97,"./../../util/videomailError":99,"./userMedia":114,"animitter":2,"buffer":8,"canvas-to-buffer":9,"hidden":30,"hyperscript":32,"util":79,"websocket-stream":81}],113:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _util = _dereq_('util');

var _util2 = _interopRequireDefault(_util);

var _hyperscript = _dereq_('hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _hidden = _dereq_('hidden');

var _hidden2 = _interopRequireDefault(_hidden);

var _addEventlistenerWithOptions = _dereq_('add-eventlistener-with-options');

var _addEventlistenerWithOptions2 = _interopRequireDefault(_addEventlistenerWithOptions);

var _events = _dereq_('./../../events');

var _events2 = _interopRequireDefault(_events);

var _browser = _dereq_('./../../util/browser');

var _browser2 = _interopRequireDefault(_browser);

var _eventEmitter = _dereq_('./../../util/eventEmitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _videomailError = _dereq_('./../../util/videomailError');

var _videomailError2 = _interopRequireDefault(_videomailError);

var _iphoneInlineVideo = _dereq_('iphone-inline-video');

var _iphoneInlineVideo2 = _interopRequireDefault(_iphoneInlineVideo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Replay = function Replay(parentElement, options) {
  _eventEmitter2.default.call(this, options, 'Replay');

  var self = this;
  var browser = new _browser2.default(options);
  var debug = options.debug;

  var built;
  var replayElement;
  var videomail;

  function buildElement() {
    debug('Replay: buildElement()');

    replayElement = (0, _hyperscript2.default)('video.' + options.selectors.replayClass);

    if (!replayElement.setAttribute) {
      throw _videomailError2.default.create('Please upgrade browser', options);
    }

    parentElement.appendChild(replayElement);
  }

  function isStandalone() {
    return parentElement.constructor.name === 'HTMLDivElement';
  }

  function copyAttributes(newVideomail) {
    var attributeContainer;

    Object.keys(newVideomail).forEach(function (attribute) {
      attributeContainer = parentElement.querySelector('.' + attribute);

      if (attributeContainer) {
        attributeContainer.innerHTML = newVideomail[attribute];
      }
    });
  }

  function correctDimensions(options) {
    var width, height;

    if (videomail && videomail.playerWidth) {
      width = videomail.playerWidth;
    } else if (parentElement.calculateWidth) {
      width = parentElement.calculateWidth(options);
    }

    if (videomail && videomail.playerHeight) {
      height = videomail.playerHeight;
    } else if (parentElement.calculateHeight) {
      height = parentElement.calculateHeight(options);
    }

    if (width > 0) {
      replayElement.style.width = width + 'px';
    } else {
      replayElement.style.width = 'auto';
    }

    if (height > 0) {
      replayElement.style.height = height + 'px';
    } else {
      replayElement.style.height = 'auto';
    }
  }

  this.setVideomail = function (newVideomail) {
    videomail = newVideomail;

    if (videomail.webm) {
      this.setWebMSource(videomail.webm);
    }

    if (videomail.mp4) {
      this.setMp4Source(videomail.mp4);
    }

    if (videomail.poster) {
      replayElement.setAttribute('poster', videomail.poster);
    }

    copyAttributes(videomail);

    var hasAudio = videomail.recordingStats && videomail.recordingStats.sampleRate > 0;

    this.show(videomail.width, videomail.height, hasAudio);
  };

  this.show = function (recorderWidth, recorderHeight, hasAudio) {
    correctDimensions({
      responsive: true,
      // beware that recorderWidth and recorderHeight can be null sometimes
      videoWidth: recorderWidth || replayElement.videoWidth,
      videoHeight: recorderHeight || replayElement.videoHeight
    });

    (0, _hidden2.default)(replayElement, false);

    // parent element can be any object, be careful!
    if (parentElement) {
      if (parentElement.style) {
        (0, _hidden2.default)(parentElement, false);
      } else if (parentElement.show) {
        parentElement.show();
      }
    }

    if (hasAudio) {
      // https://github.com/binarykitchen/videomail-client/issues/115
      // do not set mute to false as this will mess up. just do not mention this attribute at all
      replayElement.setAttribute('volume', 1);
    } else if (!options.isAudioEnabled()) {
      replayElement.setAttribute('muted', true);
    }

    // this must be called after setting the sources and when becoming visible
    // see https://github.com/bfred-it/iphone-inline-video/issues/16
    _iphoneInlineVideo2.default && (0, _iphoneInlineVideo2.default)(replayElement, {
      iPad: true
    });

    // this forces to actually fetch the videos from the server
    replayElement.load();

    if (!videomail) {
      self.emit(_events2.default.PREVIEW_SHOWN);
    } else {
      self.emit(_events2.default.REPLAY_SHOWN);
    }
  };

  this.build = function () {
    debug('Replay: build()');

    replayElement = parentElement.querySelector('video.' + options.selectors.replayClass);

    if (!replayElement) {
      buildElement();
    }

    this.hide();

    replayElement.setAttribute('autoplay', true);
    replayElement.setAttribute('autostart', true);
    replayElement.setAttribute('autobuffer', true);
    replayElement.setAttribute('playsinline', true);
    replayElement.setAttribute('controls', 'controls');
    replayElement.setAttribute('preload', 'auto');
    replayElement.setAttribute('webkit-playsinline', 'webkit-playsinline');

    if (!built) {
      if (!isStandalone()) {
        this.on(_events2.default.PREVIEW, function (key, recorderWidth, recorderHeight) {
          self.show(recorderWidth, recorderHeight);
        });
      }

      // makes use of passive option automatically for better performance
      // https://www.npmjs.com/package/add-eventlistener-with-options
      (0, _addEventlistenerWithOptions2.default)(replayElement, 'touchstart', function (e) {
        e && e.preventDefault();

        if (this.paused) {
          play();
        } else {
          pause();
        }
      });

      replayElement.onclick = function (e) {
        e && e.preventDefault();

        if (this.paused) {
          play();
        } else {
          pause();
        }
      };
    }

    built = true;

    debug('Replay: built.');
  };

  this.unload = function () {
    built = false;
  };

  this.getVideoSource = function (type) {
    var sources = replayElement.getElementsByTagName('source');
    var l = sources.length;
    var videoType = 'video/' + type;

    var source;

    if (l) {
      var i;

      for (i = 0; i < l && !source; i++) {
        if (sources[i].getAttribute('type') === videoType) {
          source = sources[i];
        }
      }
    }

    return source;
  };

  function setVideoSource(type, src, bustCache) {
    var source = self.getVideoSource(type);

    if (src && bustCache) {
      src += '?' + Date.now();
    }

    if (!source) {
      if (src) {
        source = (0, _hyperscript2.default)('source', {
          src: src,
          type: 'video/' + type
        });

        replayElement.appendChild(source);
      }
    } else {
      if (src) {
        source.setAttribute('src', src);
      } else {
        replayElement.removeChild(source);
      }
    }
  }

  this.setMp4Source = function (src, bustCache) {
    setVideoSource('mp4', src, bustCache);
  };

  this.setWebMSource = function (src, bustCache) {
    setVideoSource('webm', src, bustCache);
  };

  this.getVideoType = function () {
    return browser.getVideoType(replayElement);
  };

  function pause(cb) {
    // avoids race condition, inspired by
    // http://stackoverflow.com/questions/36803176/how-to-prevent-the-play-request-was-interrupted-by-a-call-to-pause-error
    setTimeout(function () {
      try {
        replayElement.pause();
      } catch (exc) {
        // just ignore, see https://github.com/binarykitchen/videomail.io/issues/386
        options.logger.warn(exc);
      }

      cb && cb();
    }, 15);
  }

  function play() {
    if (replayElement && replayElement.play) {
      var p = replayElement.play();

      if (p && typeof Promise !== 'undefined' && p instanceof Promise) {
        p.catch(function (reason) {
          options.logger.warn('Caught pending play exception: %s', reason);
        });
      }
    }
  }

  this.reset = function (cb) {
    // pause video to make sure it won't consume any memory
    pause(function () {
      if (replayElement) {
        self.setMp4Source(null);
        self.setWebMSource(null);
      }

      cb && cb();
    });
  };

  this.hide = function () {
    debug('Replay: hide()');

    if (isStandalone()) {
      (0, _hidden2.default)(parentElement, true);
    } else {
      replayElement && (0, _hidden2.default)(replayElement, true);
    }
  };

  this.isShown = function () {
    return replayElement && !(0, _hidden2.default)(replayElement);
  };

  this.getParentElement = function () {
    return parentElement;
  };
};

_util2.default.inherits(Replay, _eventEmitter2.default);

exports.default = Replay;

},{"./../../events":87,"./../../util/browser":92,"./../../util/eventEmitter":94,"./../../util/videomailError":99,"add-eventlistener-with-options":1,"hidden":30,"hyperscript":32,"iphone-inline-video":38,"util":79}],114:[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (recorder, options) {
  _eventEmitter2.default.call(this, options, 'UserMedia');

  var rawVisualUserMedia = recorder && recorder.getRawVisualUserMedia();
  var self = this;

  var paused = false;
  var record = false;

  var audioRecorder;
  var currentVisualStream;

  function attachMediaStream(stream) {
    currentVisualStream = stream;

    if (typeof rawVisualUserMedia.srcObject !== 'undefined') {
      rawVisualUserMedia.srcObject = stream;
    } else if (typeof rawVisualUserMedia.src !== 'undefined') {
      var URL = window.URL || window.webkitURL;
      rawVisualUserMedia.src = URL.createObjectURL(stream) || stream;
    } else {
      throw _videomailError2.default.create('Error attaching stream to element.', 'Contact the developer about this', options);
    }
  }

  function setVisualStream(localMediaStream) {
    if (localMediaStream) {
      attachMediaStream(localMediaStream);
    } else {
      rawVisualUserMedia.removeAttribute('srcObject');
      rawVisualUserMedia.removeAttribute('src');

      currentVisualStream = null;
    }
  }

  function getVisualStream() {
    if (rawVisualUserMedia.mozSrcObject) {
      return rawVisualUserMedia.mozSrcObject;
    } else if (rawVisualUserMedia.srcObject) {
      return rawVisualUserMedia.srcObject;
    } else {
      return currentVisualStream;
    }
  }

  function hasEnded() {
    if (rawVisualUserMedia.ended) {
      return rawVisualUserMedia.ended;
    } else {
      var visualStream = getVisualStream();
      return visualStream && visualStream.ended;
    }
  }

  function hasInvalidDimensions() {
    if (rawVisualUserMedia.videoWidth && rawVisualUserMedia.videoWidth < 3 || rawVisualUserMedia.height && rawVisualUserMedia.height < 3) {
      return true;
    }
  }

  function getTracks(localMediaStream) {
    var tracks;

    if (localMediaStream && localMediaStream.getTracks) {
      tracks = localMediaStream.getTracks();
    }

    return tracks;
  }

  function getVideoTracks(localMediaStream) {
    var videoTracks;

    if (localMediaStream && localMediaStream.getVideoTracks) {
      videoTracks = localMediaStream.getVideoTracks();
    }

    return videoTracks;
  }

  function getFirstVideoTrack(localMediaStream) {
    var videoTracks = getVideoTracks(localMediaStream);
    var videoTrack;

    if (videoTracks && videoTracks[0]) {
      videoTrack = videoTracks[0];
    }

    return videoTrack;
  }

  function logEvent(event, params) {
    options.debug('UserMedia: ...', EVENT_ASCII, 'event', event, JSON.stringify(params));
  }

  function isPromise(anything) {
    return anything && typeof Promise !== 'undefined' && anything instanceof Promise;
  }

  function outputEvent(e) {
    logEvent(e.type, { readyState: rawVisualUserMedia.readyState });

    // remove myself
    rawVisualUserMedia.removeEventListener && rawVisualUserMedia.removeEventListener(e.type, outputEvent);
  }

  this.unloadRemainingEventListeners = function () {
    options.debug('UserMedia: unloadRemainingEventListeners()');

    _mediaEvents2.default.forEach(function (eventName) {
      rawVisualUserMedia.removeEventListener(eventName, outputEvent);
    });
  };

  this.init = function (localMediaStream, videoCallback, audioCallback, endedEarlyCallback) {
    this.stop(localMediaStream, true);

    var onPlayReached = false;
    var onLoadedMetaDataReached = false;
    var playingPromiseReached = false;

    if (options && options.isAudioEnabled()) {
      audioRecorder = audioRecorder || new _audioRecorder2.default(this, options);
    }

    function audioRecord() {
      self.removeListener(_events2.default.SENDING_FIRST_FRAME, audioRecord);
      audioRecorder && audioRecorder.record(audioCallback);
    }

    function unloadAllEventListeners() {
      options.debug('UserMedia: unloadAllEventListeners()');

      self.removeListener(_events2.default.SENDING_FIRST_FRAME, audioRecord);

      rawVisualUserMedia.removeEventListener && rawVisualUserMedia.removeEventListener('play', onPlay);

      rawVisualUserMedia.removeEventListener && rawVisualUserMedia.removeEventListener('loadedmetadata', onLoadedMetaData);

      self.unloadRemainingEventListeners();
    }

    function play() {
      // Resets the media element and restarts the media resource. Any pending events are discarded.
      // But do them in the next tick to ensure event queue is ready for a lot to come
      //
      // this also to have the abort and emptied event to be processed as early as possible before
      // all the other important events to come
      setTimeout(function () {
        try {
          // todo debug and fix that weird error
          // The play() request was interrupted by a new load request.
          options.debug('UserMedia: play()', 'media.readyState=' + rawVisualUserMedia.readyState, 'media.paused=' + rawVisualUserMedia.paused, 'media.ended=' + rawVisualUserMedia.ended, 'media.played=' + (0, _pretty2.default)(rawVisualUserMedia.played));

          rawVisualUserMedia.load();
          var p = rawVisualUserMedia.play();

          // using the promise here just experimental for now
          // and this to catch any weird errors early if possible
          if (isPromise(p)) {
            p.then(function () {
              if (!playingPromiseReached) {
                options.debug('UserMedia: ... play promise successful. Playing now.');
                playingPromiseReached = true;
              }
            }).catch(function (reason) {
              // promise can be interrupted, i.E. when switching tabs
              // and promise can get resumed when switching back to tab, hence
              // do not treat this like an error
              options.debug('UserMedia:', reason.toString());
            });
          }
        } catch (exc) {
          unloadAllEventListeners();
          endedEarlyCallback(exc);
        }
      }, 0);
    }

    function fireCallbacks() {
      var readyState = rawVisualUserMedia.readyState;

      // ready state, see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState
      options.debug('UserMedia: fireCallbacks(' + 'readyState=' + readyState + ', ' + 'onPlayReached=' + onPlayReached + ', ' + 'onLoadedMetaDataReached=' + onLoadedMetaDataReached + ')');

      if (onPlayReached && onLoadedMetaDataReached) {
        videoCallback();

        if (audioRecorder && audioCallback) {
          try {
            audioRecorder.init(localMediaStream);
            self.on(_events2.default.SENDING_FIRST_FRAME, audioRecord);
          } catch (exc) {
            unloadAllEventListeners();
            endedEarlyCallback(exc);
          }
        }
      }
    }

    function onPlay() {
      try {
        logEvent('play', {
          readyState: rawVisualUserMedia.readyState,
          audio: options.isAudioEnabled(),
          width: rawVisualUserMedia.width,
          height: rawVisualUserMedia.height,
          videoWidth: rawVisualUserMedia.videoWidth,
          videoHeight: rawVisualUserMedia.videoHeight
        });

        rawVisualUserMedia.removeEventListener && rawVisualUserMedia.removeEventListener('play', onPlay);

        if (hasEnded() || hasInvalidDimensions()) {
          endedEarlyCallback(_videomailError2.default.create('Already busy', 'Probably another browser window is using your webcam?', options));
        } else {
          onPlayReached = true;
          fireCallbacks();
        }
      } catch (exc) {
        unloadAllEventListeners();
        endedEarlyCallback(exc);
      }
    }

    // player modifications to perform that must wait until `loadedmetadata` has been triggered
    function onLoadedMetaData() {
      logEvent('loadedmetadata', {
        readyState: rawVisualUserMedia.readyState,
        width: rawVisualUserMedia.width,
        height: rawVisualUserMedia.height,
        videoWidth: rawVisualUserMedia.videoWidth,
        videoHeight: rawVisualUserMedia.videoHeight
      });

      rawVisualUserMedia.removeEventListener && rawVisualUserMedia.removeEventListener('loadedmetadata', onLoadedMetaData);

      if (!hasEnded() && !hasInvalidDimensions()) {
        self.emit(_events2.default.LOADED_META_DATA);

        // for android devices, we cannot call play() unless meta data has been loaded!
        play();

        onLoadedMetaDataReached = true;
        fireCallbacks();
      }
    }

    try {
      var videoTrack = getFirstVideoTrack(localMediaStream);

      if (!videoTrack) {
        options.debug('UserMedia: detected (but no video tracks exist');
      } else if (!videoTrack.enabled) {
        throw _videomailError2.default.create('Webcam is disabled', 'The video track seems to be disabled. Enable it in your system.', options);
      } else {
        var description;

        if (videoTrack.label && videoTrack.label.length > 0) {
          description = videoTrack.label;
        }

        description += ' with enabled=' + videoTrack.enabled;
        description += ', muted=' + videoTrack.muted;
        description += ', remote=' + videoTrack.remote;
        description += ', readyState=' + videoTrack.readyState;
        description += ', error=' + videoTrack.error;

        options.debug('UserMedia: ' + videoTrack.kind + ' detected.', description || '');
      }

      // very useful i think, so leave this and just use options.debug()
      var heavyDebugging = true;

      if (heavyDebugging) {
        _mediaEvents2.default.forEach(function (eventName) {
          rawVisualUserMedia.addEventListener(eventName, outputEvent, false);
        });
      }

      rawVisualUserMedia.addEventListener('loadedmetadata', onLoadedMetaData);
      rawVisualUserMedia.addEventListener('play', onPlay);

      // experimental, not sure if this is ever needed/called? since 2 apr 2017
      // An error occurs while fetching the media data.
      // Error can be an object with the code MEDIA_ERR_NETWORK or higher.
      // networkState equals either NETWORK_EMPTY or NETWORK_IDLE, depending on when the download was aborted.
      rawVisualUserMedia.addEventListener('error', function (err) {
        // ignore here, do nothing. IE/Edge emit that sometimes for unknown reasons.
        options.logger.warn(err);
      });

      setVisualStream(localMediaStream);

      play();
    } catch (exc) {
      self.emit(_events2.default.ERROR, exc);
    }
  };

  this.isReady = function () {
    return !!rawVisualUserMedia.src;
  };

  this.stop = function (visualStream, aboutToInitialize) {
    try {
      // do not stop "too much" when going to initialize anyway
      if (!aboutToInitialize) {
        if (!visualStream) {
          visualStream = getVisualStream();
        }

        var tracks = getTracks(visualStream);
        var newStopApiFound = false;

        if (tracks) {
          tracks.forEach(function (track) {
            if (track.stop) {
              newStopApiFound = true;
              track.stop();
            }
          });
        }

        // will probably become obsolete in one year (after june 2017)
        !newStopApiFound && visualStream && visualStream.stop && visualStream.stop();

        setVisualStream(null);

        audioRecorder && audioRecorder.stop();

        audioRecorder = null;
      }

      paused = record = false;
    } catch (exc) {
      self.emit(_events2.default.ERROR, exc);
    }
  };

  this.createCanvas = function () {
    return (0, _hyperscript2.default)('canvas', {
      width: this.getRawWidth(true),
      height: this.getRawHeight(true)
    });
  };

  this.getVideoHeight = function () {
    return rawVisualUserMedia.videoHeight;
  };

  this.getVideoWidth = function () {
    return rawVisualUserMedia.videoWidth;
  };

  this.getRawWidth = function (responsive) {
    var rawWidth = this.getVideoWidth();
    var widthDefined = options.hasDefinedWidth();

    if (widthDefined || options.hasDefinedHeight()) {
      if (!responsive && widthDefined) {
        rawWidth = options.video.width;
      } else {
        rawWidth = recorder.calculateWidth(responsive);
      }
    }

    if (responsive) {
      rawWidth = recorder.limitWidth(rawWidth);
    }

    return rawWidth;
  };

  this.getRawHeight = function (responsive) {
    var rawHeight;

    if (options.hasDefinedDimension()) {
      rawHeight = recorder.calculateHeight(responsive);

      if (rawHeight < 1) {
        throw _videomailError2.default.create('Bad dimensions', 'Calculated raw height cannot be less than 1!', options);
      }
    } else {
      rawHeight = this.getVideoHeight();

      if (rawHeight < 1) {
        throw _videomailError2.default.create('Bad dimensions', 'Raw video height from DOM element cannot be less than 1!', options);
      }
    }

    if (responsive) {
      rawHeight = recorder.limitHeight(rawHeight);
    }

    return rawHeight;
  };

  this.getRawVisuals = function () {
    return rawVisualUserMedia;
  };

  this.pause = function () {
    paused = true;
  };

  this.isPaused = function () {
    return paused;
  };

  this.resume = function () {
    paused = false;
  };

  this.record = function () {
    record = true;
  };

  this.isRecording = function () {
    return record;
  };

  this.getAudioSampleRate = function () {
    if (audioRecorder) {
      return audioRecorder.getSampleRate();
    } else {
      return -1;
    }
  };

  this.getCharacteristics = function () {
    return {
      audioSampleRate: this.getAudioSampleRate(),
      muted: rawVisualUserMedia && rawVisualUserMedia.muted,
      width: rawVisualUserMedia && rawVisualUserMedia.width,
      height: rawVisualUserMedia && rawVisualUserMedia.height,
      videoWidth: rawVisualUserMedia && rawVisualUserMedia.videoWidth,
      videoHeight: rawVisualUserMedia && rawVisualUserMedia.videoHeight
    };
  };
};

var _hyperscript = _dereq_('hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _audioRecorder = _dereq_('./../../util/audioRecorder');

var _audioRecorder2 = _interopRequireDefault(_audioRecorder);

var _videomailError = _dereq_('./../../util/videomailError');

var _videomailError2 = _interopRequireDefault(_videomailError);

var _eventEmitter = _dereq_('./../../util/eventEmitter');

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _mediaEvents = _dereq_('./../../util/mediaEvents');

var _mediaEvents2 = _interopRequireDefault(_mediaEvents);

var _pretty = _dereq_('./../../util/pretty');

var _pretty2 = _interopRequireDefault(_pretty);

var _events = _dereq_('./../../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EVENT_ASCII = '|O|';

},{"./../../events":87,"./../../util/audioRecorder":91,"./../../util/eventEmitter":94,"./../../util/mediaEvents":96,"./../../util/pretty":97,"./../../util/videomailError":99,"hyperscript":32}],"videomail-client":[function(_dereq_,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _standardize = _dereq_('./util/standardize');

var _standardize2 = _interopRequireDefault(_standardize);

var _client = _dereq_('./client');

var _client2 = _interopRequireDefault(_client);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!navigator) {
  throw new Error('Navigator is missing!');
} else {
  // Ensures Videomail functionality is not broken on exotic browsers with shims.
  //
  // UMD (Universal Module Definition), inspired by https://github.com/es-shims/es5-shim
  ;(function (navigator) {
    (0, _standardize2.default)(window, navigator);
  })(navigator);
}

exports.default = _client2.default;

// also add that so that we can require() it the normal ES5 way

module.exports = _client2.default;

},{"./client":85,"./util/standardize":98}]},{},["videomail-client"])("videomail-client")
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYWRkLWV2ZW50bGlzdGVuZXItd2l0aC1vcHRpb25zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FuaW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hdWRpby1zYW1wbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXNwbGl0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXRvLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGFzcy1saXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzbGlzdC5qcy9jbGFzc0xpc3QuanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29udGFpbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZS1lcnJvci9jcmVhdGUtZXJyb3IuanMiLCJub2RlX21vZHVsZXMvZGVmaW5lZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZXNwb3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZG9jdW1lbnQtdmlzaWJpbGl0eS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kb2N1bWVudC12aXNpYmlsaXR5L2tleXMuanMiLCJub2RlX21vZHVsZXMvZHVwbGV4aWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VsZW1lbnQtY2xvc2VzdC9lbGVtZW50LWNsb3Nlc3QuanMiLCJub2RlX21vZHVsZXMvZW5kLW9mLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2ZpbGVzaXplL2xpYi9maWxlc2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9nZXQtZm9ybS1kYXRhL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZXZhbC9ldmVudC5qcyIsIm5vZGVfbW9kdWxlcy9nZXZhbC9zb3VyY2UuanMiLCJub2RlX21vZHVsZXMvZ2xvYmFsL2RvY3VtZW50LmpzIiwibm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvaGlkZGVuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h1bWFuaXplLWR1cmF0aW9uL2h1bWFuaXplLWR1cmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyc2NyaXB0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5kZXhvZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2luc2VydC1jc3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW50ZXJ2YWxvbWV0ZXIvZGlzdC9pbnRlcnZhbG9tZXRlci5jb21tb24tanMuanMiLCJub2RlX21vZHVsZXMvaXBob25lLWlubGluZS12aWRlby9kaXN0L2lwaG9uZS1pbmxpbmUtdmlkZW8uY29tbW9uLWpzLmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1maW5pdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcG93ZXItb2YtdHdvL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXR5cGVkYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9rZXltaXJyb3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVyZ2UtcmVjdXJzaXZlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9udW1iZXItaXMtaW50ZWdlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9udW1iZXItaXMtbmFuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29uY2Uvb25jZS5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYWYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkeXN0YXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZHlzdGF0ZS9yZWFkeXN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlcXVlc3QtZnJhbWUvZGlzdC9yZXF1ZXN0LWZyYW1lLmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1zaGlmdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvY2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2lzLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LWJhc2UuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVzcG9uc2UtYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9zaG91bGQtcmV0cnkuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvdHlwZWRhcnJheS10by1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdWEtcGFyc2VyLWpzL3NyYy91YS1wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy92YWxpZGF0ZS5pby1mbG9hdDMyYXJyYXkvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYnNvY2tldC1zdHJlYW0vc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3dlYnNvY2tldC1zdHJlYW0vd3MtZmFsbGJhY2suanMiLCJub2RlX21vZHVsZXMvd3JhcHB5L3dyYXBweS5qcyIsInBhY2thZ2UuanNvbiIsInNyYy9jbGllbnQuanMiLCJzcmMvY29uc3RhbnRzLmpzIiwic3JjL2V2ZW50cy5qcyIsInNyYy9vcHRpb25zLmpzIiwic3JjL3Jlc291cmNlLmpzIiwic3JjL3N0eWxlcy9jc3MvbWFpbi5taW4uY3NzLmpzIiwic3JjL3V0aWwvYXVkaW9SZWNvcmRlci5qcyIsInNyYy91dGlsL2Jyb3dzZXIuanMiLCJzcmMvdXRpbC9jb2xsZWN0TG9nZ2VyLmpzIiwic3JjL3V0aWwvZXZlbnRFbWl0dGVyLmpzIiwic3JjL3V0aWwvaHVtYW5pemUuanMiLCJzcmMvdXRpbC9tZWRpYUV2ZW50cy5qcyIsInNyYy91dGlsL3ByZXR0eS5qcyIsInNyYy91dGlsL3N0YW5kYXJkaXplLmpzIiwic3JjL3V0aWwvdmlkZW9tYWlsRXJyb3IuanMiLCJzcmMvd3JhcHBlcnMvYnV0dG9ucy5qcyIsInNyYy93cmFwcGVycy9jb250YWluZXIuanMiLCJzcmMvd3JhcHBlcnMvZGltZW5zaW9uLmpzIiwic3JjL3dyYXBwZXJzL2Zvcm0uanMiLCJzcmMvd3JhcHBlcnMvb3B0aW9uc1dyYXBwZXIuanMiLCJzcmMvd3JhcHBlcnMvdmlzdWFscy5qcyIsInNyYy93cmFwcGVycy92aXN1YWxzL2luc2lkZS9yZWNvcmRlci9jb3VudGRvd24uanMiLCJzcmMvd3JhcHBlcnMvdmlzdWFscy9pbnNpZGUvcmVjb3JkZXIvcGF1c2VkTm90ZS5qcyIsInNyYy93cmFwcGVycy92aXN1YWxzL2luc2lkZS9yZWNvcmRlci9yZWNvcmROb3RlLmpzIiwic3JjL3dyYXBwZXJzL3Zpc3VhbHMvaW5zaWRlL3JlY29yZGVyL3JlY29yZFRpbWVyLmpzIiwic3JjL3dyYXBwZXJzL3Zpc3VhbHMvaW5zaWRlL3JlY29yZGVySW5zaWRlcy5qcyIsInNyYy93cmFwcGVycy92aXN1YWxzL25vdGlmaWVyLmpzIiwic3JjL3dyYXBwZXJzL3Zpc3VhbHMvcmVjb3JkZXIuanMiLCJzcmMvd3JhcHBlcnMvdmlzdWFscy9yZXBsYXkuanMiLCJzcmMvd3JhcHBlcnMvdmlzdWFscy91c2VyTWVkaWEuanMiLCJzcmMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxcURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdnBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3I2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMva0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDemdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0dBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJ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LEdBRkQ7O0FBSUEsT0FBSyxNQUFMLEdBQWMsWUFBWTtBQUN4QixhQUFTLElBQVQ7QUFDRCxHQUZEOztBQUlBLE9BQUssV0FBTCxHQUFtQixZQUFZO0FBQzdCLFdBQU8sTUFBUDtBQUNELEdBRkQ7O0FBSUEsT0FBSyxrQkFBTCxHQUEwQixZQUFZO0FBQ3BDLFFBQUksYUFBSixFQUFtQjtBQUNqQixhQUFPLGNBQWMsYUFBZCxFQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBTyxDQUFDLENBQVI7QUFDRDtBQUNGLEdBTkQ7O0FBUUEsT0FBSyxrQkFBTCxHQUEwQixZQUFZO0FBQ3BDLFdBQU87QUFDTCx1QkFBaUIsS0FBSyxrQkFBTCxFQURaO0FBRUwsYUFBTyxzQkFBc0IsbUJBQW1CLEtBRjNDO0FBR0wsYUFBTyxzQkFBc0IsbUJBQW1CLEtBSDNDO0FBSUwsY0FBUSxzQkFBc0IsbUJBQW1CLE1BSjVDO0FBS0wsa0JBQVksc0JBQXNCLG1CQUFtQixVQUxoRDtBQU1MLG1CQUFhLHNCQUFzQixtQkFBbUI7QUFOakQsS0FBUDtBQVFELEdBVEQ7QUFVRCxDOztBQXRlRDs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTSxjQUFjLE9BQXBCOzs7Ozs7Ozs7QUNUQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJLENBQUMsU0FBTCxFQUFnQjtBQUNkLFFBQU0sSUFBSSxLQUFKLENBQVUsdUJBQVYsQ0FBTjtBQUNELENBRkQsTUFFTztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUUsV0FBVSxTQUFWLEVBQXFCO0FBQ3JCLCtCQUFZLE1BQVosRUFBb0IsU0FBcEI7QUFDRCxHQUZDLEVBRUEsU0FGQSxDQUFEO0FBR0Y7Ozs7QUFJRDs7QUFDQSxPQUFPLE9BQVAiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiYWRkLWV2ZW50bGlzdGVuZXItd2l0aC1vcHRpb25zXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImFkZC1ldmVudGxpc3RlbmVyLXdpdGgtb3B0aW9uc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gYWRkRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zO1xuXG5cdHZhciBfY2hlY2tTdXBwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXHRmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5cdC8qKlxuXHQgKiBBZGQgZXZlbnQgbGlzdGVuZXIgd2l0aCBhZGRpdGlvbmFsIG9wdGlvbnNcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0IC0gVGhlIEV2ZW50VGFyZ2V0IGVsZW1lbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgbGlzdGVuZXIgY2FsbGJhY2tcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBleHBsaWNpdGx5IHBhc3NlZCBmcm9tIGNhbGxlclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uTmFtZSAtIFRoZSBhZGRpdGlvYW5sIG9wdGlvbiB0byBhZGQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyIFxuXHQgKi9cblx0ZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zKHRhcmdldCwgbmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcblx0ICAgIHZhciBvcHRpb25OYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAncGFzc2l2ZSc7XG5cblx0ICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgdmFyIGxpc3RlbmVyT3B0aW9ucyA9IF9jaGVja1N1cHBvcnQuU3VwcG9ydE1hcFtvcHRpb25OYW1lXSA/IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgb3B0aW9uTmFtZSwgdHJ1ZSkpIDogb3B0aW9ucztcblx0ICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lciwgbGlzdGVuZXJPcHRpb25zKTtcblx0ICAgIH1cblx0fVxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5TdXBwb3J0TWFwID0gdW5kZWZpbmVkO1xuXG5cdHZhciBfT3B0aW9uc01hcDtcblxuXHR2YXIgX2NvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cblx0ZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuXHR2YXIgT3B0aW9uc01hcCA9IChfT3B0aW9uc01hcCA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09wdGlvbnNNYXAsIF9jb25zdGFudHMuUEFTU0lWRSwgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX09wdGlvbnNNYXAsIF9jb25zdGFudHMuQ0FQVFVSRSwgZmFsc2UpLCBfZGVmaW5lUHJvcGVydHkoX09wdGlvbnNNYXAsIF9jb25zdGFudHMuT05DRSwgZmFsc2UpLCBfT3B0aW9uc01hcCk7XG5cblx0dmFyIGdldE9wdGlvbnNNYXAgPSBmdW5jdGlvbiBnZXRPcHRpb25zTWFwKCkge1xuXHQgICAgT2JqZWN0LmtleXMoT3B0aW9uc01hcCkuZm9yRWFjaChmdW5jdGlvbiAoaywgaSkge1xuXHQgICAgICAgIE9wdGlvbnNNYXBba10gPSBjaGVja1N1cHBvcnRGb3JQcm9wZXJ0eShrKTtcblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gT3B0aW9uc01hcDtcblx0fTtcblxuXHRmdW5jdGlvbiBjaGVja1N1cHBvcnRGb3JQcm9wZXJ0eShwcm9wZXJ0eSkge1xuXHQgICAgaWYgKCEhT3B0aW9uc01hcFtwcm9wZXJ0eV0pIHtcblx0ICAgICAgICByZXR1cm4gT3B0aW9uc01hcFtwcm9wZXJ0eV07XG5cdCAgICB9XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIHByb3BlcnR5LCB7XG5cdCAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICAgICAgICAgICAgT3B0aW9uc01hcFtwcm9wZXJ0eV0gPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG51bGwsIG9wdHMpO1xuXHQgICAgICAgIHdpbmRvdy5yZW1vdmVMaXN0ZW5lcihcInRlc3RcIiwgbnVsbCk7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXG5cdCAgICByZXR1cm4gT3B0aW9uc01hcFtwcm9wZXJ0eV07XG5cdH1cblxuXHR2YXIgU3VwcG9ydE1hcCA9IGV4cG9ydHMuU3VwcG9ydE1hcCA9IGdldE9wdGlvbnNNYXAoKTtcblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0dmFyIFBBU1NJVkUgPSBleHBvcnRzLlBBU1NJVkUgPSAncGFzc2l2ZSc7XG5cdHZhciBDQVBUVVJFID0gZXhwb3J0cy5DQVBUVVJFID0gJ2NhcHR1cmUnO1xuXHR2YXIgT05DRSA9IGV4cG9ydHMuT05DRSA9ICdvbmNlJztcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuOyIsInZhciBFdmVudEVtaXR0ZXIgICAgICAgICAgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIsXG4gICAgaW5oZXJpdHMgICAgICAgICAgICAgID0gcmVxdWlyZSgnaW5oZXJpdHMnKSxcbiAgICByYWYgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdyYWYnKSxcbiAgICBtZXRob2RzO1xuXG5cbi8vdGhlIHNhbWUgYXMgb2ZmIHdpbmRvdyB1bmxlc3MgcG9seWZpbGxlZCBvciBpbiBub2RlXG52YXIgZGVmYXVsdFJBRk9iamVjdCA9IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IHJhZixcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZTogcmFmLmNhbmNlbFxufTtcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpeyByZXR1cm4gdHJ1ZTsgfVxuXG4vL21hbmFnZSBGUFMgaWYgPCA2MCwgZWxzZSByZXR1cm4gdHJ1ZTtcbmZ1bmN0aW9uIG1ha2VUaHJvdHRsZShmcHMpe1xuICAgIHZhciBkZWxheSA9IDEwMDAvZnBzO1xuICAgIHZhciBsYXN0VGltZSA9IERhdGUubm93KCk7XG5cblxuICAgIGlmKCBmcHM8PTAgfHwgZnBzID09PSBJbmZpbml0eSApe1xuICAgICAgICByZXR1cm4gcmV0dXJuVHJ1ZTtcbiAgICB9XG5cbiAgICAvL2lmIGFuIGZwcyB0aHJvdHRsZSBoYXMgYmVlbiBzZXQgdGhlbiB3ZSdsbCBhc3N1bWVcbiAgICAvL2l0IG5hdGl2ZWx5IHJ1bnMgYXQgNjBmcHMsXG4gICAgdmFyIGhhbGYgPSBNYXRoLmNlaWwoMTAwMCAvIDYwKSAvIDI7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgLy9pZiBhIGN1c3RvbSBmcHMgaXMgcmVxdWVzdGVkXG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAvL2lzIHRoaXMgZnJhbWUgd2l0aGluIDguNW1zIG9mIHRoZSB0YXJnZXQ/XG4gICAgICAgIC8vaWYgc28gdGhlbiBuZXh0IGZyYW1lIGlzIGdvbm5hIGJlIHRvbyBsYXRlXG4gICAgICAgIGlmKG5vdyAtIGxhc3RUaW1lIDwgZGVsYXkgLSBoYWxmKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0VGltZSA9IG5vdztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cblxuXG4vKipcbiAqIEFuaW1pdHRlciBwcm92aWRlcyBldmVudC1iYXNlZCBsb29wcyBmb3IgdGhlIGJyb3dzZXIgYW5kIG5vZGUsXG4gKiB1c2luZyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLmZwcz1JbmZpbml0eV0gdGhlIGZyYW1lcmF0ZSByZXF1ZXN0ZWQsIGRlZmF1bHRzIHRvIGFzIGZhc3QgYXMgaXQgY2FuICg2MGZwcyBvbiB3aW5kb3cpXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMuZGVsYXk9MF0gbWlsbGlzZWNvbmRzIGRlbGF5IGJldHdlZW4gaW52b2tpbmcgYHN0YXJ0YCBhbmQgaW5pdGlhbGl6aW5nIHRoZSBsb29wXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lT2JqZWN0PWdsb2JhbF0gdGhlIG9iamVjdCBvbiB3aGljaCB0byBmaW5kIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFuZCBgY2FuY2VsQW5pbWF0aW9uRnJhbWVgIG1ldGhvZHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdHMuZml4ZWREZWx0YT1mYWxzZV0gaWYgdHJ1ZSwgdGltZXN0YW1wcyB3aWxsIHByZXRlbmQgdG8gYmUgZXhlY3V0ZWQgYXQgZml4ZWQgaW50ZXJ2YWxzIGFsd2F5c1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEFuaW1pdHRlciggb3B0cyApe1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgdGhpcy5fX2RlbGF5ID0gb3B0cy5kZWxheSB8fCAwO1xuXG4gICAgLyoqIEBleHBvc2UgKi9cbiAgICB0aGlzLmZpeGVkRGVsdGEgPSAhIW9wdHMuZml4ZWREZWx0YTtcblxuICAgIC8qKiBAZXhwb3NlICovXG4gICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgICAvKiogQGV4cG9zZSAqL1xuICAgIHRoaXMuZGVsdGFUaW1lID0gMDtcbiAgICAvKiogQGV4cG9zZSAqL1xuICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5fX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLl9fY29tcGxldGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnNldEZQUyhvcHRzLmZwcyB8fCBJbmZpbml0eSk7XG4gICAgdGhpcy5zZXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVPYmplY3Qob3B0cy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVPYmplY3QgfHwgZGVmYXVsdFJBRk9iamVjdCk7XG59XG5cbmluaGVyaXRzKEFuaW1pdHRlciwgRXZlbnRFbWl0dGVyKTtcblxuZnVuY3Rpb24gb25TdGFydChzY29wZSl7XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIHJBRklEO1xuICAgIC8vZG9udCBsZXQgYSBzZWNvbmQgYW5pbWF0aW9uIHN0YXJ0IG9uIHRoZSBzYW1lIG9iamVjdFxuICAgIC8vdXNlICoub24oJ3VwZGF0ZScsZm4pKiBpbnN0ZWFkXG4gICAgaWYoc2NvcGUuX19ydW5uaW5nKXtcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cblxuICAgIGV4cG9ydHMucnVubmluZyArPSAxO1xuICAgIHNjb3BlLl9fcnVubmluZyA9IHRydWU7XG4gICAgc2NvcGUuX19sYXN0VGltZSA9IG5vdztcbiAgICBzY29wZS5kZWx0YVRpbWUgPSAwO1xuXG4gICAgLy9lbWl0ICoqc3RhcnQqKiBvbmNlIGF0IHRoZSBiZWdpbm5pbmdcbiAgICBzY29wZS5lbWl0KCdzdGFydCcsIHNjb3BlLmRlbHRhVGltZSwgMCwgc2NvcGUuZnJhbWVDb3VudCk7XG5cbiAgICB2YXIgbGFzdFJBRk9iamVjdCA9IHNjb3BlLnJlcXVlc3RBbmltYXRpb25GcmFtZU9iamVjdDtcblxuICAgIHZhciBkcmF3RnJhbWUgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZihsYXN0UkFGT2JqZWN0ICE9PSBzY29wZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVPYmplY3Qpe1xuICAgICAgICAgICAgLy9pZiB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lT2JqZWN0IHN3aXRjaGVkIGluLWJldHdlZW4sXG4gICAgICAgICAgICAvL3RoZW4gcmUtcmVxdWVzdCB3aXRoIHRoZSBuZXcgb25lIHRvIGVuc3VyZSBwcm9wZXIgdXBkYXRlIGV4ZWN1dGlvbiBjb250ZXh0XG4gICAgICAgICAgICAvL2kuZS4gVlJEaXNwbGF5I3N1Ym1pdEZyYW1lKCkgbWF5IG9ubHkgYmUgcmVxdWVzdGVkIHRocm91Z2ggVlJEaXNwbGF5I3JlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3RnJhbWUpXG4gICAgICAgICAgICBsYXN0UkFGT2JqZWN0ID0gc2NvcGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lT2JqZWN0O1xuICAgICAgICAgICAgc2NvcGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lT2JqZWN0LnJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3RnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKHNjb3BlLl9faXNSZWFkeUZvclVwZGF0ZSgpKXtcbiAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHNjb3BlLl9fcnVubmluZyl7XG4gICAgICAgICAgICByQUZJRCA9IHNjb3BlLnJlcXVlc3RBbmltYXRpb25GcmFtZU9iamVjdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhd0ZyYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjb3BlLnJlcXVlc3RBbmltYXRpb25GcmFtZU9iamVjdC5jYW5jZWxBbmltYXRpb25GcmFtZShyQUZJRCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2NvcGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lT2JqZWN0LnJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3RnJhbWUpO1xuXG4gICAgcmV0dXJuIHNjb3BlO1xufVxuXG5tZXRob2RzID0ge1xuICAgIC8vRXZlbnRFbWl0dGVyIEFsaWFzZXNcbiAgICBvZmYgICAgIDogRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcixcbiAgICB0cmlnZ2VyIDogRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0LFxuXG4gICAgLyoqXG4gICAgICogc3RvcHMgdGhlIGFuaW1hdGlvbiBhbmQgbWFya3MgaXQgYXMgY29tcGxldGVkXG4gICAgICogQGVtaXQgQW5pbWl0dGVyI2NvbXBsZXRlXG4gICAgICogQHJldHVybnMge0FuaW1pdHRlcn1cbiAgICAgKi9cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuX19jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbXBsZXRlJywgdGhpcy5mcmFtZUNvdW50LCB0aGlzLmRlbHRhVGltZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzdG9wcyB0aGUgYW5pbWF0aW9uIGFuZCByZW1vdmVzIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiBAZW1pdCBBbmltaXR0ZXIjc3RvcFxuICAgICAqIEByZXR1cm5zIHtBbmltaXR0ZXJ9XG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgbWlsbGlzZWNvbmRzIGJldHdlZW4gdGhlIGxhc3QgMiB1cGRhdGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0RGVsdGFUaW1lOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5kZWx0YVRpbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdG90YWwgbWlsbGlzZWNvbmRzIHRoYXQgdGhlIGFuaW1hdGlvbiBoYXMgcmFuLlxuICAgICAqIFRoaXMgaXMgdGhlIGN1bWxhdGl2ZSB2YWx1ZSBvZiB0aGUgZGVsdGFUaW1lIGJldHdlZW4gZnJhbWVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0RWxhcHNlZFRpbWU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmVsYXBzZWRUaW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGluc3RhbmNlcyBmcmFtZXMgcGVyIHNlY29uZCBhcyBjYWxjdWxhdGVkIGJ5IHRoZSBsYXN0IGRlbHRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0RlBTOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5kZWx0YVRpbWUgPiAwID8gMTAwMCAvIHRoaXMuZGVsdGFUaW1lIDogMDtcbiAgICAgICAgaWYodGhpcy5kZWx0YVRpbWUpe1xuICAgICAgICAgICAgcmV0dXJuIDEwMDAgLyB0aGlzLmRlbHRhVGltZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGV4cGxpY2l0IEZQUyBsaW1pdCBzZXQgdmlhIGBBbmltaXR0ZXIjc2V0RlBTKGZwcylgIG9yXG4gICAgICogdmlhIHRoZSBpbml0aWFsIGBvcHRpb25zLmZwc2AgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGVpdGhlciBhcyBzZXQgb3IgSW5maW5pdHlcbiAgICAgKi9cbiAgICBnZXRGUFNMaW1pdDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19mcHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgbnVtYmVyIG9mIGZyYW1lcyB0aGF0IGhhdmUgb2NjdXJyZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRGcmFtZUNvdW50OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFtZUNvdW50O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgb2JqZWN0IHByb3ZpZGluZyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICAgICAqIGFuZCBgY2FuY2VsQW5pbWF0aW9uRnJhbWVgIG1ldGhvZHNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0UmVxdWVzdEFuaW1hdGlvbkZyYW1lT2JqZWN0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVPYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGlzIHRoZSBhbmltYXRpb24gbG9vcCBhY3RpdmVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSdW5uaW5nOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fX3J1bm5pbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGlzIHRoZSBhbmltYXRpb24gbWFya2VkIGFzIGNvbXBsZXRlZFxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0NvbXBsZXRlZDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb21wbGV0ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlc2V0IHRoZSBhbmltYXRpb24gbG9vcCwgbWFya3MgYXMgaW5jb21wbGV0ZSxcbiAgICAgKiBsZWF2ZXMgbGlzdGVuZXJzIGludGFjdFxuICAgICAqXG4gICAgICogQGVtaXQgQW5pbWl0dGVyI3Jlc2V0XG4gICAgICogQHJldHVybiB7QW5pbWl0dGVyfVxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5fX2NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fbGFzdFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmRlbHRhVGltZSA9IDA7XG4gICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmZyYW1lQ291bnQgPSAwO1xuXG4gICAgICAgIHRoaXMuZW1pdCgncmVzZXQnLCAwLCAwLCB0aGlzLmZyYW1lQ291bnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBmcmFtZXJhdGUgZm9yIHRoZSBhbmltYXRpb24gbG9vcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZwc1xuICAgICAqIEByZXR1cm4ge0FuaW1pdHRlcn1cbiAgICAgKi9cbiAgICBzZXRGUFM6IGZ1bmN0aW9uKGZwcyl7XG4gICAgICAgIHRoaXMuX19mcHMgPSBmcHM7XG4gICAgICAgIHRoaXMuX19pc1JlYWR5Rm9yVXBkYXRlID0gbWFrZVRocm90dGxlKGZwcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIG9iamVjdCB0aGF0IHdpbGwgcHJvdmlkZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICAgICAqIGFuZCBgY2FuY2VsQW5pbWF0aW9uRnJhbWVgIG1ldGhvZHMgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBbmltaXR0ZXJ9XG4gICAgICovXG4gICAgc2V0UmVxdWVzdEFuaW1hdGlvbkZyYW1lT2JqZWN0OiBmdW5jdGlvbihvYmplY3Qpe1xuICAgICAgICBpZih0eXBlb2Ygb2JqZWN0LnJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqZWN0LmNhbmNlbEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb2JqZWN0IHByb3ZpZGUgdG8gYHNldFJlcXVlc3RBbmltYXRpb25GcmFtZU9iamVjdGBcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVPYmplY3QgPSBvYmplY3Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzdGFydCBhbiBhbmltYXRpb24gbG9vcFxuICAgICAqIEBlbWl0IEFuaW1pdHRlciNzdGFydFxuICAgICAqIEByZXR1cm4ge0FuaW1pdHRlcn1cbiAgICAgKi9cbiAgICBzdGFydDogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZih0aGlzLl9fZGVsYXkpe1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIG9uU3RhcnQoc2VsZik7XG4gICAgICAgICAgICB9LCB0aGlzLl9fZGVsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25TdGFydCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcHMgdGhlIGFuaW1hdGlvbiBsb29wLCBkb2VzIG5vdCBtYXJrIGFzIGNvbXBsZXRlZFxuICAgICAqXG4gICAgICogQGVtaXQgQW5pbWl0dGVyI3N0b3BcbiAgICAgKiBAcmV0dXJuIHtBbmltaXR0ZXJ9XG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIHRoaXMuX19ydW5uaW5nICl7XG4gICAgICAgICAgICB0aGlzLl9fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgZXhwb3J0cy5ydW5uaW5nIC09IDE7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnLCB0aGlzLmRlbHRhVGltZSwgdGhpcy5lbGFwc2VkVGltZSwgdGhpcy5mcmFtZUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBhbmltYXRpb24gbG9vcCBvbmNlXG4gICAgICpcbiAgICAgKiBAZW1pdCBBbmltaXR0ZXIjdXBkYXRlXG4gICAgICogQHJldHVybiB7QW5pbWl0dGVyfVxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5fX2xhc3RUaW1lID0gdGhpcy5fX2xhc3RUaW1lIHx8IG5vdztcbiAgICAgICAgdGhpcy5kZWx0YVRpbWUgPSAodGhpcy5maXhlZERlbHRhIHx8IGV4cG9ydHMuZ2xvYmFsRml4ZWREZWx0YSkgPyAxMDAwL01hdGgubWluKDYwLCB0aGlzLl9fZnBzKSA6IG5vdyAtIHRoaXMuX19sYXN0VGltZTtcbiAgICAgICAgdGhpcy5lbGFwc2VkVGltZSArPSB0aGlzLmRlbHRhVGltZTtcbiAgICAgICAgdGhpcy5fX2xhc3RUaW1lID0gbm93O1xuXG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5kZWx0YVRpbWUsIHRoaXMuZWxhcHNlZFRpbWUsIHRoaXMuZnJhbWVDb3VudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cblxuXG5mb3IodmFyIG1ldGhvZCBpbiBtZXRob2RzKXtcbiAgICBBbmltaXR0ZXIucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RzW21ldGhvZF07XG59XG5cblxuLyoqXG4gKiBjcmVhdGUgYW4gYW5pbWl0dGVyIGluc3RhbmNlLFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4oIGRlbHRhVGltZTpOdW1iZXIsIGVsYXBzZWRUaW1lOk51bWJlciwgZnJhbWVDb3VudDpOdW1iZXIgKVxuICogQHJldHVybnMge0FuaW1pdHRlcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQW5pbWl0dGVyKG9wdGlvbnMsIGZuKXtcblxuICAgIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKXtcbiAgICAgICAgZm4gPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9pbnN0YW5jZSA9IG5ldyBBbmltaXR0ZXIoIG9wdGlvbnMgKTtcblxuICAgIGlmKCBmbiApe1xuICAgICAgICBfaW5zdGFuY2Uub24oJ3VwZGF0ZScsIGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2luc3RhbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBjcmVhdGVBbmltaXR0ZXI7XG5cbi8qKlxuICogY3JlYXRlIGFuIGFuaW1pdHRlciBpbnN0YW5jZSxcbiAqIHdoZXJlIHRoZSBzY29wZSBpcyBib3VuZCBpbiBhbGwgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiggZGVsdGFUaW1lOk51bWJlciwgZWxhcHNlZFRpbWU6TnVtYmVyLCBmcmFtZUNvdW50Ok51bWJlciApXG4gKiBAcmV0dXJucyB7QW5pbWl0dGVyfVxuICovXG5leHBvcnRzLmJvdW5kID0gZnVuY3Rpb24ob3B0aW9ucywgZm4pe1xuXG4gICAgdmFyIGxvb3AgPSBjcmVhdGVBbmltaXR0ZXIob3B0aW9ucywgZm4pLFxuICAgICAgICBmdW5jdGlvbktleXMgPSBmdW5jdGlvbnMoQW5pbWl0dGVyLnByb3RvdHlwZSksXG4gICAgICAgIGhhc0JpbmQgPSAhIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLFxuICAgICAgICBmbktleTtcblxuICAgIGZvcih2YXIgaT0wOyBpPGZ1bmN0aW9uS2V5cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGZuS2V5ID0gZnVuY3Rpb25LZXlzW2ldO1xuICAgICAgICBsb29wW2ZuS2V5XSA9IGhhc0JpbmQgPyBsb29wW2ZuS2V5XS5iaW5kKGxvb3ApIDogYmluZChsb29wW2ZuS2V5XSwgbG9vcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvb3A7XG59O1xuXG5cbmV4cG9ydHMuQW5pbWl0dGVyID0gQW5pbWl0dGVyO1xuXG4vKipcbiAqIGlmIHRydWUsIGFsbCBgQW5pbWl0dGVyYCBpbnN0YW5jZXMgd2lsbCBiZWhhdmUgYXMgaWYgYG9wdGlvbnMuZml4ZWREZWx0YSA9IHRydWVgXG4gKi9cbmV4cG9ydHMuZ2xvYmFsRml4ZWREZWx0YSA9IGZhbHNlO1xuXG4vL2hlbHBmdWwgdG8gaW5oZXJpdCBmcm9tIHdoZW4gdXNpbmcgYnVuZGxlZFxuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG4vL2tlZXAgYSBnbG9iYWwgY291bnRlciBvZiBhbGwgbG9vcHMgcnVubmluZywgaGVscGZ1bCB0byB3YXRjaCBpbiBkZXYgdG9vbHNcbmV4cG9ydHMucnVubmluZyA9IDA7XG5cbmZ1bmN0aW9uIGJpbmQoZm4sIHNjb3BlKXtcbiAgICBpZih0eXBlb2YgZm4uYmluZCA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgIHJldHVybiBmbi5iaW5kKHNjb3BlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvbnMob2JqKXtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPGtleXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZih0eXBlb2Ygb2JqW2tleXNbaV1dID09PSAnZnVuY3Rpb24nKXtcbiAgICAgICAgICAgIGFyci5wdXNoKGtleXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5cblxuXG4vL3BvbHlmaWxsIERhdGUubm93IGZvciByZWFsLW9sZCBicm93c2Vyc1xuRGF0ZS5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufTtcbiIsInZhciB0b0J1ZmZlciAgICAgICA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktdG8tYnVmZmVyJyksXG4gICAgaXNGbG9hdDMyQXJyYXkgPSByZXF1aXJlKCd2YWxpZGF0ZS5pby1mbG9hdDMyYXJyYXknKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZsb2F0MzJBcnJheSkge1xuXG4gICAgaWYgKCFmbG9hdDMyQXJyYXkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQSBGbG9hdDMyQXJyYXkgcGFyYW1ldGVyIGlzIG1pc3NpbmcuJylcblxuICAgIGlmICghaXNGbG9hdDMyQXJyYXkoZmxvYXQzMkFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGFyYW1ldGVyIGlzIG5vdCBhIEZsb2F0MzJBcnJheS4nKVxuXG4gICAgdGhpcy50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBsICAgPSBmbG9hdDMyQXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgYXJyID0gbmV3IEludDE2QXJyYXkobCksXG4gICAgICAgICAgICBpXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gTWF0aC5taW4oMSwgZmxvYXQzMkFycmF5W2ldKSAqIDB4N0ZGRlxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvQnVmZmVyKGFycilcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycigobGVuICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiIiwiLyohXG4gKiBDcm9zcy1Ccm93c2VyIFNwbGl0IDEuMS4xXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDEyIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPlxuICogQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogRUNNQVNjcmlwdCBjb21wbGlhbnQsIHVuaWZvcm0gY3Jvc3MtYnJvd3NlciBzcGxpdCBtZXRob2RcbiAqL1xuXG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYSByZWdleCBvciBzdHJpbmcgc2VwYXJhdG9yLiBNYXRjaGVzIG9mIHRoZVxuICogc2VwYXJhdG9yIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBhcnJheS4gSG93ZXZlciwgaWYgYHNlcGFyYXRvcmAgaXMgYSByZWdleCB0aGF0IGNvbnRhaW5zXG4gKiBjYXB0dXJpbmcgZ3JvdXBzLCBiYWNrcmVmZXJlbmNlcyBhcmUgc3BsaWNlZCBpbnRvIHRoZSByZXN1bHQgZWFjaCB0aW1lIGBzZXBhcmF0b3JgIGlzIG1hdGNoZWQuXG4gKiBGaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWQgdG8gdGhlIG5hdGl2ZSBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgYW5kIGNhbiBiZSB1c2VkIHJlbGlhYmx5XG4gKiBjcm9zcy1icm93c2VyLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXQuXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHNlcGFyYXRvciBSZWdleCBvciBzdHJpbmcgdG8gdXNlIGZvciBzZXBhcmF0aW5nIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHQgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN1YnN0cmluZ3MuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzZVxuICogc3BsaXQoJ2EgYiBjIGQnLCAnICcpO1xuICogLy8gLT4gWydhJywgJ2InLCAnYycsICdkJ11cbiAqXG4gKiAvLyBXaXRoIGxpbWl0XG4gKiBzcGxpdCgnYSBiIGMgZCcsICcgJywgMik7XG4gKiAvLyAtPiBbJ2EnLCAnYiddXG4gKlxuICogLy8gQmFja3JlZmVyZW5jZXMgaW4gcmVzdWx0IGFycmF5XG4gKiBzcGxpdCgnLi53b3JkMSB3b3JkMi4uJywgLyhbYS16XSspKFxcZCspL2kpO1xuICogLy8gLT4gWycuLicsICd3b3JkJywgJzEnLCAnICcsICd3b3JkJywgJzInLCAnLi4nXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBzcGxpdCh1bmRlZikge1xuXG4gIHZhciBuYXRpdmVTcGxpdCA9IFN0cmluZy5wcm90b3R5cGUuc3BsaXQsXG4gICAgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYyhcIlwiKVsxXSA9PT0gdW5kZWYsXG4gICAgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICBzZWxmO1xuXG4gIHNlbGYgPSBmdW5jdGlvbihzdHIsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIGBuYXRpdmVTcGxpdGBcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09IFwiW29iamVjdCBSZWdFeHBdXCIpIHtcbiAgICAgIHJldHVybiBuYXRpdmVTcGxpdC5jYWxsKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArIChzZXBhcmF0b3IubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKSArIChzZXBhcmF0b3IuZXh0ZW5kZWQgPyBcInhcIiA6IFwiXCIpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyBcInlcIiA6IFwiXCIpLFxuICAgICAgLy8gRmlyZWZveCAzK1xuICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArIFwiZ1wiKSxcbiAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgc3RyICs9IFwiXCI7IC8vIFR5cGUtY29udmVydFxuICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBzZXBhcmF0b3Iuc291cmNlICsgXCIkKD8hXFxcXHMpXCIsIGZsYWdzKTtcbiAgICB9XG4gICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAqL1xuICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmID8gLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgbGltaXQgPj4+IDA7IC8vIFRvVWludDMyKGxpbWl0KVxuICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cikpIHtcbiAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB1bmRlZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdChcIlwiKSkge1xuICAgICAgICBvdXRwdXQucHVzaChcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59KSgpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcob2JqKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWVcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDApIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gTm9kZSAwLjEwIHN1cHBvcnRzIGBBcnJheUJ1ZmZlcmAgYnV0IGxhY2tzIGBBcnJheUJ1ZmZlci5pc1ZpZXdgXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyAob2JqKSB7XG4gIHJldHVybiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9iailcbn1cblxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsInZhciB0b0J1ZmZlciAgPSByZXF1aXJlKCd0eXBlZGFycmF5LXRvLWJ1ZmZlcicpLFxuICAgIGlzQnJvd3NlciA9IHR5cGVvZihkb2N1bWVudCkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZihkb2N1bWVudC5jcmVhdGVFbGVtZW50KSA9PT0gJ2Z1bmN0aW9uJyxcblxuICAgIC8vIGNhY2hlZCwgdXNlZCBvbmx5IG9uY2UgZm9yIGJyb3dzZXIgZW52aXJvbm1lbnRzXG4gICAgdmVyaWZpZWRJbWFnZVR5cGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYW52YXMsIG9wdGlvbnMpIHtcblxuICAgIHZhciBzZWxmID0gdGhpcywgcXVhbGl0eVxuXG4gICAgb3B0aW9ucyAgICAgICAgICAgICA9IG9wdGlvbnMgICAgICAgICAgICAgICA/IG9wdGlvbnMgOiAgICAgICAgICAgICB7fVxuICAgIG9wdGlvbnMuaW1hZ2UgICAgICAgPSBvcHRpb25zLmltYWdlICAgICAgICAgPyBvcHRpb25zLmltYWdlIDogICAgICAge31cbiAgICBvcHRpb25zLmltYWdlLnR5cGVzID0gb3B0aW9ucy5pbWFnZS50eXBlcyAgID8gb3B0aW9ucy5pbWFnZS50eXBlcyA6IFtdXG5cbiAgICAvLyB2YWxpZGF0ZSBzb21lIG9wdGlvbnMgdGhpcyBjbGFzcyBuZWVkc1xuICAgIGlmIChvcHRpb25zLmltYWdlLnR5cGVzLmxlbmd0aCA+IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgaW1hZ2UgdHlwZXMgYXJlIHNwZWNpZmllZCEnKVxuXG4gICAgZWxzZSBpZiAob3B0aW9ucy5pbWFnZS50eXBlcy5sZW5ndGggPCAxKSB7XG5cbiAgICAgICAgLy8gU2V0IGEgZGVmYXVsdCBpbWFnZSB0eXBlLCBqdXN0IHRvIGJlIHJvYnVzdFxuICAgICAgICBvcHRpb25zLmltYWdlLnR5cGVzID0gaXNCcm93c2VyID8gWyd3ZWJwJywgJ2pwZWcnXSA6IFsncG5nJ11cbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuaW1hZ2UucXVhbGl0eSlcbiAgICAgICAgb3B0aW9ucy5pbWFnZS5xdWFsaXR5ID0gLjUgLy8gZGVmYXVsdFxuXG4gICAgcXVhbGl0eSA9IHBhcnNlRmxvYXQob3B0aW9ucy5pbWFnZS5xdWFsaXR5KVxuXG4gICAgZnVuY3Rpb24gY29tcG9zZUltYWdlVHlwZShpbmRleCkge1xuICAgICAgICB2YXIgaW1hZ2VUeXBlXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaW1hZ2UudHlwZXNbaW5kZXhdKVxuICAgICAgICAgICAgaW1hZ2VUeXBlID0gJ2ltYWdlLycgKyBvcHRpb25zLmltYWdlLnR5cGVzW2luZGV4XVxuXG4gICAgICAgIHJldHVybiBpbWFnZVR5cGVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01hdGNoKHVyaSwgaW1hZ2VUeXBlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHVyaSAmJiB1cmkubWF0Y2goaW1hZ2VUeXBlKVxuXG4gICAgICAgIG1hdGNoICYmIG9wdGlvbnMuZGVidWcgJiYgb3B0aW9ucy5kZWJ1ZygnSW1hZ2UgdHlwZSAlcyB2ZXJpZmllZCcsIGltYWdlVHlwZSlcblxuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtYW5jZSB0d2Vhaywgd2UgZG8gbm90IG5lZWQgYSBiaWcgY2FudmFzIGZvciBmaW5kaW5nIG91dCB0aGUgc3VwcG9ydGVkIGltYWdlIHR5cGVcbiAgICBmdW5jdGlvbiBnZXRUZXN0Q2FudmFzKCkge1xuXG4gICAgICAgIHZhciB0ZXN0Q2FudmFzXG5cbiAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdGVzdENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgICAgICB0ZXN0Q2FudmFzLndpZHRoID0gdGVzdENhbnZhcy5oZWlnaHQgPSAxXG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgdGVzdENhbnZhcyA9IGNhbnZhc1xuXG4gICAgICAgIHJldHVybiB0ZXN0Q2FudmFzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FudmFzU3VwcG9ydHNJbWFnZVR5cGVBc3luYyhpbWFnZVR5cGUsIGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnZXRUZXN0Q2FudmFzKCkudG9EYXRhVVJMKGltYWdlVHlwZSwgZnVuY3Rpb24oZXJyLCB1cmkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICBjYihlcnIpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBpc01hdGNoKHVyaSwgaW1hZ2VUeXBlKSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgICAgICAgY2IobnVsbCwgZmFsc2UpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW52YXNTdXBwb3J0c0ltYWdlVHlwZVN5bmMoaW1hZ2VUeXBlKSB7XG4gICAgICAgIHZhciBtYXRjaFxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdGVzdENhbnZhcyA9IGdldFRlc3RDYW52YXMoKSxcbiAgICAgICAgICAgICAgICB1cmkgICAgICAgID0gdGVzdENhbnZhcy50b0RhdGFVUkwgJiYgdGVzdENhbnZhcy50b0RhdGFVUkwoaW1hZ2VUeXBlKVxuXG4gICAgICAgICAgICBtYXRjaCA9IGlzTWF0Y2godXJpLCBpbWFnZVR5cGUpXG4gICAgICAgIH0gY2F0Y2ggKGV4Yykge1xuXG4gICAgICAgICAgICAvLyBDYW4gaGFwcGVuIHdoZW4gaS5FLiBhIHNwaWRlciBpcyBjb21pbmcuIEp1c3QgYmUgcm9idXN0IGhlcmUgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgb3B0aW9ucy5kZWJ1ZyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5sb2dnZXIuZGVidWcoJ0ZhaWxlZCB0byBjYWxsIHRvRGF0YVVSTCgpIG9uIGNhbnZhcyBmb3IgaW1hZ2UgdHlwZSAlcycsIGltYWdlVHlwZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZlcmlmeUltYWdlVHlwZUFzeW5jKGltYWdlVHlwZSwgY2IpIHtcbiAgICAgICAgY2FudmFzU3VwcG9ydHNJbWFnZVR5cGVBc3luYyhpbWFnZVR5cGUsIGZ1bmN0aW9uKGVyciwgbWF0Y2gpIHtcbiAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgY2IoZXJyKVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGltYWdlVHlwZSlcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VUeXBlID0gY29tcG9zZUltYWdlVHlwZSgxKVxuXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc1N1cHBvcnRzSW1hZ2VUeXBlQXN5bmMoaW1hZ2VUeXBlLCBmdW5jdGlvbihlcnIsIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBtYXRjaCA/IGltYWdlVHlwZTogbnVsbClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmVyaWZ5SW1hZ2VUeXBlU3luYyhpbWFnZVR5cGUpIHtcbiAgICAgICAgaWYgKCFjYW52YXNTdXBwb3J0c0ltYWdlVHlwZVN5bmMoaW1hZ2VUeXBlKSkge1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbWFnZS50eXBlc1sxXSkge1xuICAgICAgICAgICAgICAgIGltYWdlVHlwZSA9IGNvbXBvc2VJbWFnZVR5cGUoMSlcblxuICAgICAgICAgICAgICAgIGlmICghY2FudmFzU3VwcG9ydHNJbWFnZVR5cGVTeW5jKGltYWdlVHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIGltYWdlVHlwZSA9IG51bGxcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGltYWdlVHlwZSA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgICFpbWFnZVR5cGUgJiYgb3B0aW9ucy5kZWJ1ZyAmJiBvcHRpb25zLmxvZ2dlci5kZWJ1ZygnVW5hYmxlIHRvIHZlcmlmeSBpbWFnZSB0eXBlJylcblxuICAgICAgICByZXR1cm4gaW1hZ2VUeXBlXG4gICAgfVxuXG4gICAgLy8gY2FsbGJhY2tzIGFyZSBuZWVkZWQgZm9yIHNlcnZlciBzaWRlIHRlc3RzXG4gICAgZnVuY3Rpb24gdmVyaWZ5SW1hZ2VUeXBlKGNiKSB7XG4gICAgICAgIHZhciBpbWFnZVR5cGUgPSBjb21wb3NlSW1hZ2VUeXBlKDApXG5cbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICB2ZXJpZnlJbWFnZVR5cGVBc3luYyhpbWFnZVR5cGUsIGNiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZlcmlmeUltYWdlVHlwZVN5bmMoaW1hZ2VUeXBlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhpcyBtZXRob2QgaXMgcHJvdmVuIHRvIGJlIGZhc3QsIHNlZVxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2RhdGEtdXJpLXRvLWJ1ZmZlci1wZXJmb3JtYW5jZS8zXG4gICAgZnVuY3Rpb24gdXJpVG9CdWZmZXIodXJpKSB7XG5cbiAgICAgICAgdmFyIHVyaSA9IHVyaS5zcGxpdCgnLCcpWzFdLFxuICAgICAgICAgICAgYnl0ZXNcblxuICAgICAgICAvLyBCZXdhcmUgdGhhdCB0aGUgYXRvYiBmdW5jdGlvbiBtaWdodCBiZSBhIHN0YXRpYyBvbmUgZm9yIHNlcnZlciBzaWRlIHRlc3RzXG4gICAgICAgIGlmICh0eXBlb2YoYXRvYikgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBieXRlcyA9IGF0b2IodXJpKVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Yoc2VsZi5jb25zdHJ1Y3Rvci5hdG9iKSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGJ5dGVzID0gc2VsZi5jb25zdHJ1Y3Rvci5hdG9iKHVyaSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdG9iIGZ1bmN0aW9uIGlzIG1pc3NpbmcnKVxuXG4gICAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShieXRlcy5sZW5ndGgpXG5cbiAgICAgICAgLy8gaHR0cDovL21yYWxlLnBoL2Jsb2cvMjAxNC8xMi8yNC9hcnJheS1sZW5ndGgtY2FjaGluZy5odG1sXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnl0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9CdWZmZXIoYXJyKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQnVmZmVyU3luYygpIHtcbiAgICAgICAgdmFyIGltYWdlVHlwZSA9IHNlbGYuZ2V0SW1hZ2VUeXBlKCksXG4gICAgICAgICAgICBidWZmZXJcblxuICAgICAgICBpZiAoaW1hZ2VUeXBlKSB7XG4gICAgICAgICAgICB2YXIgdXJpID0gY2FudmFzLnRvRGF0YVVSTChpbWFnZVR5cGUsIHF1YWxpdHkpXG4gICAgICAgICAgICBidWZmZXIgPSB1cmlUb0J1ZmZlcih1cmkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnVmZmVyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9CdWZmZXJBc3luYyhjYikge1xuICAgICAgICBzZWxmLmdldEltYWdlVHlwZShmdW5jdGlvbihlcnIsIGltYWdlVHlwZSkge1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICBjYihlcnIpXG4gICAgICAgICAgICBlbHNlIGlmICghaW1hZ2VUeXBlKVxuICAgICAgICAgICAgICAgIGNiKClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYW52YXMudG9EYXRhVVJMKGltYWdlVHlwZSwgZnVuY3Rpb24oZXJyLCB1cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgdXJpVG9CdWZmZXIodXJpKSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMudG9CdWZmZXIgPSBmdW5jdGlvbihjYikge1xuICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICB0b0J1ZmZlckFzeW5jKGNiKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdG9CdWZmZXJTeW5jKClcbiAgICB9XG5cbiAgICAvLyBicm93c2VycyBkbyBub3QgbmVlZCBhIGNhbGxiYWNrLCBidXQgdGVzdHMgZG9cbiAgICB0aGlzLmdldEltYWdlVHlwZSA9IGZ1bmN0aW9uKGNiKSB7XG5cbiAgICAgICAgLy8gb25seSBydW4gZm9yIHRoZSBmaXJzdCB0aW1lIHRoaXMgY29uc3RydWN0b3IgaXMgY2FsbGVkIGFuZFxuICAgICAgICAvLyBjYWNoZSByZXN1bHQgZm9yIHRoZSBuZXh0IGNhbGxzXG5cbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBpZiAoIXZlcmlmaWVkSW1hZ2VUeXBlIHx8ICFpc0Jyb3dzZXIpXG4gICAgICAgICAgICAgICAgdmVyaWZ5SW1hZ2VUeXBlKGZ1bmN0aW9uKGVyciwgbmV3VmVyaWZpZWRJbWFnZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZmllZEltYWdlVHlwZSA9IG5ld1ZlcmlmaWVkSW1hZ2VUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBjYihudWxsLCB2ZXJpZmllZEltYWdlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2IobnVsbCwgdmVyaWZpZWRJbWFnZVR5cGUpXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9uIHRoZSBicm93c2VyIHNpZGUgd2UgZG8gY2FjaGUgaXQgZm9yIHNwZWVkXG4gICAgICAgICAgICBpZiAoIXZlcmlmaWVkSW1hZ2VUeXBlIHx8ICFpc0Jyb3dzZXIpXG4gICAgICAgICAgICAgICAgdmVyaWZpZWRJbWFnZVR5cGUgPSB2ZXJpZnlJbWFnZVR5cGUoKVxuXG4gICAgICAgICAgICByZXR1cm4gdmVyaWZpZWRJbWFnZVR5cGVcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vIGNvbnRhaW5zLCBhZGQsIHJlbW92ZSwgdG9nZ2xlXG52YXIgaW5kZXhvZiA9IHJlcXVpcmUoJ2luZGV4b2YnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsYXNzTGlzdFxuXG5mdW5jdGlvbiBDbGFzc0xpc3QoZWxlbSkge1xuICAgIHZhciBjbCA9IGVsZW0uY2xhc3NMaXN0XG5cbiAgICBpZiAoY2wpIHtcbiAgICAgICAgcmV0dXJuIGNsXG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTGlzdCA9IHtcbiAgICAgICAgYWRkOiBhZGRcbiAgICAgICAgLCByZW1vdmU6IHJlbW92ZVxuICAgICAgICAsIGNvbnRhaW5zOiBjb250YWluc1xuICAgICAgICAsIHRvZ2dsZTogdG9nZ2xlXG4gICAgICAgICwgdG9TdHJpbmc6ICR0b1N0cmluZ1xuICAgICAgICAsIGxlbmd0aDogMFxuICAgICAgICAsIGl0ZW06IGl0ZW1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NMaXN0XG5cbiAgICBmdW5jdGlvbiBhZGQodG9rZW4pIHtcbiAgICAgICAgdmFyIGxpc3QgPSBnZXRUb2tlbnMoKVxuICAgICAgICBpZiAoaW5kZXhvZihsaXN0LCB0b2tlbikgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5wdXNoKHRva2VuKVxuICAgICAgICBzZXRUb2tlbnMobGlzdClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUodG9rZW4pIHtcbiAgICAgICAgdmFyIGxpc3QgPSBnZXRUb2tlbnMoKVxuICAgICAgICAgICAgLCBpbmRleCA9IGluZGV4b2YobGlzdCwgdG9rZW4pXG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgc2V0VG9rZW5zKGxpc3QpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGFpbnModG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGluZGV4b2YoZ2V0VG9rZW5zKCksIHRva2VuKSA+IC0xXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlKHRva2VuKSB7XG4gICAgICAgIGlmIChjb250YWlucyh0b2tlbikpIHtcbiAgICAgICAgICAgIHJlbW92ZSh0b2tlbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkKHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICR0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NOYW1lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlbShpbmRleCkge1xuICAgICAgICB2YXIgdG9rZW5zID0gZ2V0VG9rZW5zKClcbiAgICAgICAgcmV0dXJuIHRva2Vuc1tpbmRleF0gfHwgbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRva2VucygpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lXG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcihjbGFzc05hbWUuc3BsaXQoXCIgXCIpLCBpc1RydXRoeSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUb2tlbnMobGlzdCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGhcblxuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGxpc3Quam9pbihcIiBcIilcbiAgICAgICAgY2xhc3NMaXN0Lmxlbmd0aCA9IGxlbmd0aFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2xhc3NMaXN0W2ldID0gbGlzdFtpXVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGxpc3RbbGVuZ3RoXVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyIChhcnIsIGZuKSB7XG4gICAgdmFyIHJldCA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZuKGFycltpXSkpIHJldC5wdXNoKGFycltpXSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBpc1RydXRoeSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlXG59XG4iLCIvKlxuICogY2xhc3NMaXN0LmpzOiBDcm9zcy1icm93c2VyIGZ1bGwgZWxlbWVudC5jbGFzc0xpc3QgaW1wbGVtZW50YXRpb24uXG4gKiAxLjEuMjAxNTAzMTJcbiAqXG4gKiBCeSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXG4gKiBMaWNlbnNlOiBEZWRpY2F0ZWQgdG8gdGhlIHB1YmxpYyBkb21haW4uXG4gKiAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9jbGFzc0xpc3QuanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuICovXG5cbi8qZ2xvYmFsIHNlbGYsIGRvY3VtZW50LCBET01FeGNlcHRpb24gKi9cblxuLyohIEBzb3VyY2UgaHR0cDovL3B1cmwuZWxpZ3JleS5jb20vZ2l0aHViL2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9jbGFzc0xpc3QuanMgKi9cblxuaWYgKFwiZG9jdW1lbnRcIiBpbiBzZWxmKSB7XG5cbi8vIEZ1bGwgcG9seWZpbGwgZm9yIGJyb3dzZXJzIHdpdGggbm8gY2xhc3NMaXN0IHN1cHBvcnRcbi8vIEluY2x1ZGluZyBJRSA8IEVkZ2UgbWlzc2luZyBTVkdFbGVtZW50LmNsYXNzTGlzdFxuaWYgKCEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKSkgXG5cdHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiAhKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcImdcIikpKSB7XG5cbihmdW5jdGlvbiAodmlldykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKCEoJ0VsZW1lbnQnIGluIHZpZXcpKSByZXR1cm47XG5cbnZhclxuXHQgIGNsYXNzTGlzdFByb3AgPSBcImNsYXNzTGlzdFwiXG5cdCwgcHJvdG9Qcm9wID0gXCJwcm90b3R5cGVcIlxuXHQsIGVsZW1DdHJQcm90byA9IHZpZXcuRWxlbWVudFtwcm90b1Byb3BdXG5cdCwgb2JqQ3RyID0gT2JqZWN0XG5cdCwgc3RyVHJpbSA9IFN0cmluZ1twcm90b1Byb3BdLnRyaW0gfHwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xuXHR9XG5cdCwgYXJySW5kZXhPZiA9IEFycmF5W3Byb3RvUHJvcF0uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhclxuXHRcdFx0ICBpID0gMFxuXHRcdFx0LCBsZW4gPSB0aGlzLmxlbmd0aFxuXHRcdDtcblx0XHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fVxuXHQvLyBWZW5kb3JzOiBwbGVhc2UgYWxsb3cgY29udGVudCBjb2RlIHRvIGluc3RhbnRpYXRlIERPTUV4Y2VwdGlvbnNcblx0LCBET01FeCA9IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XG5cdFx0dGhpcy5uYW1lID0gdHlwZTtcblx0XHR0aGlzLmNvZGUgPSBET01FeGNlcHRpb25bdHlwZV07XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0fVxuXHQsIGNoZWNrVG9rZW5BbmRHZXRJbmRleCA9IGZ1bmN0aW9uIChjbGFzc0xpc3QsIHRva2VuKSB7XG5cdFx0aWYgKHRva2VuID09PSBcIlwiKSB7XG5cdFx0XHR0aHJvdyBuZXcgRE9NRXgoXG5cdFx0XHRcdCAgXCJTWU5UQVhfRVJSXCJcblx0XHRcdFx0LCBcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZFwiXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRpZiAoL1xccy8udGVzdCh0b2tlbikpIHtcblx0XHRcdHRocm93IG5ldyBET01FeChcblx0XHRcdFx0ICBcIklOVkFMSURfQ0hBUkFDVEVSX0VSUlwiXG5cdFx0XHRcdCwgXCJTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXJcIlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGFyckluZGV4T2YuY2FsbChjbGFzc0xpc3QsIHRva2VuKTtcblx0fVxuXHQsIENsYXNzTGlzdCA9IGZ1bmN0aW9uIChlbGVtKSB7XG5cdFx0dmFyXG5cdFx0XHQgIHRyaW1tZWRDbGFzc2VzID0gc3RyVHJpbS5jYWxsKGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIilcblx0XHRcdCwgY2xhc3NlcyA9IHRyaW1tZWRDbGFzc2VzID8gdHJpbW1lZENsYXNzZXMuc3BsaXQoL1xccysvKSA6IFtdXG5cdFx0XHQsIGkgPSAwXG5cdFx0XHQsIGxlbiA9IGNsYXNzZXMubGVuZ3RoXG5cdFx0O1xuXHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHRoaXMucHVzaChjbGFzc2VzW2ldKTtcblx0XHR9XG5cdFx0dGhpcy5fdXBkYXRlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLnRvU3RyaW5nKCkpO1xuXHRcdH07XG5cdH1cblx0LCBjbGFzc0xpc3RQcm90byA9IENsYXNzTGlzdFtwcm90b1Byb3BdID0gW11cblx0LCBjbGFzc0xpc3RHZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBDbGFzc0xpc3QodGhpcyk7XG5cdH1cbjtcbi8vIE1vc3QgRE9NRXhjZXB0aW9uIGltcGxlbWVudGF0aW9ucyBkb24ndCBhbGxvdyBjYWxsaW5nIERPTUV4Y2VwdGlvbidzIHRvU3RyaW5nKClcbi8vIG9uIG5vbi1ET01FeGNlcHRpb25zLiBFcnJvcidzIHRvU3RyaW5nKCkgaXMgc3VmZmljaWVudCBoZXJlLlxuRE9NRXhbcHJvdG9Qcm9wXSA9IEVycm9yW3Byb3RvUHJvcF07XG5jbGFzc0xpc3RQcm90by5pdGVtID0gZnVuY3Rpb24gKGkpIHtcblx0cmV0dXJuIHRoaXNbaV0gfHwgbnVsbDtcbn07XG5jbGFzc0xpc3RQcm90by5jb250YWlucyA9IGZ1bmN0aW9uICh0b2tlbikge1xuXHR0b2tlbiArPSBcIlwiO1xuXHRyZXR1cm4gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSAhPT0gLTE7XG59O1xuY2xhc3NMaXN0UHJvdG8uYWRkID0gZnVuY3Rpb24gKCkge1xuXHR2YXJcblx0XHQgIHRva2VucyA9IGFyZ3VtZW50c1xuXHRcdCwgaSA9IDBcblx0XHQsIGwgPSB0b2tlbnMubGVuZ3RoXG5cdFx0LCB0b2tlblxuXHRcdCwgdXBkYXRlZCA9IGZhbHNlXG5cdDtcblx0ZG8ge1xuXHRcdHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcblx0XHRpZiAoY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSA9PT0gLTEpIHtcblx0XHRcdHRoaXMucHVzaCh0b2tlbik7XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0d2hpbGUgKCsraSA8IGwpO1xuXG5cdGlmICh1cGRhdGVkKSB7XG5cdFx0dGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XG5cdH1cbn07XG5jbGFzc0xpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdHZhclxuXHRcdCAgdG9rZW5zID0gYXJndW1lbnRzXG5cdFx0LCBpID0gMFxuXHRcdCwgbCA9IHRva2Vucy5sZW5ndGhcblx0XHQsIHRva2VuXG5cdFx0LCB1cGRhdGVkID0gZmFsc2Vcblx0XHQsIGluZGV4XG5cdDtcblx0ZG8ge1xuXHRcdHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcblx0XHRpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XG5cdFx0d2hpbGUgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0dGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cdFx0XHRpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XG5cdFx0fVxuXHR9XG5cdHdoaWxlICgrK2kgPCBsKTtcblxuXHRpZiAodXBkYXRlZCkge1xuXHRcdHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xuXHR9XG59O1xuY2xhc3NMaXN0UHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gKHRva2VuLCBmb3JjZSkge1xuXHR0b2tlbiArPSBcIlwiO1xuXG5cdHZhclxuXHRcdCAgcmVzdWx0ID0gdGhpcy5jb250YWlucyh0b2tlbilcblx0XHQsIG1ldGhvZCA9IHJlc3VsdCA/XG5cdFx0XHRmb3JjZSAhPT0gdHJ1ZSAmJiBcInJlbW92ZVwiXG5cdFx0OlxuXHRcdFx0Zm9yY2UgIT09IGZhbHNlICYmIFwiYWRkXCJcblx0O1xuXG5cdGlmIChtZXRob2QpIHtcblx0XHR0aGlzW21ldGhvZF0odG9rZW4pO1xuXHR9XG5cblx0aWYgKGZvcmNlID09PSB0cnVlIHx8IGZvcmNlID09PSBmYWxzZSkge1xuXHRcdHJldHVybiBmb3JjZTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gIXJlc3VsdDtcblx0fVxufTtcbmNsYXNzTGlzdFByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5qb2luKFwiIFwiKTtcbn07XG5cbmlmIChvYmpDdHIuZGVmaW5lUHJvcGVydHkpIHtcblx0dmFyIGNsYXNzTGlzdFByb3BEZXNjID0ge1xuXHRcdCAgZ2V0OiBjbGFzc0xpc3RHZXR0ZXJcblx0XHQsIGVudW1lcmFibGU6IHRydWVcblx0XHQsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHR9O1xuXHR0cnkge1xuXHRcdG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcblx0fSBjYXRjaCAoZXgpIHsgLy8gSUUgOCBkb2Vzbid0IHN1cHBvcnQgZW51bWVyYWJsZTp0cnVlXG5cdFx0aWYgKGV4Lm51bWJlciA9PT0gLTB4N0ZGNUVDNTQpIHtcblx0XHRcdGNsYXNzTGlzdFByb3BEZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcblx0XHRcdG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcblx0XHR9XG5cdH1cbn0gZWxzZSBpZiAob2JqQ3RyW3Byb3RvUHJvcF0uX19kZWZpbmVHZXR0ZXJfXykge1xuXHRlbGVtQ3RyUHJvdG8uX19kZWZpbmVHZXR0ZXJfXyhjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RHZXR0ZXIpO1xufVxuXG59KHNlbGYpKTtcblxufSBlbHNlIHtcbi8vIFRoZXJlIGlzIGZ1bGwgb3IgcGFydGlhbCBuYXRpdmUgY2xhc3NMaXN0IHN1cHBvcnQsIHNvIGp1c3QgY2hlY2sgaWYgd2UgbmVlZFxuLy8gdG8gbm9ybWFsaXplIHRoZSBhZGQvcmVtb3ZlIGFuZCB0b2dnbGUgQVBJcy5cblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIik7XG5cblx0dGVzdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImMxXCIsIFwiYzJcIik7XG5cblx0Ly8gUG9seWZpbGwgZm9yIElFIDEwLzExIGFuZCBGaXJlZm94IDwyNiwgd2hlcmUgY2xhc3NMaXN0LmFkZCBhbmRcblx0Ly8gY2xhc3NMaXN0LnJlbW92ZSBleGlzdCBidXQgc3VwcG9ydCBvbmx5IG9uZSBhcmd1bWVudCBhdCBhIHRpbWUuXG5cdGlmICghdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYzJcIikpIHtcblx0XHR2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWwgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlW21ldGhvZF07XG5cblx0XHRcdERPTVRva2VuTGlzdC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHRva2VuKSB7XG5cdFx0XHRcdHZhciBpLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdHRva2VuID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdG9yaWdpbmFsLmNhbGwodGhpcywgdG9rZW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0Y3JlYXRlTWV0aG9kKCdhZGQnKTtcblx0XHRjcmVhdGVNZXRob2QoJ3JlbW92ZScpO1xuXHR9XG5cblx0dGVzdEVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcImMzXCIsIGZhbHNlKTtcblxuXHQvLyBQb2x5ZmlsbCBmb3IgSUUgMTAgYW5kIEZpcmVmb3ggPDI0LCB3aGVyZSBjbGFzc0xpc3QudG9nZ2xlIGRvZXMgbm90XG5cdC8vIHN1cHBvcnQgdGhlIHNlY29uZCBhcmd1bWVudC5cblx0aWYgKHRlc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImMzXCIpKSB7XG5cdFx0dmFyIF90b2dnbGUgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZTtcblxuXHRcdERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24odG9rZW4sIGZvcmNlKSB7XG5cdFx0XHRpZiAoMSBpbiBhcmd1bWVudHMgJiYgIXRoaXMuY29udGFpbnModG9rZW4pID09PSAhZm9yY2UpIHtcblx0XHRcdFx0cmV0dXJuIGZvcmNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIF90b2dnbGUuY2FsbCh0aGlzLCB0b2tlbik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHR9XG5cblx0dGVzdEVsZW1lbnQgPSBudWxsO1xufSgpKTtcblxufVxuXG59XG5cbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsInZhciBET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkgPSAxNlxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zXG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGNvbnRhaW5lciwgZWxlbSkge1xuICAgIGlmIChjb250YWluZXIuY29udGFpbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jb250YWlucyhlbGVtKVxuICAgIH1cblxuICAgIHZhciBjb21wYXJpc29uID0gY29udGFpbmVyLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW0pXG5cbiAgICByZXR1cm4gY29tcGFyaXNvbiA9PT0gMCB8fCBjb21wYXJpc29uICYgRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvLyAgICAgY3JlYXRlLWVycm9yLmpzIDAuMy4xXG4vLyAgICAgKGMpIDIwMTMgVGltIEdyaWVzc2VyXG4vLyAgICAgVGhpcyBzb3VyY2UgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gQSBzaW1wbGUgdXRpbGl0eSBmb3Igc3ViY2xhc3NpbmcgdGhlIFwiRXJyb3JcIlxuLy8gb2JqZWN0IGluIG11bHRpcGxlIGVudmlyb25tZW50cywgd2hpbGUgbWFpbnRhaW5pbmdcbi8vIHJlbGV2YW50IHN0YWNrIHRyYWNlcywgbWVzc2FnZXMsIGFuZCBwcm90b3R5cGVzLlxuZmFjdG9yeShmdW5jdGlvbigpIHtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gQ3JlYXRlcyBhbiBuZXcgZXJyb3IgdHlwZSB3aXRoIGEgXCJuYW1lXCIsXG4vLyBhbmQgYW55IGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXRcbi8vIG9uIHRoZSBlcnJvciBpbnN0YW5jZS5cbnJldHVybiBmdW5jdGlvbigpIHtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gIH1cbiAgdmFyIG5hbWUgICAgICAgPSBnZXROYW1lKGFyZ3MpO1xuICB2YXIgdGFyZ2V0ICAgICA9IGdldFRhcmdldChhcmdzKTtcbiAgdmFyIHByb3BlcnRpZXMgPSBnZXRQcm9wcyhhcmdzKTtcbiAgZnVuY3Rpb24gRXJyb3JDdG9yKG1lc3NhZ2UsIG9iaikge1xuICAgIGF0dGFjaFByb3BzKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIGF0dGFjaFByb3BzKHRoaXMsIG9iaik7XG4gICAgdGhpcy5tZXNzYWdlID0gKG1lc3NhZ2UgfHwgdGhpcy5tZXNzYWdlKTtcbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlLm1lc3NhZ2U7XG4gICAgICB0aGlzLnN0YWNrID0gbWVzc2FnZS5zdGFjaztcbiAgICB9IGVsc2UgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gRXJyKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gRXJyb3JDdG9yOyB9XG4gIEVyci5wcm90b3R5cGUgPSB0YXJnZXRbJ3Byb3RvdHlwZSddO1xuICBFcnJvckN0b3IucHJvdG90eXBlID0gbmV3IEVycigpO1xuICBFcnJvckN0b3IucHJvdG90eXBlLm5hbWUgPSAoJycgKyBuYW1lKSB8fCAnQ3VzdG9tRXJyb3InO1xuICByZXR1cm4gRXJyb3JDdG9yO1xufTtcblxuLy8gSnVzdCBhIGZldyBoZWxwZXJzIHRvIGNsZWFuIHVwIHRoZSBmdW5jdGlvbiBhYm92ZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzXG5mdW5jdGlvbiBnZXROYW1lKGFyZ3MpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHJldHVybiBpc0Vycm9yKGFyZ3NbMF0pID8gKGFyZ3NbMV0gfHwgJycpIDogYXJnc1swXTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldChhcmdzKSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEVycm9yO1xuICByZXR1cm4gaXNFcnJvcihhcmdzWzBdKSA/IGFyZ3NbMF0gOiBFcnJvcjtcbn1cbmZ1bmN0aW9uIGdldFByb3BzKGFyZ3MpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGlzRXJyb3IoYXJnc1swXSkgPyBhcmdzWzJdIDogYXJnc1sxXTtcbn1cbmZ1bmN0aW9uIGluaGVyaXRlZEtleXMob2JqKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHJldC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gUmlnaHQgbm93IHdlJ3JlIGp1c3QgYXNzdW1pbmcgdGhhdCBhIGZ1bmN0aW9uIGluIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBlcnJvci5cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiKTtcbn1cblxuLy8gV2UgZG9uJ3QgbmVlZCB0aGUgZnVsbCB1bmRlcnNjb3JlIGNoZWNrIGhlcmUsIHNpbmNlIGl0IHNob3VsZCBlaXRoZXIgYmVcbi8vIGFuIG9iamVjdC1saXRlcmFsLCBvciBub3RoaW5nIGF0IGFsbC5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gKG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIik7XG59XG5cbi8vIFVzZWQgdG8gYXR0YWNoIGF0dHJpYnV0ZXMgdG8gdGhlIGVycm9yIG9iamVjdCBpbiB0aGUgY29uc3RydWN0b3IuXG5mdW5jdGlvbiBhdHRhY2hQcm9wcyhjb250ZXh0LCB0YXJnZXQpIHtcbiAgaWYgKGlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICB2YXIga2V5cyA9IGluaGVyaXRlZEtleXModGFyZ2V0KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICBjb250ZXh0W2tleXNbaV1dID0gY2xvbmUodGFyZ2V0W2tleXNbaV1dKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRG9uJ3QgbmVlZCB0aGUgZnVsbC1vdXQgXCJjbG9uZVwiIG1lY2hhbmlzbSBoZXJlLCBzaW5jZSBpZiB5b3UncmVcbi8vIHRyeWluZyB0byBzZXQgdGhpbmdzIG90aGVyIHRoYW4gZW1wdHkgYXJyYXlzL29iamVjdHMgb24geW91clxuLy8gc3ViLWNsYXNzZWQgYEVycm9yYCBvYmplY3QsIHlvdSdyZSBwcm9iYWJseSBkb2luZyBpdCB3cm9uZy5cbmZ1bmN0aW9uIGNsb25lKHRhcmdldCkge1xuICBpZiAodGFyZ2V0ID09IG51bGwgfHwgdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHRhcmdldDtcbiAgdmFyIGNsb25lZCA9IHRhcmdldC5jb25zdHJ1Y3RvciA/IHRhcmdldC5jb25zdHJ1Y3RvcigpIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yICh2YXIgYXR0ciBpbiB0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICBjbG9uZWRbYXR0cl0gPSB0YXJnZXRbYXR0cl07XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5cbn0pO1xuXG4vLyBCb2lsZXJwbGF0ZSBVTUQgZGVmaW5pdGlvbiBibG9jay4uLlxufSkoZnVuY3Rpb24oY3JlYXRlRXJyb3JMaWIpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGNyZWF0ZUVycm9yTGliKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUVycm9yTGliKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzO1xuICAgIHZhciBsYXN0Y3JlYXRlRXJyb3IgPSByb290LmNyZWF0ZUVycm9yO1xuICAgIHZhciBjcmVhdGVFcnJvciA9IHJvb3QuY3JlYXRlRXJyb3IgPSBjcmVhdGVFcnJvckxpYigpO1xuICAgIGNyZWF0ZUVycm9yLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJvb3QuY3JlYXRlRXJyb3IgPSBsYXN0Y3JlYXRlRXJyb3I7XG4gICAgICByZXR1cm4gY3JlYXRlRXJyb3I7XG4gICAgfTtcbiAgfVxufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJndW1lbnRzW2ldICE9PSB1bmRlZmluZWQpIHJldHVybiBhcmd1bWVudHNbaV07XG4gICAgfVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnZ2xvYmFsJylcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKVxuXG52YXIgbWFrZURlc3BvdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIERlc3BvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZ2xvYmFsLl9zaW5nbGV0b25EZXNwb3RJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGdsb2JhbC5fc2luZ2xldG9uRGVzcG90SW5zdGFuY2VcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xvYmFsLl9zaW5nbGV0b25EZXNwb3RJbnN0YW5jZSA9IHRoaXNcbiAgICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdXRpbC5pbmhlcml0cyhEZXNwb3QsIEV2ZW50RW1pdHRlcilcblxuICByZXR1cm4gbmV3IERlc3BvdCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFrZURlc3BvdCgpXG4iLCIndXNlIHN0cmljdCdcblxudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnZ2xvYmFsL2RvY3VtZW50JylcbnZhciBFdmVudCA9IHJlcXVpcmUoJ2dldmFsJylcbnZhciBLZXlzID0gcmVxdWlyZSgnLi9rZXlzJylcblxubW9kdWxlLmV4cG9ydHMgPSBWaXNpYmlsaXR5XG5cbmZ1bmN0aW9uIFZpc2liaWxpdHkgKCkge1xuICB2YXIga2V5cyA9IEtleXMoZG9jdW1lbnQpXG4gIGlmICgha2V5cykgcmV0dXJuIG5vb3BTaGltKClcblxuICByZXR1cm4ge1xuICAgIHZpc2libGU6IHZpc2libGUsXG4gICAgb25DaGFuZ2U6IEV2ZW50KGxpc3RlbilcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGUgKCkge1xuICAgIHJldHVybiAhZG9jdW1lbnRba2V5cy5oaWRkZW5dXG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4gKGJyb2FkY2FzdCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoa2V5cy5ldmVudCwgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlICgpIHtcbiAgICAgIGJyb2FkY2FzdCh2aXNpYmxlKCkpXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBub29wU2hpbSAoKSB7XG4gIHJldHVybiB7XG4gICAgdmlzaWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9LFxuICAgIG9uQ2hhbmdlOiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c1xuXG5mdW5jdGlvbiBrZXlzIChkb2N1bWVudCkge1xuICB2YXIgcHJlZml4ID0gZGV0ZWN0UHJlZml4KGRvY3VtZW50KVxuICBpZiAocHJlZml4ID09IG51bGwpIHJldHVyblxuICByZXR1cm4ge1xuICAgIGhpZGRlbjogbG93ZXJjYXNlRmlyc3QocHJlZml4ICsgJ0hpZGRlbicpLFxuICAgIGV2ZW50OiBwcmVmaXggKyAndmlzaWJpbGl0eWNoYW5nZSdcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRlY3RQcmVmaXggKGRvY3VtZW50KSB7XG4gIGlmIChkb2N1bWVudC5oaWRkZW4gIT0gbnVsbCkgcmV0dXJuICcnXG4gIGlmIChkb2N1bWVudC5tb3pIaWRkZW4gIT0gbnVsbCkgcmV0dXJuICdtb3onXG4gIGlmIChkb2N1bWVudC5tc0hpZGRlbiAhPSBudWxsKSByZXR1cm4gJ21zJ1xuICBpZiAoZG9jdW1lbnQud2Via2l0SGlkZGVuICE9IG51bGwpIHJldHVybiAnd2Via2l0J1xufVxuXG5mdW5jdGlvbiBsb3dlcmNhc2VGaXJzdCAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3Vic3RyaW5nKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBzdHJpbmcuc3Vic3RyaW5nKDEpXG59XG4iLCJ2YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbnZhciBlb3MgPSByZXF1aXJlKCdlbmQtb2Ytc3RyZWFtJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzaGlmdCA9IHJlcXVpcmUoJ3N0cmVhbS1zaGlmdCcpXG5cbnZhciBTSUdOQUxfRkxVU0ggPSBuZXcgQnVmZmVyKFswXSlcblxudmFyIG9udW5jb3JrID0gZnVuY3Rpb24oc2VsZiwgZm4pIHtcbiAgaWYgKHNlbGYuX2NvcmtlZCkgc2VsZi5vbmNlKCd1bmNvcmsnLCBmbilcbiAgZWxzZSBmbigpXG59XG5cbnZhciBkZXN0cm95ZXIgPSBmdW5jdGlvbihzZWxmLCBlbmQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIpIHNlbGYuZGVzdHJveShlcnIubWVzc2FnZSA9PT0gJ3ByZW1hdHVyZSBjbG9zZScgPyBudWxsIDogZXJyKVxuICAgIGVsc2UgaWYgKGVuZCAmJiAhc2VsZi5fZW5kZWQpIHNlbGYuZW5kKClcbiAgfVxufVxuXG52YXIgZW5kID0gZnVuY3Rpb24od3MsIGZuKSB7XG4gIGlmICghd3MpIHJldHVybiBmbigpXG4gIGlmICh3cy5fd3JpdGFibGVTdGF0ZSAmJiB3cy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkgcmV0dXJuIGZuKClcbiAgaWYgKHdzLl93cml0YWJsZVN0YXRlKSByZXR1cm4gd3MuZW5kKGZuKVxuICB3cy5lbmQoKVxuICBmbigpXG59XG5cbnZhciB0b1N0cmVhbXMyID0gZnVuY3Rpb24ocnMpIHtcbiAgcmV0dXJuIG5ldyAoc3RyZWFtLlJlYWRhYmxlKSh7b2JqZWN0TW9kZTp0cnVlLCBoaWdoV2F0ZXJNYXJrOjE2fSkud3JhcChycylcbn1cblxudmFyIER1cGxleGlmeSA9IGZ1bmN0aW9uKHdyaXRhYmxlLCByZWFkYWJsZSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4aWZ5KSkgcmV0dXJuIG5ldyBEdXBsZXhpZnkod3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKVxuICBzdHJlYW0uRHVwbGV4LmNhbGwodGhpcywgb3B0cylcblxuICB0aGlzLl93cml0YWJsZSA9IG51bGxcbiAgdGhpcy5fcmVhZGFibGUgPSBudWxsXG4gIHRoaXMuX3JlYWRhYmxlMiA9IG51bGxcblxuICB0aGlzLl9mb3J3YXJkRGVzdHJveSA9ICFvcHRzIHx8IG9wdHMuZGVzdHJveSAhPT0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZEVuZCA9ICFvcHRzIHx8IG9wdHMuZW5kICE9PSBmYWxzZVxuICB0aGlzLl9jb3JrZWQgPSAxIC8vIHN0YXJ0IGNvcmtlZFxuICB0aGlzLl9vbmRyYWluID0gbnVsbFxuICB0aGlzLl9kcmFpbmVkID0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZGluZyA9IGZhbHNlXG4gIHRoaXMuX3Vud3JpdGUgPSBudWxsXG4gIHRoaXMuX3VucmVhZCA9IG51bGxcbiAgdGhpcy5fZW5kZWQgPSBmYWxzZVxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICBpZiAod3JpdGFibGUpIHRoaXMuc2V0V3JpdGFibGUod3JpdGFibGUpXG4gIGlmIChyZWFkYWJsZSkgdGhpcy5zZXRSZWFkYWJsZShyZWFkYWJsZSlcbn1cblxuaW5oZXJpdHMoRHVwbGV4aWZ5LCBzdHJlYW0uRHVwbGV4KVxuXG5EdXBsZXhpZnkub2JqID0gZnVuY3Rpb24od3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIG9wdHMub2JqZWN0TW9kZSA9IHRydWVcbiAgb3B0cy5oaWdoV2F0ZXJNYXJrID0gMTZcbiAgcmV0dXJuIG5ldyBEdXBsZXhpZnkod3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCsrdGhpcy5fY29ya2VkID09PSAxKSB0aGlzLmVtaXQoJ2NvcmsnKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fY29ya2VkICYmIC0tdGhpcy5fY29ya2VkID09PSAwKSB0aGlzLmVtaXQoJ3VuY29yaycpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuc2V0V3JpdGFibGUgPSBmdW5jdGlvbih3cml0YWJsZSkge1xuICBpZiAodGhpcy5fdW53cml0ZSkgdGhpcy5fdW53cml0ZSgpXG5cbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgaWYgKHdyaXRhYmxlICYmIHdyaXRhYmxlLmRlc3Ryb3kpIHdyaXRhYmxlLmRlc3Ryb3koKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHdyaXRhYmxlID09PSBudWxsIHx8IHdyaXRhYmxlID09PSBmYWxzZSkge1xuICAgIHRoaXMuZW5kKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgdW5lbmQgPSBlb3Mod3JpdGFibGUsIHt3cml0YWJsZTp0cnVlLCByZWFkYWJsZTpmYWxzZX0sIGRlc3Ryb3llcih0aGlzLCB0aGlzLl9mb3J3YXJkRW5kKSlcblxuICB2YXIgb25kcmFpbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbmRyYWluID0gc2VsZi5fb25kcmFpblxuICAgIHNlbGYuX29uZHJhaW4gPSBudWxsXG4gICAgaWYgKG9uZHJhaW4pIG9uZHJhaW4oKVxuICB9XG5cbiAgdmFyIGNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fd3JpdGFibGUucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbilcbiAgICB1bmVuZCgpXG4gIH1cblxuICBpZiAodGhpcy5fdW53cml0ZSkgcHJvY2Vzcy5uZXh0VGljayhvbmRyYWluKSAvLyBmb3JjZSBhIGRyYWluIG9uIHN0cmVhbSByZXNldCB0byBhdm9pZCBsaXZlbG9ja3NcblxuICB0aGlzLl93cml0YWJsZSA9IHdyaXRhYmxlXG4gIHRoaXMuX3dyaXRhYmxlLm9uKCdkcmFpbicsIG9uZHJhaW4pXG4gIHRoaXMuX3Vud3JpdGUgPSBjbGVhclxuXG4gIHRoaXMudW5jb3JrKCkgLy8gYWx3YXlzIHVuY29yayBzZXRXcml0YWJsZVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLnNldFJlYWRhYmxlID0gZnVuY3Rpb24ocmVhZGFibGUpIHtcbiAgaWYgKHRoaXMuX3VucmVhZCkgdGhpcy5fdW5yZWFkKClcblxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICBpZiAocmVhZGFibGUgJiYgcmVhZGFibGUuZGVzdHJveSkgcmVhZGFibGUuZGVzdHJveSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocmVhZGFibGUgPT09IG51bGwgfHwgcmVhZGFibGUgPT09IGZhbHNlKSB7XG4gICAgdGhpcy5wdXNoKG51bGwpXG4gICAgdGhpcy5yZXN1bWUoKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciB1bmVuZCA9IGVvcyhyZWFkYWJsZSwge3dyaXRhYmxlOmZhbHNlLCByZWFkYWJsZTp0cnVlfSwgZGVzdHJveWVyKHRoaXMpKVxuXG4gIHZhciBvbnJlYWRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fZm9yd2FyZCgpXG4gIH1cblxuICB2YXIgb25lbmQgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLnB1c2gobnVsbClcbiAgfVxuXG4gIHZhciBjbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3JlYWRhYmxlMi5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBvbnJlYWRhYmxlKVxuICAgIHNlbGYuX3JlYWRhYmxlMi5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpXG4gICAgdW5lbmQoKVxuICB9XG5cbiAgdGhpcy5fZHJhaW5lZCA9IHRydWVcbiAgdGhpcy5fcmVhZGFibGUgPSByZWFkYWJsZVxuICB0aGlzLl9yZWFkYWJsZTIgPSByZWFkYWJsZS5fcmVhZGFibGVTdGF0ZSA/IHJlYWRhYmxlIDogdG9TdHJlYW1zMihyZWFkYWJsZSlcbiAgdGhpcy5fcmVhZGFibGUyLm9uKCdyZWFkYWJsZScsIG9ucmVhZGFibGUpXG4gIHRoaXMuX3JlYWRhYmxlMi5vbignZW5kJywgb25lbmQpXG4gIHRoaXMuX3VucmVhZCA9IGNsZWFyXG5cbiAgdGhpcy5fZm9yd2FyZCgpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZHJhaW5lZCA9IHRydWVcbiAgdGhpcy5fZm9yd2FyZCgpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX2ZvcndhcmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2ZvcndhcmRpbmcgfHwgIXRoaXMuX3JlYWRhYmxlMiB8fCAhdGhpcy5fZHJhaW5lZCkgcmV0dXJuXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSB0cnVlXG5cbiAgdmFyIGRhdGFcblxuICB3aGlsZSAodGhpcy5fZHJhaW5lZCAmJiAoZGF0YSA9IHNoaWZ0KHRoaXMuX3JlYWRhYmxlMikpICE9PSBudWxsKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSBjb250aW51ZVxuICAgIHRoaXMuX2RyYWluZWQgPSB0aGlzLnB1c2goZGF0YSlcbiAgfVxuXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSBmYWxzZVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fZGVzdHJveShlcnIpXG4gIH0pXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKGVycikge1xuICAgIHZhciBvbmRyYWluID0gdGhpcy5fb25kcmFpblxuICAgIHRoaXMuX29uZHJhaW4gPSBudWxsXG4gICAgaWYgKG9uZHJhaW4pIG9uZHJhaW4oZXJyKVxuICAgIGVsc2UgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxuXG4gIGlmICh0aGlzLl9mb3J3YXJkRGVzdHJveSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZSAmJiB0aGlzLl9yZWFkYWJsZS5kZXN0cm95KSB0aGlzLl9yZWFkYWJsZS5kZXN0cm95KClcbiAgICBpZiAodGhpcy5fd3JpdGFibGUgJiYgdGhpcy5fd3JpdGFibGUuZGVzdHJveSkgdGhpcy5fd3JpdGFibGUuZGVzdHJveSgpXG4gIH1cblxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihkYXRhLCBlbmMsIGNiKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuIGNiKClcbiAgaWYgKHRoaXMuX2NvcmtlZCkgcmV0dXJuIG9udW5jb3JrKHRoaXMsIHRoaXMuX3dyaXRlLmJpbmQodGhpcywgZGF0YSwgZW5jLCBjYikpXG4gIGlmIChkYXRhID09PSBTSUdOQUxfRkxVU0gpIHJldHVybiB0aGlzLl9maW5pc2goY2IpXG4gIGlmICghdGhpcy5fd3JpdGFibGUpIHJldHVybiBjYigpXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlLndyaXRlKGRhdGEpID09PSBmYWxzZSkgdGhpcy5fb25kcmFpbiA9IGNiXG4gIGVsc2UgY2IoKVxufVxuXG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLmVtaXQoJ3ByZWVuZCcpXG4gIG9udW5jb3JrKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGVuZChzZWxmLl9mb3J3YXJkRW5kICYmIHNlbGYuX3dyaXRhYmxlLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGhheHggdG8gbm90IGVtaXQgcHJlZmluaXNoIHR3aWNlXG4gICAgICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9PT0gZmFsc2UpIHNlbGYuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSB0cnVlXG4gICAgICBzZWxmLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICBvbnVuY29yayhzZWxmLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGRhdGEsIGVuYywgY2IpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5lbmQobnVsbCwgbnVsbCwgZGF0YSlcbiAgaWYgKHR5cGVvZiBlbmMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmVuZChkYXRhLCBudWxsLCBlbmMpXG4gIHRoaXMuX2VuZGVkID0gdHJ1ZVxuICBpZiAoZGF0YSkgdGhpcy53cml0ZShkYXRhKVxuICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nKSB0aGlzLndyaXRlKFNJR05BTF9GTFVTSClcbiAgcmV0dXJuIHN0cmVhbS5Xcml0YWJsZS5wcm90b3R5cGUuZW5kLmNhbGwodGhpcywgY2IpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4aWZ5XG4iLCIvLyBlbGVtZW50LWNsb3Nlc3QgfCBDQzAtMS4wIHwgZ2l0aHViLmNvbS9qb25hdGhhbnRuZWFsL2Nsb3Nlc3RcblxuKGZ1bmN0aW9uIChFbGVtZW50UHJvdG8pIHtcblx0aWYgKHR5cGVvZiBFbGVtZW50UHJvdG8ubWF0Y2hlcyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdEVsZW1lbnRQcm90by5tYXRjaGVzID0gRWxlbWVudFByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnRQcm90by5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudFByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBmdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9yKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHRoaXM7XG5cdFx0XHR2YXIgZWxlbWVudHMgPSAoZWxlbWVudC5kb2N1bWVudCB8fCBlbGVtZW50Lm93bmVyRG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXHRcdFx0dmFyIGluZGV4ID0gMDtcblxuXHRcdFx0d2hpbGUgKGVsZW1lbnRzW2luZGV4XSAmJiBlbGVtZW50c1tpbmRleF0gIT09IGVsZW1lbnQpIHtcblx0XHRcdFx0KytpbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIEJvb2xlYW4oZWxlbWVudHNbaW5kZXhdKTtcblx0XHR9O1xuXHR9XG5cblx0aWYgKHR5cGVvZiBFbGVtZW50UHJvdG8uY2xvc2VzdCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdEVsZW1lbnRQcm90by5jbG9zZXN0ID0gZnVuY3Rpb24gY2xvc2VzdChzZWxlY3Rvcikge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzO1xuXG5cdFx0XHR3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG5cdFx0XHRcdGlmIChlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9XG59KSh3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUpO1xuIiwidmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJyk7XG5cbnZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxudmFyIGlzUmVxdWVzdCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRyZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGVvcyA9IGZ1bmN0aW9uKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG5cdGlmICghb3B0cykgb3B0cyA9IHt9O1xuXG5cdGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcblxuXHR2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cdHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblx0dmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCAob3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlKTtcblx0dmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCAob3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlKTtcblxuXHR2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcblx0fTtcblxuXHR2YXIgb25maW5pc2ggPSBmdW5jdGlvbigpIHtcblx0XHR3cml0YWJsZSA9IGZhbHNlO1xuXHRcdGlmICghcmVhZGFibGUpIGNhbGxiYWNrKCk7XG5cdH07XG5cblx0dmFyIG9uZW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0cmVhZGFibGUgPSBmYWxzZTtcblx0XHRpZiAoIXdyaXRhYmxlKSBjYWxsYmFjaygpO1xuXHR9O1xuXG5cdHZhciBvbmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHJlYWRhYmxlICYmICEocnMgJiYgcnMuZW5kZWQpKSByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdwcmVtYXR1cmUgY2xvc2UnKSk7XG5cdFx0aWYgKHdyaXRhYmxlICYmICEod3MgJiYgd3MuZW5kZWQpKSByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdwcmVtYXR1cmUgY2xvc2UnKSk7XG5cdH07XG5cblx0dmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0fTtcblxuXHRpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcblx0XHRzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcblx0XHRpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7XG5cdFx0ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuXHR9IGVsc2UgaWYgKHdyaXRhYmxlICYmICF3cykgeyAvLyBsZWdhY3kgc3RyZWFtc1xuXHRcdHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdH1cblxuXHRzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTtcblx0c3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcblx0c3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuXHRcdGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgY2FsbGJhY2spO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcclxuICogZmlsZXNpemVcclxuICpcclxuICogQGNvcHlyaWdodCAyMDE3IEphc29uIE11bGxpZ2FuIDxqYXNvbi5tdWxsaWdhbkBhdm9pZHdvcmsuY29tPlxyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2VcclxuICogQHZlcnNpb24gMy41LjEwXHJcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwpIHtcblx0dmFyIGIgPSAvXihifEIpJC8sXG5cdCAgICBzeW1ib2wgPSB7XG5cdFx0aWVjOiB7XG5cdFx0XHRiaXRzOiBbXCJiXCIsIFwiS2liXCIsIFwiTWliXCIsIFwiR2liXCIsIFwiVGliXCIsIFwiUGliXCIsIFwiRWliXCIsIFwiWmliXCIsIFwiWWliXCJdLFxuXHRcdFx0Ynl0ZXM6IFtcIkJcIiwgXCJLaUJcIiwgXCJNaUJcIiwgXCJHaUJcIiwgXCJUaUJcIiwgXCJQaUJcIiwgXCJFaUJcIiwgXCJaaUJcIiwgXCJZaUJcIl1cblx0XHR9LFxuXHRcdGplZGVjOiB7XG5cdFx0XHRiaXRzOiBbXCJiXCIsIFwiS2JcIiwgXCJNYlwiLCBcIkdiXCIsIFwiVGJcIiwgXCJQYlwiLCBcIkViXCIsIFwiWmJcIiwgXCJZYlwiXSxcblx0XHRcdGJ5dGVzOiBbXCJCXCIsIFwiS0JcIiwgXCJNQlwiLCBcIkdCXCIsIFwiVEJcIiwgXCJQQlwiLCBcIkVCXCIsIFwiWkJcIiwgXCJZQlwiXVxuXHRcdH1cblx0fSxcblx0ICAgIGZ1bGxmb3JtID0ge1xuXHRcdGllYzogW1wiXCIsIFwia2liaVwiLCBcIm1lYmlcIiwgXCJnaWJpXCIsIFwidGViaVwiLCBcInBlYmlcIiwgXCJleGJpXCIsIFwiemViaVwiLCBcInlvYmlcIl0sXG5cdFx0amVkZWM6IFtcIlwiLCBcImtpbG9cIiwgXCJtZWdhXCIsIFwiZ2lnYVwiLCBcInRlcmFcIiwgXCJwZXRhXCIsIFwiZXhhXCIsIFwiemV0dGFcIiwgXCJ5b3R0YVwiXVxuXHR9O1xuXG5cdC8qKlxyXG4gICogZmlsZXNpemVcclxuICAqXHJcbiAgKiBAbWV0aG9kIGZpbGVzaXplXHJcbiAgKiBAcGFyYW0gIHtNaXhlZH0gICBhcmcgICAgICAgIFN0cmluZywgSW50IG9yIEZsb2F0IHRvIHRyYW5zZm9ybVxyXG4gICogQHBhcmFtICB7T2JqZWN0fSAgZGVzY3JpcHRvciBbT3B0aW9uYWxdIEZsYWdzXHJcbiAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgIFJlYWRhYmxlIGZpbGUgc2l6ZSBTdHJpbmdcclxuICAqL1xuXHRmdW5jdGlvbiBmaWxlc2l6ZShhcmcpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cblx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0ICAgIHZhbCA9IDAsXG5cdFx0ICAgIGUgPSB2b2lkIDAsXG5cdFx0ICAgIGJhc2UgPSB2b2lkIDAsXG5cdFx0ICAgIGJpdHMgPSB2b2lkIDAsXG5cdFx0ICAgIGNlaWwgPSB2b2lkIDAsXG5cdFx0ICAgIGZ1bGwgPSB2b2lkIDAsXG5cdFx0ICAgIGZ1bGxmb3JtcyA9IHZvaWQgMCxcblx0XHQgICAgbmVnID0gdm9pZCAwLFxuXHRcdCAgICBudW0gPSB2b2lkIDAsXG5cdFx0ICAgIG91dHB1dCA9IHZvaWQgMCxcblx0XHQgICAgcm91bmQgPSB2b2lkIDAsXG5cdFx0ICAgIHVuaXggPSB2b2lkIDAsXG5cdFx0ICAgIHNwYWNlciA9IHZvaWQgMCxcblx0XHQgICAgc3RhbmRhcmQgPSB2b2lkIDAsXG5cdFx0ICAgIHN5bWJvbHMgPSB2b2lkIDA7XG5cblx0XHRpZiAoaXNOYU4oYXJnKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHNcIik7XG5cdFx0fVxuXG5cdFx0Yml0cyA9IGRlc2NyaXB0b3IuYml0cyA9PT0gdHJ1ZTtcblx0XHR1bml4ID0gZGVzY3JpcHRvci51bml4ID09PSB0cnVlO1xuXHRcdGJhc2UgPSBkZXNjcmlwdG9yLmJhc2UgfHwgMjtcblx0XHRyb3VuZCA9IGRlc2NyaXB0b3Iucm91bmQgIT09IHVuZGVmaW5lZCA/IGRlc2NyaXB0b3Iucm91bmQgOiB1bml4ID8gMSA6IDI7XG5cdFx0c3BhY2VyID0gZGVzY3JpcHRvci5zcGFjZXIgIT09IHVuZGVmaW5lZCA/IGRlc2NyaXB0b3Iuc3BhY2VyIDogdW5peCA/IFwiXCIgOiBcIiBcIjtcblx0XHRzeW1ib2xzID0gZGVzY3JpcHRvci5zeW1ib2xzIHx8IGRlc2NyaXB0b3Iuc3VmZml4ZXMgfHwge307XG5cdFx0c3RhbmRhcmQgPSBiYXNlID09PSAyID8gZGVzY3JpcHRvci5zdGFuZGFyZCB8fCBcImplZGVjXCIgOiBcImplZGVjXCI7XG5cdFx0b3V0cHV0ID0gZGVzY3JpcHRvci5vdXRwdXQgfHwgXCJzdHJpbmdcIjtcblx0XHRmdWxsID0gZGVzY3JpcHRvci5mdWxsZm9ybSA9PT0gdHJ1ZTtcblx0XHRmdWxsZm9ybXMgPSBkZXNjcmlwdG9yLmZ1bGxmb3JtcyBpbnN0YW5jZW9mIEFycmF5ID8gZGVzY3JpcHRvci5mdWxsZm9ybXMgOiBbXTtcblx0XHRlID0gZGVzY3JpcHRvci5leHBvbmVudCAhPT0gdW5kZWZpbmVkID8gZGVzY3JpcHRvci5leHBvbmVudCA6IC0xO1xuXHRcdG51bSA9IE51bWJlcihhcmcpO1xuXHRcdG5lZyA9IG51bSA8IDA7XG5cdFx0Y2VpbCA9IGJhc2UgPiAyID8gMTAwMCA6IDEwMjQ7XG5cblx0XHQvLyBGbGlwcGluZyBhIG5lZ2F0aXZlIG51bWJlciB0byBkZXRlcm1pbmUgdGhlIHNpemVcblx0XHRpZiAobmVnKSB7XG5cdFx0XHRudW0gPSAtbnVtO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluaW5nIHRoZSBleHBvbmVudFxuXHRcdGlmIChlID09PSAtMSB8fCBpc05hTihlKSkge1xuXHRcdFx0ZSA9IE1hdGguZmxvb3IoTWF0aC5sb2cobnVtKSAvIE1hdGgubG9nKGNlaWwpKTtcblxuXHRcdFx0aWYgKGUgPCAwKSB7XG5cdFx0XHRcdGUgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEV4Y2VlZGluZyBzdXBwb3J0ZWQgbGVuZ3RoLCB0aW1lIHRvIHJlZHVjZSAmIG11bHRpcGx5XG5cdFx0aWYgKGUgPiA4KSB7XG5cdFx0XHRlID0gODtcblx0XHR9XG5cblx0XHQvLyBaZXJvIGlzIG5vdyBhIHNwZWNpYWwgY2FzZSBiZWNhdXNlIGJ5dGVzIGRpdmlkZSBieSAxXG5cdFx0aWYgKG51bSA9PT0gMCkge1xuXHRcdFx0cmVzdWx0WzBdID0gMDtcblx0XHRcdHJlc3VsdFsxXSA9IHVuaXggPyBcIlwiIDogc3ltYm9sW3N0YW5kYXJkXVtiaXRzID8gXCJiaXRzXCIgOiBcImJ5dGVzXCJdW2VdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWwgPSBudW0gLyAoYmFzZSA9PT0gMiA/IE1hdGgucG93KDIsIGUgKiAxMCkgOiBNYXRoLnBvdygxMDAwLCBlKSk7XG5cblx0XHRcdGlmIChiaXRzKSB7XG5cdFx0XHRcdHZhbCA9IHZhbCAqIDg7XG5cblx0XHRcdFx0aWYgKHZhbCA+PSBjZWlsICYmIGUgPCA4KSB7XG5cdFx0XHRcdFx0dmFsID0gdmFsIC8gY2VpbDtcblx0XHRcdFx0XHRlKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmVzdWx0WzBdID0gTnVtYmVyKHZhbC50b0ZpeGVkKGUgPiAwID8gcm91bmQgOiAwKSk7XG5cdFx0XHRyZXN1bHRbMV0gPSBiYXNlID09PSAxMCAmJiBlID09PSAxID8gYml0cyA/IFwia2JcIiA6IFwia0JcIiA6IHN5bWJvbFtzdGFuZGFyZF1bYml0cyA/IFwiYml0c1wiIDogXCJieXRlc1wiXVtlXTtcblxuXHRcdFx0aWYgKHVuaXgpIHtcblx0XHRcdFx0cmVzdWx0WzFdID0gc3RhbmRhcmQgPT09IFwiamVkZWNcIiA/IHJlc3VsdFsxXS5jaGFyQXQoMCkgOiBlID4gMCA/IHJlc3VsdFsxXS5yZXBsYWNlKC9CJC8sIFwiXCIpIDogcmVzdWx0WzFdO1xuXG5cdFx0XHRcdGlmIChiLnRlc3QocmVzdWx0WzFdKSkge1xuXHRcdFx0XHRcdHJlc3VsdFswXSA9IE1hdGguZmxvb3IocmVzdWx0WzBdKTtcblx0XHRcdFx0XHRyZXN1bHRbMV0gPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRGVjb3JhdGluZyBhICdkaWZmJ1xuXHRcdGlmIChuZWcpIHtcblx0XHRcdHJlc3VsdFswXSA9IC1yZXN1bHRbMF07XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHlpbmcgY3VzdG9tIHN5bWJvbFxuXHRcdHJlc3VsdFsxXSA9IHN5bWJvbHNbcmVzdWx0WzFdXSB8fCByZXN1bHRbMV07XG5cblx0XHQvLyBSZXR1cm5pbmcgQXJyYXksIE9iamVjdCwgb3IgU3RyaW5nIChkZWZhdWx0KVxuXHRcdGlmIChvdXRwdXQgPT09IFwiYXJyYXlcIikge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cblx0XHRpZiAob3V0cHV0ID09PSBcImV4cG9uZW50XCIpIHtcblx0XHRcdHJldHVybiBlO1xuXHRcdH1cblxuXHRcdGlmIChvdXRwdXQgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdHJldHVybiB7IHZhbHVlOiByZXN1bHRbMF0sIHN1ZmZpeDogcmVzdWx0WzFdLCBzeW1ib2w6IHJlc3VsdFsxXSB9O1xuXHRcdH1cblxuXHRcdGlmIChmdWxsKSB7XG5cdFx0XHRyZXN1bHRbMV0gPSBmdWxsZm9ybXNbZV0gPyBmdWxsZm9ybXNbZV0gOiBmdWxsZm9ybVtzdGFuZGFyZF1bZV0gKyAoYml0cyA/IFwiYml0XCIgOiBcImJ5dGVcIikgKyAocmVzdWx0WzBdID09PSAxID8gXCJcIiA6IFwic1wiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oc3BhY2VyKTtcblx0fVxuXG5cdC8vIFBhcnRpYWwgYXBwbGljYXRpb24gZm9yIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmdcblx0ZmlsZXNpemUucGFydGlhbCA9IGZ1bmN0aW9uIChvcHQpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuXHRcdFx0cmV0dXJuIGZpbGVzaXplKGFyZywgb3B0KTtcblx0XHR9O1xuXHR9O1xuXG5cdC8vIENvbW1vbkpTLCBBTUQsIHNjcmlwdCB0YWdcblx0aWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmaWxlc2l6ZTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZmlsZXNpemU7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0Z2xvYmFsLmZpbGVzaXplID0gZmlsZXNpemU7XG5cdH1cbn0pKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBnbG9iYWwpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIE5PREVfTElTVF9DTEFTU0VTID0ge1xuICAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nOiB0cnVlLFxuICAnW29iamVjdCBOb2RlTGlzdF0nOiB0cnVlLFxuICAnW29iamVjdCBSYWRpb05vZGVMaXN0XSc6IHRydWVcbn07XG5cbi8vIC50eXBlIHZhbHVlcyBmb3IgZWxlbWVudHMgd2hpY2ggY2FuIGFwcGVhciBpbiAuZWxlbWVudHMgYW5kIHNob3VsZCBiZSBpZ25vcmVkXG52YXIgSUdOT1JFRF9FTEVNRU5UX1RZUEVTID0ge1xuICAnYnV0dG9uJzogdHJ1ZSxcbiAgJ2ZpZWxkc2V0JzogdHJ1ZSxcbiAgLy8gJ2tleWdlbic6IHRydWUsXG4gIC8vICdvdXRwdXQnOiB0cnVlLFxuICAncmVzZXQnOiB0cnVlLFxuICAnc3VibWl0JzogdHJ1ZVxufTtcblxudmFyIENIRUNLRURfSU5QVVRfVFlQRVMgPSB7XG4gICdjaGVja2JveCc6IHRydWUsXG4gICdyYWRpbyc6IHRydWVcbn07XG5cbnZhciBUUklNX1JFID0gL15cXHMrfFxccyskL2c7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywoc3RyaW5nfEFycmF5LjxzdHJpbmc+KT59IGFuIG9iamVjdCBjb250YWluaW5nXG4gKiAgIHN1Ym1pdHRhYmxlIHZhbHVlKHMpIGhlbGQgaW4gdGhlIGZvcm0ncyAuZWxlbWVudHMgY29sbGVjdGlvbiwgd2l0aFxuICogICBwcm9wZXJ0aWVzIG5hbWVkIGFzIHBlciBlbGVtZW50IG5hbWVzIG9yIGlkcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Rm9ybURhdGEoZm9ybSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHsgdHJpbTogZmFsc2UgfSA6IGFyZ3VtZW50c1sxXTtcblxuICBpZiAoIWZvcm0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgZm9ybSBpcyByZXF1aXJlZCBieSBnZXRGb3JtRGF0YSwgd2FzIGdpdmVuIGZvcm09JyArIGZvcm0pO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIGVsZW1lbnROYW1lID0gdW5kZWZpbmVkO1xuICB2YXIgZWxlbWVudE5hbWVzID0gW107XG4gIHZhciBlbGVtZW50TmFtZUxvb2t1cCA9IHt9O1xuXG4gIC8vIEdldCB1bmlxdWUgc3VibWl0dGFibGUgZWxlbWVudCBuYW1lcyBmb3IgdGhlIGZvcm1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBmb3JtLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBlbGVtZW50ID0gZm9ybS5lbGVtZW50c1tpXTtcbiAgICBpZiAoSUdOT1JFRF9FTEVNRU5UX1RZUEVTW2VsZW1lbnQudHlwZV0gfHwgZWxlbWVudC5kaXNhYmxlZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGVsZW1lbnROYW1lID0gZWxlbWVudC5uYW1lIHx8IGVsZW1lbnQuaWQ7XG4gICAgaWYgKGVsZW1lbnROYW1lICYmICFlbGVtZW50TmFtZUxvb2t1cFtlbGVtZW50TmFtZV0pIHtcbiAgICAgIGVsZW1lbnROYW1lcy5wdXNoKGVsZW1lbnROYW1lKTtcbiAgICAgIGVsZW1lbnROYW1lTG9va3VwW2VsZW1lbnROYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRXh0cmFjdCBlbGVtZW50IGRhdGEgbmFtZS1ieS1uYW1lIGZvciBjb25zaXN0ZW50IGhhbmRsaW5nIG9mIHNwZWNpYWwgY2FzZXNcbiAgLy8gYXJvdW5kIGVsZW1lbnRzIHdoaWNoIGNvbnRhaW4gbXVsdGlwbGUgaW5wdXRzLlxuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsZW1lbnROYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lc1tpXTtcbiAgICB2YXIgdmFsdWUgPSBnZXROYW1lZEZvcm1FbGVtZW50RGF0YShmb3JtLCBlbGVtZW50TmFtZSwgb3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGRhdGFbZWxlbWVudE5hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyhzdHJpbmd8QXJyYXkuPHN0cmluZz4pfSBzdWJtaXR0YWJsZSB2YWx1ZShzKSBpbiB0aGUgZm9ybSBmb3IgYVxuICogICBuYW1lZCBlbGVtZW50IGZyb20gaXRzIC5lbGVtZW50cyBjb2xsZWN0aW9uLCBvciBudWxsIGlmIHRoZXJlIHdhcyBub1xuICogICBlbGVtZW50IHdpdGggdGhhdCBuYW1lIG9yIHRoZSBlbGVtZW50IGhhZCBubyBzdWJtaXR0YWJsZSB2YWx1ZShzKS5cbiAqL1xuZnVuY3Rpb24gZ2V0TmFtZWRGb3JtRWxlbWVudERhdGEoZm9ybSwgZWxlbWVudE5hbWUpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7IHRyaW06IGZhbHNlIH0gOiBhcmd1bWVudHNbMl07XG5cbiAgaWYgKCFmb3JtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGZvcm0gaXMgcmVxdWlyZWQgYnkgZ2V0TmFtZWRGb3JtRWxlbWVudERhdGEsIHdhcyBnaXZlbiBmb3JtPScgKyBmb3JtKTtcbiAgfVxuICBpZiAoIWVsZW1lbnROYW1lICYmIHRvU3RyaW5nLmNhbGwoZWxlbWVudE5hbWUpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBmb3JtIGVsZW1lbnQgbmFtZSBpcyByZXF1aXJlZCBieSBnZXROYW1lZEZvcm1FbGVtZW50RGF0YSwgd2FzIGdpdmVuIGVsZW1lbnROYW1lPScgKyBlbGVtZW50TmFtZSk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGZvcm0uZWxlbWVudHNbZWxlbWVudE5hbWVdO1xuICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudC5kaXNhYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFOT0RFX0xJU1RfQ0xBU1NFU1t0b1N0cmluZy5jYWxsKGVsZW1lbnQpXSkge1xuICAgIHJldHVybiBnZXRGb3JtRWxlbWVudFZhbHVlKGVsZW1lbnQsIG9wdGlvbnMudHJpbSk7XG4gIH1cblxuICAvLyBEZWFsIHdpdGggbXVsdGlwbGUgZm9ybSBjb250cm9scyB3aGljaCBoYXZlIHRoZSBzYW1lIG5hbWVcbiAgdmFyIGRhdGEgPSBbXTtcbiAgdmFyIGFsbFJhZGlvcyA9IHRydWU7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWxlbWVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoZWxlbWVudFtpXS5kaXNhYmxlZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbGxSYWRpb3MgJiYgZWxlbWVudFtpXS50eXBlICE9PSAncmFkaW8nKSB7XG4gICAgICBhbGxSYWRpb3MgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gZ2V0Rm9ybUVsZW1lbnRWYWx1ZShlbGVtZW50W2ldLCBvcHRpb25zLnRyaW0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBkYXRhID0gZGF0YS5jb25jYXQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgYW4gZWxlbWVudCB3aXRoIG11bHRpcGxlIHNhbWUtbmFtZWQgaW5wdXRzIHdoaWNoIHdlcmUgYWxsXG4gIC8vIHJhZGlvIGJ1dHRvbnM6IGlmIHRoZXJlIHdhcyBhIHNlbGVjdGVkIHZhbHVlLCBvbmx5IHJldHVybiB0aGUgdmFsdWUuXG4gIGlmIChhbGxSYWRpb3MgJiYgZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZGF0YVswXTtcbiAgfVxuXG4gIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBkYXRhIDogbnVsbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IGEgZm9ybSBlbGVtZW50LlxuICogQHBhcmFtIHtib29sZWFtfSB0cmltIHNob3VsZCB2YWx1ZXMgZm9yIHRleHQgZW50cnkgaW5wdXRzIGJlIHRyaW1tZWQ/XG4gKiBAcmV0dXJuIHsoc3RyaW5nfEFycmF5LjxzdHJpbmc+fEZpbGV8QXJyYXkuPEZpbGU+KX0gdGhlIGVsZW1lbnQncyBzdWJtaXR0YWJsZVxuICogICB2YWx1ZShzKSwgb3IgbnVsbCBpZiBpdCBoYWQgbm9uZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Rm9ybUVsZW1lbnRWYWx1ZShlbGVtZW50LCB0cmltKSB7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gIGlmICh0eXBlID09PSAnc2VsZWN0LW9uZScpIHtcbiAgICBpZiAoZWxlbWVudC5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgdmFsdWUgPSBlbGVtZW50Lm9wdGlvbnNbZWxlbWVudC5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdzZWxlY3QtbXVsdGlwbGUnKSB7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsZW1lbnQub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChlbGVtZW50Lm9wdGlvbnNbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgdmFsdWUucHVzaChlbGVtZW50Lm9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8vIElmIGEgZmlsZSBpbnB1dCBkb2Vzbid0IGhhdmUgYSBmaWxlcyBhdHRyaWJ1dGUsIGZhbGwgdGhyb3VnaCB0byB1c2luZyBpdHNcbiAgLy8gdmFsdWUgYXR0cmlidXRlLlxuICBpZiAodHlwZSA9PT0gJ2ZpbGUnICYmICdmaWxlcycgaW4gZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50Lm11bHRpcGxlKSB7XG4gICAgICB2YWx1ZSA9IHNsaWNlLmNhbGwoZWxlbWVudC5maWxlcyk7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2hvdWxkIGJlIG51bGwgaWYgbm90IHByZXNlbnQsIGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAgICAgdmFsdWUgPSBlbGVtZW50LmZpbGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoIUNIRUNLRURfSU5QVVRfVFlQRVNbdHlwZV0pIHtcbiAgICB2YWx1ZSA9IHRyaW0gPyBlbGVtZW50LnZhbHVlLnJlcGxhY2UoVFJJTV9SRSwgJycpIDogZWxlbWVudC52YWx1ZTtcbiAgfSBlbHNlIGlmIChlbGVtZW50LmNoZWNrZWQpIHtcbiAgICB2YWx1ZSA9IGVsZW1lbnQudmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmdldEZvcm1EYXRhLmdldE5hbWVkRm9ybUVsZW1lbnREYXRhID0gZ2V0TmFtZWRGb3JtRWxlbWVudERhdGE7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdldEZvcm1EYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwibW9kdWxlLmV4cG9ydHMgPSBFdmVudFxuXG5mdW5jdGlvbiBFdmVudCgpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gW11cblxuICAgIHJldHVybiB7IGJyb2FkY2FzdDogYnJvYWRjYXN0LCBsaXN0ZW46IGV2ZW50IH1cblxuICAgIGZ1bmN0aW9uIGJyb2FkY2FzdCh2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2ldKHZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXZlbnQobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpXG5cbiAgICAgICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyXG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcilcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwidmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gU291cmNlXG5cbmZ1bmN0aW9uIFNvdXJjZShicm9hZGNhc3Rlcikge1xuICAgIHZhciB0dXBsZSA9IEV2ZW50KClcblxuICAgIGJyb2FkY2FzdGVyKHR1cGxlLmJyb2FkY2FzdClcblxuICAgIHJldHVybiB0dXBsZS5saXN0ZW5cbn1cbiIsInZhciB0b3BMZXZlbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9XG52YXIgbWluRG9jID0gcmVxdWlyZSgnbWluLWRvY3VtZW50Jyk7XG5cbnZhciBkb2NjeTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkb2NjeSA9IGRvY3VtZW50O1xufSBlbHNlIHtcbiAgICBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jY3k7XG4iLCJ2YXIgd2luO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbiA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbiA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgIHdpbiA9IHNlbGY7XG59IGVsc2Uge1xuICAgIHdpbiA9IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbjtcbiIsIm1vZHVsZS5leHBvcnRzID0gc2hpbVxuXG5mdW5jdGlvbiBzaGltIChlbGVtZW50LCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJ1xuICAgIH1cblxuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJ25vbmUnIDogJydcbn1cbiIsIi8vIEh1bWFuaXplRHVyYXRpb24uanMgLSBodHRwOi8vZ2l0LmlvL2owSGdtUVxuXG47KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxhbmd1YWdlcyA9IHtcbiAgICBhcjoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAn2LPZhtipJyA6ICfYs9mG2YjYp9iqJyB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ9i02YfYsScgOiAn2KPYtNmH2LEnIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICfYo9iz2KjZiNi5JyA6ICfYo9iz2KfYqNmK2LknIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICfZitmI2YUnIDogJ9ij2YrYp9mFJyB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAn2LPYp9i52KknIDogJ9iz2KfYudin2KonIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICfYr9mC2YrZgtipJyA6ICfYr9mC2KfYptmCJyB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAn2KvYp9mG2YrYqScgOiAn2KvZiNin2YbZiicgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICfYrNiy2KEg2YXZhiDYp9mE2KvYp9mG2YrYqScgOiAn2KPYrNiy2KfYoSDZhdmGINin2YTYq9in2YbZitipJyB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBjYToge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdhbnknICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21lcycgKyAoYyA9PT0gMSA/ICcnIDogJ29zJykgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnc2V0bWFuJyArIChjID09PSAxID8gJ2EnIDogJ2VzJykgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnZGknICsgKGMgPT09IDEgPyAnYScgOiAnZXMnKSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdob3InICsgKGMgPT09IDEgPyAnYScgOiAnZXMnKSB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaW51dCcgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdzZWdvbicgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWlsaXNlZ29uJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBkZWNpbWFsOiAnLCdcbiAgICB9LFxuICAgIGNzOiB7XG4gICAgICB5OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydyb2snLCAncm9rdScsICdyb2t5JywgJ2xldCddW2dldEN6ZWNoRm9ybShjKV0gfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydtxJtzw61jJywgJ23Em3PDrWNlJywgJ23Em3PDrWNlJywgJ23Em3PDrWPFryddW2dldEN6ZWNoRm9ybShjKV0gfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ3TDvWRlbicsICd0w71kbmUnLCAndMO9ZG55JywgJ3TDvWRuxa8nXVtnZXRDemVjaEZvcm0oYyldIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydkZW4nLCAnZG5lJywgJ2RueScsICdkbsOtJ11bZ2V0Q3plY2hGb3JtKGMpXSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnaG9kaW5hJywgJ2hvZGlueScsICdob2RpbnknLCAnaG9kaW4nXVtnZXRDemVjaEZvcm0oYyldIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydtaW51dGEnLCAnbWludXR5JywgJ21pbnV0eScsICdtaW51dCddW2dldEN6ZWNoRm9ybShjKV0gfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ3Nla3VuZGEnLCAnc2VrdW5keScsICdzZWt1bmR5JywgJ3Nla3VuZCddW2dldEN6ZWNoRm9ybShjKV0gfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydtaWxpc2VrdW5kYScsICdtaWxpc2VrdW5keScsICdtaWxpc2VrdW5keScsICdtaWxpc2VrdW5kJ11bZ2V0Q3plY2hGb3JtKGMpXSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBkYToge1xuICAgICAgeTogJ8OlcicsXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtw6VuZWQnICsgKGMgPT09IDEgPyAnJyA6ICdlcicpIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3VnZScgKyAoYyA9PT0gMSA/ICcnIDogJ3InKSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdkYWcnICsgKGMgPT09IDEgPyAnJyA6ICdlJykgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAndGltZScgKyAoYyA9PT0gMSA/ICcnIDogJ3InKSB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaW51dCcgKyAoYyA9PT0gMSA/ICcnIDogJ3RlcicpIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3Nla3VuZCcgKyAoYyA9PT0gMSA/ICcnIDogJ2VyJykgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbGxpc2VrdW5kJyArIChjID09PSAxID8gJycgOiAnZXInKSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBkZToge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdKYWhyJyArIChjID09PSAxID8gJycgOiAnZScpIH0sXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdNb25hdCcgKyAoYyA9PT0gMSA/ICcnIDogJ2UnKSB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdXb2NoZScgKyAoYyA9PT0gMSA/ICcnIDogJ24nKSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdUYWcnICsgKGMgPT09IDEgPyAnJyA6ICdlJykgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnU3R1bmRlJyArIChjID09PSAxID8gJycgOiAnbicpIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ01pbnV0ZScgKyAoYyA9PT0gMSA/ICcnIDogJ24nKSB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdTZWt1bmRlJyArIChjID09PSAxID8gJycgOiAnbicpIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdNaWxsaXNla3VuZGUnICsgKGMgPT09IDEgPyAnJyA6ICduJykgfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgZW46IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAneWVhcicgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbW9udGgnICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnd2VlaycgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdkYXknICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnaG91cicgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaW51dGUnICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnc2Vjb25kJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaWxsaXNlY29uZCcgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgZGVjaW1hbDogJy4nXG4gICAgfSxcbiAgICBlczoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdhw7FvJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtZXMnICsgKGMgPT09IDEgPyAnJyA6ICdlcycpIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3NlbWFuYScgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdkw61hJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2hvcmEnICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWludXRvJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3NlZ3VuZG8nICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbGlzZWd1bmRvJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBkZWNpbWFsOiAnLCdcbiAgICB9LFxuICAgIGZpOiB7XG4gICAgICB5OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICd2dW9zaScgOiAndnVvdHRhJyB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ2t1dWthdXNpJyA6ICdrdXVrYXV0dGEnIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3ZpaWtrbycgKyAoYyA9PT0gMSA/ICcnIDogJ2EnKSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdww6RpdsOkJyArIChjID09PSAxID8gJycgOiAnw6QnKSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICd0dW50aScgKyAoYyA9PT0gMSA/ICcnIDogJ2EnKSB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaW51dXR0aScgKyAoYyA9PT0gMSA/ICcnIDogJ2EnKSB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdzZWt1bnRpJyArIChjID09PSAxID8gJycgOiAnYScpIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaWxsaXNla3VudGknICsgKGMgPT09IDEgPyAnJyA6ICdhJykgfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgZnI6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnYW4nICsgKGMgPj0gMiA/ICdzJyA6ICcnKSB9LFxuICAgICAgbW86ICdtb2lzJyxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnc2VtYWluZScgKyAoYyA+PSAyID8gJ3MnIDogJycpIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2pvdXInICsgKGMgPj0gMiA/ICdzJyA6ICcnKSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdoZXVyZScgKyAoYyA+PSAyID8gJ3MnIDogJycpIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbnV0ZScgKyAoYyA+PSAyID8gJ3MnIDogJycpIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3NlY29uZGUnICsgKGMgPj0gMiA/ICdzJyA6ICcnKSB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWlsbGlzZWNvbmRlJyArIChjID49IDIgPyAncycgOiAnJykgfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgZ3I6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ8+Hz4HPjM69zr/PgicgOiAnz4fPgc+Mzr3Ouc6xJyB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ868zq7Ovc6xz4InIDogJ868zq7Ovc61z4InIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICfOtc6yzrTOv868zqzOtM6xJyA6ICfOtc6yzrTOv868zqzOtM61z4InIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICfOvM6tz4HOsScgOiAnzrzOrc+BzrXPgicgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ8+Oz4HOsScgOiAnz47Pgc61z4InIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICfOu861z4DPhM+MJyA6ICfOu861z4DPhM6sJyB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnzrTOtc+Fz4TOtc+Bz4zOu861z4DPhM6/JyA6ICfOtM61z4XPhM61z4HPjM67zrXPgM+EzrEnIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnz4fOuc67zrnOv8+Dz4TPjCDPhM6/z4UgzrTOtc+Fz4TOtc+Bzr/Ou86tz4DPhM6/z4UnIDogJ8+HzrnOu865zr/Pg8+Ezqwgz4TOv8+FIM60zrXPhc+EzrXPgc6/zrvOrc+Az4TOv8+FJyB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBodToge1xuICAgICAgeTogJ8OpdicsXG4gICAgICBtbzogJ2jDs25hcCcsXG4gICAgICB3OiAnaMOpdCcsXG4gICAgICBkOiAnbmFwJyxcbiAgICAgIGg6ICfDs3JhJyxcbiAgICAgIG06ICdwZXJjJyxcbiAgICAgIHM6ICdtw6Fzb2RwZXJjJyxcbiAgICAgIG1zOiAnZXpyZWRtw6Fzb2RwZXJjJyxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgaWQ6IHtcbiAgICAgIHk6ICd0YWh1bicsXG4gICAgICBtbzogJ2J1bGFuJyxcbiAgICAgIHc6ICdtaW5nZ3UnLFxuICAgICAgZDogJ2hhcmknLFxuICAgICAgaDogJ2phbScsXG4gICAgICBtOiAnbWVuaXQnLFxuICAgICAgczogJ2RldGlrJyxcbiAgICAgIG1zOiAnbWlsaWRldGlrJyxcbiAgICAgIGRlY2ltYWw6ICcuJ1xuICAgIH0sXG4gICAgaXM6IHtcbiAgICAgIHk6ICfDoXInLFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbcOhbnXDsCcgKyAoYyA9PT0gMSA/ICd1cicgOiAnaXInKSB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICd2aWsnICsgKGMgPT09IDEgPyAnYScgOiAndXInKSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdkYWcnICsgKGMgPT09IDEgPyAndXInIDogJ2FyJykgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAna2x1a2t1dMOtbScgKyAoYyA9PT0gMSA/ICdpJyA6ICdhcicpIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ23DrW7DunQnICsgKGMgPT09IDEgPyAnYScgOiAndXInKSB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdzZWvDum5kJyArIChjID09PSAxID8gJ2EnIDogJ3VyJykgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbGxpc2Vrw7puZCcgKyAoYyA9PT0gMSA/ICdhJyA6ICd1cicpIH0sXG4gICAgICBkZWNpbWFsOiAnLidcbiAgICB9LFxuICAgIGl0OiB7XG4gICAgICB5OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2FubicgKyAoYyA9PT0gMSA/ICdvJyA6ICdpJykgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21lcycgKyAoYyA9PT0gMSA/ICdlJyA6ICdpJykgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnc2V0dGltYW4nICsgKGMgPT09IDEgPyAnYScgOiAnZScpIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2dpb3JuJyArIChjID09PSAxID8gJ28nIDogJ2knKSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdvcicgKyAoYyA9PT0gMSA/ICdhJyA6ICdlJykgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWludXQnICsgKGMgPT09IDEgPyAnbycgOiAnaScpIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3NlY29uZCcgKyAoYyA9PT0gMSA/ICdvJyA6ICdpJykgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbGxpc2Vjb25kJyArIChjID09PSAxID8gJ28nIDogJ2knKSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBqYToge1xuICAgICAgeTogJ+W5tCcsXG4gICAgICBtbzogJ+aciCcsXG4gICAgICB3OiAn6YCxJyxcbiAgICAgIGQ6ICfml6UnLFxuICAgICAgaDogJ+aZgumWkycsXG4gICAgICBtOiAn5YiGJyxcbiAgICAgIHM6ICfnp5InLFxuICAgICAgbXM6ICfjg5/jg6rnp5InLFxuICAgICAgZGVjaW1hbDogJy4nXG4gICAgfSxcbiAgICBrbzoge1xuICAgICAgeTogJ+uFhCcsXG4gICAgICBtbzogJ+qwnOyblCcsXG4gICAgICB3OiAn7KO87J28JyxcbiAgICAgIGQ6ICfsnbwnLFxuICAgICAgaDogJ+yLnOqwhCcsXG4gICAgICBtOiAn67aEJyxcbiAgICAgIHM6ICfstIgnLFxuICAgICAgbXM6ICfrsIDrpqwg7LSIJyxcbiAgICAgIGRlY2ltYWw6ICcuJ1xuICAgIH0sXG4gICAgbHQ6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAoKGMgJSAxMCA9PT0gMCkgfHwgKGMgJSAxMDAgPj0gMTAgJiYgYyAlIDEwMCA8PSAyMCkpID8gJ21ldMWzJyA6ICdtZXRhaScgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydtxJdudW8nLCAnbcSXbmVzaWFpJywgJ23El25lc2nFsyddW2dldExpdGh1YW5pYW5Gb3JtKGMpXSB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnc2F2YWl0xJcnLCAnc2F2YWl0xJdzJywgJ3NhdmFpxI1pxbMnXVtnZXRMaXRodWFuaWFuRm9ybShjKV0gfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ2RpZW5hJywgJ2RpZW5vcycsICdkaWVuxbMnXVtnZXRMaXRodWFuaWFuRm9ybShjKV0gfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ3ZhbGFuZGEnLCAndmFsYW5kb3MnLCAndmFsYW5kxbMnXVtnZXRMaXRodWFuaWFuRm9ybShjKV0gfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ21pbnV0xJcnLCAnbWludXTEl3MnLCAnbWludcSNacWzJ11bZ2V0TGl0aHVhbmlhbkZvcm0oYyldIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydzZWt1bmTElycsICdzZWt1bmTEl3MnLCAnc2VrdW5kxb5pxbMnXVtnZXRMaXRodWFuaWFuRm9ybShjKV0gfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydtaWxpc2VrdW5kxJcnLCAnbWlsaXNla3VuZMSXcycsICdtaWxpc2VrdW5kxb5pxbMnXVtnZXRMaXRodWFuaWFuRm9ybShjKV0gfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgbXM6IHtcbiAgICAgIHk6ICd0YWh1bicsXG4gICAgICBtbzogJ2J1bGFuJyxcbiAgICAgIHc6ICdtaW5nZ3UnLFxuICAgICAgZDogJ2hhcmknLFxuICAgICAgaDogJ2phbScsXG4gICAgICBtOiAnbWluaXQnLFxuICAgICAgczogJ3NhYXQnLFxuICAgICAgbXM6ICdtaWxpc2FhdCcsXG4gICAgICBkZWNpbWFsOiAnLidcbiAgICB9LFxuICAgIG5sOiB7XG4gICAgICB5OiAnamFhcicsXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgPT09IDEgPyAnbWFhbmQnIDogJ21hYW5kZW4nIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA9PT0gMSA/ICd3ZWVrJyA6ICd3ZWtlbicgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ2RhZycgOiAnZGFnZW4nIH0sXG4gICAgICBoOiAndXVyJyxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ21pbnV1dCcgOiAnbWludXRlbicgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ3NlY29uZGUnIDogJ3NlY29uZGVuJyB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID09PSAxID8gJ21pbGxpc2Vjb25kZScgOiAnbWlsbGlzZWNvbmRlbicgfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgbm86IHtcbiAgICAgIHk6ICfDpXInLFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbcOlbmVkJyArIChjID09PSAxID8gJycgOiAnZXInKSB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICd1a2UnICsgKGMgPT09IDEgPyAnJyA6ICdyJykgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnZGFnJyArIChjID09PSAxID8gJycgOiAnZXInKSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICd0aW1lJyArIChjID09PSAxID8gJycgOiAncicpIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbnV0dCcgKyAoYyA9PT0gMSA/ICcnIDogJ2VyJykgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnc2VrdW5kJyArIChjID09PSAxID8gJycgOiAnZXInKSB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWlsbGlzZWt1bmQnICsgKGMgPT09IDEgPyAnJyA6ICdlcicpIH0sXG4gICAgICBkZWNpbWFsOiAnLCdcbiAgICB9LFxuICAgIHBsOiB7XG4gICAgICB5OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydyb2snLCAncm9rdScsICdsYXRhJywgJ2xhdCddW2dldFBvbGlzaEZvcm0oYyldIH0sXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsnbWllc2nEhWMnLCAnbWllc2nEhWNhJywgJ21pZXNpxIVjZScsICdtaWVzacSZY3knXVtnZXRQb2xpc2hGb3JtKGMpXSB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsndHlkemllxYQnLCAndHlnb2RuaWEnLCAndHlnb2RuaWUnLCAndHlnb2RuaSddW2dldFBvbGlzaEZvcm0oYyldIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydkemllxYQnLCAnZG5pYScsICdkbmknLCAnZG5pJ11bZ2V0UG9saXNoRm9ybShjKV0gfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ2dvZHppbmEnLCAnZ29kemlueScsICdnb2R6aW55JywgJ2dvZHppbiddW2dldFBvbGlzaEZvcm0oYyldIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydtaW51dGEnLCAnbWludXR5JywgJ21pbnV0eScsICdtaW51dCddW2dldFBvbGlzaEZvcm0oYyldIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWydzZWt1bmRhJywgJ3Nla3VuZHknLCAnc2VrdW5keScsICdzZWt1bmQnXVtnZXRQb2xpc2hGb3JtKGMpXSB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ21pbGlzZWt1bmRhJywgJ21pbGlzZWt1bmR5JywgJ21pbGlzZWt1bmR5JywgJ21pbGlzZWt1bmQnXVtnZXRQb2xpc2hGb3JtKGMpXSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBwdDoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdhbm8nICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPT0gMSA/ICdtZXNlcycgOiAnbcOqcycgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnc2VtYW5hJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ2RpYScgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdob3JhJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ21pbnV0bycgKyAoYyA9PT0gMSA/ICcnIDogJ3MnKSB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdzZWd1bmRvJyArIChjID09PSAxID8gJycgOiAncycpIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaWxpc3NlZ3VuZG8nICsgKGMgPT09IDEgPyAnJyA6ICdzJykgfSxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgcnU6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9C70LXRgicsICfQs9C+0LQnLCAn0LPQvtC00LAnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9C80LXRgdGP0YbQtdCyJywgJ9C80LXRgdGP0YYnLCAn0LzQtdGB0Y/RhtCwJ11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9C90LXQtNC10LvRjCcsICfQvdC10LTQtdC70Y8nLCAn0L3QtdC00LXQu9C4J11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9C00L3QtdC5JywgJ9C00LXQvdGMJywgJ9C00L3RjyddW2dldFNsYXZpY0Zvcm0oYyldIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfRh9Cw0YHQvtCyJywgJ9GH0LDRgScsICfRh9Cw0YHQsCddW2dldFNsYXZpY0Zvcm0oYyldIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfQvNC40L3Rg9GCJywgJ9C80LjQvdGD0YLQsCcsICfQvNC40L3Rg9GC0YsnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0YHQtdC60YPQvdC0JywgJ9GB0LXQutGD0L3QtNCwJywgJ9GB0LXQutGD0L3QtNGLJ11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfQvNC40LvQu9C40YHQtdC60YPQvdC0JywgJ9C80LjQu9C70LjRgdC10LrRg9C90LTQsCcsICfQvNC40LvQu9C40YHQtdC60YPQvdC00YsnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICB1azoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0YDQvtC60ZbQsicsICfRgNGW0LonLCAn0YDQvtC60LgnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9C80ZbRgdGP0YbRltCyJywgJ9C80ZbRgdGP0YbRjCcsICfQvNGW0YHRj9GG0ZYnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0L3QtdC00ZbQu9GMJywgJ9C90LXQtNGW0LvRjycsICfQvdC10LTRltC70ZYnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0LTQvdGW0LInLCAn0LTQtdC90YwnLCAn0LTQvdGWJ11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7IHJldHVybiBbJ9Cz0L7QtNC40L0nLCAn0LPQvtC00LjQvdCwJywgJ9Cz0L7QtNC40L3QuCddW2dldFNsYXZpY0Zvcm0oYyldIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfRhdCy0LjQu9C40L0nLCAn0YXQstC40LvQuNC90LAnLCAn0YXQstC40LvQuNC90LgnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFsn0YHQtdC60YPQvdC0JywgJ9GB0LXQutGD0L3QtNCwJywgJ9GB0LXQutGD0L3QtNC4J11bZ2V0U2xhdmljRm9ybShjKV0gfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gWyfQvNGW0LvRltGB0LXQutGD0L3QtCcsICfQvNGW0LvRltGB0LXQutGD0L3QtNCwJywgJ9C80ZbQu9GW0YHQtdC60YPQvdC00LgnXVtnZXRTbGF2aWNGb3JtKGMpXSB9LFxuICAgICAgZGVjaW1hbDogJywnXG4gICAgfSxcbiAgICBzdjoge1xuICAgICAgeTogJ8OlcicsXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtw6VuYWQnICsgKGMgPT09IDEgPyAnJyA6ICdlcicpIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3ZlY2snICsgKGMgPT09IDEgPyAnYScgOiAnb3InKSB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdkYWcnICsgKGMgPT09IDEgPyAnJyA6ICdhcicpIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gJ3RpbW0nICsgKGMgPT09IDEgPyAnZScgOiAnYXInKSB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHsgcmV0dXJuICdtaW51dCcgKyAoYyA9PT0gMSA/ICcnIDogJ2VyJykgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnc2VrdW5kJyArIChjID09PSAxID8gJycgOiAnZXInKSB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnbWlsbGlzZWt1bmQnICsgKGMgPT09IDEgPyAnJyA6ICdlcicpIH0sXG4gICAgICBkZWNpbWFsOiAnLCdcbiAgICB9LFxuICAgIHRyOiB7XG4gICAgICB5OiAnecSxbCcsXG4gICAgICBtbzogJ2F5JyxcbiAgICAgIHc6ICdoYWZ0YScsXG4gICAgICBkOiAnZ8O8bicsXG4gICAgICBoOiAnc2FhdCcsXG4gICAgICBtOiAnZGFraWthJyxcbiAgICAgIHM6ICdzYW5peWUnLFxuICAgICAgbXM6ICdtaWxpc2FuaXllJyxcbiAgICAgIGRlY2ltYWw6ICcsJ1xuICAgIH0sXG4gICAgdmk6IHtcbiAgICAgIHk6ICduxINtJyxcbiAgICAgIG1vOiAndGjDoW5nJyxcbiAgICAgIHc6ICd0deG6p24nLFxuICAgICAgZDogJ25nw6B5JyxcbiAgICAgIGg6ICdnaeG7nScsXG4gICAgICBtOiAncGjDunQnLFxuICAgICAgczogJ2dpw6J5JyxcbiAgICAgIG1zOiAnbWlsaSBnacOieScsXG4gICAgICBkZWNpbWFsOiAnLCdcbiAgICB9LFxuICAgIHpoX0NOOiB7XG4gICAgICB5OiAn5bm0JyxcbiAgICAgIG1vOiAn5Liq5pyIJyxcbiAgICAgIHc6ICflkagnLFxuICAgICAgZDogJ+WkqScsXG4gICAgICBoOiAn5bCP5pe2JyxcbiAgICAgIG06ICfliIbpkp8nLFxuICAgICAgczogJ+enkicsXG4gICAgICBtczogJ+avq+enkicsXG4gICAgICBkZWNpbWFsOiAnLidcbiAgICB9LFxuICAgIHpoX1RXOiB7XG4gICAgICB5OiAn5bm0JyxcbiAgICAgIG1vOiAn5YCL5pyIJyxcbiAgICAgIHc6ICflkagnLFxuICAgICAgZDogJ+WkqScsXG4gICAgICBoOiAn5bCP5pmCJyxcbiAgICAgIG06ICfliIbpkJgnLFxuICAgICAgczogJ+enkicsXG4gICAgICBtczogJ+avq+enkicsXG4gICAgICBkZWNpbWFsOiAnLidcbiAgICB9XG4gIH1cblxuICAvLyBZb3UgY2FuIGNyZWF0ZSBhIGh1bWFuaXplciwgd2hpY2ggcmV0dXJucyBhIGZ1bmN0aW9uIHdpdGggZGVmYXVsdFxuICAvLyBwYXJhbWV0ZXJzLlxuICBmdW5jdGlvbiBodW1hbml6ZXIgKHBhc3NlZE9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24gaHVtYW5pemVyIChtcywgaHVtYW5pemVyT3B0aW9ucykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQoe30sIHJlc3VsdCwgaHVtYW5pemVyT3B0aW9ucyB8fCB7fSlcbiAgICAgIHJldHVybiBkb0h1bWFuaXphdGlvbihtcywgb3B0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4gZXh0ZW5kKHJlc3VsdCwge1xuICAgICAgbGFuZ3VhZ2U6ICdlbicsXG4gICAgICBkZWxpbWl0ZXI6ICcsICcsXG4gICAgICBzcGFjZXI6ICcgJyxcbiAgICAgIGNvbmp1bmN0aW9uOiAnJyxcbiAgICAgIHNlcmlhbENvbW1hOiB0cnVlLFxuICAgICAgdW5pdHM6IFsneScsICdtbycsICd3JywgJ2QnLCAnaCcsICdtJywgJ3MnXSxcbiAgICAgIGxhbmd1YWdlczoge30sXG4gICAgICByb3VuZDogZmFsc2UsXG4gICAgICB1bml0TWVhc3VyZXM6IHtcbiAgICAgICAgeTogMzE1NTc2MDAwMDAsXG4gICAgICAgIG1vOiAyNjI5ODAwMDAwLFxuICAgICAgICB3OiA2MDQ4MDAwMDAsXG4gICAgICAgIGQ6IDg2NDAwMDAwLFxuICAgICAgICBoOiAzNjAwMDAwLFxuICAgICAgICBtOiA2MDAwMCxcbiAgICAgICAgczogMTAwMCxcbiAgICAgICAgbXM6IDFcbiAgICAgIH1cbiAgICB9LCBwYXNzZWRPcHRpb25zKVxuICB9XG5cbiAgLy8gVGhlIG1haW4gZnVuY3Rpb24gaXMganVzdCBhIHdyYXBwZXIgYXJvdW5kIGEgZGVmYXVsdCBodW1hbml6ZXIuXG4gIHZhciBodW1hbml6ZUR1cmF0aW9uID0gaHVtYW5pemVyKHt9KVxuXG4gIC8vIGRvSHVtYW5pemF0aW9uIGRvZXMgdGhlIGJ1bGsgb2YgdGhlIHdvcmsuXG4gIGZ1bmN0aW9uIGRvSHVtYW5pemF0aW9uIChtcywgb3B0aW9ucykge1xuICAgIHZhciBpLCBsZW4sIHBpZWNlXG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIHBvc2l0aXZlIG51bWJlci5cbiAgICAvLyBIYXMgdGhlIG5pY2Ugc2lkZWZmZWN0IG9mIHR1cm5pbmcgTnVtYmVyIG9iamVjdHMgaW50byBwcmltaXRpdmVzLlxuICAgIG1zID0gTWF0aC5hYnMobXMpXG5cbiAgICB2YXIgZGljdGlvbmFyeSA9IG9wdGlvbnMubGFuZ3VhZ2VzW29wdGlvbnMubGFuZ3VhZ2VdIHx8IGxhbmd1YWdlc1tvcHRpb25zLmxhbmd1YWdlXVxuICAgIGlmICghZGljdGlvbmFyeSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBsYW5ndWFnZSAnICsgZGljdGlvbmFyeSArICcuJylcbiAgICB9XG5cbiAgICB2YXIgcGllY2VzID0gW11cblxuICAgIC8vIFN0YXJ0IGF0IHRoZSB0b3AgYW5kIGtlZXAgcmVtb3ZpbmcgdW5pdHMsIGJpdCBieSBiaXQuXG4gICAgdmFyIHVuaXROYW1lLCB1bml0TVMsIHVuaXRDb3VudFxuICAgIGZvciAoaSA9IDAsIGxlbiA9IG9wdGlvbnMudW5pdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHVuaXROYW1lID0gb3B0aW9ucy51bml0c1tpXVxuICAgICAgdW5pdE1TID0gb3B0aW9ucy51bml0TWVhc3VyZXNbdW5pdE5hbWVdXG5cbiAgICAgIC8vIFdoYXQncyB0aGUgbnVtYmVyIG9mIGZ1bGwgdW5pdHMgd2UgY2FuIGZpdD9cbiAgICAgIGlmIChpICsgMSA9PT0gbGVuKSB7XG4gICAgICAgIHVuaXRDb3VudCA9IG1zIC8gdW5pdE1TXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bml0Q291bnQgPSBNYXRoLmZsb29yKG1zIC8gdW5pdE1TKVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIHN0cmluZy5cbiAgICAgIHBpZWNlcy5wdXNoKHtcbiAgICAgICAgdW5pdENvdW50OiB1bml0Q291bnQsXG4gICAgICAgIHVuaXROYW1lOiB1bml0TmFtZVxuICAgICAgfSlcblxuICAgICAgLy8gUmVtb3ZlIHdoYXQgd2UganVzdCBmaWd1cmVkIG91dC5cbiAgICAgIG1zIC09IHVuaXRDb3VudCAqIHVuaXRNU1xuICAgIH1cblxuICAgIHZhciBmaXJzdE9jY3VwaWVkVW5pdEluZGV4ID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwaWVjZXNbaV0udW5pdENvdW50KSB7XG4gICAgICAgIGZpcnN0T2NjdXBpZWRVbml0SW5kZXggPSBpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucm91bmQpIHtcbiAgICAgIHZhciByYXRpb1RvTGFyZ2VyVW5pdCwgcHJldmlvdXNQaWVjZVxuICAgICAgZm9yIChpID0gcGllY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHBpZWNlID0gcGllY2VzW2ldXG4gICAgICAgIHBpZWNlLnVuaXRDb3VudCA9IE1hdGgucm91bmQocGllY2UudW5pdENvdW50KVxuXG4gICAgICAgIGlmIChpID09PSAwKSB7IGJyZWFrIH1cblxuICAgICAgICBwcmV2aW91c1BpZWNlID0gcGllY2VzW2kgLSAxXVxuXG4gICAgICAgIHJhdGlvVG9MYXJnZXJVbml0ID0gb3B0aW9ucy51bml0TWVhc3VyZXNbcHJldmlvdXNQaWVjZS51bml0TmFtZV0gLyBvcHRpb25zLnVuaXRNZWFzdXJlc1twaWVjZS51bml0TmFtZV1cbiAgICAgICAgaWYgKChwaWVjZS51bml0Q291bnQgJSByYXRpb1RvTGFyZ2VyVW5pdCkgPT09IDAgfHwgKG9wdGlvbnMubGFyZ2VzdCAmJiAoKG9wdGlvbnMubGFyZ2VzdCAtIDEpIDwgKGkgLSBmaXJzdE9jY3VwaWVkVW5pdEluZGV4KSkpKSB7XG4gICAgICAgICAgcHJldmlvdXNQaWVjZS51bml0Q291bnQgKz0gcGllY2UudW5pdENvdW50IC8gcmF0aW9Ub0xhcmdlclVuaXRcbiAgICAgICAgICBwaWVjZS51bml0Q291bnQgPSAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW11cbiAgICBmb3IgKGkgPSAwLCBwaWVjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHBpZWNlID0gcGllY2VzW2ldXG4gICAgICBpZiAocGllY2UudW5pdENvdW50KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJlbmRlcihwaWVjZS51bml0Q291bnQsIHBpZWNlLnVuaXROYW1lLCBkaWN0aW9uYXJ5LCBvcHRpb25zKSlcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IG9wdGlvbnMubGFyZ2VzdCkgeyBicmVhayB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgIGlmICghb3B0aW9ucy5jb25qdW5jdGlvbiB8fCByZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihvcHRpb25zLmRlbGltaXRlcilcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4ob3B0aW9ucy5jb25qdW5jdGlvbilcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zbGljZSgwLCAtMSkuam9pbihvcHRpb25zLmRlbGltaXRlcikgKyAob3B0aW9ucy5zZXJpYWxDb21tYSA/ICcsJyA6ICcnKSArIG9wdGlvbnMuY29uanVuY3Rpb24gKyByZXN1bHQuc2xpY2UoLTEpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZW5kZXIoMCwgb3B0aW9ucy51bml0c1tvcHRpb25zLnVuaXRzLmxlbmd0aCAtIDFdLCBkaWN0aW9uYXJ5LCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlciAoY291bnQsIHR5cGUsIGRpY3Rpb25hcnksIG9wdGlvbnMpIHtcbiAgICB2YXIgZGVjaW1hbFxuICAgIGlmIChvcHRpb25zLmRlY2ltYWwgPT09IHZvaWQgMCkge1xuICAgICAgZGVjaW1hbCA9IGRpY3Rpb25hcnkuZGVjaW1hbFxuICAgIH0gZWxzZSB7XG4gICAgICBkZWNpbWFsID0gb3B0aW9ucy5kZWNpbWFsXG4gICAgfVxuXG4gICAgdmFyIGNvdW50U3RyID0gY291bnQudG9TdHJpbmcoKS5yZXBsYWNlKCcuJywgZGVjaW1hbClcblxuICAgIHZhciBkaWN0aW9uYXJ5VmFsdWUgPSBkaWN0aW9uYXJ5W3R5cGVdXG4gICAgdmFyIHdvcmRcbiAgICBpZiAodHlwZW9mIGRpY3Rpb25hcnlWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29yZCA9IGRpY3Rpb25hcnlWYWx1ZShjb3VudClcbiAgICB9IGVsc2Uge1xuICAgICAgd29yZCA9IGRpY3Rpb25hcnlWYWx1ZVxuICAgIH1cblxuICAgIHJldHVybiBjb3VudFN0ciArIG9wdGlvbnMuc3BhY2VyICsgd29yZFxuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kIChkZXN0aW5hdGlvbikge1xuICAgIHZhciBzb3VyY2VcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25bcHJvcF0gPSBzb3VyY2VbcHJvcF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdGluYXRpb25cbiAgfVxuXG4gIC8vIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiBmb3IgQ3plY2ggbGFuZ3VhZ2UuXG4gIGZ1bmN0aW9uIGdldEN6ZWNoRm9ybSAoYykge1xuICAgIGlmIChjID09PSAxKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZiAoTWF0aC5mbG9vcihjKSAhPT0gYykge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKGMgJSAxMCA+PSAyICYmIGMgJSAxMCA8PSA0ICYmIGMgJSAxMDAgPCAxMCkge1xuICAgICAgcmV0dXJuIDJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDNcbiAgICB9XG4gIH1cblxuICAvLyBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gZm9yIFBvbGlzaCBsYW5ndWFnZS5cbiAgZnVuY3Rpb24gZ2V0UG9saXNoRm9ybSAoYykge1xuICAgIGlmIChjID09PSAxKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZiAoTWF0aC5mbG9vcihjKSAhPT0gYykge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKGMgJSAxMCA+PSAyICYmIGMgJSAxMCA8PSA0ICYmICEoYyAlIDEwMCA+IDEwICYmIGMgJSAxMDAgPCAyMCkpIHtcbiAgICAgIHJldHVybiAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAzXG4gICAgfVxuICB9XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIGZvciBSdXNzaWFuIGFuZCBVa3JhbmlhbiBsYW5ndWFnZXMuXG4gIGZ1bmN0aW9uIGdldFNsYXZpY0Zvcm0gKGMpIHtcbiAgICBpZiAoTWF0aC5mbG9vcihjKSAhPT0gYykge1xuICAgICAgcmV0dXJuIDJcbiAgICB9IGVsc2UgaWYgKChjICUgMTAwID49IDUgJiYgYyAlIDEwMCA8PSAyMCkgfHwgKGMgJSAxMCA+PSA1ICYmIGMgJSAxMCA8PSA5KSB8fCBjICUgMTAgPT09IDApIHtcbiAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIGlmIChjICUgMTAgPT09IDEpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfSBlbHNlIGlmIChjID4gMSkge1xuICAgICAgcmV0dXJuIDJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gIH1cblxuICAvLyBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gZm9yIExpdGh1YW5pYW4gbGFuZ3VhZ2UuXG4gIGZ1bmN0aW9uIGdldExpdGh1YW5pYW5Gb3JtIChjKSB7XG4gICAgaWYgKGMgPT09IDEgfHwgKGMgJSAxMCA9PT0gMSAmJiBjICUgMTAwID4gMjApKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZiAoTWF0aC5mbG9vcihjKSAhPT0gYyB8fCAoYyAlIDEwID49IDIgJiYgYyAlIDEwMCA+IDIwKSB8fCAoYyAlIDEwID49IDIgJiYgYyAlIDEwMCA8IDEwKSkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDJcbiAgICB9XG4gIH1cblxuICBodW1hbml6ZUR1cmF0aW9uLmdldFN1cHBvcnRlZExhbmd1YWdlcyA9IGZ1bmN0aW9uIGdldFN1cHBvcnRlZExhbmd1YWdlcyAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdXG4gICAgZm9yICh2YXIgbGFuZ3VhZ2UgaW4gbGFuZ3VhZ2VzKSB7XG4gICAgICBpZiAobGFuZ3VhZ2VzLmhhc093blByb3BlcnR5KGxhbmd1YWdlKSkge1xuICAgICAgICByZXN1bHQucHVzaChsYW5ndWFnZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgaHVtYW5pemVEdXJhdGlvbi5odW1hbml6ZXIgPSBodW1hbml6ZXJcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBodW1hbml6ZUR1cmF0aW9uXG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gaHVtYW5pemVEdXJhdGlvblxuICB9IGVsc2Uge1xuICAgIHRoaXMuaHVtYW5pemVEdXJhdGlvbiA9IGh1bWFuaXplRHVyYXRpb25cbiAgfVxufSkoKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc2VtaVxuIiwidmFyIHNwbGl0ID0gcmVxdWlyZSgnYnJvd3Nlci1zcGxpdCcpXG52YXIgQ2xhc3NMaXN0ID0gcmVxdWlyZSgnY2xhc3MtbGlzdCcpXG5cbnZhciB3ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdodG1sLWVsZW1lbnQnKSA6IHdpbmRvd1xudmFyIGRvY3VtZW50ID0gdy5kb2N1bWVudFxudmFyIFRleHQgPSB3LlRleHRcblxuZnVuY3Rpb24gY29udGV4dCAoKSB7XG5cbiAgdmFyIGNsZWFudXBGdW5jcyA9IFtdXG5cbiAgZnVuY3Rpb24gaCgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZSA9IG51bGxcbiAgICBmdW5jdGlvbiBpdGVtIChsKSB7XG4gICAgICB2YXIgclxuICAgICAgZnVuY3Rpb24gcGFyc2VDbGFzcyAoc3RyaW5nKSB7XG4gICAgICAgIC8vIE91ciBtaW5pbWFsIHBhcnNlciBkb2VzbuKAmXQgdW5kZXJzdGFuZCBlc2NhcGluZyBDU1Mgc3BlY2lhbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIGxpa2UgYCNgLiBEb27igJl0IHVzZSB0aGVtLiBNb3JlIHJlYWRpbmc6XG4gICAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9jc3MtZXNjYXBlcyAuXG5cbiAgICAgICAgdmFyIG0gPSBzcGxpdChzdHJpbmcsIC8oW1xcLiNdP1teXFxzIy5dKykvKVxuICAgICAgICBpZigvXlxcLnwjLy50ZXN0KG1bMV0pKVxuICAgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICBmb3JFYWNoKG0sIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgdmFyIHMgPSB2LnN1YnN0cmluZygxLHYubGVuZ3RoKVxuICAgICAgICAgIGlmKCF2KSByZXR1cm5cbiAgICAgICAgICBpZighZSlcbiAgICAgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHYpXG4gICAgICAgICAgZWxzZSBpZiAodlswXSA9PT0gJy4nKVxuICAgICAgICAgICAgQ2xhc3NMaXN0KGUpLmFkZChzKVxuICAgICAgICAgIGVsc2UgaWYgKHZbMF0gPT09ICcjJylcbiAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKCdpZCcsIHMpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmKGwgPT0gbnVsbClcbiAgICAgICAgO1xuICAgICAgZWxzZSBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGwpIHtcbiAgICAgICAgaWYoIWUpXG4gICAgICAgICAgcGFyc2VDbGFzcyhsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobCkpXG4gICAgICB9XG4gICAgICBlbHNlIGlmKCdudW1iZXInID09PSB0eXBlb2YgbFxuICAgICAgICB8fCAnYm9vbGVhbicgPT09IHR5cGVvZiBsXG4gICAgICAgIHx8IGwgaW5zdGFuY2VvZiBEYXRlXG4gICAgICAgIHx8IGwgaW5zdGFuY2VvZiBSZWdFeHAgKSB7XG4gICAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobC50b1N0cmluZygpKSlcbiAgICAgIH1cbiAgICAgIC8vdGhlcmUgbWlnaHQgYmUgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG4gICAgICBlbHNlIGlmIChpc0FycmF5KGwpKVxuICAgICAgICBmb3JFYWNoKGwsIGl0ZW0pXG4gICAgICBlbHNlIGlmKGlzTm9kZShsKSlcbiAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gbClcbiAgICAgIGVsc2UgaWYobCBpbnN0YW5jZW9mIFRleHQpXG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGwpXG4gICAgICBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIGwpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBsKSB7XG4gICAgICAgICAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGxba10pIHtcbiAgICAgICAgICAgIGlmKC9eb25cXHcrLy50ZXN0KGspKSB7XG4gICAgICAgICAgICAgIChmdW5jdGlvbiAoaywgbCkgeyAvLyBjYXB0dXJlIGssIGwgaW4gdGhlIGNsb3N1cmVcbiAgICAgICAgICAgICAgICBpZiAoZS5hZGRFdmVudExpc3RlbmVyKXtcbiAgICAgICAgICAgICAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihrLnN1YnN0cmluZygyKSwgbFtrXSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoay5zdWJzdHJpbmcoMiksIGxba10sIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgIGUuYXR0YWNoRXZlbnQoaywgbFtrXSlcbiAgICAgICAgICAgICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGUuZGV0YWNoRXZlbnQoaywgbFtrXSlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KShrLCBsKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgICBlW2tdID0gbFtrXSgpXG4gICAgICAgICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKGxba10oZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBlW2tdID0gdlxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZihrID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGxba10pIHtcbiAgICAgICAgICAgICAgZS5zdHlsZS5jc3NUZXh0ID0gbFtrXVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGZvciAodmFyIHMgaW4gbFtrXSkgKGZ1bmN0aW9uKHMsIHYpIHtcbiAgICAgICAgICAgICAgICBpZignZnVuY3Rpb24nID09PSB0eXBlb2Ygdikge1xuICAgICAgICAgICAgICAgICAgLy8gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCB2KCkpXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaCh2KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCB2YWwpXG4gICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxba11bc10ubWF0Y2goLyguKilcXFcrIWltcG9ydGFudFxcVyokLyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCBtYXRjaFsxXSwgJ2ltcG9ydGFudCcpXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlLnN0eWxlLnNldFByb3BlcnR5KHMsIGxba11bc10pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKHMsIGxba11bc10pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKGsgPT09ICdhdHRycycpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgaW4gbFtrXSkge1xuICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZSh2LCBsW2tdW3ZdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChrLnN1YnN0cigwLCA1KSA9PT0gXCJkYXRhLVwiKSB7XG4gICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrLCBsW2tdKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlW2tdID0gbFtrXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgbCkge1xuICAgICAgICAvL2Fzc3VtZSBpdCdzIGFuIG9ic2VydmFibGUhXG4gICAgICAgIHZhciB2ID0gbCgpXG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGlzTm9kZSh2KSA/IHYgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2KSlcblxuICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChsKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgaWYoaXNOb2RlKHYpICYmIHIucGFyZW50RWxlbWVudClcbiAgICAgICAgICAgIHIucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQodiwgciksIHIgPSB2XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgci50ZXh0Q29udGVudCA9IHZcbiAgICAgICAgfSkpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByXG4gICAgfVxuICAgIHdoaWxlKGFyZ3MubGVuZ3RoKVxuICAgICAgaXRlbShhcmdzLnNoaWZ0KCkpXG5cbiAgICByZXR1cm4gZVxuICB9XG5cbiAgaC5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xlYW51cEZ1bmNzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNsZWFudXBGdW5jc1tpXSgpXG4gICAgfVxuICAgIGNsZWFudXBGdW5jcy5sZW5ndGggPSAwXG4gIH1cblxuICByZXR1cm4gaFxufVxuXG52YXIgaCA9IG1vZHVsZS5leHBvcnRzID0gY29udGV4dCgpXG5oLmNvbnRleHQgPSBjb250ZXh0XG5cbmZ1bmN0aW9uIGlzTm9kZSAoZWwpIHtcbiAgcmV0dXJuIGVsICYmIGVsLm5vZGVOYW1lICYmIGVsLm5vZGVUeXBlXG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKGFyciwgZm4pIHtcbiAgaWYgKGFyci5mb3JFYWNoKSByZXR1cm4gYXJyLmZvckVhY2goZm4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBmbihhcnJbaV0sIGkpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJ1xufVxuXG5cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwidmFyIGNvbnRhaW5lcnMgPSBbXTsgLy8gd2lsbCBzdG9yZSBjb250YWluZXIgSFRNTEVsZW1lbnQgcmVmZXJlbmNlc1xudmFyIHN0eWxlRWxlbWVudHMgPSBbXTsgLy8gd2lsbCBzdG9yZSB7cHJlcGVuZDogSFRNTEVsZW1lbnQsIGFwcGVuZDogSFRNTEVsZW1lbnR9XG5cbnZhciB1c2FnZSA9ICdpbnNlcnQtY3NzOiBZb3UgbmVlZCB0byBwcm92aWRlIGEgQ1NTIHN0cmluZy4gVXNhZ2U6IGluc2VydENzcyhjc3NTdHJpbmdbLCBvcHRpb25zXSkuJztcblxuZnVuY3Rpb24gaW5zZXJ0Q3NzKGNzcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKGNzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1c2FnZSk7XG4gICAgfVxuXG4gICAgdmFyIHBvc2l0aW9uID0gb3B0aW9ucy5wcmVwZW5kID09PSB0cnVlID8gJ3ByZXBlbmQnIDogJ2FwcGVuZCc7XG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbnRhaW5lciA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbiAgICB2YXIgY29udGFpbmVySWQgPSBjb250YWluZXJzLmluZGV4T2YoY29udGFpbmVyKTtcblxuICAgIC8vIGZpcnN0IHRpbWUgd2Ugc2VlIHRoaXMgY29udGFpbmVyLCBjcmVhdGUgdGhlIG5lY2Vzc2FyeSBlbnRyaWVzXG4gICAgaWYgKGNvbnRhaW5lcklkID09PSAtMSkge1xuICAgICAgICBjb250YWluZXJJZCA9IGNvbnRhaW5lcnMucHVzaChjb250YWluZXIpIC0gMTtcbiAgICAgICAgc3R5bGVFbGVtZW50c1tjb250YWluZXJJZF0gPSB7fTtcbiAgICB9XG5cbiAgICAvLyB0cnkgdG8gZ2V0IHRoZSBjb3JyZXBvbmRpbmcgY29udGFpbmVyICsgcG9zaXRpb24gc3R5bGVFbGVtZW50LCBjcmVhdGUgaXQgb3RoZXJ3aXNlXG4gICAgdmFyIHN0eWxlRWxlbWVudDtcblxuICAgIGlmIChzdHlsZUVsZW1lbnRzW2NvbnRhaW5lcklkXSAhPT0gdW5kZWZpbmVkICYmIHN0eWxlRWxlbWVudHNbY29udGFpbmVySWRdW3Bvc2l0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0eWxlRWxlbWVudCA9IHN0eWxlRWxlbWVudHNbY29udGFpbmVySWRdW3Bvc2l0aW9uXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZUVsZW1lbnQgPSBzdHlsZUVsZW1lbnRzW2NvbnRhaW5lcklkXVtwb3NpdGlvbl0gPSBjcmVhdGVTdHlsZUVsZW1lbnQoKTtcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdwcmVwZW5kJykge1xuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGNvbnRhaW5lci5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3RyaXAgcG90ZW50aWFsIFVURi04IEJPTSBpZiBjc3Mgd2FzIHJlYWQgZnJvbSBhIGZpbGVcbiAgICBpZiAoY3NzLmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikgeyBjc3MgPSBjc3Muc3Vic3RyKDEsIGNzcy5sZW5ndGgpOyB9XG5cbiAgICAvLyBhY3R1YWxseSBhZGQgdGhlIHN0eWxlc2hlZXRcbiAgICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCArPSBjc3NcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgKz0gY3NzO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZUVsZW1lbnQ7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQoKSB7XG4gICAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICAgIHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0Q3NzO1xubW9kdWxlLmV4cG9ydHMuaW5zZXJ0Q3NzID0gaW5zZXJ0Q3NzO1xuIiwiLyohIG5wbS5pbS9pbnRlcnZhbG9tZXRlciAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBpbnRlcnZhbG9tZXRlcihjYiwgcmVxdWVzdCwgY2FuY2VsLCByZXF1ZXN0UGFyYW1ldGVyKSB7XG5cdHZhciByZXF1ZXN0SWQ7XG5cdHZhciBwcmV2aW91c0xvb3BUaW1lO1xuXHRmdW5jdGlvbiBsb29wKG5vdykge1xuXHRcdC8vIG11c3QgYmUgcmVxdWVzdGVkIGJlZm9yZSBjYigpIGJlY2F1c2UgdGhhdCBtaWdodCBjYWxsIC5zdG9wKClcblx0XHRyZXF1ZXN0SWQgPSByZXF1ZXN0KGxvb3AsIHJlcXVlc3RQYXJhbWV0ZXIpO1xuXG5cdFx0Ly8gY2FsbGVkIHdpdGggXCJtcyBzaW5jZSBsYXN0IGNhbGxcIi4gMCBvbiBzdGFydCgpXG5cdFx0Y2Iobm93IC0gKHByZXZpb3VzTG9vcFRpbWUgfHwgbm93KSk7XG5cblx0XHRwcmV2aW91c0xvb3BUaW1lID0gbm93O1xuXHR9XG5cdHJldHVybiB7XG5cdFx0c3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuXHRcdFx0aWYgKCFyZXF1ZXN0SWQpIHsgLy8gcHJldmVudCBkb3VibGUgc3RhcnRzXG5cdFx0XHRcdGxvb3AoMCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuXHRcdFx0Y2FuY2VsKHJlcXVlc3RJZCk7XG5cdFx0XHRyZXF1ZXN0SWQgPSBudWxsO1xuXHRcdFx0cHJldmlvdXNMb29wVGltZSA9IDA7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBmcmFtZUludGVydmFsb21ldGVyKGNiKSB7XG5cdHJldHVybiBpbnRlcnZhbG9tZXRlcihjYiwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSk7XG59XG5cbmZ1bmN0aW9uIHRpbWVySW50ZXJ2YWxvbWV0ZXIoY2IsIGRlbGF5KSB7XG5cdHJldHVybiBpbnRlcnZhbG9tZXRlcihjYiwgc2V0VGltZW91dCwgY2xlYXJUaW1lb3V0LCBkZWxheSk7XG59XG5cbmV4cG9ydHMuaW50ZXJ2YWxvbWV0ZXIgPSBpbnRlcnZhbG9tZXRlcjtcbmV4cG9ydHMuZnJhbWVJbnRlcnZhbG9tZXRlciA9IGZyYW1lSW50ZXJ2YWxvbWV0ZXI7XG5leHBvcnRzLnRpbWVySW50ZXJ2YWxvbWV0ZXIgPSB0aW1lckludGVydmFsb21ldGVyOyIsIi8qISBucG0uaW0vaXBob25lLWlubGluZS12aWRlbyAyLjIuMiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW50ZXJ2YWxvbWV0ZXIgPSByZXF1aXJlKCdpbnRlcnZhbG9tZXRlcicpO1xuXG5mdW5jdGlvbiBwcmV2ZW50RXZlbnQoZWxlbWVudCwgZXZlbnROYW1lLCB0ZXN0KSB7XG5cdGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuXHRcdGlmICghdGVzdCB8fCB0ZXN0KGVsZW1lbnQsIGV2ZW50TmFtZSkpIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHQvLyAvLyBjb25zb2xlLmxvZyhldmVudE5hbWUsICdwcmV2ZW50ZWQgb24nLCBlbGVtZW50KTtcblx0XHR9XG5cdH1cblx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG5cblx0Ly8gUmV0dXJuIGhhbmRsZXIgdG8gYWxsb3cgdG8gZGlzYWJsZSB0aGUgcHJldmVudGlvbi4gVXNhZ2U6XG5cdC8vIGNvbnN0IHByZXZlbnRpb25IYW5kbGVyID0gcHJldmVudEV2ZW50KGVsLCAnY2xpY2snKTtcblx0Ly8gZWwucmVtb3ZlRXZlbnRIYW5kbGVyKCdjbGljaycsIHByZXZlbnRpb25IYW5kbGVyKTtcblx0cmV0dXJuIGhhbmRsZXI7XG59XG5cbmZ1bmN0aW9uIHByb3h5UHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHNvdXJjZU9iamVjdCwgY29weUZpcnN0KSB7XG5cdGZ1bmN0aW9uIGdldCgpIHtcblx0XHRyZXR1cm4gc291cmNlT2JqZWN0W3Byb3BlcnR5TmFtZV07XG5cdH1cblx0ZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG5cdFx0c291cmNlT2JqZWN0W3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcblx0fVxuXG5cdGlmIChjb3B5Rmlyc3QpIHtcblx0XHRzZXQob2JqZWN0W3Byb3BlcnR5TmFtZV0pO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHlOYW1lLCB7Z2V0OiBnZXQsIHNldDogc2V0fSk7XG59XG5cbmZ1bmN0aW9uIHByb3h5RXZlbnQob2JqZWN0LCBldmVudE5hbWUsIHNvdXJjZU9iamVjdCkge1xuXHRzb3VyY2VPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iamVjdC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChldmVudE5hbWUpKTsgfSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRBc3luYyhlbGVtZW50LCB0eXBlKSB7XG5cdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQodHlwZSkpO1xuXHR9KTtcbn1cblxudmFyIGlPUzhvcjkgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnICYmICdvYmplY3QtZml0JyBpbiBkb2N1bWVudC5oZWFkLnN0eWxlICYmICFtYXRjaE1lZGlhKCcoLXdlYmtpdC12aWRlby1wbGF5YWJsZS1pbmxpbmUpJykubWF0Y2hlcztcblxudmFyIElJViA9ICdiZnJlZC1pdDppcGhvbmUtaW5saW5lLXZpZGVvJztcbnZhciBJSVZFdmVudCA9ICdiZnJlZC1pdDppcGhvbmUtaW5saW5lLXZpZGVvOmV2ZW50JztcbnZhciBJSVZQbGF5ID0gJ2JmcmVkLWl0OmlwaG9uZS1pbmxpbmUtdmlkZW86bmF0aXZlcGxheSc7XG52YXIgSUlWUGF1c2UgPSAnYmZyZWQtaXQ6aXBob25lLWlubGluZS12aWRlbzpuYXRpdmVwYXVzZSc7XG5cbi8qKlxuICogVVRJTFNcbiAqL1xuXG5mdW5jdGlvbiBnZXRBdWRpb0Zyb21WaWRlbyh2aWRlbykge1xuXHR2YXIgYXVkaW8gPSBuZXcgQXVkaW8oKTtcblx0cHJveHlFdmVudCh2aWRlbywgJ3BsYXknLCBhdWRpbyk7XG5cdHByb3h5RXZlbnQodmlkZW8sICdwbGF5aW5nJywgYXVkaW8pO1xuXHRwcm94eUV2ZW50KHZpZGVvLCAncGF1c2UnLCBhdWRpbyk7XG5cdGF1ZGlvLmNyb3NzT3JpZ2luID0gdmlkZW8uY3Jvc3NPcmlnaW47XG5cblx0Ly8gJ2RhdGE6JyBjYXVzZXMgYXVkaW8ubmV0d29ya1N0YXRlID4gMFxuXHQvLyB3aGljaCB0aGVuIGFsbG93cyB0byBrZWVwIDxhdWRpbz4gaW4gYSByZXN1bWFibGUgcGxheWluZyBzdGF0ZVxuXHQvLyBpLmUuIG9uY2UgeW91IHNldCBhIHJlYWwgc3JjIGl0IHdpbGwga2VlcCBwbGF5aW5nIGlmIGl0IHdhcyBpZiAucGxheSgpIHdhcyBjYWxsZWRcblx0YXVkaW8uc3JjID0gdmlkZW8uc3JjIHx8IHZpZGVvLmN1cnJlbnRTcmMgfHwgJ2RhdGE6JztcblxuXHQvLyAvLyBpZiAoYXVkaW8uc3JjID09PSAnZGF0YTonKSB7XG5cdC8vICAgVE9ETzogd2FpdCBmb3IgdmlkZW8gdG8gYmUgc2VsZWN0ZWRcblx0Ly8gLy8gfVxuXHRyZXR1cm4gYXVkaW87XG59XG5cbnZhciBsYXN0UmVxdWVzdHMgPSBbXTtcbnZhciByZXF1ZXN0SW5kZXggPSAwO1xudmFyIGxhc3RUaW1ldXBkYXRlRXZlbnQ7XG5cbmZ1bmN0aW9uIHNldFRpbWUodmlkZW8sIHRpbWUsIHJlbWVtYmVyT25seSkge1xuXHQvLyBBbGxvdyBvbmUgdGltZXVwZGF0ZSBldmVudCBldmVyeSAyMDArIG1zXG5cdGlmICgobGFzdFRpbWV1cGRhdGVFdmVudCB8fCAwKSArIDIwMCA8IERhdGUubm93KCkpIHtcblx0XHR2aWRlb1tJSVZFdmVudF0gPSB0cnVlO1xuXHRcdGxhc3RUaW1ldXBkYXRlRXZlbnQgPSBEYXRlLm5vdygpO1xuXHR9XG5cdGlmICghcmVtZW1iZXJPbmx5KSB7XG5cdFx0dmlkZW8uY3VycmVudFRpbWUgPSB0aW1lO1xuXHR9XG5cdGxhc3RSZXF1ZXN0c1srK3JlcXVlc3RJbmRleCAlIDNdID0gdGltZSAqIDEwMCB8IDAgLyAxMDA7XG59XG5cbmZ1bmN0aW9uIGlzUGxheWVyRW5kZWQocGxheWVyKSB7XG5cdHJldHVybiBwbGF5ZXIuZHJpdmVyLmN1cnJlbnRUaW1lID49IHBsYXllci52aWRlby5kdXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gdXBkYXRlKHRpbWVEaWZmKSB7XG5cdHZhciBwbGF5ZXIgPSB0aGlzO1xuXHQvLyAvLyBjb25zb2xlLmxvZygndXBkYXRlJywgcGxheWVyLnZpZGVvLnJlYWR5U3RhdGUsIHBsYXllci52aWRlby5uZXR3b3JrU3RhdGUsIHBsYXllci5kcml2ZXIucmVhZHlTdGF0ZSwgcGxheWVyLmRyaXZlci5uZXR3b3JrU3RhdGUsIHBsYXllci5kcml2ZXIucGF1c2VkKTtcblx0aWYgKHBsYXllci52aWRlby5yZWFkeVN0YXRlID49IHBsYXllci52aWRlby5IQVZFX0ZVVFVSRV9EQVRBKSB7XG5cdFx0aWYgKCFwbGF5ZXIuaGFzQXVkaW8pIHtcblx0XHRcdHBsYXllci5kcml2ZXIuY3VycmVudFRpbWUgPSBwbGF5ZXIudmlkZW8uY3VycmVudFRpbWUgKyAoKHRpbWVEaWZmICogcGxheWVyLnZpZGVvLnBsYXliYWNrUmF0ZSkgLyAxMDAwKTtcblx0XHRcdGlmIChwbGF5ZXIudmlkZW8ubG9vcCAmJiBpc1BsYXllckVuZGVkKHBsYXllcikpIHtcblx0XHRcdFx0cGxheWVyLmRyaXZlci5jdXJyZW50VGltZSA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNldFRpbWUocGxheWVyLnZpZGVvLCBwbGF5ZXIuZHJpdmVyLmN1cnJlbnRUaW1lKTtcblx0fSBlbHNlIGlmIChwbGF5ZXIudmlkZW8ubmV0d29ya1N0YXRlID09PSBwbGF5ZXIudmlkZW8uTkVUV09SS19JRExFICYmIHBsYXllci52aWRlby5idWZmZXJlZC5sZW5ndGggPT09IDApIHtcblx0XHQvLyBUaGlzIHNob3VsZCBoYXBwZW4gd2hlbiB0aGUgc291cmNlIGlzIGF2YWlsYWJsZSBidXQ6XG5cdFx0Ly8gLSBpdCdzIHBvdGVudGlhbGx5IHBsYXlpbmcgKC5wYXVzZWQgPT09IGZhbHNlKVxuXHRcdC8vIC0gaXQncyBub3QgcmVhZHkgdG8gcGxheVxuXHRcdC8vIC0gaXQncyBub3QgbG9hZGluZ1xuXHRcdC8vIElmIGl0IGhhc0F1ZGlvLCB0aGF0IHdpbGwgYmUgbG9hZGVkIGluIHRoZSAnZW1wdGllZCcgaGFuZGxlciBiZWxvd1xuXHRcdHBsYXllci52aWRlby5sb2FkKCk7XG5cdFx0Ly8gLy8gY29uc29sZS5sb2coJ1dpbGwgbG9hZCcpO1xuXHR9XG5cblx0Ly8gLy8gY29uc29sZS5hc3NlcnQocGxheWVyLnZpZGVvLmN1cnJlbnRUaW1lID09PSBwbGF5ZXIuZHJpdmVyLmN1cnJlbnRUaW1lLCAnVmlkZW8gbm90IHVwZGF0aW5nIScpO1xuXG5cdGlmIChwbGF5ZXIudmlkZW8uZW5kZWQpIHtcblx0XHRkZWxldGUgcGxheWVyLnZpZGVvW0lJVkV2ZW50XTsgLy8gQWxsb3cgdGltZXVwZGF0ZSBldmVudFxuXHRcdHBsYXllci52aWRlby5wYXVzZSh0cnVlKTtcblx0fVxufVxuXG4vKipcbiAqIE1FVEhPRFNcbiAqL1xuXG5mdW5jdGlvbiBwbGF5KCkge1xuXHQvLyAvLyBjb25zb2xlLmxvZygncGxheScpO1xuXHR2YXIgdmlkZW8gPSB0aGlzO1xuXHR2YXIgcGxheWVyID0gdmlkZW9bSUlWXTtcblxuXHQvLyBJZiBpdCdzIGZ1bGxzY3JlZW4sIHVzZSB0aGUgbmF0aXZlIHBsYXllclxuXHRpZiAodmlkZW8ud2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4pIHtcblx0XHR2aWRlb1tJSVZQbGF5XSgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChwbGF5ZXIuZHJpdmVyLnNyYyAhPT0gJ2RhdGE6JyAmJiBwbGF5ZXIuZHJpdmVyLnNyYyAhPT0gdmlkZW8uc3JjKSB7XG5cdFx0Ly8gLy8gY29uc29sZS5sb2coJ3NyYyBjaGFuZ2VkIG9uIHBsYXknLCB2aWRlby5zcmMpO1xuXHRcdHNldFRpbWUodmlkZW8sIDAsIHRydWUpO1xuXHRcdHBsYXllci5kcml2ZXIuc3JjID0gdmlkZW8uc3JjO1xuXHR9XG5cblx0aWYgKCF2aWRlby5wYXVzZWQpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0cGxheWVyLnBhdXNlZCA9IGZhbHNlO1xuXG5cdGlmICh2aWRlby5idWZmZXJlZC5sZW5ndGggPT09IDApIHtcblx0XHQvLyAubG9hZCgpIGNhdXNlcyB0aGUgZW1wdGllZCBldmVudFxuXHRcdC8vIHRoZSBhbHRlcm5hdGl2ZSBpcyAucGxheSgpKy5wYXVzZSgpIGJ1dCB0aGF0IHRyaWdnZXJzIHBsYXkvcGF1c2UgZXZlbnRzLCBldmVuIHdvcnNlXG5cdFx0Ly8gcG9zc2libHkgdGhlIGFsdGVybmF0aXZlIGlzIHByZXZlbnRpbmcgdGhpcyBldmVudCBvbmx5IG9uY2Vcblx0XHR2aWRlby5sb2FkKCk7XG5cdH1cblxuXHRwbGF5ZXIuZHJpdmVyLnBsYXkoKTtcblx0cGxheWVyLnVwZGF0ZXIuc3RhcnQoKTtcblxuXHRpZiAoIXBsYXllci5oYXNBdWRpbykge1xuXHRcdGRpc3BhdGNoRXZlbnRBc3luYyh2aWRlbywgJ3BsYXknKTtcblx0XHRpZiAocGxheWVyLnZpZGVvLnJlYWR5U3RhdGUgPj0gcGxheWVyLnZpZGVvLkhBVkVfRU5PVUdIX0RBVEEpIHtcblx0XHRcdC8vIC8vIGNvbnNvbGUubG9nKCdvbnBsYXknKTtcblx0XHRcdGRpc3BhdGNoRXZlbnRBc3luYyh2aWRlbywgJ3BsYXlpbmcnKTtcblx0XHR9XG5cdH1cbn1cbmZ1bmN0aW9uIHBhdXNlKGZvcmNlRXZlbnRzKSB7XG5cdC8vIC8vIGNvbnNvbGUubG9nKCdwYXVzZScpO1xuXHR2YXIgdmlkZW8gPSB0aGlzO1xuXHR2YXIgcGxheWVyID0gdmlkZW9bSUlWXTtcblxuXHRwbGF5ZXIuZHJpdmVyLnBhdXNlKCk7XG5cdHBsYXllci51cGRhdGVyLnN0b3AoKTtcblxuXHQvLyBJZiBpdCdzIGZ1bGxzY3JlZW4sIHRoZSBkZXZlbG9wZXIgdGhlIG5hdGl2ZSBwbGF5ZXIucGF1c2UoKVxuXHQvLyBUaGlzIGlzIGF0IHRoZSBlbmQgb2YgcGF1c2UoKSBiZWNhdXNlIGl0IGFsc29cblx0Ly8gbmVlZHMgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHNpbXVsYXRpb24gaXMgcGF1c2VkXG5cdGlmICh2aWRlby53ZWJraXREaXNwbGF5aW5nRnVsbHNjcmVlbikge1xuXHRcdHZpZGVvW0lJVlBhdXNlXSgpO1xuXHR9XG5cblx0aWYgKHBsYXllci5wYXVzZWQgJiYgIWZvcmNlRXZlbnRzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0cGxheWVyLnBhdXNlZCA9IHRydWU7XG5cdGlmICghcGxheWVyLmhhc0F1ZGlvKSB7XG5cdFx0ZGlzcGF0Y2hFdmVudEFzeW5jKHZpZGVvLCAncGF1c2UnKTtcblx0fVxuXG5cdC8vIEhhbmRsZSB0aGUgJ2VuZGVkJyBldmVudCBvbmx5IGlmIGl0J3Mgbm90IGZ1bGxzY3JlZW5cblx0aWYgKHZpZGVvLmVuZGVkICYmICF2aWRlby53ZWJraXREaXNwbGF5aW5nRnVsbHNjcmVlbikge1xuXHRcdHZpZGVvW0lJVkV2ZW50XSA9IHRydWU7XG5cdFx0ZGlzcGF0Y2hFdmVudEFzeW5jKHZpZGVvLCAnZW5kZWQnKTtcblx0fVxufVxuXG4vKipcbiAqIFNFVFVQXG4gKi9cblxuZnVuY3Rpb24gYWRkUGxheWVyKHZpZGVvLCBoYXNBdWRpbykge1xuXHR2YXIgcGxheWVyID0ge307XG5cdHZpZGVvW0lJVl0gPSBwbGF5ZXI7XG5cdHBsYXllci5wYXVzZWQgPSB0cnVlOyAvLyBUcmFjayB3aGV0aGVyICdwYXVzZScgZXZlbnRzIGhhdmUgYmVlbiBmaXJlZFxuXHRwbGF5ZXIuaGFzQXVkaW8gPSBoYXNBdWRpbztcblx0cGxheWVyLnZpZGVvID0gdmlkZW87XG5cdHBsYXllci51cGRhdGVyID0gaW50ZXJ2YWxvbWV0ZXIuZnJhbWVJbnRlcnZhbG9tZXRlcih1cGRhdGUuYmluZChwbGF5ZXIpKTtcblxuXHRpZiAoaGFzQXVkaW8pIHtcblx0XHRwbGF5ZXIuZHJpdmVyID0gZ2V0QXVkaW9Gcm9tVmlkZW8odmlkZW8pO1xuXHR9IGVsc2Uge1xuXHRcdHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIXZpZGVvLnBhdXNlZCkge1xuXHRcdFx0XHQvLyAvLyBjb25zb2xlLmxvZygnb25jYW5wbGF5Jyk7XG5cdFx0XHRcdGRpc3BhdGNoRXZlbnRBc3luYyh2aWRlbywgJ3BsYXlpbmcnKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRwbGF5ZXIuZHJpdmVyID0ge1xuXHRcdFx0c3JjOiB2aWRlby5zcmMgfHwgdmlkZW8uY3VycmVudFNyYyB8fCAnZGF0YTonLFxuXHRcdFx0bXV0ZWQ6IHRydWUsXG5cdFx0XHRwYXVzZWQ6IHRydWUsXG5cdFx0XHRwYXVzZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRwbGF5ZXIuZHJpdmVyLnBhdXNlZCA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0cGxheTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRwbGF5ZXIuZHJpdmVyLnBhdXNlZCA9IGZhbHNlO1xuXHRcdFx0XHQvLyBNZWRpYSBhdXRvbWF0aWNhbGx5IGdvZXMgdG8gMCBpZiAucGxheSgpIGlzIGNhbGxlZCB3aGVuIGl0J3MgZG9uZVxuXHRcdFx0XHRpZiAoaXNQbGF5ZXJFbmRlZChwbGF5ZXIpKSB7XG5cdFx0XHRcdFx0c2V0VGltZSh2aWRlbywgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRnZXQgZW5kZWQoKSB7XG5cdFx0XHRcdHJldHVybiBpc1BsYXllckVuZGVkKHBsYXllcik7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIC5sb2FkKCkgY2F1c2VzIHRoZSBlbXB0aWVkIGV2ZW50XG5cdHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gLy8gY29uc29sZS5sb2coJ2RyaXZlciBzcmMgaXMnLCBwbGF5ZXIuZHJpdmVyLnNyYyk7XG5cdFx0dmFyIHdhc0VtcHR5ID0gIXBsYXllci5kcml2ZXIuc3JjIHx8IHBsYXllci5kcml2ZXIuc3JjID09PSAnZGF0YTonO1xuXHRcdGlmIChwbGF5ZXIuZHJpdmVyLnNyYyAmJiBwbGF5ZXIuZHJpdmVyLnNyYyAhPT0gdmlkZW8uc3JjKSB7XG5cdFx0XHQvLyAvLyBjb25zb2xlLmxvZygnc3JjIGNoYW5nZWQgdG8nLCB2aWRlby5zcmMpO1xuXHRcdFx0c2V0VGltZSh2aWRlbywgMCwgdHJ1ZSk7XG5cdFx0XHRwbGF5ZXIuZHJpdmVyLnNyYyA9IHZpZGVvLnNyYztcblx0XHRcdC8vIFBsYXlpbmcgdmlkZW9zIHdpbGwgb25seSBrZWVwIHBsYXlpbmcgaWYgbm8gc3JjIHdhcyBwcmVzZW50IHdoZW4gLnBsYXkoKeKAmWVkXG5cdFx0XHRpZiAod2FzRW1wdHkgfHwgKCFoYXNBdWRpbyAmJiB2aWRlby5hdXRvcGxheSkpIHtcblx0XHRcdFx0cGxheWVyLmRyaXZlci5wbGF5KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwbGF5ZXIudXBkYXRlci5zdG9wKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCBmYWxzZSk7XG5cblx0Ly8gU3RvcCBwcm9ncmFtbWF0aWMgcGxheWVyIHdoZW4gT1MgdGFrZXMgb3ZlclxuXHR2aWRlby5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRiZWdpbmZ1bGxzY3JlZW4nLCBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF2aWRlby5wYXVzZWQpIHtcblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSA8YXVkaW8+IGFuZCB0aGUgc3luY2VyL3VwZGF0ZXIgYXJlIHN0b3BwZWRcblx0XHRcdHZpZGVvLnBhdXNlKCk7XG5cblx0XHRcdC8vIFBsYXkgdmlkZW8gbmF0aXZlbHlcblx0XHRcdHZpZGVvW0lJVlBsYXldKCk7XG5cdFx0fSBlbHNlIGlmIChoYXNBdWRpbyAmJiBwbGF5ZXIuZHJpdmVyLmJ1ZmZlcmVkLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Ly8gSWYgdGhlIGZpcnN0IHBsYXkgaXMgbmF0aXZlLFxuXHRcdFx0Ly8gdGhlIDxhdWRpbz4gbmVlZHMgdG8gYmUgYnVmZmVyZWQgbWFudWFsbHlcblx0XHRcdC8vIHNvIHdoZW4gdGhlIGZ1bGxzY3JlZW4gZW5kcywgaXQgY2FuIGJlIHNldCB0byB0aGUgc2FtZSBjdXJyZW50IHRpbWVcblx0XHRcdHBsYXllci5kcml2ZXIubG9hZCgpO1xuXHRcdH1cblx0fSk7XG5cdGlmIChoYXNBdWRpbykge1xuXHRcdHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGVuZGZ1bGxzY3JlZW4nLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBTeW5jIGF1ZGlvIHRvIG5ldyB2aWRlbyBwb3NpdGlvblxuXHRcdFx0cGxheWVyLmRyaXZlci5jdXJyZW50VGltZSA9IHZpZGVvLmN1cnJlbnRUaW1lO1xuXHRcdFx0Ly8gLy8gY29uc29sZS5hc3NlcnQocGxheWVyLmRyaXZlci5jdXJyZW50VGltZSA9PT0gdmlkZW8uY3VycmVudFRpbWUsICdBdWRpbyBub3Qgc3luY2VkJyk7XG5cdFx0fSk7XG5cblx0XHQvLyBBbGxvdyBzZWVraW5nXG5cdFx0dmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChsYXN0UmVxdWVzdHMuaW5kZXhPZih2aWRlby5jdXJyZW50VGltZSAqIDEwMCB8IDAgLyAxMDApIDwgMCkge1xuXHRcdFx0XHQvLyAvLyBjb25zb2xlLmxvZygnVXNlci1yZXF1ZXN0ZWQgc2Vla2luZycpO1xuXHRcdFx0XHRwbGF5ZXIuZHJpdmVyLmN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJldmVudFdpdGhQcm9wT3JGdWxsc2NyZWVuKGVsKSB7XG5cdHZhciBpc0FsbG93ZWQgPSBlbFtJSVZFdmVudF07XG5cdGRlbGV0ZSBlbFtJSVZFdmVudF07XG5cdHJldHVybiAhZWwud2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4gJiYgIWlzQWxsb3dlZDtcbn1cblxuZnVuY3Rpb24gb3ZlcmxvYWRBUEkodmlkZW8pIHtcblx0dmFyIHBsYXllciA9IHZpZGVvW0lJVl07XG5cdHZpZGVvW0lJVlBsYXldID0gdmlkZW8ucGxheTtcblx0dmlkZW9bSUlWUGF1c2VdID0gdmlkZW8ucGF1c2U7XG5cdHZpZGVvLnBsYXkgPSBwbGF5O1xuXHR2aWRlby5wYXVzZSA9IHBhdXNlO1xuXHRwcm94eVByb3BlcnR5KHZpZGVvLCAncGF1c2VkJywgcGxheWVyLmRyaXZlcik7XG5cdHByb3h5UHJvcGVydHkodmlkZW8sICdtdXRlZCcsIHBsYXllci5kcml2ZXIsIHRydWUpO1xuXHRwcm94eVByb3BlcnR5KHZpZGVvLCAncGxheWJhY2tSYXRlJywgcGxheWVyLmRyaXZlciwgdHJ1ZSk7XG5cdHByb3h5UHJvcGVydHkodmlkZW8sICdlbmRlZCcsIHBsYXllci5kcml2ZXIpO1xuXHRwcm94eVByb3BlcnR5KHZpZGVvLCAnbG9vcCcsIHBsYXllci5kcml2ZXIsIHRydWUpO1xuXG5cdC8vIElJViB3b3JrcyBieSBzZWVraW5nIDYwIHRpbWVzIHBlciBzZWNvbmQuXG5cdC8vIFRoZXNlIGV2ZW50cyBhcmUgbm93IHVzZWxlc3MuXG5cdHByZXZlbnRFdmVudCh2aWRlbywgJ3NlZWtpbmcnLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICFlbC53ZWJraXREaXNwbGF5aW5nRnVsbHNjcmVlbjsgfSk7XG5cdHByZXZlbnRFdmVudCh2aWRlbywgJ3NlZWtlZCcsIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gIWVsLndlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuOyB9KTtcblxuXHQvLyBMaW1pdCB0aW1ldXBkYXRlIGV2ZW50c1xuXHRwcmV2ZW50RXZlbnQodmlkZW8sICd0aW1ldXBkYXRlJywgcHJldmVudFdpdGhQcm9wT3JGdWxsc2NyZWVuKTtcblxuXHQvLyBQcmV2ZW50IG9jY2FzaW9uYWwgbmF0aXZlIGVuZGVkIGV2ZW50c1xuXHRwcmV2ZW50RXZlbnQodmlkZW8sICdlbmRlZCcsIHByZXZlbnRXaXRoUHJvcE9yRnVsbHNjcmVlbik7XG59XG5cbmZ1bmN0aW9uIGVuYWJsZUlubGluZVZpZGVvKHZpZGVvLCBvcHRzKSB7XG5cdGlmICggb3B0cyA9PT0gdm9pZCAwICkgb3B0cyA9IHt9O1xuXG5cdC8vIFN0b3AgaWYgYWxyZWFkeSBlbmFibGVkXG5cdGlmICh2aWRlb1tJSVZdKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gQWxsb3cgdGhlIHVzZXIgdG8gc2tpcCBkZXRlY3Rpb25cblx0aWYgKCFvcHRzLmV2ZXJ5d2hlcmUpIHtcblx0XHQvLyBPbmx5IGlPUzggYW5kIDkgYXJlIHN1cHBvcnRlZFxuXHRcdGlmICghaU9TOG9yOSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFN0b3AgaWYgaXQncyBub3QgYW4gYWxsb3dlZCBkZXZpY2Vcblx0XHRpZiAoIShvcHRzLmlQYWQgfHwgb3B0cy5pcGFkID8gL2lQaG9uZXxpUG9kfGlQYWQvIDogL2lQaG9uZXxpUG9kLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXG5cdC8vIFRyeSB0byBwYXVzZVxuXHR2aWRlby5wYXVzZSgpO1xuXG5cdC8vIFByZXZlbnQgYXV0b3BsYXkuXG5cdC8vIEFuIG5vbi1zdGFydGVkIGF1dG9wbGF5aW5nIHZpZGVvIGNhbid0IGJlIC5wYXVzZSgpJ2Rcblx0dmFyIHdpbGxBdXRvcGxheSA9IHZpZGVvLmF1dG9wbGF5O1xuXHR2aWRlby5hdXRvcGxheSA9IGZhbHNlO1xuXG5cdGFkZFBsYXllcih2aWRlbywgIXZpZGVvLm11dGVkKTtcblx0b3ZlcmxvYWRBUEkodmlkZW8pO1xuXHR2aWRlby5jbGFzc0xpc3QuYWRkKCdJSVYnKTtcblxuXHQvLyBBdXRvcGxheVxuXHRpZiAodmlkZW8ubXV0ZWQgJiYgd2lsbEF1dG9wbGF5KSB7XG5cdFx0dmlkZW8ucGxheSgpO1xuXHRcdHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCBmdW5jdGlvbiByZXN0b3JlQXV0b3BsYXkoKSB7XG5cdFx0XHR2aWRlby5hdXRvcGxheSA9IHRydWU7XG5cdFx0XHR2aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgcmVzdG9yZUF1dG9wbGF5KTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICghL2lQaG9uZXxpUG9kfGlQYWQvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSkge1xuXHRcdGNvbnNvbGUud2FybignaXBob25lLWlubGluZS12aWRlbyBpcyBub3QgZ3VhcmFudGVlZCB0byB3b3JrIGluIGVtdWxhdGVkIGVudmlyb25tZW50cycpO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW5hYmxlSW5saW5lVmlkZW87XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgbnVtYmVySXNOYW4gPSByZXF1aXJlKCdudW1iZXItaXMtbmFuJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh2YWwpIHtcblx0cmV0dXJuICEodHlwZW9mIHZhbCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYW4odmFsKSB8fCB2YWwgPT09IEluZmluaXR5IHx8IHZhbCA9PT0gLUluZmluaXR5KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlzUG93ZXJPZlR3b1xuXG5mdW5jdGlvbiBpc1Bvd2VyT2ZUd28obikge1xuICByZXR1cm4gbiAhPT0gMCAmJiAobiAmIChuIC0gMSkpID09PSAwXG59IiwibW9kdWxlLmV4cG9ydHMgICAgICA9IGlzVHlwZWRBcnJheVxuaXNUeXBlZEFycmF5LnN0cmljdCA9IGlzU3RyaWN0VHlwZWRBcnJheVxuaXNUeXBlZEFycmF5Lmxvb3NlICA9IGlzTG9vc2VUeXBlZEFycmF5XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBuYW1lcyA9IHtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IEludDE2QXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IEludDMyQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQ4QXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50MTZBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDMyQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IHRydWVcbn1cblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5KGFycikge1xuICByZXR1cm4gKFxuICAgICAgIGlzU3RyaWN0VHlwZWRBcnJheShhcnIpXG4gICAgfHwgaXNMb29zZVR5cGVkQXJyYXkoYXJyKVxuICApXG59XG5cbmZ1bmN0aW9uIGlzU3RyaWN0VHlwZWRBcnJheShhcnIpIHtcbiAgcmV0dXJuIChcbiAgICAgICBhcnIgaW5zdGFuY2VvZiBJbnQ4QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBJbnQxNkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgSW50MzJBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQxNkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDMyQXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXlcbiAgKVxufVxuXG5mdW5jdGlvbiBpc0xvb3NlVHlwZWRBcnJheShhcnIpIHtcbiAgcmV0dXJuIG5hbWVzW3RvU3RyaW5nLmNhbGwoYXJyKV1cbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bWVyYXRpb24gd2l0aCBrZXlzIGVxdWFsIHRvIHRoZWlyIHZhbHVlLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgdmFyIENPTE9SUyA9IGtleU1pcnJvcih7Ymx1ZTogbnVsbCwgcmVkOiBudWxsfSk7XG4gKiAgIHZhciBteUNvbG9yID0gQ09MT1JTLmJsdWU7XG4gKiAgIHZhciBpc0NvbG9yVmFsaWQgPSAhIUNPTE9SU1tteUNvbG9yXTtcbiAqXG4gKiBUaGUgbGFzdCBsaW5lIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgaWYgdGhlIHZhbHVlcyBvZiB0aGUgZ2VuZXJhdGVkIGVudW0gd2VyZVxuICogbm90IGVxdWFsIHRvIHRoZWlyIGtleXMuXG4gKlxuICogICBJbnB1dDogIHtrZXkxOiB2YWwxLCBrZXkyOiB2YWwyfVxuICogICBPdXRwdXQ6IHtrZXkxOiBrZXkxLCBrZXkyOiBrZXkyfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xudmFyIGtleU1pcnJvciA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcmV0ID0ge307XG4gIHZhciBrZXk7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigna2V5TWlycm9yKC4uLik6IEFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICB9XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXRba2V5XSA9IGtleTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3I7XG4iLCJcbi8vIEZsYXQgbWVyZ2Vcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZ1bmN0aW9uKGhvc3QpIHtcblx0dmFyIGRvbm9ycyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG5cdGRvbm9ycy5mb3JFYWNoKGZ1bmN0aW9uKGRvbm9yKSB7XG5cdFx0T2JqZWN0LmtleXMoZG9ub3IpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRob3N0W2tleV0gPSBkb25vcltrZXldO1xuXHRcdH0pO1xuXHR9KTtcblx0cmV0dXJuIGhvc3Q7XG59O1xuXG4vLyBGbGF0LCBzZWxlY3RpdmUgbWVyZ2VcbmV4cG9ydHMuc2VsZWN0aXZlID0gZnVuY3Rpb24oa2V5cywgaG9zdCkge1xuXHR2YXIgZG9ub3JzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcblx0ZG9ub3JzLmZvckVhY2goZnVuY3Rpb24oZG9ub3IpIHtcblx0XHRrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRob3N0W2tleV0gPSBkb25vcltrZXldO1xuXHRcdH0pO1xuXHR9KTtcblx0cmV0dXJuIGhvc3Q7XG59O1xuXG4vLyBSZWN1cnNpdmUgbWVyZ2VcbmV4cG9ydHMucmVjdXJzaXZlID0gZnVuY3Rpb24oaG9zdCkge1xuXHR2YXIgZG9ub3JzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcblx0ZG9ub3JzLmZvckVhY2goZnVuY3Rpb24oZG9ub3IpIHtcblx0XHRPYmplY3Qua2V5cyhkb25vcikuZm9yRWFjaChyZWN1cnNlcihob3N0LCBkb25vcikpO1xuXHR9KTtcblx0cmV0dXJuIGhvc3Q7XG59O1xuXG4vLyBSZWN1cnNpdmUsIHNlbGVjdGl2ZSBtZXJnZVxuZXhwb3J0cy5zZWxlY3RpdmUucmVjdXJzaXZlID0gZnVuY3Rpb24oa2V5cywgaG9zdCkge1xuXHR2YXIgZG9ub3JzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcblx0ZG9ub3JzLmZvckVhY2goZnVuY3Rpb24oZG9ub3IpIHtcblx0XHRrZXlzLmZvckVhY2gocmVjdXJzZXIoaG9zdCwgZG9ub3IpKTtcblx0fSk7XG5cdHJldHVybiBob3N0O1xufTtcblxuLy8gSGVscGVyc1xuXG5mdW5jdGlvbiBzbGljZShhcnIsIGkpIHtcblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyciwgaSk7XG59XG5cbmZ1bmN0aW9uIGlzT2JqKHZhbHVlKSB7XG5cdHJldHVybiAhISAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2VyKGhvc3QsIGRvbm9yKSB7XG5cdHJldHVybiBmdW5jdGlvbihrZXkpIHtcblx0XHRpZiAoaXNPYmooZG9ub3Jba2V5XSkpIHtcblx0XHRcdGlmIChpc09iaihob3N0W2tleV0pKSB7XG5cdFx0XHRcdGV4cG9ydHMucmVjdXJzaXZlKGhvc3Rba2V5XSwgZG9ub3Jba2V5XSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYmFzZSA9IEFycmF5LmlzQXJyYXkoZG9ub3Jba2V5XSkgPyBbIF0gOiB7IH07XG5cdFx0XHRcdGhvc3Rba2V5XSA9IGV4cG9ydHMucmVjdXJzaXZlKGJhc2UsIGRvbm9yW2tleV0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRob3N0W2tleV0gPSBkb25vcltrZXldO1xuXHRcdH1cblx0fTtcbn1cblxuLyogRW5kIG9mIGZpbGUgaW5kZXguanMgKi9cbi8qIExvY2F0aW9uOiAuL2xpYi9pbmRleC5qcyAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG51bWJlcklzRmluaXRlID0gcmVxdWlyZSgnaXMtZmluaXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiAoeCkge1xuXHRyZXR1cm4gbnVtYmVySXNGaW5pdGUoeCkgJiYgTWF0aC5mbG9vcih4KSA9PT0geDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAoeCkge1xuXHRyZXR1cm4geCAhPT0geDtcbn07XG4iLCJ2YXIgd3JhcHB5ID0gcmVxdWlyZSgnd3JhcHB5Jylcbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5KG9uY2UpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmLmNhbGxlZCkgcmV0dXJuIGYudmFsdWVcbiAgICBmLmNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICBmLmNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmXG59XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWUsIG1vZHVsZUxvYWRUaW1lLCBub2RlTG9hZFRpbWUsIHVwVGltZTtcblxuICBpZiAoKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwZXJmb3JtYW5jZSAhPT0gbnVsbCkgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzICE9PSBudWxsKSAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGdldE5hbm9TZWNvbmRzKCkgLSBub2RlTG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIG1vZHVsZUxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgICB1cFRpbWUgPSBwcm9jZXNzLnVwdGltZSgpICogMWU5O1xuICAgIG5vZGVMb2FkVGltZSA9IG1vZHVsZUxvYWRUaW1lIC0gdXBUaW1lO1xuICB9IGVsc2UgaWYgKERhdGUubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJmb3JtYW5jZS1ub3cuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MubmV4dFRpY2s7XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cbiIsInZhciBub3cgPSByZXF1aXJlKCdwZXJmb3JtYW5jZS1ub3cnKVxuICAsIHJvb3QgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvd1xuICAsIHZlbmRvcnMgPSBbJ21veicsICd3ZWJraXQnXVxuICAsIHN1ZmZpeCA9ICdBbmltYXRpb25GcmFtZSdcbiAgLCByYWYgPSByb290WydyZXF1ZXN0JyArIHN1ZmZpeF1cbiAgLCBjYWYgPSByb290WydjYW5jZWwnICsgc3VmZml4XSB8fCByb290WydjYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cblxuZm9yKHZhciBpID0gMDsgIXJhZiAmJiBpIDwgdmVuZG9ycy5sZW5ndGg7IGkrKykge1xuICByYWYgPSByb290W3ZlbmRvcnNbaV0gKyAnUmVxdWVzdCcgKyBzdWZmaXhdXG4gIGNhZiA9IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWwnICsgc3VmZml4XVxuICAgICAgfHwgcm9vdFt2ZW5kb3JzW2ldICsgJ0NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxufVxuXG4vLyBTb21lIHZlcnNpb25zIG9mIEZGIGhhdmUgckFGIGJ1dCBub3QgY0FGXG5pZighcmFmIHx8ICFjYWYpIHtcbiAgdmFyIGxhc3QgPSAwXG4gICAgLCBpZCA9IDBcbiAgICAsIHF1ZXVlID0gW11cbiAgICAsIGZyYW1lRHVyYXRpb24gPSAxMDAwIC8gNjBcblxuICByYWYgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIF9ub3cgPSBub3coKVxuICAgICAgICAsIG5leHQgPSBNYXRoLm1heCgwLCBmcmFtZUR1cmF0aW9uIC0gKF9ub3cgLSBsYXN0KSlcbiAgICAgIGxhc3QgPSBuZXh0ICsgX25vd1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNwID0gcXVldWUuc2xpY2UoMClcbiAgICAgICAgLy8gQ2xlYXIgcXVldWUgaGVyZSB0byBwcmV2ZW50XG4gICAgICAgIC8vIGNhbGxiYWNrcyBmcm9tIGFwcGVuZGluZyBsaXN0ZW5lcnNcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgZnJhbWUncyBxdWV1ZVxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKCFjcFtpXS5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgY3BbaV0uY2FsbGJhY2sobGFzdClcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0aHJvdyBlIH0sIDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBNYXRoLnJvdW5kKG5leHQpKVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKHtcbiAgICAgIGhhbmRsZTogKytpZCxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGNhbmNlbGxlZDogZmFsc2VcbiAgICB9KVxuICAgIHJldHVybiBpZFxuICB9XG5cbiAgY2FmID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihxdWV1ZVtpXS5oYW5kbGUgPT09IGhhbmRsZSkge1xuICAgICAgICBxdWV1ZVtpXS5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4pIHtcbiAgLy8gV3JhcCBpbiBhIG5ldyBmdW5jdGlvbiB0byBwcmV2ZW50XG4gIC8vIGBjYW5jZWxgIHBvdGVudGlhbGx5IGJlaW5nIGFzc2lnbmVkXG4gIC8vIHRvIHRoZSBuYXRpdmUgckFGIGZ1bmN0aW9uXG4gIHJldHVybiByYWYuY2FsbChyb290LCBmbilcbn1cbm1vZHVsZS5leHBvcnRzLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICBjYWYuYXBwbHkocm9vdCwgYXJndW1lbnRzKVxufVxubW9kdWxlLmV4cG9ydHMucG9seWZpbGwgPSBmdW5jdGlvbigpIHtcbiAgcm9vdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByYWZcbiAgcm9vdC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNhZlxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVycik7XG59O1xuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyBUT0RPKGJtZXVyZXIpOiBDaGFuZ2UgdGhpcyBiYWNrIHRvIGNvbnN0IG9uY2UgaG9sZSBjaGVja3MgYXJlXG4vLyBwcm9wZXJseSBvcHRpbWl6ZWQgYXdheSBlYXJseSBpbiBJZ25pdGlvbitUdXJib0Zhbi5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHByb2Nlc3NOZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzc05leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzc05leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCBzZWxmLmVtaXQuYmluZChzZWxmLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIsIGRhdGEpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpcy5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHByb2Nlc3NOZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gX2lzVWludDhBcnJheShjaHVuaykgJiYgIXN0YXRlLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHByb2Nlc3NOZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3NOZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzc05leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTsiLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwcm9jZXNzTmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHByb2Nlc3NOZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWFkeXN0YXRlID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWR5c3RhdGUnKVxuICAsIHdpbiA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykpKClcbiAgLCBjb21wbGV0ZSA9ICdjb21wbGV0ZSdcbiAgLCByb290ID0gdHJ1ZVxuICAsIGRvYyA9IHdpbi5kb2N1bWVudFxuICAsIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4oZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgLy9cbiAgLy8gQmFpbCBvdXQgZWFybHkgaWYgdGhlIGRvY3VtZW50IGlzIGFscmVhZHkgZnVsbHkgbG9hZGVkLiBUaGlzIG1lYW5zIHRoYXQgdGhpc1xuICAvLyBzY3JpcHQgaXMgbG9hZGVkIGFmdGVyIHRoZSBvbmxvYWQgZXZlbnQuXG4gIC8vXG4gIGlmIChjb21wbGV0ZSA9PT0gZG9jLnJlYWR5U3RhdGUpIHtcbiAgICByZXR1cm4gcmVhZHlzdGF0ZS5jaGFuZ2UoY29tcGxldGUpO1xuICB9XG5cbiAgLy9cbiAgLy8gVXNlIGZlYXR1cmUgZGV0ZWN0aW9uIHRvIHNlZSB3aGF0IGtpbmQgb2YgYnJvd3NlciBlbnZpcm9ubWVudCB3ZSdyZSBkZWFsaW5nXG4gIC8vIHdpdGguIE9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3JlciBkbyBub3Qgc3VwcG9ydCB0aGUgYWRkRXZlbnRMaXN0ZW5lclxuICAvLyBpbnRlcmZhY2Ugc28gd2UgY2FuIGFsc28gc2FmZWx5IGFzc3VtZSB0aGF0IHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIHBvbGxpbmcuXG4gIC8vXG4gIHZhciBtb2Rlcm4gPSAhIWRvYy5hZGRFdmVudExpc3RlbmVyXG4gICAgLCBwcmVmaXggPSBtb2Rlcm4gPyAnJyA6ICdvbidcbiAgICAsIG9uID0gbW9kZXJuID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ2F0dGFjaEV2ZW50J1xuICAgICwgb2ZmID0gbW9kZXJuID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2RldGFjaEV2ZW50JztcblxuICBpZiAoIW1vZGVybiAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgaHRtbC5kb1Njcm9sbCkge1xuICAgIHRyeSB7IHJvb3QgPSAhd2luLmZyYW1lRWxlbWVudDsgfVxuICAgIGNhdGNoIChlKSB7fVxuXG4gICAgaWYgKHJvb3QpIChmdW5jdGlvbiBwb2xsaW5nKCkge1xuICAgICAgdHJ5IHsgaHRtbC5kb1Njcm9sbCgnbGVmdCcpOyB9XG4gICAgICBjYXRjaCAoZSkgeyByZXR1cm4gc2V0VGltZW91dChwb2xsaW5nLCA1MCk7IH1cblxuICAgICAgcmVhZHlzdGF0ZS5jaGFuZ2UoJ2ludGVyYWN0aXZlJyk7XG4gICAgfSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIHZhcmlvdXMgb2YgZXZlbnQgbGlzdGVuZXIgY2FsbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2dCBTaW1wbGUgRE9NIGV2ZW50LlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNoYW5nZShldnQpIHtcbiAgICBldnQgPSBldnQgfHwgd2luLmV2ZW50O1xuXG4gICAgaWYgKCdyZWFkeXN0YXRlY2hhbmdlJyA9PT0gZXZ0LnR5cGUpIHtcbiAgICAgIHJlYWR5c3RhdGUuY2hhbmdlKGRvYy5yZWFkeVN0YXRlKTtcbiAgICAgIGlmIChjb21wbGV0ZSAhPT0gZG9jLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoJ2xvYWQnID09PSBldnQudHlwZSkgcmVhZHlzdGF0ZS5jaGFuZ2UoJ2NvbXBsZXRlJyk7XG4gICAgZWxzZSByZWFkeXN0YXRlLmNoYW5nZSgnaW50ZXJhY3RpdmUnKTtcblxuICAgIC8vXG4gICAgLy8gSG91c2Uga2VlcGluZywgcmVtb3ZlIG91ciBhc3NpZ25lZCBldmVudCBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICAoZXZ0LnR5cGUgPT09ICdsb2FkJyA/IHdpbiA6IGRvYylbb2ZmXShldnQudHlwZSwgY2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICAvL1xuICAvLyBBc3NpZ24gYSBzaGl0IGxvYWQgb2YgZXZlbnQgbGlzdGVuZXJzIHNvIHdlIGNhbiB1cGRhdGUgb3VyIGludGVybmFsIHN0YXRlLlxuICAvL1xuICBkb2Nbb25dKHByZWZpeCArJ0RPTUNvbnRlbnRMb2FkZWQnLCBjaGFuZ2UsIGZhbHNlKTtcbiAgZG9jW29uXShwcmVmaXggKydyZWFkeXN0YXRlY2hhbmdlJywgY2hhbmdlLCBmYWxzZSk7XG4gIHdpbltvbl0ocHJlZml4ICsnbG9hZCcsIGNoYW5nZSwgZmFsc2UpO1xufSAoKSk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG5ldyBwcm90b3R5cGUgbWV0aG9kIHdoaWNoIHdpbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIG9uY2UgdGhlXG4gKiBkZXNpcmVkIHN0YXRlIGhhcyBiZWVuIHJlYWNoZWQuIFRoZSByZXR1cm5lZCBmdW5jdGlvbiBhY2NlcHRzIDIgYXJndW1lbnRzOlxuICpcbiAqIC0gZm46IFRoZSBhc3NpZ25lZCBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBiZSBjYWxsZWQuXG4gKiAtIGNvbnRleHQ6IENvbnRleHQvdGhpcyB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gd2UgbmVlZCB0byBleGVjdXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZSBUaGUgc3RhdGUgd2UgbmVlZCB0byBvcGVyYXRlIHVwb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGUoc3RhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb3h5KGZuLCBjb250ZXh0KSB7XG4gICAgdmFyIHJzID0gdGhpcztcblxuICAgIGlmIChycy5pcyhzdGF0ZSkpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBmbi5jYWxsKGNvbnRleHQsIHJzLnJlYWR5U3RhdGUpO1xuICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcnMuX2V2ZW50c1tzdGF0ZV0pIHJzLl9ldmVudHNbc3RhdGVdID0gW107XG4gICAgICBycy5fZXZlbnRzW3N0YXRlXS5wdXNoKHsgZm46IGZuLCBjb250ZXh0OiBjb250ZXh0IH0pO1xuICAgIH1cblxuICAgIHJldHVybiBycztcbiAgfTtcbn1cblxuLyoqXG4gKiBSUyAocmVhZHlTdGF0ZSkgaW5zdGFuY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBSUygpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gUlMuVU5LTk9XTjtcbiAgdGhpcy5fZXZlbnRzID0ge307XG59XG5cbi8qKlxuICogVGhlIGVudmlyb25tZW50IGNhbiBiZSBpbiBkaWZmZXJlbnQgc3RhdGVzLiBUaGUgZm9sbG93aW5nIHN0YXRlcyBhcmVcbiAqIGdlbmVyYXRlZDpcbiAqXG4gKiAtIEFMTDogICAgICAgICBUaGUgSSBkb24ndCByZWFsbHkgZ2l2ZSBhIGZ1Y2sgc3RhdGUuXG4gKiAtIFVOS05PV046ICAgICBXZSBnb3QgYW4gdW5rbm93biByZWFkeVN0YXRlIHdlIHNob3VsZCBzdGFydCBsaXN0ZW5pbmcgZm9yIGV2ZW50cy5cbiAqIC0gTE9BRElORzogICAgIEVudmlyb25tZW50IGlzIGN1cnJlbnRseSBsb2FkaW5nLlxuICogLSBJTlRFUkFDVElWRTogRW52aXJvbm1lbnQgaXMgcmVhZHkgZm9yIG1vZGlmaWNhdGlvbi5cbiAqIC0gQ09NUExFVEU6ICAgIEFsbCByZXNvdXJjZXMgaGF2ZSBiZWVuIGxvYWRlZC5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgYHN0YXRlc2Agc3RyaW5nL2FycmF5IGlzIG9mIHZpdGFsXG4gKiBpbXBvcnRhbmNlIGFzIGl0J3MgdXNlZCBpbiB0aGUgcmVhZHlTdGF0ZSBjaGVjay5cbiAqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuUlMuc3RhdGVzID0gJ0FMTCxVTktOT1dOLExPQURJTkcsSU5URVJBQ1RJVkUsQ09NUExFVEUnLnNwbGl0KCcsJyk7XG5cbmZvciAodmFyIHMgPSAwLCBzdGF0ZTsgcyA8IFJTLnN0YXRlcy5sZW5ndGg7IHMrKykge1xuICBzdGF0ZSA9IFJTLnN0YXRlc1tzXTtcblxuICBSU1tzdGF0ZV0gPSBSUy5wcm90b3R5cGVbc3RhdGVdID0gcztcbiAgUlMucHJvdG90eXBlW3N0YXRlLnRvTG93ZXJDYXNlKCldID0gZ2VuZXJhdGUoc3RhdGUpO1xufVxuXG4vKipcbiAqIEEgY2hhbmdlIGluIHRoZSBlbnZpcm9ubWVudCBoYXMgYmVlbiBkZXRlY3RlZCBzbyB3ZSBuZWVkIHRvIGNoYW5nZSBvdXJcbiAqIHJlYWR5U3RhdGUgYW5kIGNhbGwgYXNzaWduZWQgZXZlbnQgbGlzdGVuZXJzIGFuZCB0aG9zZSBvZiB0aGUgcHJldmlvdXNcbiAqIHN0YXRlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdGUgVGhlIG5ldyByZWFkeVN0YXRlIHRoYXQgd2UgZGV0ZWN0ZWQuXG4gKiBAcmV0dXJucyB7UlN9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUlMucHJvdG90eXBlLmNoYW5nZSA9IGZ1bmN0aW9uIGNoYW5nZShzdGF0ZSkge1xuICBzdGF0ZSA9IHRoaXMuY2xlYW4oc3RhdGUsIHRydWUpO1xuXG4gIHZhciBqXG4gICAgLCBuYW1lXG4gICAgLCBpID0gMFxuICAgICwgbGlzdGVuZXJcbiAgICAsIHJzID0gdGhpc1xuICAgICwgcHJldmlvdXNseSA9IHJzLnJlYWR5U3RhdGU7XG5cbiAgaWYgKHByZXZpb3VzbHkgPj0gc3RhdGUpIHJldHVybiBycztcblxuICBycy5yZWFkeVN0YXRlID0gc3RhdGU7XG5cbiAgZm9yICg7IGkgPCBSUy5zdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA+IHN0YXRlKSBicmVhaztcbiAgICBuYW1lID0gUlMuc3RhdGVzW2ldO1xuXG4gICAgaWYgKG5hbWUgaW4gcnMuX2V2ZW50cykge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHJzLl9ldmVudHNbbmFtZV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGlzdGVuZXIgPSBycy5fZXZlbnRzW25hbWVdW2pdO1xuICAgICAgICBsaXN0ZW5lci5mbi5jYWxsKGxpc3RlbmVyLmNvbnRleHQgfHwgcnMsIHByZXZpb3VzbHkpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgcnMuX2V2ZW50c1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIGN1cnJlbnRseSBpbiBhIGdpdmVuIHJlYWR5U3RhdGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBzdGF0ZSBUaGUgcmVxdWlyZWQgcmVhZHlTdGF0ZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJbmRpY2F0aW9uIGlmIHRoaXMgc3RhdGUgaGFzIGJlZW4gcmVhY2hlZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblJTLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uIGlzKHN0YXRlKSB7XG4gIHJldHVybiB0aGlzLnJlYWR5U3RhdGUgPj0gdGhpcy5jbGVhbihzdGF0ZSwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHN0YXRlIHRvIGEgbnVtYmVyIG9yIHRvVXBwZXJDYXNlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHN0YXRlIFN0YXRlIHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbnIgQ2hhbmdlIHRvIG51bWJlci5cbiAqIEByZXR1cm5zIHtNaXhlZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblJTLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uIHRyYW5zZm9ybShzdGF0ZSwgbnIpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3RhdGU7XG5cbiAgaWYgKG5yKSByZXR1cm4gJ251bWJlcicgIT09IHR5cGVcbiAgPyArUlNbc3RhdGUudG9VcHBlckNhc2UoKV0gfHwgMFxuICA6IHN0YXRlO1xuXG4gIHJldHVybiAoJ251bWJlcicgPT09IHR5cGUgPyBSUy5zdGF0ZXNbc3RhdGVdIDogc3RhdGUpLnRvVXBwZXJDYXNlKCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycy4gVXNlZnVsIHdoZW4geW91IHdhbnQgdG8gdW5sb2FkIHJlYWR5c3RhdGVjaGFuZ2VcbiAqIGNvbXBsZXRlbHkgc28gdGhhdCBpdCB3b24ndCByZWFjdCB0byBhbnkgZXZlbnRzIGFueW1vcmUuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3Vuc2hpZnRpby9yZWFkeXN0YXRlL2lzc3Vlcy84XG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBycyBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuUlMucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgdGhpcy5fZXZlbnRzID0ge307XG4gIHJldHVybiB0aGlzO1xufVxuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgUlMoKTtcbiIsIi8qKlxuICogcmVxdWVzdC1mcmFtZSAtIHJlcXVlc3RBbmltYXRpb25GcmFtZSAmIGNhbmNlbEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGZvciBvcHRpbWFsIGNyb3NzLWJyb3dzZXIgZGV2ZWxvcG1lbnQuXG4gKiBAdmVyc2lvbiB2MS41LjNcbiAqIEBsaWNlbnNlIE1JVFxuICogQ29weXJpZ2h0IEp1bGllbiBFdGllbm5lIDIwMTUgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsLnJlcXVlc3RGcmFtZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgLSByZXF1ZXN0IHwgY2FuY2VsIHwgbmF0aXZlLlxuICogQHJldHVybiB7RnVuY3Rpb259IFRpbWluZyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gcmVxdWVzdEZyYW1lKHR5cGUpIHtcbiAgICAvLyBUaGUgb25seSB2ZW5kb3IgcHJlZml4ZXMgcmVxdWlyZWQuXG4gICAgdmFyIHZlbmRvcnMgPSBbJ21veicsICd3ZWJraXQnXTtcblxuICAgIC8vIERpc2Fzc2VtYmxlZCB0aW1pbmcgZnVuY3Rpb24gYWJicmV2aWF0aW9ucy5cbiAgICB2YXIgYUYgPSAnQW5pbWF0aW9uRnJhbWUnO1xuICAgIHZhciBycUFGID0gJ1JlcXVlc3QnICsgYUY7XG5cbiAgICAvLyBDaGVja3MgZm9yIGZpcmVmb3ggNCAtIDEwIGZ1bmN0aW9uIHBhaXIgbWlzbWF0Y2guXG4gICAgdmFyIG1velJBRiA9IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgdmFyIG1vekNBRiA9IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZTtcbiAgICB2YXIgaGFzTW96TWlzbWF0Y2ggPSBtb3pSQUYgJiYgIW1vekNBRjtcblxuICAgIC8vIEZpbmFsIGFzc2lnbmVkIGZ1bmN0aW9ucy5cbiAgICB2YXIgYXNzaWduZWRSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgdmFyIGFzc2lnbmVkQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cbiAgICAvLyBJbml0aWFsIHRpbWUgb2YgdGhlIHRpbWluZyBsYXBzZS5cbiAgICB2YXIgcHJldmlvdXNUaW1lID0gMDtcblxuICAgIHZhciByZXF1ZXN0RnJhbWVNYWluO1xuXG4gICAgLy8gRGF0ZS5ub3cgcG9seWZpbGwsIG1haW5seSBmb3IgbGVnYWN5IElFIHZlcnNpb25zLlxuICAgIGlmICghRGF0ZS5ub3cpIHtcbiAgICAgICAgRGF0ZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFzSU9TNlJlcXVlc3RBbmltYXRpb25GcmFtZUJ1Zy5cbiAgICAgKiBAU2VlIHtATGluayBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qdWxpZW5ldGllLzg2YWMzOTRlYzQxZjEyNzFmZjBhfVxuICAgICAqIC0gZm9yIENvbW1lbnRhcnkuXG4gICAgICogQENvcHlyaWdodCAyMDE1IC0gSnVsaWVuIEV0aWVubmUuIFxuICAgICAqIEBMaWNlbnNlOiBNSVQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzSU9TNlJlcXVlc3RBbmltYXRpb25GcmFtZUJ1ZygpIHtcbiAgICAgICAgdmFyIHdlYmtpdFJBRiA9IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgICAgIHZhciByQUYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4gICAgICAgIC8vIENTUy8gRGV2aWNlIHdpdGggbWF4IGZvciBpT1M2IERldmljZXMuXG4gICAgICAgIHZhciBoYXNNb2JpbGVEZXZpY2VXaWR0aCA9IHNjcmVlbi53aWR0aCA8PSA3NjggPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgLy8gT25seSBzdXBwb3J0cyB3ZWJraXQgcHJlZml4ZWQgcmVxdWVzdEFuaW10aW9uRnJhbmUuXG4gICAgICAgIHZhciByZXF1aXJlc1dlYmtpdHByZWZpeCA9ICEod2Via2l0UkFGICYmIHJBRik7XG5cbiAgICAgICAgLy8gaU9TNiB3ZWJraXQgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBwZXJmb3JtYW5jZSBub3cuXG4gICAgICAgIHZhciBoYXNOb05hdmlnYXRpb25UaW1pbmcgPSB3aW5kb3cucGVyZm9ybWFuY2UgPyBmYWxzZSA6IHRydWU7XG5cbiAgICAgICAgdmFyIGlPUzZOb3RpY2UgPSAnc2V0VGltZW91dCBpcyBiZWluZyB1c2VkIGFzIGEgc3Vic3RpdGl1ZSBmb3IgXFxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGR1ZSB0byBhIGJ1ZyB3aXRoaW4gaU9TIDYgYnVpbGRzJztcblxuICAgICAgICB2YXIgaGFzSU9TNkJ1ZyA9IHJlcXVpcmVzV2Via2l0cHJlZml4ICYmIGhhc01vYmlsZURldmljZVdpZHRoICYmIGhhc05vTmF2aWdhdGlvblRpbWluZztcblxuICAgICAgICB2YXIgYnVnQ2hlY2tyZXN1bHRzID0gZnVuY3Rpb24gYnVnQ2hlY2tyZXN1bHRzKHRpbWluZ0ZuQSwgdGltaW5nRm5CLCBub3RpY2UpIHtcbiAgICAgICAgICAgIGlmICh0aW1pbmdGbkEgfHwgdGltaW5nRm5CKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG5vdGljZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGlzcGxheVJlc3VsdHMgPSBmdW5jdGlvbiBkaXNwbGF5UmVzdWx0cyhoYXNCdWcsIGhhc0J1Z05vdGljZSwgd2Via2l0Rm4sIG5hdGl2ZUZuKSB7XG4gICAgICAgICAgICBpZiAoaGFzQnVnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1Z0NoZWNrcmVzdWx0cyh3ZWJraXRGbiwgbmF0aXZlRm4sIGhhc0J1Z05vdGljZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZGlzcGxheVJlc3VsdHMoaGFzSU9TNkJ1ZywgaU9TNk5vdGljZSwgd2Via2l0UkFGLCByQUYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5hdGl2ZSBjbGVhclRpbWVvdXQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xlYXJUaW1lb3V0V2l0aElkKGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gYSBwb2x5ZmlsbCBieSBFcmlrLCBpbnRyb2R1Y2VkIGJ5IFBhdWwgSXJpc2ggJiBcbiAgICAgKiBmdXJ0aGVyIGltcHJvdmVkIGJ5IERhcml1cyBCYWNvbi5cbiAgICAgKiBAc2VlICB7QGxpbmsgaHR0cDovL3d3dy5wYXVsaXJpc2guY29tLzIwMTEvXG4gICAgICogcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmd9XG4gICAgICogQHNlZSAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJpdXMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lL2Jsb2IvXG4gICAgICogbWFzdGVyL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qc31cbiAgICAgKiBAY2FsbGJhY2sge051bWJlcn0gVGltZXN0YW1wLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBzZXRUaW1lb3V0IEZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFRpbWVvdXRXaXRoVGltZXN0YW1wKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpbW1lZGlhdGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGxhcHNlZFRpbWUgPSBNYXRoLm1heChwcmV2aW91c1RpbWUgKyAxNiwgaW1tZWRpYXRlVGltZSk7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHByZXZpb3VzVGltZSA9IGxhcHNlZFRpbWUpO1xuICAgICAgICB9LCBsYXBzZWRUaW1lIC0gaW1tZWRpYXRlVGltZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVlcmllcyB0aGUgbmF0aXZlIGZ1bmN0aW9uLCBwcmVmaXhlZCBmdW5jdGlvbiBcbiAgICAgKiBvciB1c2UgdGhlIHNldFRpbWVvdXRXaXRoVGltZXN0YW1wIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1ZXJ5UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkge1xuICAgICAgICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbHRlcikge1xuICAgICAgICAgICAgYXNzaWduZWRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbJ3JlcXVlc3QnICsgYUZdIHx8IHdpbmRvd1t2ZW5kb3JzLmZpbHRlcihmdW5jdGlvbiAodmVuZG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvd1t2ZW5kb3IgKyBycUFGXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdmVuZG9yO1xuICAgICAgICAgICAgfSkgKyBycUFGXSB8fCBzZXRUaW1lb3V0V2l0aFRpbWVzdGFtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0V2l0aFRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0lPUzZSZXF1ZXN0QW5pbWF0aW9uRnJhbWVCdWcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFzc2lnbmVkUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXRXaXRoVGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVlcmllcyB0aGUgbmF0aXZlIGZ1bmN0aW9uLCBwcmVmaXhlZCBmdW5jdGlvbiBcbiAgICAgKiBvciB1c2UgdGhlIGNsZWFyVGltZW91dFdpdGhJZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWVyeUNhbmNlbEFuaW1hdGlvbkZyYW1lKCkge1xuICAgICAgICB2YXIgY2FuY2VsbGF0aW9uTmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LnByb3RvdHlwZS5tYXApIHtcbiAgICAgICAgICAgIHZlbmRvcnMubWFwKGZ1bmN0aW9uICh2ZW5kb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydDYW5jZWwnLCAnQ2FuY2VsUmVxdWVzdCddLm1hcChmdW5jdGlvbiAoY2FuY2VsbGF0aW9uTmFtZVByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25OYW1lcy5wdXNoKHZlbmRvciArIGNhbmNlbGxhdGlvbk5hbWVQcmVmaXggKyBhRik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXRXaXRoSWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGZvciB0aGUgcHJlZml4ZWQgY2FuY2VsQW5pbWF0aW9uRnJhbWUgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAqIEBwYXJhbSAge0FycmF5fSBwcmVmaXhlZE5hbWVzIC0gQW4gYXJyYXkgb2YgdGhlIHByZWZpeGVkIG5hbWVzLiBcbiAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBpIC0gSXRlcmF0aW9uIHN0YXJ0IHBvaW50LlxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJlZml4ZWQgY2FuY2VsQW5pbWF0aW9uRnJhbWUgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBwcmVmaXhlZENhbmNlbEFuaW1hdGlvbkZyYW1lKHByZWZpeGVkTmFtZXMsIGkpIHtcbiAgICAgICAgICAgIHZhciBjYW5jZWxsYXRpb25GdW5jdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcHJlZml4ZWROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3dbcHJlZml4ZWROYW1lc1tpXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uRnVuY3Rpb24gPSB3aW5kb3dbcHJlZml4ZWROYW1lc1tpXV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW5jZWxsYXRpb25GdW5jdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSB0cnV0aGx5IGZ1bmN0aW9uXG4gICAgICAgIGFzc2lnbmVkQ2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbJ2NhbmNlbCcgKyBhRl0gfHwgcHJlZml4ZWRDYW5jZWxBbmltYXRpb25GcmFtZShjYW5jZWxsYXRpb25OYW1lcywgMCkgfHwgY2xlYXJUaW1lb3V0V2l0aElkO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBpT1MgNiBidWdcbiAgICAgICAgaWYgKCFoYXNJT1M2UmVxdWVzdEFuaW1hdGlvbkZyYW1lQnVnKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3NpZ25lZENhbmNlbEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dFdpdGhJZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlcXVlc3RGbigpIHtcbiAgICAgICAgaWYgKGhhc01vek1pc21hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dFdpdGhUaW1lc3RhbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnlSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENhbmNlbEZuKCkge1xuICAgICAgICByZXR1cm4gcXVlcnlDYW5jZWxBbmltYXRpb25GcmFtZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE5hdGl2ZUZuKCkge1xuICAgICAgICBpZiAoaGFzTW96TWlzbWF0Y2gpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBzZXRUaW1lb3V0V2l0aFRpbWVzdGFtcDtcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNsZWFyVGltZW91dFdpdGhJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBxdWVyeVJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gcXVlcnlDYW5jZWxBbmltYXRpb25GcmFtZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgdmFsdWUgXCJyZXF1ZXN0XCIgc2luZ2xlcyBvdXQgZmlyZWZveCA0IC0gMTAgYW5kIFxuICAgICAqIGFzc2lnbnMgdGhlIHNldFRpbWVvdXQgZnVuY3Rpb24gaWYgcGxhdXNpYmxlLlxuICAgICAqL1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3JlcXVlc3QnOlxuICAgICAgICBjYXNlICcnOlxuICAgICAgICAgICAgcmVxdWVzdEZyYW1lTWFpbiA9IGdldFJlcXVlc3RGbigpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2FuY2VsJzpcbiAgICAgICAgICAgIHJlcXVlc3RGcmFtZU1haW4gPSBnZXRDYW5jZWxGbigpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbmF0aXZlJzpcbiAgICAgICAgICAgIHNldE5hdGl2ZUZuKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdEZyYW1lIHBhcmFtZXRlciBpcyBub3QgYSB0eXBlLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdEZyYW1lTWFpbjtcbn1cblxucmV0dXJuIHJlcXVlc3RGcmFtZTtcblxufSkpKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNoaWZ0XG5cbmZ1bmN0aW9uIHNoaWZ0IChzdHJlYW0pIHtcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGlmICghcnMpIHJldHVybiBudWxsXG4gIHJldHVybiBycy5vYmplY3RNb2RlID8gc3RyZWFtLnJlYWQoKSA6IHN0cmVhbS5yZWFkKGdldFN0YXRlTGVuZ3RoKHJzKSlcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVMZW5ndGggKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoKSB7XG4gICAgLy8gU2luY2Ugbm9kZSA2LjMuMCBzdGF0ZS5idWZmZXIgaXMgYSBCdWZmZXJMaXN0IG5vdCBhbiBhcnJheVxuICAgIGlmIChzdGF0ZS5idWZmZXIuaGVhZCkge1xuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGhcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gLTE7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnLnJlcGVhdChwKTtcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHAgKyAxKTtcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnLnJlcGVhdChwICsgMik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgZm9yIGVhY2ggYnVmZmVyZWQgYnl0ZSBvZiBhIChwYXJ0aWFsKVxuLy8gY2hhcmFjdGVyIG5lZWRzIHRvIGJlIGFkZGVkIHRvIHRoZSBvdXRwdXQuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJy5yZXBlYXQodGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwiLyoqXG4gKiBSb290IHJlZmVyZW5jZSBmb3IgaWZyYW1lcy5cbiAqL1xuXG52YXIgcm9vdDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyAvLyBCcm93c2VyIHdpbmRvd1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gV2ViIFdvcmtlclxuICByb290ID0gc2VsZjtcbn0gZWxzZSB7IC8vIE90aGVyIGVudmlyb25tZW50c1xuICBjb25zb2xlLndhcm4oXCJVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICByb290ID0gdGhpcztcbn1cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIFJlcXVlc3RCYXNlID0gcmVxdWlyZSgnLi9yZXF1ZXN0LWJhc2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXMtZnVuY3Rpb24nKTtcbnZhciBSZXNwb25zZUJhc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlLWJhc2UnKTtcbnZhciBzaG91bGRSZXRyeSA9IHJlcXVpcmUoJy4vc2hvdWxkLXJldHJ5Jyk7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fTtcblxuLyoqXG4gKiBFeHBvc2UgYHJlcXVlc3RgLlxuICovXG5cbnZhciByZXF1ZXN0ID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0aG9kLCB1cmwpIHtcbiAgLy8gY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHVybCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpLmVuZCh1cmwpO1xuICB9XG5cbiAgLy8gdXJsIGZpcnN0XG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbn1cblxuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBEZXRlcm1pbmUgWEhSLlxuICovXG5cbnJlcXVlc3QuZ2V0WEhSID0gZnVuY3Rpb24gKCkge1xuICBpZiAocm9vdC5YTUxIdHRwUmVxdWVzdFxuICAgICAgJiYgKCFyb290LmxvY2F0aW9uIHx8ICdmaWxlOicgIT0gcm9vdC5sb2NhdGlvbi5wcm90b2NvbFxuICAgICAgICAgIHx8ICFyb290LkFjdGl2ZVhPYmplY3QpKSB7XG4gICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdDtcbiAgfSBlbHNlIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjYuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICB9XG4gIHRocm93IEVycm9yKFwiQnJvd3Nlci1vbmx5IHZlcmlzb24gb2Ygc3VwZXJhZ2VudCBjb3VsZCBub3QgZmluZCBYSFJcIik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgYWRkZWQgdG8gc3VwcG9ydCBJRS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHRyaW0gPSAnJy50cmltXG4gID8gZnVuY3Rpb24ocykgeyByZXR1cm4gcy50cmltKCk7IH1cbiAgOiBmdW5jdGlvbihzKSB7IHJldHVybiBzLnJlcGxhY2UoLyheXFxzKnxcXHMqJCkvZywgJycpOyB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gIHZhciBwYWlycyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgb2JqW2tleV0pO1xuICB9XG4gIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogSGVscHMgJ3NlcmlhbGl6ZScgd2l0aCBzZXJpYWxpemluZyBhcnJheXMuXG4gKiBNdXRhdGVzIHRoZSBwYWlycyBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKi9cblxuZnVuY3Rpb24gcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdmFsKSB7XG4gIGlmICh2YWwgIT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGZvcih2YXIgc3Via2V5IGluIHZhbCkge1xuICAgICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5ICsgJ1snICsgc3Via2V5ICsgJ10nLCB2YWxbc3Via2V5XSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSlcbiAgICAgICAgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIHNlcmlhbGl6YXRpb24gbWV0aG9kLlxuICovXG5cbiByZXF1ZXN0LnNlcmlhbGl6ZU9iamVjdCA9IHNlcmlhbGl6ZTtcblxuIC8qKlxuICAqIFBhcnNlIHRoZSBnaXZlbiB4LXd3dy1mb3JtLXVybGVuY29kZWQgYHN0cmAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICogQHJldHVybiB7T2JqZWN0fVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICB2YXIgcGFpcnMgPSBzdHIuc3BsaXQoJyYnKTtcbiAgdmFyIHBhaXI7XG4gIHZhciBwb3M7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBvcyA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpcildID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZSgwLCBwb3MpKV0gPVxuICAgICAgICBkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZShwb3MgKyAxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHBvc2UgcGFyc2VyLlxuICovXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcblxuLyoqXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICovXG5cbnJlcXVlc3QudHlwZXMgPSB7XG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIHhtbDogJ2FwcGxpY2F0aW9uL3htbCcsXG4gIHVybGVuY29kZWQ6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAnZm9ybSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAnZm9ybS1kYXRhJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzZXJpYWxpemF0aW9uIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24ob2JqKXtcbiAqICAgICAgIHJldHVybiAnZ2VuZXJhdGVkIHhtbCBoZXJlJztcbiAqICAgICB9O1xuICpcbiAqL1xuXG4gcmVxdWVzdC5zZXJpYWxpemUgPSB7XG4gICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnN0cmluZ2lmeVxuIH07XG5cbiAvKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICB2YXIgaW5kZXg7XG4gIHZhciBsaW5lO1xuICB2YXIgZmllbGQ7XG4gIHZhciB2YWw7XG5cbiAgbGluZXMucG9wKCk7IC8vIHRyYWlsaW5nIENSTEZcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgaW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIGZpZWxkc1tmaWVsZF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBtaW1lYCBpcyBqc29uIG9yIGhhcyAranNvbiBzdHJ1Y3R1cmVkIHN5bnRheCBzdWZmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0pTT04obWltZSkge1xuICByZXR1cm4gL1tcXC8rXWpzb25cXGIvLnRlc3QobWltZSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VgIHdpdGggdGhlIGdpdmVuIGB4aHJgLlxuICpcbiAqICAtIHNldCBmbGFncyAoLm9rLCAuZXJyb3IsIGV0YylcbiAqICAtIHBhcnNlIGhlYWRlclxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICBBbGlhc2luZyBgc3VwZXJhZ2VudGAgYXMgYHJlcXVlc3RgIGlzIG5pY2U6XG4gKlxuICogICAgICByZXF1ZXN0ID0gc3VwZXJhZ2VudDtcbiAqXG4gKiAgV2UgY2FuIHVzZSB0aGUgcHJvbWlzZS1saWtlIEFQSSwgb3IgcGFzcyBjYWxsYmFja3M6XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnLycpLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICogICAgICByZXF1ZXN0LmdldCgnLycsIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIFNlbmRpbmcgZGF0YSBjYW4gYmUgY2hhaW5lZDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAuc2VuZCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5wb3N0KClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBPciBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW5nbGUgY2FsbCBmb3Igc2ltcGxlIGNhc2VzOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIEBwYXJhbSB7WE1MSFRUUFJlcXVlc3R9IHhoclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSkge1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcbiAgdGhpcy50ZXh0ID0gKCh0aGlzLnJlcS5tZXRob2QgIT0nSEVBRCcgJiYgKHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgfHwgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcpKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJylcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHRcbiAgICAgOiBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSB0aGlzLnJlcS54aHIuc3RhdHVzVGV4dDtcbiAgdmFyIHN0YXR1cyA9IHRoaXMueGhyLnN0YXR1cztcbiAgLy8gaGFuZGxlIElFOSBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAwNDY5NzIvbXNpZS1yZXR1cm5zLXN0YXR1cy1jb2RlLW9mLTEyMjMtZm9yLWFqYXgtcmVxdWVzdFxuICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICBzdGF0dXMgPSAyMDQ7XG4gIH1cbiAgdGhpcy5fc2V0U3RhdHVzUHJvcGVydGllcyhzdGF0dXMpO1xuICB0aGlzLmhlYWRlciA9IHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVyKHRoaXMueGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcbiAgLy8gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIHNvbWV0aW1lcyBmYWxzZWx5IHJldHVybnMgXCJcIiBmb3IgQ09SUyByZXF1ZXN0cywgYnV0XG4gIC8vIGdldFJlc3BvbnNlSGVhZGVyIHN0aWxsIHdvcmtzLiBzbyB3ZSBnZXQgY29udGVudC10eXBlIGV2ZW4gaWYgZ2V0dGluZ1xuICAvLyBvdGhlciBoZWFkZXJzIGZhaWxzLlxuICB0aGlzLmhlYWRlclsnY29udGVudC10eXBlJ10gPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG4gIHRoaXMuX3NldEhlYWRlclByb3BlcnRpZXModGhpcy5oZWFkZXIpO1xuXG4gIGlmIChudWxsID09PSB0aGlzLnRleHQgJiYgcmVxLl9yZXNwb25zZVR5cGUpIHtcbiAgICB0aGlzLmJvZHkgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmJvZHkgPSB0aGlzLnJlcS5tZXRob2QgIT0gJ0hFQUQnXG4gICAgICA/IHRoaXMuX3BhcnNlQm9keSh0aGlzLnRleHQgPyB0aGlzLnRleHQgOiB0aGlzLnhoci5yZXNwb25zZSlcbiAgICAgIDogbnVsbDtcbiAgfVxufVxuXG5SZXNwb25zZUJhc2UoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYm9keSBgc3RyYC5cbiAqXG4gKiBVc2VkIGZvciBhdXRvLXBhcnNpbmcgb2YgYm9kaWVzLiBQYXJzZXJzXG4gKiBhcmUgZGVmaW5lZCBvbiB0aGUgYHN1cGVyYWdlbnQucGFyc2VgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fcGFyc2VCb2R5ID0gZnVuY3Rpb24oc3RyKXtcbiAgdmFyIHBhcnNlID0gcmVxdWVzdC5wYXJzZVt0aGlzLnR5cGVdO1xuICBpZih0aGlzLnJlcS5fcGFyc2VyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxLl9wYXJzZXIodGhpcywgc3RyKTtcbiAgfVxuICBpZiAoIXBhcnNlICYmIGlzSlNPTih0aGlzLnR5cGUpKSB7XG4gICAgcGFyc2UgPSByZXF1ZXN0LnBhcnNlWydhcHBsaWNhdGlvbi9qc29uJ107XG4gIH1cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCB8fCBzdHIgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgPyBwYXJzZShzdHIpXG4gICAgOiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZXEgPSB0aGlzLnJlcTtcbiAgdmFyIG1ldGhvZCA9IHJlcS5tZXRob2Q7XG4gIHZhciB1cmwgPSByZXEudXJsO1xuXG4gIHZhciBtc2cgPSAnY2Fubm90ICcgKyBtZXRob2QgKyAnICcgKyB1cmwgKyAnICgnICsgdGhpcy5zdGF0dXMgKyAnKSc7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gbWV0aG9kO1xuICBlcnIudXJsID0gdXJsO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VgLlxuICovXG5cbnJlcXVlc3QuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICAgIC8vIGllOSBkb2Vzbid0IGhhdmUgJ3Jlc3BvbnNlJyBwcm9wZXJ0eVxuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSB0eXBlb2Ygc2VsZi54aHIucmVzcG9uc2VUeXBlID09ICd1bmRlZmluZWQnID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogc2VsZi54aHIucmVzcG9uc2U7XG4gICAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgICBlcnIuc3RhdHVzID0gc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1c0NvZGUgPSBlcnIuc3RhdHVzOyAvLyBiYWNrd2FyZHMtY29tcGF0IG9ubHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5jYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuXG4gICAgdmFyIG5ld19lcnI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VsZi5faXNSZXNwb25zZU9LKHJlcykpIHtcbiAgICAgICAgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICAgICAgbmV3X2Vyci5vcmlnaW5hbCA9IGVycjtcbiAgICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgICAgbmV3X2Vyci5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgbmV3X2VyciA9IGU7IC8vICM5ODUgdG91Y2hpbmcgcmVzIG1heSBjYXVzZSBJTlZBTElEX1NUQVRFX0VSUiBvbiBvbGQgQW5kcm9pZFxuICAgIH1cblxuICAgIC8vICMxMDAwIGRvbid0IGNhdGNoIGVycm9ycyBmcm9tIHRoZSBjYWxsYmFjayB0byBhdm9pZCBkb3VibGUgY2FsbGluZyBpdFxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBzZWxmLmNhbGxiYWNrKG5ld19lcnIsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1peGluIGBFbWl0dGVyYCBhbmQgYFJlcXVlc3RCYXNlYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblJlcXVlc3RCYXNlKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXQgQ29udGVudC1UeXBlIHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgneG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCdhcHBsaWNhdGlvbi94bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0NvbnRlbnQtVHlwZScsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQWNjZXB0IHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLmpzb24gPSAnYXBwbGljYXRpb24vanNvbic7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdqc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY2NlcHRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0FjY2VwdCcsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQXV0aG9yaXphdGlvbiBmaWVsZCB2YWx1ZSB3aXRoIGB1c2VyYCBhbmQgYHBhc3NgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Bhc3NdIG9wdGlvbmFsIGluIGNhc2Ugb2YgdXNpbmcgJ2JlYXJlcicgYXMgdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgd2l0aCAndHlwZScgcHJvcGVydHkgJ2F1dG8nLCAnYmFzaWMnIG9yICdiZWFyZXInIChkZWZhdWx0ICdiYXNpYycpXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uKHVzZXIsIHBhc3MsIG9wdGlvbnMpe1xuICBpZiAodHlwZW9mIHBhc3MgPT09ICdvYmplY3QnICYmIHBhc3MgIT09IG51bGwpIHsgLy8gcGFzcyBpcyBvcHRpb25hbCBhbmQgY2FuIHN1YnN0aXR1dGUgZm9yIG9wdGlvbnNcbiAgICBvcHRpb25zID0gcGFzcztcbiAgfVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgdHlwZTogJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGJ0b2EgPyAnYmFzaWMnIDogJ2F1dG8nLFxuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIGJ0b2EodXNlciArICc6JyArIHBhc3MpKTtcbiAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXI7XG4gICAgICB0aGlzLnBhc3N3b3JkID0gcGFzcztcbiAgICBicmVhaztcbiAgICAgIFxuICAgIGNhc2UgJ2JlYXJlcic6IC8vIHVzYWdlIHdvdWxkIGJlIC5hdXRoKGFjY2Vzc1Rva2VuLCB7IHR5cGU6ICdiZWFyZXInIH0pXG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsICdCZWFyZXIgJyArIHVzZXIpO1xuICAgIGJyZWFrOyAgXG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICByZXF1ZXN0LmdldCgnL3Nob2VzJylcbiAqICAgICAucXVlcnkoJ3NpemU9MTAnKVxuICogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24odmFsKXtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiB2YWwpIHZhbCA9IHNlcmlhbGl6ZSh2YWwpO1xuICBpZiAodmFsKSB0aGlzLl9xdWVyeS5wdXNoKHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBRdWV1ZSB0aGUgZ2l2ZW4gYGZpbGVgIGFzIGFuIGF0dGFjaG1lbnQgdG8gdGhlIHNwZWNpZmllZCBgZmllbGRgLFxuICogd2l0aCBvcHRpb25hbCBgb3B0aW9uc2AgKG9yIGZpbGVuYW1lKS5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5hdHRhY2goJ2NvbnRlbnQnLCBuZXcgQmxvYihbJzxhIGlkPVwiYVwiPjxiIGlkPVwiYlwiPmhleSE8L2I+PC9hPiddLCB7IHR5cGU6IFwidGV4dC9odG1sXCJ9KSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbihmaWVsZCwgZmlsZSwgb3B0aW9ucyl7XG4gIGlmIChmaWxlKSB7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHRocm93IEVycm9yKFwic3VwZXJhZ2VudCBjYW4ndCBtaXggLnNlbmQoKSBhbmQgLmF0dGFjaCgpXCIpO1xuICAgIH1cblxuICAgIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKGZpZWxkLCBmaWxlLCBvcHRpb25zIHx8IGZpbGUubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZ2V0Rm9ybURhdGEgPSBmdW5jdGlvbigpe1xuICBpZiAoIXRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhpcy5fZm9ybURhdGEgPSBuZXcgcm9vdC5Gb3JtRGF0YSgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9mb3JtRGF0YTtcbn07XG5cbi8qKlxuICogSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGBlcnJgIGFuZCBgcmVzYFxuICogYW5kIGhhbmRsZSBhcml0eSBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIHJlcyl7XG4gIC8vIGNvbnNvbGUubG9nKHRoaXMuX3JldHJpZXMsIHRoaXMuX21heFJldHJpZXMpXG4gIGlmICh0aGlzLl9tYXhSZXRyaWVzICYmIHRoaXMuX3JldHJpZXMrKyA8IHRoaXMuX21heFJldHJpZXMgJiYgc2hvdWxkUmV0cnkoZXJyLCByZXMpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJ5KCk7XG4gIH1cblxuICB2YXIgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuX21heFJldHJpZXMpIGVyci5yZXRyaWVzID0gdGhpcy5fcmV0cmllcyAtIDE7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgZXJyID0gbmV3IEVycm9yKCdSZXF1ZXN0IGhhcyBiZWVuIHRlcm1pbmF0ZWRcXG5Qb3NzaWJsZSBjYXVzZXM6IHRoZSBuZXR3b3JrIGlzIG9mZmxpbmUsIE9yaWdpbiBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4sIHRoZSBwYWdlIGlzIGJlaW5nIHVubG9hZGVkLCBldGMuJyk7XG4gIGVyci5jcm9zc0RvbWFpbiA9IHRydWU7XG5cbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gIGVyci51cmwgPSB0aGlzLnVybDtcblxuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vLyBUaGlzIG9ubHkgd2FybnMsIGJlY2F1c2UgdGhlIHJlcXVlc3QgaXMgc3RpbGwgbGlrZWx5IHRvIHdvcmtcblJlcXVlc3QucHJvdG90eXBlLmJ1ZmZlciA9IFJlcXVlc3QucHJvdG90eXBlLmNhID0gUmVxdWVzdC5wcm90b3R5cGUuYWdlbnQgPSBmdW5jdGlvbigpe1xuICBjb25zb2xlLndhcm4oXCJUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gVGhpcyB0aHJvd3MsIGJlY2F1c2UgaXQgY2FuJ3Qgc2VuZC9yZWNlaXZlIGRhdGEgYXMgZXhwZWN0ZWRcblJlcXVlc3QucHJvdG90eXBlLnBpcGUgPSBSZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKCl7XG4gIHRocm93IEVycm9yKFwiU3RyZWFtaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIik7XG59O1xuXG4vKipcbiAqIENvbXBvc2UgcXVlcnlzdHJpbmcgdG8gYXBwZW5kIHRvIHJlcS51cmxcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fYXBwZW5kUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeS5qb2luKCcmJyk7XG4gIGlmIChxdWVyeSkge1xuICAgIHRoaXMudXJsICs9ICh0aGlzLnVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgKyBxdWVyeTtcbiAgfVxuXG4gIGlmICh0aGlzLl9zb3J0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy51cmwuaW5kZXhPZignPycpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgcXVlcnlBcnIgPSB0aGlzLnVybC5zdWJzdHJpbmcoaW5kZXggKyAxKS5zcGxpdCgnJicpO1xuICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5fc29ydCkpIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCh0aGlzLl9zb3J0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gdGhpcy51cmwuc3Vic3RyaW5nKDAsIGluZGV4KSArICc/JyArIHF1ZXJ5QXJyLmpvaW4oJyYnKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBob3N0IG9iamVjdCxcbiAqIHdlIGRvbid0IHdhbnQgdG8gc2VyaWFsaXplIHRoZXNlIDopXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5SZXF1ZXN0LnByb3RvdHlwZS5faXNIb3N0ID0gZnVuY3Rpb24gX2lzSG9zdChvYmopIHtcbiAgLy8gTmF0aXZlIG9iamVjdHMgc3RyaW5naWZ5IHRvIFtvYmplY3QgRmlsZV0sIFtvYmplY3QgQmxvYl0sIFtvYmplY3QgRm9ybURhdGFdLCBldGMuXG4gIHJldHVybiBvYmogJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmogJiYgIUFycmF5LmlzQXJyYXkob2JqKSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSAhPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogSW5pdGlhdGUgcmVxdWVzdCwgaW52b2tpbmcgY2FsbGJhY2sgYGZuKHJlcylgXG4gKiB3aXRoIGFuIGluc3RhbmNlb2YgYFJlc3BvbnNlYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGZuKXtcbiAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IC5lbmQoKSB3YXMgY2FsbGVkIHR3aWNlLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gc3VwZXJhZ2VudFwiKTtcbiAgfVxuICB0aGlzLl9lbmRDYWxsZWQgPSB0cnVlO1xuXG4gIC8vIHN0b3JlIGNhbGxiYWNrXG4gIHRoaXMuX2NhbGxiYWNrID0gZm4gfHwgbm9vcDtcblxuICAvLyBxdWVyeXN0cmluZ1xuICB0aGlzLl9hcHBlbmRRdWVyeVN0cmluZygpO1xuXG4gIHJldHVybiB0aGlzLl9lbmQoKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGhyID0gdGhpcy54aHIgPSByZXF1ZXN0LmdldFhIUigpO1xuICB2YXIgZGF0YSA9IHRoaXMuX2Zvcm1EYXRhIHx8IHRoaXMuX2RhdGE7XG5cbiAgdGhpcy5fc2V0VGltZW91dHMoKTtcblxuICAvLyBzdGF0ZSBjaGFuZ2VcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyICYmIHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICAgIH1cbiAgICBpZiAoNCAhPSByZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW4gSUU5LCByZWFkcyB0byBhbnkgcHJvcGVydHkgKGUuZy4gc3RhdHVzKSBvZmYgb2YgYW4gYWJvcnRlZCBYSFIgd2lsbFxuICAgIC8vIHJlc3VsdCBpbiB0aGUgZXJyb3IgXCJDb3VsZCBub3QgY29tcGxldGUgdGhlIG9wZXJhdGlvbiBkdWUgdG8gZXJyb3IgYzAwYzAyM2ZcIlxuICAgIHZhciBzdGF0dXM7XG4gICAgdHJ5IHsgc3RhdHVzID0geGhyLnN0YXR1cyB9IGNhdGNoKGUpIHsgc3RhdHVzID0gMDsgfVxuXG4gICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLnRpbWVkb3V0IHx8IHNlbGYuX2Fib3J0ZWQpIHJldHVybjtcbiAgICAgIHJldHVybiBzZWxmLmNyb3NzRG9tYWluRXJyb3IoKTtcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdlbmQnKTtcbiAgfTtcblxuICAvLyBwcm9ncmVzc1xuICB2YXIgaGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcbiAgICBpZiAoZS50b3RhbCA+IDApIHtcbiAgICAgIGUucGVyY2VudCA9IGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMDtcbiAgICB9XG4gICAgZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIGUpO1xuICB9XG4gIGlmICh0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgIHRyeSB7XG4gICAgICB4aHIub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ2Rvd25sb2FkJyk7XG4gICAgICBpZiAoeGhyLnVwbG9hZCkge1xuICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICd1cGxvYWQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIC8vIEFjY2Vzc2luZyB4aHIudXBsb2FkIGZhaWxzIGluIElFIGZyb20gYSB3ZWIgd29ya2VyLCBzbyBqdXN0IHByZXRlbmQgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFJlcG9ydGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzgzNzI0NS94bWxodHRwcmVxdWVzdC11cGxvYWQtdGhyb3dzLWludmFsaWQtYXJndW1lbnQtd2hlbi11c2VkLWZyb20td2ViLXdvcmtlci1jb250ZXh0XG4gICAgfVxuICB9XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICB0cnkge1xuICAgIGlmICh0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmQpIHtcbiAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSwgdGhpcy51c2VybmFtZSwgdGhpcy5wYXNzd29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBzZWUgIzExNDlcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgLy8gQ09SU1xuICBpZiAodGhpcy5fd2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICAvLyBib2R5XG4gIGlmICghdGhpcy5fZm9ybURhdGEgJiYgJ0dFVCcgIT0gdGhpcy5tZXRob2QgJiYgJ0hFQUQnICE9IHRoaXMubWV0aG9kICYmICdzdHJpbmcnICE9IHR5cGVvZiBkYXRhICYmICF0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICAvLyBzZXJpYWxpemUgc3R1ZmZcbiAgICB2YXIgY29udGVudFR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIHZhciBzZXJpYWxpemUgPSB0aGlzLl9zZXJpYWxpemVyIHx8IHJlcXVlc3Quc2VyaWFsaXplW2NvbnRlbnRUeXBlID8gY29udGVudFR5cGUuc3BsaXQoJzsnKVswXSA6ICcnXTtcbiAgICBpZiAoIXNlcmlhbGl6ZSAmJiBpc0pTT04oY29udGVudFR5cGUpKSB7XG4gICAgICBzZXJpYWxpemUgPSByZXF1ZXN0LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuXG4gICAgaWYgKHRoaXMuaGVhZGVyLmhhc093blByb3BlcnR5KGZpZWxkKSlcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdHRVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogSEVBRCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuaGVhZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIE9QVElPTlMgcXVlcnkgdG8gYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0Lm9wdGlvbnMgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBERUxFVEUgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlbCh1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG5yZXF1ZXN0WydkZWwnXSA9IGRlbDtcbnJlcXVlc3RbJ2RlbGV0ZSddID0gZGVsO1xuXG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBhdGNoID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQQVRDSCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBPU1QgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucG9zdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBVVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuIiwiLyoqXG4gKiBDaGVjayBpZiBgZm5gIGlzIGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihmbikge1xuICB2YXIgdGFnID0gaXNPYmplY3QoZm4pID8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZuKSA6ICcnO1xuICByZXR1cm4gdGFnID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBudWxsICE9PSBvYmogJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIE1vZHVsZSBvZiBtaXhlZC1pbiBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gbm9kZSBhbmQgY2xpZW50IGNvZGVcbiAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlcXVlc3RCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RCYXNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlcXVlc3RCYXNlYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3RCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBSZXF1ZXN0QmFzZS5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQ2xlYXIgcHJldmlvdXMgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIF9jbGVhclRpbWVvdXQoKXtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgZGVsZXRlIHRoaXMuX3RpbWVyO1xuICBkZWxldGUgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlc3BvbnNlIGJvZHkgcGFyc2VyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGluY29taW5nIGRhdGEgaW50byByZXF1ZXN0LmJvZHlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShmbil7XG4gIHRoaXMuX3BhcnNlciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IGZvcm1hdCBvZiBiaW5hcnkgcmVzcG9uc2UgYm9keS5cbiAqIEluIGJyb3dzZXIgdmFsaWQgZm9ybWF0cyBhcmUgJ2Jsb2InIGFuZCAnYXJyYXlidWZmZXInLFxuICogd2hpY2ggcmV0dXJuIEJsb2IgYW5kIEFycmF5QnVmZmVyLCByZXNwZWN0aXZlbHkuXG4gKlxuICogSW4gTm9kZSBhbGwgdmFsdWVzIHJlc3VsdCBpbiBCdWZmZXIuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAucmVzcG9uc2VUeXBlKCdibG9iJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uKHZhbCl7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVxdWVzdCBib2R5IHNlcmlhbGl6ZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgZGF0YSBzZXQgdmlhIC5zZW5kIG9yIC5hdHRhY2ggaW50byBwYXlsb2FkIHRvIHNlbmRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKGZuKXtcbiAgdGhpcy5fc2VyaWFsaXplciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRpbWVvdXRzLlxuICpcbiAqIC0gcmVzcG9uc2UgdGltZW91dCBpcyB0aW1lIGJldHdlZW4gc2VuZGluZyByZXF1ZXN0IGFuZCByZWNlaXZpbmcgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIHJlc3BvbnNlLiBJbmNsdWRlcyBETlMgYW5kIGNvbm5lY3Rpb24gdGltZS5cbiAqIC0gZGVhZGxpbmUgaXMgdGhlIHRpbWUgZnJvbSBzdGFydCBvZiB0aGUgcmVxdWVzdCB0byByZWNlaXZpbmcgcmVzcG9uc2UgYm9keSBpbiBmdWxsLiBJZiB0aGUgZGVhZGxpbmUgaXMgdG9vIHNob3J0IGxhcmdlIGZpbGVzIG1heSBub3QgbG9hZCBhdCBhbGwgb24gc2xvdyBjb25uZWN0aW9ucy5cbiAqXG4gKiBWYWx1ZSBvZiAwIG9yIGZhbHNlIG1lYW5zIG5vIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBtcyBvciB7cmVzcG9uc2UsIHJlYWQsIGRlYWRsaW5lfVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gdGltZW91dChvcHRpb25zKXtcbiAgaWYgKCFvcHRpb25zIHx8ICdvYmplY3QnICE9PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zO1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgc3dpdGNoKG9wdGlvbikge1xuICAgICAgY2FzZSAnZGVhZGxpbmUnOlxuICAgICAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucy5kZWFkbGluZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZXNwb25zZSc6XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biB0aW1lb3V0IG9wdGlvblwiLCBvcHRpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBvbiBlcnJvci5cbiAqXG4gKiBGYWlsZWQgcmVxdWVzdHMgd2lsbCBiZSByZXRyaWVkICdjb3VudCcgdGltZXMgaWYgdGltZW91dCBvciBlcnIuY29kZSA+PSA1MDAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24gcmV0cnkoY291bnQpe1xuICAvLyBEZWZhdWx0IHRvIDEgaWYgbm8gY291bnQgcGFzc2VkIG9yIHRydWVcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgY291bnQgPT09IHRydWUpIGNvdW50ID0gMTtcbiAgaWYgKGNvdW50IDw9IDApIGNvdW50ID0gMDtcbiAgdGhpcy5fbWF4UmV0cmllcyA9IGNvdW50O1xuICB0aGlzLl9yZXRyaWVzID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHJ5IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fcmV0cnkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICAvLyBub2RlXG4gIGlmICh0aGlzLnJlcSkge1xuICAgIHRoaXMucmVxID0gbnVsbDtcbiAgICB0aGlzLnJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB9XG5cbiAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlO1xuICB0aGlzLnRpbWVkb3V0ID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRoaXMuX2VuZCgpO1xufTtcblxuLyoqXG4gKiBQcm9taXNlIHN1cHBvcnRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVqZWN0XVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIHRoZW4ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGlmICghdGhpcy5fZnVsbGZpbGxlZFByb21pc2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogc3VwZXJhZ2VudCByZXF1ZXN0IHdhcyBzZW50IHR3aWNlLCBiZWNhdXNlIGJvdGggLmVuZCgpIGFuZCAudGhlbigpIHdlcmUgY2FsbGVkLiBOZXZlciBjYWxsIC5lbmQoKSBpZiB5b3UgdXNlIHByb21pc2VzXCIpO1xuICAgIH1cbiAgICB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKGlubmVyUmVzb2x2ZSwgaW5uZXJSZWplY3Qpe1xuICAgICAgc2VsZi5lbmQoZnVuY3Rpb24oZXJyLCByZXMpe1xuICAgICAgICBpZiAoZXJyKSBpbm5lclJlamVjdChlcnIpOyBlbHNlIGlubmVyUmVzb2x2ZShyZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbn1cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24oY2IpIHtcbiAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNiKTtcbn07XG5cbi8qKlxuICogQWxsb3cgZm9yIGV4dGVuc2lvblxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZm4pIHtcbiAgZm4odGhpcyk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUub2sgPSBmdW5jdGlvbihjYikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNiKSB0aHJvdyBFcnJvcihcIkNhbGxiYWNrIHJlcXVpcmVkXCIpO1xuICB0aGlzLl9va0NhbGxiYWNrID0gY2I7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9pc1Jlc3BvbnNlT0sgPSBmdW5jdGlvbihyZXMpIHtcbiAgaWYgKCFyZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fb2tDYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9va0NhbGxiYWNrKHJlcyk7XG4gIH1cblxuICByZXR1cm4gcmVzLnN0YXR1cyA+PSAyMDAgJiYgcmVzLnN0YXR1cyA8IDMwMDtcbn07XG5cblxuLyoqXG4gKiBHZXQgcmVxdWVzdCBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBgZmllbGRgIHZhbHVlLlxuICogVGhpcyBpcyBhIGRlcHJlY2F0ZWQgaW50ZXJuYWwgQVBJLiBVc2UgYC5nZXQoZmllbGQpYCBpbnN0ZWFkLlxuICpcbiAqIChnZXRIZWFkZXIgaXMgbm8gbG9uZ2VyIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgc3VwZXJhZ2VudCBjb2RlIGJhc2UpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldEhlYWRlciA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihmaWVsZCwgdmFsKXtcbiAgaWYgKGlzT2JqZWN0KGZpZWxkKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBmaWVsZCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAudW5zZXQoJ1VzZXItQWdlbnQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIGRlbGV0ZSB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG4gIGRlbGV0ZSB0aGlzLmhlYWRlcltmaWVsZF07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZSB0aGUgZmllbGQgYG5hbWVgIGFuZCBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdFxuICogZm9yIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHJlcXVlc3QgYm9kaWVzLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKCdmb28nLCAnYmFyJylcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKHsgZm9vOiAnYmFyJywgYmF6OiAncXV4JyB9KVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd8QmxvYnxGaWxlfEJ1ZmZlcnxmcy5SZWFkU3RyZWFtfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG5cbiAgLy8gbmFtZSBzaG91bGQgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdC5cbiAgaWYgKG51bGwgPT09IG5hbWUgfHwgIHVuZGVmaW5lZCA9PT0gbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgbmFtZSBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCIuZmllbGQoKSBjYW4ndCBiZSB1c2VkIGlmIC5zZW5kKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICB0aGlzLmZpZWxkKGtleSwgbmFtZVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgZm9yICh2YXIgaSBpbiB2YWwpIHtcbiAgICAgIHRoaXMuZmllbGQobmFtZSwgdmFsW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB2YWwgc2hvdWxkIGJlIGRlZmluZWQgbm93XG4gIGlmIChudWxsID09PSB2YWwgfHwgdW5kZWZpbmVkID09PSB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIHZhbCBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cbiAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHZhbCkge1xuICAgIHZhbCA9ICcnICsgdmFsO1xuICB9XG4gIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhociAmJiB0aGlzLnhoci5hYm9ydCgpOyAvLyBicm93c2VyXG4gIHRoaXMucmVxICYmIHRoaXMucmVxLmFib3J0KCk7IC8vIG5vZGVcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5hYmxlIHRyYW5zbWlzc2lvbiBvZiBjb29raWVzIHdpdGggeC1kb21haW4gcmVxdWVzdHMuXG4gKlxuICogTm90ZSB0aGF0IGZvciB0aGlzIHRvIHdvcmsgdGhlIG9yaWdpbiBtdXN0IG5vdCBiZVxuICogdXNpbmcgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIiB3aXRoIGEgd2lsZGNhcmQsXG4gKiBhbmQgYWxzbyBtdXN0IHNldCBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCJcbiAqIHRvIFwidHJ1ZVwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uKG9uKXtcbiAgLy8gVGhpcyBpcyBicm93c2VyLW9ubHkgZnVuY3Rpb25hbGl0eS4gTm9kZSBzaWRlIGlzIG5vLW9wLlxuICBpZihvbj09dW5kZWZpbmVkKSBvbiA9IHRydWU7XG4gIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IG9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggcmVkaXJlY3RzIHRvIGBuYC4gRG9lcyBub3RpbmcgaW4gYnJvd3NlciBYSFIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVkaXJlY3RzID0gZnVuY3Rpb24obil7XG4gIHRoaXMuX21heFJlZGlyZWN0cyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgKG5vdCBKU09OIHN0cmluZykgb2Ygc2NhbGFyIHByb3BlcnRpZXMuXG4gKiBOb3RlIGFzIHRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIHJldHVybiBhIHVzZWZ1bCBub24tdGhpcyB2YWx1ZSxcbiAqIGl0IGNhbm5vdCBiZSBjaGFpbmVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVzY3JpYmluZyBtZXRob2QsIHVybCwgYW5kIGRhdGEgb2YgdGhpcyByZXF1ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpe1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgdXJsOiB0aGlzLnVybCxcbiAgICBkYXRhOiB0aGlzLl9kYXRhLFxuICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlclxuICB9O1xufTtcblxuXG4vKipcbiAqIFNlbmQgYGRhdGFgIGFzIHRoZSByZXF1ZXN0IGJvZHksIGRlZmF1bHRpbmcgdGhlIGAudHlwZSgpYCB0byBcImpzb25cIiB3aGVuXG4gKiBhbiBvYmplY3QgaXMgZ2l2ZW4uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gbWFudWFsIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnanNvbicpXG4gKiAgICAgICAgIC5zZW5kKCd7XCJuYW1lXCI6XCJ0alwifScpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gbWFudWFsIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoJ25hbWU9dGonKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0cyB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoJ25hbWU9dG9iaScpXG4gKiAgICAgICAgLnNlbmQoJ3NwZWNpZXM9ZmVycmV0JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGF0YVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBpc09iaiA9IGlzT2JqZWN0KGRhdGEpO1xuICB2YXIgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgaWYgKHRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgY29uc29sZS5lcnJvcihcIi5zZW5kKCkgY2FuJ3QgYmUgdXNlZCBpZiAuYXR0YWNoKCkgb3IgLmZpZWxkKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iaiAmJiAhdGhpcy5fZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEgJiYgdGhpcy5fZGF0YSAmJiB0aGlzLl9pc0hvc3QodGhpcy5fZGF0YSkpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbid0IG1lcmdlIHRoZXNlIHNlbmQgY2FsbHNcIik7XG4gIH1cblxuICAvLyBtZXJnZVxuICBpZiAoaXNPYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIC8vIGRlZmF1bHQgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBpZiAoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgPT0gdHlwZSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGFcbiAgICAgICAgPyB0aGlzLl9kYXRhICsgJyYnICsgZGF0YVxuICAgICAgICA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghaXNPYmogfHwgdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkZWZhdWx0IHRvIGpzb25cbiAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2pzb24nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogU29ydCBgcXVlcnlzdHJpbmdgIGJ5IHRoZSBzb3J0IGZ1bmN0aW9uXG4gKlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIGRlZmF1bHQgb3JkZXJcbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KClcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBjdXN0b21pemVkIHNvcnQgZnVuY3Rpb25cbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KGZ1bmN0aW9uKGEsIGIpe1xuICogICAgICAgICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICogICAgICAgICB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNvcnRRdWVyeSA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgLy8gX3NvcnQgZGVmYXVsdCB0byB0cnVlIGJ1dCBvdGhlcndpc2UgY2FuIGJlIGEgZnVuY3Rpb24gb3IgYm9vbGVhblxuICB0aGlzLl9zb3J0ID0gdHlwZW9mIHNvcnQgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IHNvcnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fdGltZW91dEVycm9yID0gZnVuY3Rpb24ocmVhc29uLCB0aW1lb3V0LCBlcnJubyl7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IocmVhc29uICsgdGltZW91dCArICdtcyBleGNlZWRlZCcpO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIGVyci5jb2RlID0gJ0VDT05OQUJPUlRFRCc7XG4gIGVyci5lcnJubyA9IGVycm5vO1xuICB0aGlzLnRpbWVkb3V0ID0gdHJ1ZTtcbiAgdGhpcy5hYm9ydCgpO1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3NldFRpbWVvdXRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBkZWFkbGluZVxuICBpZiAodGhpcy5fdGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignVGltZW91dCBvZiAnLCBzZWxmLl90aW1lb3V0LCAnRVRJTUUnKTtcbiAgICB9LCB0aGlzLl90aW1lb3V0KTtcbiAgfVxuICAvLyByZXNwb25zZSB0aW1lb3V0XG4gIGlmICh0aGlzLl9yZXNwb25zZVRpbWVvdXQgJiYgIXRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoJ1Jlc3BvbnNlIHRpbWVvdXQgb2YgJywgc2VsZi5fcmVzcG9uc2VUaW1lb3V0LCAnRVRJTUVET1VUJyk7XG4gICAgfSwgdGhpcy5fcmVzcG9uc2VUaW1lb3V0KTtcbiAgfVxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3BvbnNlQmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZUJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2VCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBSZXNwb25zZUJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXNwb25zZUJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICByZXR1cm4gdGhpcy5oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgcmVsYXRlZCBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgLnR5cGVgIHRoZSBjb250ZW50IHR5cGUgd2l0aG91dCBwYXJhbXNcbiAqXG4gKiBBIHJlc3BvbnNlIG9mIFwiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAqIHdpbGwgcHJvdmlkZSB5b3Ugd2l0aCBhIGAudHlwZWAgb2YgXCJ0ZXh0L3BsYWluXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKGhlYWRlcil7XG4gICAgLy8gVE9ETzogbW9hciFcbiAgICAvLyBUT0RPOiBtYWtlIHRoaXMgYSB1dGlsXG5cbiAgICAvLyBjb250ZW50LXR5cGVcbiAgICB2YXIgY3QgPSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICAgIHRoaXMudHlwZSA9IHV0aWxzLnR5cGUoY3QpO1xuXG4gICAgLy8gcGFyYW1zXG4gICAgdmFyIHBhcmFtcyA9IHV0aWxzLnBhcmFtcyhjdCk7XG4gICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykgdGhpc1trZXldID0gcGFyYW1zW2tleV07XG5cbiAgICB0aGlzLmxpbmtzID0ge307XG5cbiAgICAvLyBsaW5rc1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChoZWFkZXIubGluaykge1xuICAgICAgICAgICAgdGhpcy5saW5rcyA9IHV0aWxzLnBhcnNlTGlua3MoaGVhZGVyLmxpbmspO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0U3RhdHVzUHJvcGVydGllcyA9IGZ1bmN0aW9uKHN0YXR1cyl7XG4gICAgdmFyIHR5cGUgPSBzdGF0dXMgLyAxMDAgfCAwO1xuXG4gICAgLy8gc3RhdHVzIC8gY2xhc3NcbiAgICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1R5cGUgPSB0eXBlO1xuXG4gICAgLy8gYmFzaWNzXG4gICAgdGhpcy5pbmZvID0gMSA9PSB0eXBlO1xuICAgIHRoaXMub2sgPSAyID09IHR5cGU7XG4gICAgdGhpcy5yZWRpcmVjdCA9IDMgPT0gdHlwZTtcbiAgICB0aGlzLmNsaWVudEVycm9yID0gNCA9PSB0eXBlO1xuICAgIHRoaXMuc2VydmVyRXJyb3IgPSA1ID09IHR5cGU7XG4gICAgdGhpcy5lcnJvciA9ICg0ID09IHR5cGUgfHwgNSA9PSB0eXBlKVxuICAgICAgICA/IHRoaXMudG9FcnJvcigpXG4gICAgICAgIDogZmFsc2U7XG5cbiAgICAvLyBzdWdhclxuICAgIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICAgIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cztcbiAgICB0aGlzLmJhZFJlcXVlc3QgPSA0MDAgPT0gc3RhdHVzO1xuICAgIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xuICAgIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEZvdW5kID0gNDA0ID09IHN0YXR1cztcbn07XG4iLCJ2YXIgRVJST1JfQ09ERVMgPSBbXG4gICdFQ09OTlJFU0VUJyxcbiAgJ0VUSU1FRE9VVCcsXG4gICdFQUREUklORk8nLFxuICAnRVNPQ0tFVFRJTUVET1VUJ1xuXTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSByZXF1ZXN0IHNob3VsZCBiZSByZXRyaWVkLlxuICogKEJvcnJvd2VkIGZyb20gc2VnbWVudGlvL3N1cGVyYWdlbnQtcmV0cnkpXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSBbcmVzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hvdWxkUmV0cnkoZXJyLCByZXMpIHtcbiAgaWYgKGVyciAmJiBlcnIuY29kZSAmJiB+RVJST1JfQ09ERVMuaW5kZXhPZihlcnIuY29kZSkpIHJldHVybiB0cnVlO1xuICBpZiAocmVzICYmIHJlcy5zdGF0dXMgJiYgcmVzLnN0YXR1cyA+PSA1MDApIHJldHVybiB0cnVlO1xuICAvLyBTdXBlcmFnZW50IHRpbWVvdXRcbiAgaWYgKGVyciAmJiAndGltZW91dCcgaW4gZXJyICYmIGVyci5jb2RlID09ICdFQ09OTkFCT1JURUQnKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGVyciAmJiAnY3Jvc3NEb21haW4nIGluIGVycikgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCJcbi8qKlxuICogUmV0dXJuIHRoZSBtaW1lIHR5cGUgZm9yIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKjsgKi8pLnNoaWZ0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBoZWFkZXIgZmllbGQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcmFtcyA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgc3RyKXtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLyk7XG4gICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgdmFyIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMaW5rIGhlYWRlciBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJzZUxpbmtzID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICosICovKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo7ICovKTtcbiAgICB2YXIgdXJsID0gcGFydHNbMF0uc2xpY2UoMSwgLTEpO1xuICAgIHZhciByZWwgPSBwYXJ0c1sxXS5zcGxpdCgvICo9ICovKVsxXS5zbGljZSgxLCAtMSk7XG4gICAgb2JqW3JlbF0gPSB1cmw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBTdHJpcCBjb250ZW50IHJlbGF0ZWQgZmllbGRzIGZyb20gYGhlYWRlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuY2xlYW5IZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIsIHNob3VsZFN0cmlwQ29va2llKXtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC10eXBlJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ3RyYW5zZmVyLWVuY29kaW5nJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ2hvc3QnXTtcbiAgaWYgKHNob3VsZFN0cmlwQ29va2llKSB7XG4gICAgZGVsZXRlIGhlYWRlclsnY29va2llJ107XG4gIH1cbiAgcmV0dXJuIGhlYWRlcjtcbn07IiwiLyoqXG4gKiBDb252ZXJ0IGEgdHlwZWQgYXJyYXkgdG8gYSBCdWZmZXIgd2l0aG91dCBhIGNvcHlcbiAqXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIExpY2Vuc2U6ICBNSVRcbiAqXG4gKiBgbnBtIGluc3RhbGwgdHlwZWRhcnJheS10by1idWZmZXJgXG4gKi9cblxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkYXJyYXknKS5zdHJpY3RcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0eXBlZGFycmF5VG9CdWZmZXIgKGFycikge1xuICBpZiAoaXNUeXBlZEFycmF5KGFycikpIHtcbiAgICAvLyBUbyBhdm9pZCBhIGNvcHksIHVzZSB0aGUgdHlwZWQgYXJyYXkncyB1bmRlcmx5aW5nIEFycmF5QnVmZmVyIHRvIGJhY2sgbmV3IEJ1ZmZlclxuICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGFyci5idWZmZXIpXG4gICAgaWYgKGFyci5ieXRlTGVuZ3RoICE9PSBhcnIuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIC8vIFJlc3BlY3QgdGhlIFwidmlld1wiLCBpLmUuIGJ5dGVPZmZzZXQgYW5kIGJ5dGVMZW5ndGgsIHdpdGhvdXQgZG9pbmcgYSBjb3B5XG4gICAgICBidWYgPSBidWYuc2xpY2UoYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlT2Zmc2V0ICsgYXJyLmJ5dGVMZW5ndGgpXG4gICAgfVxuICAgIHJldHVybiBidWZcbiAgfSBlbHNlIHtcbiAgICAvLyBQYXNzIHRocm91Z2ggYWxsIG90aGVyIHR5cGVzIHRvIHRoZSBgQnVmZmVyYCBjb25zdHJ1Y3RvclxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFycilcbiAgfVxufVxuIiwiLyoqXG4gKiBVQVBhcnNlci5qcyB2MC43LjE0XG4gKiBMaWdodHdlaWdodCBKYXZhU2NyaXB0LWJhc2VkIFVzZXItQWdlbnQgc3RyaW5nIHBhcnNlclxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhaXNhbG1hbi91YS1wYXJzZXItanNcbiAqXG4gKiBDb3B5cmlnaHQgwqkgMjAxMi0yMDE2IEZhaXNhbCBTYWxtYW4gPGZ5emxtYW5AZ21haWwuY29tPlxuICogRHVhbCBsaWNlbnNlZCB1bmRlciBHUEx2MiAmIE1JVFxuICovXG5cbihmdW5jdGlvbiAod2luZG93LCB1bmRlZmluZWQpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQ29uc3RhbnRzXG4gICAgLy8vLy8vLy8vLy8vL1xuXG5cbiAgICB2YXIgTElCVkVSU0lPTiAgPSAnMC43LjE0JyxcbiAgICAgICAgRU1QVFkgICAgICAgPSAnJyxcbiAgICAgICAgVU5LTk9XTiAgICAgPSAnPycsXG4gICAgICAgIEZVTkNfVFlQRSAgID0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgVU5ERUZfVFlQRSAgPSAndW5kZWZpbmVkJyxcbiAgICAgICAgT0JKX1RZUEUgICAgPSAnb2JqZWN0JyxcbiAgICAgICAgU1RSX1RZUEUgICAgPSAnc3RyaW5nJyxcbiAgICAgICAgTUFKT1IgICAgICAgPSAnbWFqb3InLCAvLyBkZXByZWNhdGVkXG4gICAgICAgIE1PREVMICAgICAgID0gJ21vZGVsJyxcbiAgICAgICAgTkFNRSAgICAgICAgPSAnbmFtZScsXG4gICAgICAgIFRZUEUgICAgICAgID0gJ3R5cGUnLFxuICAgICAgICBWRU5ET1IgICAgICA9ICd2ZW5kb3InLFxuICAgICAgICBWRVJTSU9OICAgICA9ICd2ZXJzaW9uJyxcbiAgICAgICAgQVJDSElURUNUVVJFPSAnYXJjaGl0ZWN0dXJlJyxcbiAgICAgICAgQ09OU09MRSAgICAgPSAnY29uc29sZScsXG4gICAgICAgIE1PQklMRSAgICAgID0gJ21vYmlsZScsXG4gICAgICAgIFRBQkxFVCAgICAgID0gJ3RhYmxldCcsXG4gICAgICAgIFNNQVJUVFYgICAgID0gJ3NtYXJ0dHYnLFxuICAgICAgICBXRUFSQUJMRSAgICA9ICd3ZWFyYWJsZScsXG4gICAgICAgIEVNQkVEREVEICAgID0gJ2VtYmVkZGVkJztcblxuXG4gICAgLy8vLy8vLy8vLy9cbiAgICAvLyBIZWxwZXJcbiAgICAvLy8vLy8vLy8vXG5cblxuICAgIHZhciB1dGlsID0ge1xuICAgICAgICBleHRlbmQgOiBmdW5jdGlvbiAocmVnZXhlcywgZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgdmFyIG1hcmdlZFJlZ2V4ZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcmVnZXhlcykge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zW2ldICYmIGV4dGVuc2lvbnNbaV0ubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXJnZWRSZWdleGVzW2ldID0gZXh0ZW5zaW9uc1tpXS5jb25jYXQocmVnZXhlc1tpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2VkUmVnZXhlc1tpXSA9IHJlZ2V4ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcmdlZFJlZ2V4ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyA6IGZ1bmN0aW9uIChzdHIxLCBzdHIyKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdHIxID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyMi50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyMS50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxvd2VyaXplIDogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9LFxuICAgICAgICBtYWpvciA6IGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mKHZlcnNpb24pID09PSBTVFJfVFlQRSA/IHZlcnNpb24ucmVwbGFjZSgvW15cXGRcXC5dL2csJycpLnNwbGl0KFwiLlwiKVswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpbSA6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBNYXAgaGVscGVyXG4gICAgLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgdmFyIG1hcHBlciA9IHtcblxuICAgICAgICByZ3ggOiBmdW5jdGlvbiAodWEsIGFycmF5cykge1xuXG4gICAgICAgICAgICAvL3ZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgICAgIHZhciBpID0gMCwgaiwgaywgcCwgcSwgbWF0Y2hlcywgbWF0Y2g7Ly8sIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgICAgIC8qLy8gY29uc3RydWN0IG9iamVjdCBiYXJlYm9uZXNcbiAgICAgICAgICAgIGZvciAocCA9IDA7IHAgPCBhcmdzWzFdLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgcSA9IGFyZ3NbMV1bcF07XG4gICAgICAgICAgICAgICAgcmVzdWx0W3R5cGVvZiBxID09PSBPQkpfVFlQRSA/IHFbMF0gOiBxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0qL1xuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIHJlZ2V4ZXMgbWFwc1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBhcnJheXMubGVuZ3RoICYmICFtYXRjaGVzKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVnZXggPSBhcnJheXNbaV0sICAgICAgIC8vIGV2ZW4gc2VxdWVuY2UgKDAsMiw0LC4uKVxuICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGFycmF5c1tpICsgMV07ICAgLy8gb2RkIHNlcXVlbmNlICgxLDMsNSwuLilcbiAgICAgICAgICAgICAgICBqID0gayA9IDA7XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkgbWF0Y2hpbmcgdWFzdHJpbmcgd2l0aCByZWdleGVzXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCByZWdleC5sZW5ndGggJiYgIW1hdGNoZXMpIHtcblxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gcmVnZXhbaisrXS5leGVjKHVhKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoISFtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoZXNbKytrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gcHJvcHNbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZ2l2ZW4gcHJvcGVydHkgaXMgYWN0dWFsbHkgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHEgPT09IE9CSl9UWVBFICYmIHEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocS5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxWzFdID09IEZVTkNfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBtb2RpZmllZCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBxWzFdLmNhbGwodGhpcywgbWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gZ2l2ZW4gdmFsdWUsIGlnbm9yZSByZWdleCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBxWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHEubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgZnVuY3Rpb24gb3IgcmVnZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcVsxXSA9PT0gRlVOQ19UWVBFICYmICEocVsxXS5leGVjICYmIHFbMV0udGVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIGZ1bmN0aW9uICh1c3VhbGx5IHN0cmluZyBtYXBwZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1txWzBdXSA9IG1hdGNoID8gcVsxXS5jYWxsKHRoaXMsIG1hdGNoLCBxWzJdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FuaXRpemUgbWF0Y2ggdXNpbmcgZ2l2ZW4gcmVnZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gbWF0Y2ggPyBtYXRjaC5yZXBsYWNlKHFbMV0sIHFbMl0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHEubGVuZ3RoID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gbWF0Y2ggPyBxWzNdLmNhbGwodGhpcywgbWF0Y2gucmVwbGFjZShxWzFdLCBxWzJdKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FdID0gbWF0Y2ggPyBtYXRjaCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzKTtcbiAgICAgICAgICAgIC8vcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RyIDogZnVuY3Rpb24gKHN0ciwgbWFwKSB7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbWFwKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hcFtpXSA9PT0gT0JKX1RZUEUgJiYgbWFwW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXBbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmhhcyhtYXBbaV1bal0sIHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGkgPT09IFVOS05PV04pID8gdW5kZWZpbmVkIDogaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodXRpbC5oYXMobWFwW2ldLCBzdHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaSA9PT0gVU5LTk9XTikgPyB1bmRlZmluZWQgOiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBTdHJpbmcgbWFwXG4gICAgLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgdmFyIG1hcHMgPSB7XG5cbiAgICAgICAgYnJvd3NlciA6IHtcbiAgICAgICAgICAgIG9sZHNhZmFyaSA6IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uIDoge1xuICAgICAgICAgICAgICAgICAgICAnMS4wJyAgIDogJy84JyxcbiAgICAgICAgICAgICAgICAgICAgJzEuMicgICA6ICcvMScsXG4gICAgICAgICAgICAgICAgICAgICcxLjMnICAgOiAnLzMnLFxuICAgICAgICAgICAgICAgICAgICAnMi4wJyAgIDogJy80MTInLFxuICAgICAgICAgICAgICAgICAgICAnMi4wLjInIDogJy80MTYnLFxuICAgICAgICAgICAgICAgICAgICAnMi4wLjMnIDogJy80MTcnLFxuICAgICAgICAgICAgICAgICAgICAnMi4wLjQnIDogJy80MTknLFxuICAgICAgICAgICAgICAgICAgICAnPycgICAgIDogJy8nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRldmljZSA6IHtcbiAgICAgICAgICAgIGFtYXpvbiA6IHtcbiAgICAgICAgICAgICAgICBtb2RlbCA6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0ZpcmUgUGhvbmUnIDogWydTRCcsICdLRiddXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNwcmludCA6IHtcbiAgICAgICAgICAgICAgICBtb2RlbCA6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0V2byBTaGlmdCA0RycgOiAnNzM3M0tUJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmVuZG9yIDoge1xuICAgICAgICAgICAgICAgICAgICAnSFRDJyAgICAgICA6ICdBUEEnLFxuICAgICAgICAgICAgICAgICAgICAnU3ByaW50JyAgICA6ICdTcHJpbnQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9zIDoge1xuICAgICAgICAgICAgd2luZG93cyA6IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uIDoge1xuICAgICAgICAgICAgICAgICAgICAnTUUnICAgICAgICA6ICc0LjkwJyxcbiAgICAgICAgICAgICAgICAgICAgJ05UIDMuMTEnICAgOiAnTlQzLjUxJyxcbiAgICAgICAgICAgICAgICAgICAgJ05UIDQuMCcgICAgOiAnTlQ0LjAnLFxuICAgICAgICAgICAgICAgICAgICAnMjAwMCcgICAgICA6ICdOVCA1LjAnLFxuICAgICAgICAgICAgICAgICAgICAnWFAnICAgICAgICA6IFsnTlQgNS4xJywgJ05UIDUuMiddLFxuICAgICAgICAgICAgICAgICAgICAnVmlzdGEnICAgICA6ICdOVCA2LjAnLFxuICAgICAgICAgICAgICAgICAgICAnNycgICAgICAgICA6ICdOVCA2LjEnLFxuICAgICAgICAgICAgICAgICAgICAnOCcgICAgICAgICA6ICdOVCA2LjInLFxuICAgICAgICAgICAgICAgICAgICAnOC4xJyAgICAgICA6ICdOVCA2LjMnLFxuICAgICAgICAgICAgICAgICAgICAnMTAnICAgICAgICA6IFsnTlQgNi40JywgJ05UIDEwLjAnXSxcbiAgICAgICAgICAgICAgICAgICAgJ1JUJyAgICAgICAgOiAnQVJNJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vLy8vLy8vLy8vLy8vXG4gICAgLy8gUmVnZXggbWFwXG4gICAgLy8vLy8vLy8vLy8vL1xuXG5cbiAgICB2YXIgcmVnZXhlcyA9IHtcblxuICAgICAgICBicm93c2VyIDogW1tcblxuICAgICAgICAgICAgLy8gUHJlc3RvIGJhc2VkXG4gICAgICAgICAgICAvKG9wZXJhXFxzbWluaSlcXC8oW1xcd1xcLi1dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBNaW5pXG4gICAgICAgICAgICAvKG9wZXJhXFxzW21vYmlsZXRhYl0rKS4rdmVyc2lvblxcLyhbXFx3XFwuLV0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBNb2JpL1RhYmxldFxuICAgICAgICAgICAgLyhvcGVyYSkuK3ZlcnNpb25cXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSA+IDkuODBcbiAgICAgICAgICAgIC8ob3BlcmEpW1xcL1xcc10rKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIDwgOS44MFxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8ob3Bpb3MpW1xcL1xcc10rKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIG1pbmkgb24gaXBob25lID49IDguMFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnT3BlcmEgTWluaSddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvXFxzKG9wcilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBXZWJraXRcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ09wZXJhJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8vIE1peGVkXG4gICAgICAgICAgICAvKGtpbmRsZSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtpbmRsZVxuICAgICAgICAgICAgLyhsdW5hc2NhcGV8bWF4dGhvbnxuZXRmcm9udHxqYXNtaW5lfGJsYXplcilbXFwvXFxzXT8oW1xcd1xcLl0rKSovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTHVuYXNjYXBlL01heHRob24vTmV0ZnJvbnQvSmFzbWluZS9CbGF6ZXJcblxuICAgICAgICAgICAgLy8gVHJpZGVudCBiYXNlZFxuICAgICAgICAgICAgLyhhdmFudFxcc3xpZW1vYmlsZXxzbGltfGJhaWR1KSg/OmJyb3dzZXIpP1tcXC9cXHNdPyhbXFx3XFwuXSopL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2YW50L0lFTW9iaWxlL1NsaW1Ccm93c2VyL0JhaWR1XG4gICAgICAgICAgICAvKD86bXN8XFwoKShpZSlcXHMoW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlclxuXG4gICAgICAgICAgICAvLyBXZWJraXQvS0hUTUwgYmFzZWRcbiAgICAgICAgICAgIC8ocmVrb25xKVxcLyhbXFx3XFwuXSspKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVrb25xXG4gICAgICAgICAgICAvKGNocm9taXVtfGZsb2NrfHJvY2ttZWx0fG1pZG9yaXxlcGlwaGFueXxzaWxrfHNreWZpcmV8b3ZpYnJvd3Nlcnxib2x0fGlyb258dml2YWxkaXxpcmlkaXVtfHBoYW50b21qc3xib3dzZXIpXFwvKFtcXHdcXC4tXSspL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21pdW0vRmxvY2svUm9ja01lbHQvTWlkb3JpL0VwaXBoYW55L1NpbGsvU2t5ZmlyZS9Cb2x0L0lyb24vSXJpZGl1bS9QaGFudG9tSlMvQm93c2VyXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyh0cmlkZW50KS4rcnZbOlxcc10oW1xcd1xcLl0rKS4rbGlrZVxcc2dlY2tvL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUxMVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnSUUnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhlZGdlKVxcLygoXFxkKyk/W1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IEVkZ2VcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKHlhYnJvd3NlcilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFlhbmRleFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnWWFuZGV4J10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8ocHVmZmluKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVmZmluXG4gICAgICAgICAgICBdLCBbW05BTUUsICdQdWZmaW4nXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLygoPzpbXFxzXFwvXSl1Yz9cXHM/YnJvd3NlcnwoPzpqdWMuKyl1Y3dlYilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVDQnJvd3NlclxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnVUNCcm93c2VyJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oY29tb2RvX2RyYWdvbilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tb2RvIERyYWdvblxuICAgICAgICAgICAgXSwgW1tOQU1FLCAvXy9nLCAnICddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKG1pY3JvbWVzc2VuZ2VyKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlQ2hhdFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnV2VDaGF0J10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oUVEpXFwvKFtcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUVEsIGFrYSBTaG91UVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC9tPyhxcWJyb3dzZXIpW1xcL1xcc10/KFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFFRQnJvd3NlclxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC94aWFvbWlcXC9taXVpYnJvd3NlclxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1JVUkgQnJvd3NlclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnTUlVSSBCcm93c2VyJ11dLCBbXG5cbiAgICAgICAgICAgIC87ZmJhdlxcLyhbXFx3XFwuXSspOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFjZWJvb2sgQXBwIGZvciBpT1MgJiBBbmRyb2lkXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdGYWNlYm9vayddXSwgW1xuXG4gICAgICAgICAgICAvKGhlYWRsZXNzY2hyb21lKSAoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIEhlYWRsZXNzXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdDaHJvbWUgSGVhZGxlc3MnXV0sIFtcblxuICAgICAgICAgICAgL1xcc3d2XFwpLisoY2hyb21lKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBXZWJWaWV3XG4gICAgICAgICAgICBdLCBbW05BTUUsIC8oLispLywgJyQxIFdlYlZpZXcnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLygoPzpvY3VsdXN8c2Ftc3VuZylicm93c2VyKVxcLyhbXFx3XFwuXSspL2lcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgLyguKyg/Omd8dXMpKSguKykvLCAnJDEgJDInXSwgVkVSU0lPTl0sIFsgICAgICAgICAgICAgICAgLy8gT2N1bHVzIC8gU2Ftc3VuZyBCcm93c2VyXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLit2ZXJzaW9uXFwvKFtcXHdcXC5dKylcXHMrKD86bW9iaWxlXFxzP3NhZmFyaXxzYWZhcmkpKi9pICAgICAgICAvLyBBbmRyb2lkIEJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0FuZHJvaWQgQnJvd3NlciddXSwgW1xuXG4gICAgICAgICAgICAvKGNocm9tZXxvbW5pd2VifGFyb3JhfFt0aXplbm9rYV17NX1cXHM/YnJvd3NlcilcXC92PyhbXFx3XFwuXSspL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lL09tbmlXZWIvQXJvcmEvVGl6ZW4vTm9raWFcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKGRvbGZpbilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbHBoaW5cbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0RvbHBoaW4nXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLygoPzphbmRyb2lkLispY3Jtb3xjcmlvcylcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQvaU9TXG4gICAgICAgICAgICBdLCBbW05BTUUsICdDaHJvbWUnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhjb2FzdClcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBDb2FzdFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnT3BlcmEgQ29hc3QnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL2Z4aW9zXFwvKFtcXHdcXC4tXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGZvciBpT1NcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0ZpcmVmb3gnXV0sIFtcblxuICAgICAgICAgICAgL3ZlcnNpb25cXC8oW1xcd1xcLl0rKS4rP21vYmlsZVxcL1xcdytcXHMoc2FmYXJpKS9pICAgICAgICAgICAgICAgICAgICAgICAvLyBNb2JpbGUgU2FmYXJpXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdNb2JpbGUgU2FmYXJpJ11dLCBbXG5cbiAgICAgICAgICAgIC92ZXJzaW9uXFwvKFtcXHdcXC5dKykuKz8obW9iaWxlXFxzP3NhZmFyaXxzYWZhcmkpL2kgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSAmIFNhZmFyaSBNb2JpbGVcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXSwgW1xuXG4gICAgICAgICAgICAvd2Via2l0Lis/KG1vYmlsZVxccz9zYWZhcml8c2FmYXJpKShcXC9bXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPCAzLjBcbiAgICAgICAgICAgIF0sIFtOQU1FLCBbVkVSU0lPTiwgbWFwcGVyLnN0ciwgbWFwcy5icm93c2VyLm9sZHNhZmFyaS52ZXJzaW9uXV0sIFtcblxuICAgICAgICAgICAgLyhrb25xdWVyb3IpXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLb25xdWVyb3JcbiAgICAgICAgICAgIC8od2Via2l0fGtodG1sKVxcLyhbXFx3XFwuXSspL2lcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvLyBHZWNrbyBiYXNlZFxuICAgICAgICAgICAgLyhuYXZpZ2F0b3J8bmV0c2NhcGUpXFwvKFtcXHdcXC4tXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXRzY2FwZVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnTmV0c2NhcGUnXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC8oc3dpZnRmb3gpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dpZnRmb3hcbiAgICAgICAgICAgIC8oaWNlZHJhZ29ufGljZXdlYXNlbHxjYW1pbm98Y2hpbWVyYXxmZW5uZWN8bWFlbW9cXHNicm93c2VyfG1pbmltb3xjb25rZXJvcilbXFwvXFxzXT8oW1xcd1xcLlxcK10rKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJY2VEcmFnb24vSWNld2Vhc2VsL0NhbWluby9DaGltZXJhL0Zlbm5lYy9NYWVtby9NaW5pbW8vQ29ua2Vyb3JcbiAgICAgICAgICAgIC8oZmlyZWZveHxzZWFtb25rZXl8ay1tZWxlb258aWNlY2F0fGljZWFwZXxmaXJlYmlyZHxwaG9lbml4KVxcLyhbXFx3XFwuLV0rKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94L1NlYU1vbmtleS9LLU1lbGVvbi9JY2VDYXQvSWNlQXBlL0ZpcmViaXJkL1Bob2VuaXhcbiAgICAgICAgICAgIC8obW96aWxsYSlcXC8oW1xcd1xcLl0rKS4rcnZcXDouK2dlY2tvXFwvXFxkKy9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW96aWxsYVxuXG4gICAgICAgICAgICAvLyBPdGhlclxuICAgICAgICAgICAgLyhwb2xhcmlzfGx5bnh8ZGlsbG98aWNhYnxkb3Jpc3xhbWF5YXx3M218bmV0c3VyZnxzbGVpcG5pcilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQb2xhcmlzL0x5bngvRGlsbG8vaUNhYi9Eb3Jpcy9BbWF5YS93M20vTmV0U3VyZi9TbGVpcG5pclxuICAgICAgICAgICAgLyhsaW5rcylcXHNcXCgoW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGlua3NcbiAgICAgICAgICAgIC8oZ29icm93c2VyKVxcLz8oW1xcd1xcLl0rKSovaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29Ccm93c2VyXG4gICAgICAgICAgICAvKGljZVxccz9icm93c2VyKVxcL3Y/KFtcXHdcXC5fXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJQ0UgQnJvd3NlclxuICAgICAgICAgICAgLyhtb3NhaWMpW1xcL1xcc10oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9zYWljXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl1cblxuICAgICAgICAgICAgLyogLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBNZWRpYSBwbGF5ZXJzIEJFR0lOXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgLCBbXG5cbiAgICAgICAgICAgIC8oYXBwbGUoPzpjb3JlbWVkaWF8KSlcXC8oKFxcZCspW1xcd1xcLl9dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyaWMgQXBwbGUgQ29yZU1lZGlhXG4gICAgICAgICAgICAvKGNvcmVtZWRpYSkgdigoXFxkKylbXFx3XFwuX10rKS9pXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhhcXVhbHVuZ3xseXNzbmF8YnNwbGF5ZXIpXFwvKChcXGQrKT9bXFx3XFwuLV0rKS9pICAgICAgICAgICAgICAgICAgICAgLy8gQXF1YWx1bmcvTHlzc25hL0JTUGxheWVyXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhhcmVzfG9zc3Byb3h5KVxccygoXFxkKylbXFx3XFwuLV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJlcy9PU1NQcm94eVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oYXVkYWNpb3VzfGF1ZGltdXNpY3N0cmVhbXxhbWFyb2t8YmFzc3xjb3JlfGRhbHZpa3xnbm9tZW1wbGF5ZXJ8bXVzaWMgb24gY29uc29sZXxuc3BsYXllcnxwc3AtaW50ZXJuZXRyYWRpb3BsYXllcnx2aWRlb3MpXFwvKChcXGQrKVtcXHdcXC4tXSspL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF1ZGFjaW91cy9BdWRpTXVzaWNTdHJlYW0vQW1hcm9rL0JBU1MvT3BlbkNPUkUvRGFsdmlrL0dub21lTXBsYXllci9Nb0NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTlNQbGF5ZXIvUFNQLUludGVybmV0UmFkaW9QbGF5ZXIvVmlkZW9zXG4gICAgICAgICAgICAvKGNsZW1lbnRpbmV8bXVzaWMgcGxheWVyIGRhZW1vbilcXHMoKFxcZCspW1xcd1xcLi1dKykvaSwgICAgICAgICAgICAgICAvLyBDbGVtZW50aW5lL01QRFxuICAgICAgICAgICAgLyhsZyBwbGF5ZXJ8bmV4cGxheWVyKVxccygoXFxkKylbXFxkXFwuXSspL2ksXG4gICAgICAgICAgICAvcGxheWVyXFwvKG5leHBsYXllcnxsZyBwbGF5ZXIpXFxzKChcXGQrKVtcXHdcXC4tXSspL2kgICAgICAgICAgICAgICAgICAgLy8gTmV4UGxheWVyL0xHIFBsYXllclxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKG5leHBsYXllcilcXHMoKFxcZCspW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXhwbGF5ZXJcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKGZscnApXFwvKChcXGQrKVtcXHdcXC4tXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGbGlwIFBsYXllclxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnRmxpcCBQbGF5ZXInXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhmc3RyZWFtfG5hdGl2ZWhvc3R8cXVlcnlzZWVrc3BpZGVyfGlhLWFyY2hpdmVyfGZhY2Vib29rZXh0ZXJuYWxoaXQpL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRlN0cmVhbS9OYXRpdmVIb3N0L1F1ZXJ5U2Vla1NwaWRlci9JQSBBcmNoaXZlci9mYWNlYm9va2V4dGVybmFsaGl0XG4gICAgICAgICAgICBdLCBbTkFNRV0sIFtcblxuICAgICAgICAgICAgLyhnc3RyZWFtZXIpIHNvdXBodHRwc3JjICg/OlxcKFteXFwpXStcXCkpezAsMX0gbGlic291cFxcLygoXFxkKylbXFx3XFwuLV0rKS9pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdzdHJlYW1lclxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oaHRjIHN0cmVhbWluZyBwbGF5ZXIpXFxzW1xcd19dK1xcc1xcL1xccygoXFxkKylbXFxkXFwuXSspL2ksICAgICAgICAgICAgICAvLyBIVEMgU3RyZWFtaW5nIFBsYXllclxuICAgICAgICAgICAgLyhqYXZhfHB5dGhvbi11cmxsaWJ8cHl0aG9uLXJlcXVlc3RzfHdnZXR8bGliY3VybClcXC8oKFxcZCspW1xcd1xcLi1fXSspL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEphdmEvdXJsbGliL3JlcXVlc3RzL3dnZXQvY1VSTFxuICAgICAgICAgICAgLyhsYXZmKSgoXFxkKylbXFxkXFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMYXZmIChGRk1QRUcpXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhodGNfb25lX3MpXFwvKChcXGQrKVtcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFRDIE9uZSBTXG4gICAgICAgICAgICBdLCBbW05BTUUsIC9fL2csICcgJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8obXBsYXllcikoPzpcXHN8XFwvKSg/Oig/OnNoZXJweWEtKXswLDF9c3ZuKSg/Oi18XFxzKShyXFxkKyg/Oi1cXGQrW1xcd1xcLi1dKyl7MCwxfSkvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNUGxheWVyIFNWTlxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8obXBsYXllcikoPzpcXHN8XFwvfFt1bmtvdy1dKykoKFxcZCspW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAvLyBNUGxheWVyXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhtcGxheWVyKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNUGxheWVyIChubyBvdGhlciBpbmZvKVxuICAgICAgICAgICAgLyh5b3VybXV6ZSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBZb3VyTXV6ZVxuICAgICAgICAgICAgLyhtZWRpYSBwbGF5ZXIgY2xhc3NpY3xuZXJvIHNob3d0aW1lKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNZWRpYSBQbGF5ZXIgQ2xhc3NpYy9OZXJvIFNob3dUaW1lXG4gICAgICAgICAgICBdLCBbTkFNRV0sIFtcblxuICAgICAgICAgICAgLyhuZXJvICg/OmhvbWV8c2NvdXQpKVxcLygoXFxkKylbXFx3XFwuLV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVybyBIb21lL05lcm8gU2NvdXRcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKG5va2lhXFxkKylcXC8oKFxcZCspW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9raWFcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvXFxzKHNvbmdiaXJkKVxcLygoXFxkKylbXFx3XFwuLV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29uZ2JpcmQvUGhpbGlwcy1Tb25nYmlyZFxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8od2luYW1wKTMgdmVyc2lvbiAoKFxcZCspW1xcd1xcLi1dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luYW1wXG4gICAgICAgICAgICAvKHdpbmFtcClcXHMoKFxcZCspW1xcd1xcLi1dKykvaSxcbiAgICAgICAgICAgIC8od2luYW1wKW1wZWdcXC8oKFxcZCspW1xcd1xcLi1dKykvaVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8ob2Ntcy1ib3R8dGFwaW5yYWRpb3x0dW5laW4gcmFkaW98dW5rbm93bnx3aW5hbXB8aW5saWdodCByYWRpbykvaSAgLy8gT0NNUy1ib3QvdGFwIGluIHJhZGlvL3R1bmVpbi91bmtub3duL3dpbmFtcCAobm8gb3RoZXIgaW5mbylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5saWdodCByYWRpb1xuICAgICAgICAgICAgXSwgW05BTUVdLCBbXG5cbiAgICAgICAgICAgIC8ocXVpY2t0aW1lfHJtYXxyYWRpb2FwcHxyYWRpb2NsaWVudGFwcGxpY2F0aW9ufHNvdW5kdGFwfHRvdGVtfHN0YWdlZnJpZ2h0fHN0cmVhbWl1bSlcXC8oKFxcZCspW1xcd1xcLi1dKykvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRdWlja1RpbWUvUmVhbE1lZGlhL1JhZGlvQXBwL1JhZGlvQ2xpZW50QXBwbGljYXRpb24vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvdW5kVGFwL1RvdGVtL1N0YWdlZnJpZ2h0L1N0cmVhbWl1bVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oc21wKSgoXFxkKylbXFxkXFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU01QXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyh2bGMpIG1lZGlhIHBsYXllciAtIHZlcnNpb24gKChcXGQrKVtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAvLyBWTEMgVmlkZW9sYW5cbiAgICAgICAgICAgIC8odmxjKVxcLygoXFxkKylbXFx3XFwuLV0rKS9pLFxuICAgICAgICAgICAgLyh4Ym1jfGd2ZnN8eGluZXx4bW1zfGlyYXBwKVxcLygoXFxkKylbXFx3XFwuLV0rKS9pLCAgICAgICAgICAgICAgICAgICAgLy8gWEJNQy9ndmZzL1hpbmUvWE1NUy9pcmFwcFxuICAgICAgICAgICAgLyhmb29iYXIyMDAwKVxcLygoXFxkKylbXFxkXFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9vYmFyMjAwMFxuICAgICAgICAgICAgLyhpdHVuZXMpXFwvKChcXGQrKVtcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaVR1bmVzXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyh3bXBsYXllcilcXC8oKFxcZCspW1xcd1xcLi1dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyBNZWRpYSBQbGF5ZXJcbiAgICAgICAgICAgIC8od2luZG93cy1tZWRpYS1wbGF5ZXIpXFwvKChcXGQrKVtcXHdcXC4tXSspL2lcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgLy0vZywgJyAnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL3dpbmRvd3NcXC8oKFxcZCspW1xcd1xcLi1dKykgdXBucFxcL1tcXGRcXC5dKyBkbG5hZG9jXFwvW1xcZFxcLl0rIChob21lIG1lZGlhIHNlcnZlcikvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIE1lZGlhIFNlcnZlclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnV2luZG93cyddXSwgW1xuXG4gICAgICAgICAgICAvKGNvbVxcLnJpc2V1cHJhZGlvYWxhcm0pXFwvKChcXGQrKVtcXGRcXC5dKikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmlzZVVQIFJhZGlvIEFsYXJtXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhyYWQuaW8pXFxzKChcXGQrKVtcXGRcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmFkLmlvXG4gICAgICAgICAgICAvKHJhZGlvLig/OmRlfGF0fGZyKSlcXHMoKFxcZCspW1xcZFxcLl0rKS9pXG4gICAgICAgICAgICBdLCBbW05BTUUsICdyYWQuaW8nXSwgVkVSU0lPTl1cblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gTWVkaWEgcGxheWVycyBFTkRcbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vKi9cblxuICAgICAgICBdLFxuXG4gICAgICAgIGNwdSA6IFtbXG5cbiAgICAgICAgICAgIC8oPzooYW1kfHgoPzooPzo4Nnw2NClbXy1dKT98d293fHdpbik2NClbO1xcKV0vaSAgICAgICAgICAgICAgICAgICAgIC8vIEFNRDY0XG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ2FtZDY0J11dLCBbXG5cbiAgICAgICAgICAgIC8oaWEzMig/PTspKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUEzMiAocXVpY2t0aW1lKVxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsIHV0aWwubG93ZXJpemVdXSwgW1xuXG4gICAgICAgICAgICAvKCg/OmlbMzQ2XXx4KTg2KVs7XFwpXS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJQTMyXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ2lhMzInXV0sIFtcblxuICAgICAgICAgICAgLy8gUG9ja2V0UEMgbWlzdGFrZW5seSBpZGVudGlmaWVkIGFzIFBvd2VyUENcbiAgICAgICAgICAgIC93aW5kb3dzXFxzKGNlfG1vYmlsZSk7XFxzcHBjOy9pXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ2FybSddXSwgW1xuXG4gICAgICAgICAgICAvKCg/OnBwY3xwb3dlcnBjKSg/OjY0KT8pKD86XFxzbWFjfDt8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG93ZXJQQ1xuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsIC9vd2VyLywgJycsIHV0aWwubG93ZXJpemVdXSwgW1xuXG4gICAgICAgICAgICAvKHN1bjRcXHcpWztcXCldL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU1BBUkNcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnc3BhcmMnXV0sIFtcblxuICAgICAgICAgICAgLygoPzphdnIzMnxpYTY0KD89OykpfDY4ayg/PVxcKSl8YXJtKD86NjR8KD89dlxcZCs7KSl8KD89YXRtZWxcXHMpYXZyfCg/OmlyaXh8bWlwc3xzcGFyYykoPzo2NCk/KD89Oyl8cGEtcmlzYykvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJQTY0LCA2OEssIEFSTS82NCwgQVZSLzMyLCBJUklYLzY0LCBNSVBTLzY0LCBTUEFSQy82NCwgUEEtUklTQ1xuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsIHV0aWwubG93ZXJpemVdXVxuICAgICAgICBdLFxuXG4gICAgICAgIGRldmljZSA6IFtbXG5cbiAgICAgICAgICAgIC9cXCgoaXBhZHxwbGF5Ym9vayk7W1xcd1xcc1xcKTstXSsocmltfGFwcGxlKS9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlQYWQvUGxheUJvb2tcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgVkVORE9SLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FwcGxlY29yZW1lZGlhXFwvW1xcd1xcLl0rIFxcKChpcGFkKS8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaVBhZFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQXBwbGUnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8oYXBwbGVcXHN7MCwxfXR2KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxlIFRWXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnQXBwbGUgVFYnXSwgW1ZFTkRPUiwgJ0FwcGxlJ11dLCBbXG5cbiAgICAgICAgICAgIC8oYXJjaG9zKVxccyhnYW1lcGFkMj8pL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyY2hvc1xuICAgICAgICAgICAgLyhocCkuKyh0b3VjaHBhZCkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIUCBUb3VjaFBhZFxuICAgICAgICAgICAgLyhocCkuKyh0YWJsZXQpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIUCBUYWJsZXRcbiAgICAgICAgICAgIC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlXG4gICAgICAgICAgICAvXFxzKG5vb2spW1xcd1xcc10rYnVpbGRcXC8oXFx3KykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9va1xuICAgICAgICAgICAgLyhkZWxsKVxccyhzdHJlYVtrcHJcXHNcXGRdKltcXGRrb10pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsbCBTdHJlYWtcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLyhrZltBLXpdKylcXHNidWlsZFxcL1tcXHdcXC5dKy4qc2lsa1xcLy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtpbmRsZSBGaXJlIEhEXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBbWF6b24nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKHNkfGtmKVswMzQ5aGlqb3JzdHV3XStcXHNidWlsZFxcL1tcXHdcXC5dKy4qc2lsa1xcLy9pICAgICAgICAgICAgICAgICAgLy8gRmlyZSBQaG9uZVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgbWFwcGVyLnN0ciwgbWFwcy5kZXZpY2UuYW1hem9uLm1vZGVsXSwgW1ZFTkRPUiwgJ0FtYXpvbiddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL1xcKChpcFtob25lZHxcXHNcXHcqXSspOy4rKGFwcGxlKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUG9kL2lQaG9uZVxuICAgICAgICAgICAgXSwgW01PREVMLCBWRU5ET1IsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcKChpcFtob25lZHxcXHNcXHcqXSspOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUG9kL2lQaG9uZVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQXBwbGUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8oYmxhY2tiZXJyeSlbXFxzLV0/KFxcdyspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja0JlcnJ5XG4gICAgICAgICAgICAvKGJsYWNrYmVycnl8YmVucXxwYWxtKD89XFwtKXxzb255ZXJpY3Nzb258YWNlcnxhc3VzfGRlbGx8bWVpenV8bW90b3JvbGF8cG9seXRyb24pW1xcc18tXT8oW1xcdy1dKykqL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlblEvUGFsbS9Tb255LUVyaWNzc29uL0FjZXIvQXN1cy9EZWxsL01laXp1L01vdG9yb2xhL1BvbHl0cm9uXG4gICAgICAgICAgICAvKGhwKVxccyhbXFx3XFxzXStcXHcpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIUCBpUEFRXG4gICAgICAgICAgICAvKGFzdXMpLT8oXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3VzXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFwoYmIxMDtcXHMoXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrQmVycnkgMTBcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0JsYWNrQmVycnknXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzdXMgVGFibGV0c1xuICAgICAgICAgICAgL2FuZHJvaWQuKyh0cmFuc2ZvW3ByaW1lXFxzXXs0LDEwfVxcc1xcdyt8ZWVlcGN8c2xpZGVyXFxzXFx3K3xuZXh1cyA3fHBhZGZvbmUpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FzdXMnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8oc29ueSlcXHModGFibGV0XFxzW3BzXSlcXHNidWlsZFxcLy9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb255XG4gICAgICAgICAgICAvKHNvbnkpPyg/OnNncC4rKVxcc2J1aWxkXFwvL2lcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnU29ueSddLCBbTU9ERUwsICdYcGVyaWEgVGFibGV0J10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL2FuZHJvaWQuK1xccyhbYy1nXVxcZHs0fXxzb1stbF1cXHcrKVxcc2J1aWxkXFwvL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1NvbnknXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9cXHMob3V5YSlcXHMvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdXlhXG4gICAgICAgICAgICAvKG5pbnRlbmRvKVxccyhbd2lkczN1XSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOaW50ZW5kb1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBDT05TT0xFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMoc2hpZWxkKVxcc2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE52aWRpYVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTnZpZGlhJ10sIFtUWVBFLCBDT05TT0xFXV0sIFtcblxuICAgICAgICAgICAgLyhwbGF5c3RhdGlvblxcc1szNHBvcnRhYmxldmldKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxheXN0YXRpb25cbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1NvbnknXSwgW1RZUEUsIENPTlNPTEVdXSwgW1xuXG4gICAgICAgICAgICAvKHNwcmludFxccyhcXHcrKSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ByaW50IFBob25lc1xuICAgICAgICAgICAgXSwgW1tWRU5ET1IsIG1hcHBlci5zdHIsIG1hcHMuZGV2aWNlLnNwcmludC52ZW5kb3JdLCBbTU9ERUwsIG1hcHBlci5zdHIsIG1hcHMuZGV2aWNlLnNwcmludC5tb2RlbF0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKGxlbm92bylcXHM/KFMoPzo1MDAwfDYwMDApKyg/OlstXVtcXHcrXSkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVub3ZvIHRhYmxldHNcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLyhodGMpWztfXFxzLV0rKFtcXHdcXHNdKyg/PVxcKSl8XFx3KykqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhUQ1xuICAgICAgICAgICAgLyh6dGUpLShcXHcrKSovaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWlRFXG4gICAgICAgICAgICAvKGFsY2F0ZWx8Z2Vla3NwaG9uZXxsZW5vdm98bmV4aWFufHBhbmFzb25pY3woPz07XFxzKXNvbnkpW19cXHMtXT8oW1xcdy1dKykqL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxjYXRlbC9HZWVrc1Bob25lL0xlbm92by9OZXhpYW4vUGFuYXNvbmljL1NvbnlcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIFtNT0RFTCwgL18vZywgJyAnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8obmV4dXNcXHM5KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhUQyBOZXh1cyA5XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdIVEMnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9kXFwvaHVhd2VpKFtcXHdcXHMtXSspWztcXCldL2ksXG4gICAgICAgICAgICAvKG5leHVzXFxzNnApL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIdWF3ZWlcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0h1YXdlaSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLyhtaWNyb3NvZnQpO1xccyhsdW1pYVtcXHNcXHddKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgTHVtaWFcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL1tcXHNcXCg7XSh4Ym94KD86XFxzb25lKT8pW1xcc1xcKTtdL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBYYm94XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdNaWNyb3NvZnQnXSwgW1RZUEUsIENPTlNPTEVdXSwgW1xuICAgICAgICAgICAgLyhraW5cXC5bb25ldHddezN9KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IEtpblxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgL1xcLi9nLCAnICddLCBbVkVORE9SLCAnTWljcm9zb2Z0J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdG9yb2xhXG4gICAgICAgICAgICAvXFxzKG1pbGVzdG9uZXxkcm9pZCg/OlsyLTR4XXxcXHMoPzpiaW9uaWN8eDJ8cHJvfHJhenIpKT8oOj9cXHM0Zyk/KVtcXHdcXHNdK2J1aWxkXFwvL2ksXG4gICAgICAgICAgICAvbW90W1xccy1dPyhcXHcrKSovaSxcbiAgICAgICAgICAgIC8oWFRcXGR7Myw0fSkgYnVpbGRcXC8vaSxcbiAgICAgICAgICAgIC8obmV4dXNcXHM2KS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdNb3Rvcm9sYSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9hbmRyb2lkLitcXHMobXo2MFxcZHx4b29tW1xcczJdezAsMn0pXFxzYnVpbGRcXC8vaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTW90b3JvbGEnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9oYmJ0dlxcL1xcZCtcXC5cXGQrXFwuXFxkK1xccytcXChbXFx3XFxzXSo7XFxzKihcXHdbXjtdKik7KFteO10qKS9pICAgICAgICAgICAgLy8gSGJiVFYgZGV2aWNlc1xuICAgICAgICAgICAgXSwgW1tWRU5ET1IsIHV0aWwudHJpbV0sIFtNT0RFTCwgdXRpbC50cmltXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuXG4gICAgICAgICAgICAvaGJidHYuK21hcGxlOyhcXGQrKS9pXG4gICAgICAgICAgICBdLCBbW01PREVMLCAvXi8sICdTbWFydFRWJ10sIFtWRU5ET1IsICdTYW1zdW5nJ10sIFtUWVBFLCBTTUFSVFRWXV0sIFtcblxuICAgICAgICAgICAgL1xcKGR0dltcXCk7XS4rKGFxdW9zKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYXJwXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTaGFycCddLCBbVFlQRSwgU01BUlRUVl1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLisoKHNjaC1pWzg5XTBcXGR8c2h3LW0zODBzfGd0LXBcXGR7NH18Z3QtblxcZCt8c2doLXQ4WzU2XTl8bmV4dXMgMTApKS9pLFxuICAgICAgICAgICAgLygoU00tVFxcdyspKS9pXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ1NhbXN1bmcnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgWyAgICAgICAgICAgICAgICAgIC8vIFNhbXN1bmdcbiAgICAgICAgICAgIC9zbWFydC10di4rKHNhbXN1bmcpL2lcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIFtUWVBFLCBTTUFSVFRWXSwgTU9ERUxdLCBbXG4gICAgICAgICAgICAvKChzW2NncF1oLVxcdyt8Z3QtXFx3K3xnYWxheHlcXHNuZXh1c3xzbS1cXHdbXFx3XFxkXSspKS9pLFxuICAgICAgICAgICAgLyhzYW1bc3VuZ10qKVtcXHMtXSooXFx3Ky0/W1xcdy1dKikqL2ksXG4gICAgICAgICAgICAvc2VjLSgoc2doXFx3KykpL2lcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnU2Ftc3VuZyddLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9zaWUtKFxcdyspKi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpZW1lbnNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1NpZW1lbnMnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8obWFlbW98bm9raWEpLioobjkwMHxsdW1pYVxcc1xcZCspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb2tpYVxuICAgICAgICAgICAgLyhub2tpYSlbXFxzXy1dPyhbXFx3LV0rKSovaVxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdOb2tpYSddLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkXFxzM1xcLltcXHNcXHc7LV17MTB9KGFcXGR7M30pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2VyXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBY2VyJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rKFt2bF1rXFwtP1xcZHszfSlcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExHIFRhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTEcnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvYW5kcm9pZFxcczNcXC5bXFxzXFx3Oy1dezEwfShsZz8pLShbMDZjdjldezMsNH0pL2kgICAgICAgICAgICAgICAgICAgICAvLyBMRyBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnTEcnXSwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyhsZykgbmV0Y2FzdFxcLnR2L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTEcgU21hcnRUVlxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC8obmV4dXNcXHNbNDVdKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExHXG4gICAgICAgICAgICAvbGdbZTtcXHNcXC8tXSsoXFx3KykqL2ksXG4gICAgICAgICAgICAvYW5kcm9pZC4rbGcoXFwtP1tcXGRcXHddKylcXHMrYnVpbGQvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTEcnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLisoaWRlYXRhYlthLXowLTlcXC1cXHNdKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZW5vdm9cbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0xlbm92byddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2xpbnV4Oy4rKChqb2xsYSkpOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKb2xsYVxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKChwZWJibGUpKWFwcFxcL1tcXGRcXC5dK1xccy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQZWJibGVcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgV0VBUkFCTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rO1xccyhvcHBvKVxccz8oW1xcd1xcc10rKVxcc2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT1BQT1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvY3JrZXkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBDaHJvbWVjYXN0XG4gICAgICAgICAgICBdLCBbW01PREVMLCAnQ2hyb21lY2FzdCddLCBbVkVORE9SLCAnR29vZ2xlJ11dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKGdsYXNzKVxcc1xcZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIEdsYXNzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdHb29nbGUnXSwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMocGl4ZWwgYylcXHMvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBQaXhlbCBDXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdHb29nbGUnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKHBpeGVsIHhsfHBpeGVsKVxccy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgUGl4ZWxcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0dvb2dsZSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKyhcXHcrKVxccytidWlsZFxcL2htXFwxL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWGlhb21pIEhvbmdtaSAnbnVtZXJpYycgbW9kZWxzXG4gICAgICAgICAgICAvYW5kcm9pZC4rKGhtW1xcc1xcLV9dKm5vdGU/W1xcc19dKig/OlxcZFxcdyk/KVxccytidWlsZC9pLCAgICAgICAgICAgICAgIC8vIFhpYW9taSBIb25nbWlcbiAgICAgICAgICAgIC9hbmRyb2lkLisobWlbXFxzXFwtX10qKD86b25lfG9uZVtcXHNfXXBsdXN8bm90ZSBsdGUpP1tcXHNfXSooPzpcXGRcXHcpPylcXHMrYnVpbGQvaSAgICAvLyBYaWFvbWkgTWlcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsIC9fL2csICcgJ10sIFtWRU5ET1IsICdYaWFvbWknXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKG1bMS01XVxcc25vdGUpXFxzYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVpenUgVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdNZWl6dSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK2EwMDAoMSlcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25lUGx1c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnT25lUGx1cyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooUkNUW1xcZFxcd10rKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJDQSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdSQ0EnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKFZlbnVlW1xcZFxcc10qKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxsIFZlbnVlIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0RlbGwnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKFFbVHxNXVtcXGRcXHddKylcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJpem9uIFRhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnVmVyaXpvbiddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccysoQmFybmVzWyZcXHNdK05vYmxlXFxzK3xCTltSVF0pKFY/LiopXFxzK2J1aWxkL2kgICAgIC8vIEJhcm5lcyAmIE5vYmxlIFRhYmxldFxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdCYXJuZXMgJiBOb2JsZSddLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMrKFRNXFxkezN9LipcXGIpXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXJuZXMgJiBOb2JsZSBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ051VmlzaW9uJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKih6dGUpPy4rKGtcXGR7Mn0pXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAvLyBaVEUgSyBTZXJpZXMgVGFibGV0XG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ1pURSddLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKGdlblxcZHszfSlcXHMrYnVpbGQuKjQ5aC9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3aXNzIEdFTiBNb2JpbGVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1N3aXNzJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKih6dXJcXGR7M30pXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2lzcyBaVVIgVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTd2lzcyddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooKFpla2kpP1RCLipcXGIpXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWmVraSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdaZWtpJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvKGFuZHJvaWQpLitbO1xcL11cXHMrKFtZUl1cXGR7Mn14Py4qKVxccytidWlsZC9pLFxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccysoRHJhZ29uW1xcLVxcc10rVG91Y2hcXHMrfERUKSguKylcXHMrYnVpbGQvaSAgICAgICAgICAvLyBEcmFnb24gVG91Y2ggVGFibGV0XG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0RyYWdvbiBUb3VjaCddLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKE5TLT8uKylcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zaWduaWEgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnSW5zaWduaWEnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKChOWHxOZXh0KS0/LispXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV4dEJvb2sgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTmV4dEJvb2snXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKFh0cmVtZVxcXz8pPyhWKDFbMDQ1XXwyWzAxNV18MzB8NDB8NjB8N1swNV18OTApKVxccytidWlsZC9pXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ1ZvaWNlJ10sIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFsgICAgICAgICAgICAgICAgICAgIC8vIFZvaWNlIFh0cmVtZSBQaG9uZXNcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooTFZURUxcXC0/KT8oVjFbMTJdKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgLy8gTHZUZWwgUGhvbmVzXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0x2VGVsJ10sIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooVigxMDBNRHw3MDBOQXw3MDExfDkxN0cpLipcXGIpXFxzK2J1aWxkL2kgICAgICAgICAgLy8gRW52aXplbiBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdFbnZpemVuJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihMZVtcXHNcXC1dK1BhbilbXFxzXFwtXSsoLipcXGIpXFxzK2J1aWxkL2kgICAgICAgICAgICAgLy8gTGUgUGFuIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooVHJpb1tcXHNcXC1dKi4qKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hY2hTcGVlZCBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdNYWNoU3BlZWQnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKFRyaW5pdHkpW1xcLVxcc10qKFRcXGR7M30pXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgLy8gVHJpbml0eSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqVFVfKDE0OTEpXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm90b3IgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnUm90b3InXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLisoS1MoLispKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFtYXpvbiBLaW5kbGUgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQW1hem9uJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rKEdpZ2FzZXQpW1xcc1xcLV0rKFEuKylcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdpZ2FzZXQgVGFibGV0c1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvXFxzKHRhYmxldHx0YWIpWztcXC9dL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5pZGVudGlmaWFibGUgVGFibGV0XG4gICAgICAgICAgICAvXFxzKG1vYmlsZSkoPzpbO1xcL118XFxzc2FmYXJpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuaWRlbnRpZmlhYmxlIE1vYmlsZVxuICAgICAgICAgICAgXSwgW1tUWVBFLCB1dGlsLmxvd2VyaXplXSwgVkVORE9SLCBNT0RFTF0sIFtcblxuICAgICAgICAgICAgLyhhbmRyb2lkLispWztcXC9dLitidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJpYyBBbmRyb2lkIERldmljZVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnR2VuZXJpYyddXVxuXG5cbiAgICAgICAgLyovLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gVE9ETzogbW92ZSB0byBzdHJpbmcgbWFwXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICAgIC8oQzY2MDMpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ueSBYcGVyaWEgWiBDNjYwM1xuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ1hwZXJpYSBaIEM2NjAzJ10sIFtWRU5ET1IsICdTb255J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhDNjkwMykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb255IFhwZXJpYSBaIDFcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsICdYcGVyaWEgWiAxJ10sIFtWRU5ET1IsICdTb255J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKFNNLUc5MDBbRnxIXSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhbXN1bmcgR2FsYXh5IFM1XG4gICAgICAgICAgICBdLCBbW01PREVMLCAnR2FsYXh5IFM1J10sIFtWRU5ET1IsICdTYW1zdW5nJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhTTS1HNzEwMikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYW1zdW5nIEdhbGF4eSBHcmFuZCAyXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnR2FsYXh5IEdyYW5kIDInXSwgW1ZFTkRPUiwgJ1NhbXN1bmcnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvKFNNLUc1MzBIKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhbXN1bmcgR2FsYXh5IEdyYW5kIFByaW1lXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnR2FsYXh5IEdyYW5kIFByaW1lJ10sIFtWRU5ET1IsICdTYW1zdW5nJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhTTS1HMzEzSFopL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYW1zdW5nIEdhbGF4eSBWXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnR2FsYXh5IFYnXSwgW1ZFTkRPUiwgJ1NhbXN1bmcnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvKFNNLVQ4MDUpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhbXN1bmcgR2FsYXh5IFRhYiBTIDEwLjVcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsICdHYWxheHkgVGFiIFMgMTAuNSddLCBbVkVORE9SLCAnU2Ftc3VuZyddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8oU00tRzgwMEYpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Ftc3VuZyBHYWxheHkgUzUgTWluaVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ0dhbGF4eSBTNSBNaW5pJ10sIFtWRU5ET1IsICdTYW1zdW5nJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhTTS1UMzExKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYW1zdW5nIEdhbGF4eSBUYWIgMyA4LjBcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsICdHYWxheHkgVGFiIDMgOC4wJ10sIFtWRU5ET1IsICdTYW1zdW5nJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvKFQzQykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuIFZhbmRyb2lkIFQzQ1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQWR2YW4nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKEFEVkFOIFQxSlxcKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbiBWYW5kcm9pZCBUMUorXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnVmFuZHJvaWQgVDFKKyddLCBbVkVORE9SLCAnQWR2YW4nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKEFEVkFOIFM0QSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuIFZhbmRyb2lkIFM0QVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ1ZhbmRyb2lkIFM0QSddLCBbVkVORE9SLCAnQWR2YW4nXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8oVjk3Mk0pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWlRFIFY5NzJNXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdaVEUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8oaS1tb2JpbGUpXFxzKElRXFxzW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGktbW9iaWxlIElRXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvKElRNi4zKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGktbW9iaWxlIElRIElRIDYuM1xuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ0lRIDYuMyddLCBbVkVORE9SLCAnaS1tb2JpbGUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvKGktbW9iaWxlKVxccyhpLXN0eWxlXFxzW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpLW1vYmlsZSBpLVNUWUxFXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvKGktU1RZTEUyLjEpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGktbW9iaWxlIGktU1RZTEUgMi4xXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnaS1TVFlMRSAyLjEnXSwgW1ZFTkRPUiwgJ2ktbW9iaWxlJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKG1vYmlpc3RhciB0b3VjaCBMQUkgNTEyKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vYmlpc3RhciB0b3VjaCBMQUkgNTEyXG4gICAgICAgICAgICBdLCBbW01PREVMLCAnVG91Y2ggTEFJIDUxMiddLCBbVkVORE9SLCAnbW9iaWlzdGFyJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBFTkQgVE9ET1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8qL1xuXG4gICAgICAgIF0sXG5cbiAgICAgICAgZW5naW5lIDogW1tcblxuICAgICAgICAgICAgL3dpbmRvd3MuK1xcc2VkZ2VcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWRnZUhUTUxcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0VkZ2VIVE1MJ11dLCBbXG5cbiAgICAgICAgICAgIC8ocHJlc3RvKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlc3RvXG4gICAgICAgICAgICAvKHdlYmtpdHx0cmlkZW50fG5ldGZyb250fG5ldHN1cmZ8YW1heWF8bHlueHx3M20pXFwvKFtcXHdcXC5dKykvaSwgICAgIC8vIFdlYktpdC9UcmlkZW50L05ldEZyb250L05ldFN1cmYvQW1heWEvTHlueC93M21cbiAgICAgICAgICAgIC8oa2h0bWx8dGFzbWFufGxpbmtzKVtcXC9cXHNdXFwoPyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLSFRNTC9UYXNtYW4vTGlua3NcbiAgICAgICAgICAgIC8oaWNhYilbXFwvXFxzXShbMjNdXFwuW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpQ2FiXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL3J2XFw6KFtcXHdcXC5dKykuKihnZWNrbykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZWNrb1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIE5BTUVdXG4gICAgICAgIF0sXG5cbiAgICAgICAgb3MgOiBbW1xuXG4gICAgICAgICAgICAvLyBXaW5kb3dzIGJhc2VkXG4gICAgICAgICAgICAvbWljcm9zb2Z0XFxzKHdpbmRvd3MpXFxzKHZpc3RhfHhwKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyAoaVR1bmVzKVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKHdpbmRvd3MpXFxzbnRcXHM2XFwuMjtcXHMoYXJtKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIFJUXG4gICAgICAgICAgICAvKHdpbmRvd3NcXHNwaG9uZSg/Olxcc29zKSopW1xcc1xcL10/KFtcXGRcXC5cXHNdK1xcdykqL2ksICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyBQaG9uZVxuICAgICAgICAgICAgLyh3aW5kb3dzXFxzbW9iaWxlfHdpbmRvd3MpW1xcc1xcL10/KFtudGNlXFxkXFwuXFxzXStcXHcpL2lcbiAgICAgICAgICAgIF0sIFtOQU1FLCBbVkVSU0lPTiwgbWFwcGVyLnN0ciwgbWFwcy5vcy53aW5kb3dzLnZlcnNpb25dXSwgW1xuICAgICAgICAgICAgLyh3aW4oPz0zfDl8bil8d2luXFxzOXhcXHMpKFtudFxcZFxcLl0rKS9pXG4gICAgICAgICAgICBdLCBbW05BTUUsICdXaW5kb3dzJ10sIFtWRVJTSU9OLCBtYXBwZXIuc3RyLCBtYXBzLm9zLndpbmRvd3MudmVyc2lvbl1dLCBbXG5cbiAgICAgICAgICAgIC8vIE1vYmlsZS9FbWJlZGRlZCBPU1xuICAgICAgICAgICAgL1xcKChiYikoMTApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tCZXJyeSAxMFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnQmxhY2tCZXJyeSddLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyhibGFja2JlcnJ5KVxcdypcXC8/KFtcXHdcXC5dKykqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tiZXJyeVxuICAgICAgICAgICAgLyh0aXplbilbXFwvXFxzXShbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGl6ZW5cbiAgICAgICAgICAgIC8oYW5kcm9pZHx3ZWJvc3xwYWxtXFxzb3N8cW54fGJhZGF8cmltXFxzdGFibGV0XFxzb3N8bWVlZ298Y29udGlraSlbXFwvXFxzLV0/KFtcXHdcXC5dKykqL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZHJvaWQvV2ViT1MvUGFsbS9RTlgvQmFkYS9SSU0vTWVlR28vQ29udGlraVxuICAgICAgICAgICAgL2xpbnV4Oy4rKHNhaWxmaXNoKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYWlsZmlzaCBPU1xuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKHN5bWJpYW5cXHM/b3N8c3ltYm9zfHM2MCg/PTspKVtcXC9cXHMtXT8oW1xcd1xcLl0rKSovaSAgICAgICAgICAgICAgICAgLy8gU3ltYmlhblxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnU3ltYmlhbiddLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgL1xcKChzZXJpZXM0MCk7L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VyaWVzIDQwXG4gICAgICAgICAgICBdLCBbTkFNRV0sIFtcbiAgICAgICAgICAgIC9tb3ppbGxhLitcXChtb2JpbGU7LitnZWNrby4rZmlyZWZveC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggT1NcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0ZpcmVmb3ggT1MnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLy8gQ29uc29sZVxuICAgICAgICAgICAgLyhuaW50ZW5kb3xwbGF5c3RhdGlvbilcXHMoW3dpZHMzNHBvcnRhYmxldnVdKykvaSwgICAgICAgICAgICAgICAgICAgLy8gTmludGVuZG8vUGxheXN0YXRpb25cblxuICAgICAgICAgICAgLy8gR05VL0xpbnV4IGJhc2VkXG4gICAgICAgICAgICAvKG1pbnQpW1xcL1xcc1xcKF0/KFxcdyspKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaW50XG4gICAgICAgICAgICAvKG1hZ2VpYXx2ZWN0b3JsaW51eClbO1xcc10vaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWdlaWEvVmVjdG9yTGludXhcbiAgICAgICAgICAgIC8oam9saXxba3hsbl0/dWJ1bnR1fGRlYmlhbnxbb3Blbl0qc3VzZXxnZW50b298KD89XFxzKWFyY2h8c2xhY2t3YXJlfGZlZG9yYXxtYW5kcml2YXxjZW50b3N8cGNsaW51eG9zfHJlZGhhdHx6ZW53YWxrfGxpbnB1cylbXFwvXFxzLV0/KD8hY2hyb20pKFtcXHdcXC4tXSspKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKb2xpL1VidW50dS9EZWJpYW4vU1VTRS9HZW50b28vQXJjaC9TbGFja3dhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmVkb3JhL01hbmRyaXZhL0NlbnRPUy9QQ0xpbnV4T1MvUmVkSGF0L1plbndhbGsvTGlucHVzXG4gICAgICAgICAgICAvKGh1cmR8bGludXgpXFxzPyhbXFx3XFwuXSspKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEh1cmQvTGludXhcbiAgICAgICAgICAgIC8oZ251KVxccz8oW1xcd1xcLl0rKSovaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR05VXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhjcm9zKVxcc1tcXHddK1xccyhbXFx3XFwuXStcXHcpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bSBPU1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAnQ2hyb21pdW0gT1MnXSwgVkVSU0lPTl0sW1xuXG4gICAgICAgICAgICAvLyBTb2xhcmlzXG4gICAgICAgICAgICAvKHN1bm9zKVxccz8oW1xcd1xcLl0rXFxkKSovaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb2xhcmlzXG4gICAgICAgICAgICBdLCBbW05BTUUsICdTb2xhcmlzJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8vIEJTRCBiYXNlZFxuICAgICAgICAgICAgL1xccyhbZnJlbnRvcGMtXXswLDR9YnNkfGRyYWdvbmZseSlcXHM/KFtcXHdcXC5dKykqL2kgICAgICAgICAgICAgICAgICAgLy8gRnJlZUJTRC9OZXRCU0QvT3BlbkJTRC9QQy1CU0QvRHJhZ29uRmx5XG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sW1xuXG4gICAgICAgICAgICAvKGhhaWt1KVxccyhcXHcrKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYWlrdVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLFtcblxuICAgICAgICAgICAgL2NmbmV0d29ya1xcLy4rZGFyd2luL2ksXG4gICAgICAgICAgICAvaXBbaG9uZWFkXSsoPzouKm9zXFxzKFtcXHddKykqXFxzbGlrZVxcc21hY3w7XFxzb3BlcmEpL2kgICAgICAgICAgICAgICAgLy8gaU9TXG4gICAgICAgICAgICBdLCBbW1ZFUlNJT04sIC9fL2csICcuJ10sIFtOQU1FLCAnaU9TJ11dLCBbXG5cbiAgICAgICAgICAgIC8obWFjXFxzb3NcXHN4KVxccz8oW1xcd1xcc1xcLl0rXFx3KSovaSxcbiAgICAgICAgICAgIC8obWFjaW50b3NofG1hYyg/PV9wb3dlcnBjKVxccykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hYyBPU1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAnTWFjIE9TJ10sIFtWRVJTSU9OLCAvXy9nLCAnLiddXSwgW1xuXG4gICAgICAgICAgICAvLyBPdGhlclxuICAgICAgICAgICAgLygoPzpvcGVuKT9zb2xhcmlzKVtcXC9cXHMtXT8oW1xcd1xcLl0rKSovaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29sYXJpc1xuICAgICAgICAgICAgLyhhaXgpXFxzKChcXGQpKD89XFwufFxcKXxcXHMpW1xcd1xcLl0qKSovaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQUlYXG4gICAgICAgICAgICAvKHBsYW5cXHM5fG1pbml4fGJlb3N8b3NcXC8yfGFtaWdhb3N8bW9ycGhvc3xyaXNjXFxzb3N8b3BlbnZtcykvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhbjkvTWluaXgvQmVPUy9PUzIvQW1pZ2FPUy9Nb3JwaE9TL1JJU0NPUy9PcGVuVk1TXG4gICAgICAgICAgICAvKHVuaXgpXFxzPyhbXFx3XFwuXSspKi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVOSVhcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXVxuICAgICAgICBdXG4gICAgfTtcblxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBDb25zdHJ1Y3RvclxuICAgIC8vLy8vLy8vLy8vLy8vLy9cblxuICAgIHZhciBCcm93c2VyID0gZnVuY3Rpb24gKG5hbWUsIHZlcnNpb24pIHtcbiAgICAgICAgdGhpc1tOQU1FXSA9IG5hbWU7XG4gICAgICAgIHRoaXNbVkVSU0lPTl0gPSB2ZXJzaW9uO1xuICAgIH07XG4gICAgdmFyIENQVSA9IGZ1bmN0aW9uIChhcmNoKSB7XG4gICAgICAgIHRoaXNbQVJDSElURUNUVVJFXSA9IGFyY2g7XG4gICAgfTtcbiAgICB2YXIgRGV2aWNlID0gZnVuY3Rpb24gKHZlbmRvciwgbW9kZWwsIHR5cGUpIHtcbiAgICAgICAgdGhpc1tWRU5ET1JdID0gdmVuZG9yO1xuICAgICAgICB0aGlzW01PREVMXSA9IG1vZGVsO1xuICAgICAgICB0aGlzW1RZUEVdID0gdHlwZTtcbiAgICB9O1xuICAgIHZhciBFbmdpbmUgPSBCcm93c2VyO1xuICAgIHZhciBPUyA9IEJyb3dzZXI7XG5cbiAgICB2YXIgVUFQYXJzZXIgPSBmdW5jdGlvbiAodWFzdHJpbmcsIGV4dGVuc2lvbnMpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHVhc3RyaW5nID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucyA9IHVhc3RyaW5nO1xuICAgICAgICAgICAgdWFzdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVUFQYXJzZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVBUGFyc2VyKHVhc3RyaW5nLCBleHRlbnNpb25zKS5nZXRSZXN1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1YSA9IHVhc3RyaW5nIHx8ICgod2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpID8gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQgOiBFTVBUWSk7XG4gICAgICAgIHZhciByZ3htYXAgPSBleHRlbnNpb25zID8gdXRpbC5leHRlbmQocmVnZXhlcywgZXh0ZW5zaW9ucykgOiByZWdleGVzO1xuICAgICAgICB2YXIgYnJvd3NlciA9IG5ldyBCcm93c2VyKCk7XG4gICAgICAgIHZhciBjcHUgPSBuZXcgQ1BVKCk7XG4gICAgICAgIHZhciBkZXZpY2UgPSBuZXcgRGV2aWNlKCk7XG4gICAgICAgIHZhciBlbmdpbmUgPSBuZXcgRW5naW5lKCk7XG4gICAgICAgIHZhciBvcyA9IG5ldyBPUygpO1xuXG4gICAgICAgIHRoaXMuZ2V0QnJvd3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1hcHBlci5yZ3guY2FsbChicm93c2VyLCB1YSwgcmd4bWFwLmJyb3dzZXIpO1xuICAgICAgICAgICAgYnJvd3Nlci5tYWpvciA9IHV0aWwubWFqb3IoYnJvd3Nlci52ZXJzaW9uKTsgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWFwcGVyLnJneC5jYWxsKGNwdSwgdWEsIHJneG1hcC5jcHUpO1xuICAgICAgICAgICAgcmV0dXJuIGNwdTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXREZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtYXBwZXIucmd4LmNhbGwoZGV2aWNlLCB1YSwgcmd4bWFwLmRldmljZSk7XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1hcHBlci5yZ3guY2FsbChlbmdpbmUsIHVhLCByZ3htYXAuZW5naW5lKTtcbiAgICAgICAgICAgIHJldHVybiBlbmdpbmU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0T1MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtYXBwZXIucmd4LmNhbGwob3MsIHVhLCByZ3htYXAub3MpO1xuICAgICAgICAgICAgcmV0dXJuIG9zO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdWEgICAgICA6IHRoaXMuZ2V0VUEoKSxcbiAgICAgICAgICAgICAgICBicm93c2VyIDogdGhpcy5nZXRCcm93c2VyKCksXG4gICAgICAgICAgICAgICAgZW5naW5lICA6IHRoaXMuZ2V0RW5naW5lKCksXG4gICAgICAgICAgICAgICAgb3MgICAgICA6IHRoaXMuZ2V0T1MoKSxcbiAgICAgICAgICAgICAgICBkZXZpY2UgIDogdGhpcy5nZXREZXZpY2UoKSxcbiAgICAgICAgICAgICAgICBjcHUgICAgIDogdGhpcy5nZXRDUFUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRVQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB1YTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRVQSA9IGZ1bmN0aW9uICh1YXN0cmluZykge1xuICAgICAgICAgICAgdWEgPSB1YXN0cmluZztcbiAgICAgICAgICAgIGJyb3dzZXIgPSBuZXcgQnJvd3NlcigpO1xuICAgICAgICAgICAgY3B1ID0gbmV3IENQVSgpO1xuICAgICAgICAgICAgZGV2aWNlID0gbmV3IERldmljZSgpO1xuICAgICAgICAgICAgZW5naW5lID0gbmV3IEVuZ2luZSgpO1xuICAgICAgICAgICAgb3MgPSBuZXcgT1MoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVUFQYXJzZXIuVkVSU0lPTiA9IExJQlZFUlNJT047XG4gICAgVUFQYXJzZXIuQlJPV1NFUiA9IHtcbiAgICAgICAgTkFNRSAgICA6IE5BTUUsXG4gICAgICAgIE1BSk9SICAgOiBNQUpPUiwgLy8gZGVwcmVjYXRlZFxuICAgICAgICBWRVJTSU9OIDogVkVSU0lPTlxuICAgIH07XG4gICAgVUFQYXJzZXIuQ1BVID0ge1xuICAgICAgICBBUkNISVRFQ1RVUkUgOiBBUkNISVRFQ1RVUkVcbiAgICB9O1xuICAgIFVBUGFyc2VyLkRFVklDRSA9IHtcbiAgICAgICAgTU9ERUwgICA6IE1PREVMLFxuICAgICAgICBWRU5ET1IgIDogVkVORE9SLFxuICAgICAgICBUWVBFICAgIDogVFlQRSxcbiAgICAgICAgQ09OU09MRSA6IENPTlNPTEUsXG4gICAgICAgIE1PQklMRSAgOiBNT0JJTEUsXG4gICAgICAgIFNNQVJUVFYgOiBTTUFSVFRWLFxuICAgICAgICBUQUJMRVQgIDogVEFCTEVULFxuICAgICAgICBXRUFSQUJMRTogV0VBUkFCTEUsXG4gICAgICAgIEVNQkVEREVEOiBFTUJFRERFRFxuICAgIH07XG4gICAgVUFQYXJzZXIuRU5HSU5FID0ge1xuICAgICAgICBOQU1FICAgIDogTkFNRSxcbiAgICAgICAgVkVSU0lPTiA6IFZFUlNJT05cbiAgICB9O1xuICAgIFVBUGFyc2VyLk9TID0ge1xuICAgICAgICBOQU1FICAgIDogTkFNRSxcbiAgICAgICAgVkVSU0lPTiA6IFZFUlNJT05cbiAgICB9O1xuICAgIC8vVUFQYXJzZXIuVXRpbHMgPSB1dGlsO1xuXG4gICAgLy8vLy8vLy8vLy9cbiAgICAvLyBFeHBvcnRcbiAgICAvLy8vLy8vLy8vXG5cblxuICAgIC8vIGNoZWNrIGpzIGVudmlyb25tZW50XG4gICAgaWYgKHR5cGVvZihleHBvcnRzKSAhPT0gVU5ERUZfVFlQRSkge1xuICAgICAgICAvLyBub2RlanMgZW52XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSBVTkRFRl9UWVBFICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBVQVBhcnNlcjtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLlVBUGFyc2VyID0gVUFQYXJzZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVxdWlyZWpzIGVudiAob3B0aW9uYWwpXG4gICAgICAgIGlmICh0eXBlb2YoZGVmaW5lKSA9PT0gRlVOQ19UWVBFICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFVBUGFyc2VyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93KSB7XG4gICAgICAgICAgICAvLyBicm93c2VyIGVudlxuICAgICAgICAgICAgd2luZG93LlVBUGFyc2VyID0gVUFQYXJzZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBqUXVlcnkvWmVwdG8gc3BlY2lmaWMgKG9wdGlvbmFsKVxuICAgIC8vIE5vdGU6XG4gICAgLy8gICBJbiBBTUQgZW52IHRoZSBnbG9iYWwgc2NvcGUgc2hvdWxkIGJlIGtlcHQgY2xlYW4sIGJ1dCBqUXVlcnkgaXMgYW4gZXhjZXB0aW9uLlxuICAgIC8vICAgalF1ZXJ5IGFsd2F5cyBleHBvcnRzIHRvIGdsb2JhbCBzY29wZSwgdW5sZXNzIGpRdWVyeS5ub0NvbmZsaWN0KHRydWUpIGlzIHVzZWQsXG4gICAgLy8gICBhbmQgd2Ugc2hvdWxkIGNhdGNoIHRoYXQuXG4gICAgdmFyICQgPSB3aW5kb3cgJiYgKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvKTtcbiAgICBpZiAodHlwZW9mICQgIT09IFVOREVGX1RZUEUpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBVQVBhcnNlcigpO1xuICAgICAgICAkLnVhID0gcGFyc2VyLmdldFJlc3VsdCgpO1xuICAgICAgICAkLnVhLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIuZ2V0VUEoKTtcbiAgICAgICAgfTtcbiAgICAgICAgJC51YS5zZXQgPSBmdW5jdGlvbiAodWFzdHJpbmcpIHtcbiAgICAgICAgICAgIHBhcnNlci5zZXRVQSh1YXN0cmluZyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VyLmdldFJlc3VsdCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAkLnVhW3Byb3BdID0gcmVzdWx0W3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxufSkodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgPyB3aW5kb3cgOiB0aGlzKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEZVTkNUSU9OUyAvL1xuXG52YXIgaXNTdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5cbi8vIElTIEZMT0FUMzJBUlJBWSAvL1xuXG4vKipcbiogRlVOQ1RJT046IGlzRmxvYXQzMkFycmF5KCB2YWx1ZSApXG4qXHRWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhIEZsb2F0MzJBcnJheS5cbipcbiogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIHZhbGlkYXRlXG4qIEByZXR1cm5zIHtCb29sZWFufSBib29sZWFuIGluZGljYXRpbmcgaWYgYSB2YWx1ZSBpcyBhIEZsb2F0MzJBcnJheVxuKi9cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KCB2YWx1ZSApIHtcblx0cmV0dXJuIGlzU3RyLmNhbGwoIHZhbHVlICkgPT09ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nO1xufSAvLyBlbmQgRlVOQ1RJT04gaXNGbG9hdDMyQXJyYXkoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Zsb2F0MzJBcnJheTtcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgZHVwbGV4aWZ5ID0gcmVxdWlyZSgnZHVwbGV4aWZ5JylcbnZhciBXUyA9IHJlcXVpcmUoJ3dzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFN0cmVhbVxuXG5mdW5jdGlvbiBidWlsZFByb3h5IChvcHRpb25zLCBzb2NrZXRXcml0ZSwgc29ja2V0RW5kKSB7XG4gIHZhciBwcm94eSA9IG5ldyBUcmFuc2Zvcm0oe1xuICAgIG9iamVjdE1vZGU6IG9wdGlvbnMub2JqZWN0TW9kZVxuICB9KVxuXG4gIHByb3h5Ll9kZXN0cm95ZWQgPSBmYWxzZVxuICBwcm94eS5fd3JpdGUgPSBzb2NrZXRXcml0ZVxuICBwcm94eS5fZmx1c2ggPSBzb2NrZXRFbmRcblxuICBwcm94eS5kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuXG4gICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG5cbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGVycilcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gcHJveHlcbn1cblxuZnVuY3Rpb24gV2ViU29ja2V0U3RyZWFtKHRhcmdldCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIHZhciBzdHJlYW0sIHNvY2tldFxuXG4gIHZhciBpc0Jyb3dzZXIgPSBwcm9jZXNzLnRpdGxlID09PSAnYnJvd3NlcidcbiAgdmFyIGlzTmF0aXZlID0gISFnbG9iYWwuV2ViU29ja2V0XG4gIHZhciBzb2NrZXRXcml0ZSA9IGlzQnJvd3NlciA/IHNvY2tldFdyaXRlQnJvd3NlciA6IHNvY2tldFdyaXRlTm9kZVxuXG4gIGlmIChwcm90b2NvbHMgJiYgIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHByb3RvY29scykge1xuICAgIC8vIGFjY2VwdCB0aGUgXCJvcHRpb25zXCIgT2JqZWN0IGFzIHRoZSAybmQgYXJndW1lbnRcbiAgICBvcHRpb25zID0gcHJvdG9jb2xzXG4gICAgcHJvdG9jb2xzID0gbnVsbFxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnByb3RvY29sID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMucHJvdG9jb2wpKSB7XG4gICAgICBwcm90b2NvbHMgPSBvcHRpb25zLnByb3RvY29sO1xuICAgIH1cbiAgfVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgaWYgKG9wdGlvbnMub2JqZWN0TW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5vYmplY3RNb2RlID0gIShvcHRpb25zLmJpbmFyeSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmJpbmFyeSA9PT0gdW5kZWZpbmVkKVxuICB9XG5cbiAgdmFyIHByb3h5ID0gYnVpbGRQcm94eShvcHRpb25zLCBzb2NrZXRXcml0ZSwgc29ja2V0RW5kKVxuXG4gIGlmICghb3B0aW9ucy5vYmplY3RNb2RlKSB7XG4gICAgcHJveHkuX3dyaXRldiA9IHdyaXRldlxuICB9XG5cbiAgLy8gYnJvd3NlciBvbmx5OiBzZXRzIHRoZSBtYXhpbXVtIHNvY2tldCBidWZmZXIgc2l6ZSBiZWZvcmUgdGhyb3R0bGluZ1xuICB2YXIgYnVmZmVyU2l6ZSA9IG9wdGlvbnMuYnJvd3NlckJ1ZmZlclNpemUgfHwgMTAyNCAqIDUxMlxuXG4gIC8vIGJyb3dzZXIgb25seTogaG93IGxvbmcgdG8gd2FpdCB3aGVuIHRocm90dGxpbmdcbiAgdmFyIGJ1ZmZlclRpbWVvdXQgPSBvcHRpb25zLmJyb3dzZXJCdWZmZXJUaW1lb3V0IHx8IDEwMDBcblxuICAvLyB1c2UgZXhpc3RpbmcgV2ViU29ja2V0IG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgc29ja2V0ID0gdGFyZ2V0XG4gIC8vIG90aGVyd2lzZSBtYWtlIGEgbmV3IG9uZVxuICB9IGVsc2Uge1xuICAgIC8vIHNwZWNpYWwgY29uc3RydWN0b3IgdHJlYXRtZW50IGZvciBuYXRpdmUgd2Vic29ja2V0cyBpbiBicm93c2Vycywgc2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21heG9nZGVuL3dlYnNvY2tldC1zdHJlYW0vaXNzdWVzLzgyXG4gICAgaWYgKGlzTmF0aXZlICYmIGlzQnJvd3Nlcikge1xuICAgICAgc29ja2V0ID0gbmV3IFdTKHRhcmdldCwgcHJvdG9jb2xzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQgPSBuZXcgV1ModGFyZ2V0LCBwcm90b2NvbHMsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgc29ja2V0LmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG4gIH1cblxuICAvLyB3YXMgYWxyZWFkeSBvcGVuIHdoZW4gcGFzc2VkIGluXG4gIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gc29ja2V0Lk9QRU4pIHtcbiAgICBzdHJlYW0gPSBwcm94eVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IGR1cGxleGlmeS5vYmooKVxuICAgIHNvY2tldC5vbm9wZW4gPSBvbm9wZW5cbiAgfVxuXG4gIHN0cmVhbS5zb2NrZXQgPSBzb2NrZXRcblxuICBzb2NrZXQub25jbG9zZSA9IG9uY2xvc2VcbiAgc29ja2V0Lm9uZXJyb3IgPSBvbmVycm9yXG4gIHNvY2tldC5vbm1lc3NhZ2UgPSBvbm1lc3NhZ2VcblxuICBwcm94eS5vbignY2xvc2UnLCBkZXN0cm95KVxuXG4gIHZhciBjb2VyY2VUb0J1ZmZlciA9ICFvcHRpb25zLm9iamVjdE1vZGVcblxuICBmdW5jdGlvbiBzb2NrZXRXcml0ZU5vZGUoY2h1bmssIGVuYywgbmV4dCkge1xuICAgIC8vIGF2b2lkIGVycm9ycywgdGhpcyBuZXZlciBoYXBwZW5zIHVubGVzc1xuICAgIC8vIGRlc3Ryb3koKSBpcyBjYWxsZWRcbiAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IHNvY2tldC5PUEVOKSB7XG4gICAgICBuZXh0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjb2VyY2VUb0J1ZmZlciAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssICd1dGY4JylcbiAgICB9XG4gICAgc29ja2V0LnNlbmQoY2h1bmssIG5leHQpXG4gIH1cblxuICBmdW5jdGlvbiBzb2NrZXRXcml0ZUJyb3dzZXIoY2h1bmssIGVuYywgbmV4dCkge1xuICAgIGlmIChzb2NrZXQuYnVmZmVyZWRBbW91bnQgPiBidWZmZXJTaXplKSB7XG4gICAgICBzZXRUaW1lb3V0KHNvY2tldFdyaXRlQnJvd3NlciwgYnVmZmVyVGltZW91dCwgY2h1bmssIGVuYywgbmV4dClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjb2VyY2VUb0J1ZmZlciAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssICd1dGY4JylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc29ja2V0LnNlbmQoY2h1bmspXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIHJldHVybiBuZXh0KGVycilcbiAgICB9XG5cbiAgICBuZXh0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvY2tldEVuZChkb25lKSB7XG4gICAgc29ja2V0LmNsb3NlKClcbiAgICBkb25lKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ub3BlbigpIHtcbiAgICBzdHJlYW0uc2V0UmVhZGFibGUocHJveHkpXG4gICAgc3RyZWFtLnNldFdyaXRhYmxlKHByb3h5KVxuICAgIHN0cmVhbS5lbWl0KCdjb25uZWN0JylcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgc3RyZWFtLmVuZCgpXG4gICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIH1cblxuICBmdW5jdGlvbiBvbm1lc3NhZ2UoZXZlbnQpIHtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBkYXRhID0gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkoZGF0YSkpXG4gICAgZWxzZSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKVxuICAgIHByb3h5LnB1c2goZGF0YSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgc29ja2V0LmNsb3NlKClcbiAgfVxuXG4gIC8vIHRoaXMgaXMgdG8gYmUgZW5hYmxlZCBvbmx5IGlmIG9iamVjdE1vZGUgaXMgZmFsc2VcbiAgZnVuY3Rpb24gd3JpdGV2IChjaHVua3MsIGNiKSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSBuZXcgQXJyYXkoY2h1bmtzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBjaHVua3NbaV0uY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1ZmZlcnNbaV0gPSBCdWZmZXIuZnJvbShjaHVua3NbaV0sICd1dGY4JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlcnNbaV0gPSBjaHVua3NbaV0uY2h1bmtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl93cml0ZShCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpLCAnYmluYXJ5JywgY2IpXG4gIH1cblxuICByZXR1cm4gc3RyZWFtXG59XG4iLCJcbnZhciB3cyA9IG51bGxcblxuaWYgKHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdzID0gV2ViU29ja2V0XG59IGVsc2UgaWYgKHR5cGVvZiBNb3pXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdzID0gTW96V2ViU29ja2V0XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdzID0gd2luZG93LldlYlNvY2tldCB8fCB3aW5kb3cuTW96V2ViU29ja2V0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3NcbiIsIi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJ2aWRlb21haWwtY2xpZW50XCIsXG4gIFwidmVyc2lvblwiOiBcIjIuMC4xMFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSB3aWNrZWQgbnBtIHBhY2thZ2UgdG8gcmVjb3JkIHZpZGVvcyBkaXJlY3RseSBpbiB0aGUgYnJvd3Nlciwgd29ob29vIVwiLFxuICBcImF1dGhvclwiOiBcIk1pY2hhZWwgSGV1YmVyZ2VyIDxtaWNoYWVsLmhldWJlcmdlckBiaW5hcnlraXRjaGVuLmNvbT5cIixcbiAgXCJjb250cmlidXRvcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIk1pY2hhZWwgSGV1YmVyZ2VyXCIsXG4gICAgICBcImVtYWlsXCI6IFwibWljaGFlbC5oZXViZXJnZXJAYmluYXJ5a2l0Y2hlbi5jb21cIlxuICAgIH1cbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdmlkZW9tYWlsLmlvXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwtY2xpZW50LmdpdFwiXG4gIH0sXG4gIFwibGljZW5zZVwiOiBcIkNDMC0xLjBcIixcbiAgXCJyZWFkbWVGaWxlbmFtZVwiOiBcIlJFQURNRS5tZFwiLFxuICBcIm1vZHVsZVwiOiBcInNyYy9pbmRleC5qc1wiLFxuICBcIm1haW5cIjogXCJkaXN0L3ZpZGVvbWFpbC1jbGllbnQuanNcIixcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJndWxwIHRlc3RcIixcbiAgICBcInN0YXJ0XCI6IFwiZ3VscCBleGFtcGxlc1wiLFxuICAgIFwicGF0Y2hcIjogXCIuL2Vudi9kZXYvcmVsZWFzZS5zaCAtLWltcG9ydGFuY2U9cGF0Y2hcIixcbiAgICBcIm1pbm9yXCI6IFwiLi9lbnYvZGV2L3JlbGVhc2Uuc2ggLS1pbXBvcnRhbmNlPW1pbm9yXCIsXG4gICAgXCJtYWpvclwiOiBcIi4vZW52L2Rldi9yZWxlYXNlLnNoIC0taW1wb3J0YW5jZT1tYWpvclwiXG4gIH0sXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj04LjEuMFwiLFxuICAgIFwieWFyblwiOiBcIj49MC4yNy41XCIsXG4gICAgXCJucG1cIjogXCI+PTUuMi4wXCJcbiAgfSxcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJ3ZWJjYW1cIixcbiAgICBcInZpZGVvXCIsXG4gICAgXCJ2aWRlb21haWxcIixcbiAgICBcImVuY29kZXJcIixcbiAgICBcImdldHVzZXJtZWRpYVwiLFxuICAgIFwiYXVkaW9cIixcbiAgICBcInJlY29yZGVyXCJcbiAgXSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYWRkLWV2ZW50bGlzdGVuZXItd2l0aC1vcHRpb25zXCI6IFwiMS4yNS4wXCIsXG4gICAgXCJhbmltaXR0ZXJcIjogXCIzLjAuMFwiLFxuICAgIFwiYXVkaW8tc2FtcGxlXCI6IFwiMS4wLjNcIixcbiAgICBcImNhbnZhcy10by1idWZmZXJcIjogXCIxLjAuOVwiLFxuICAgIFwiY2xhc3NsaXN0LmpzXCI6IFwiMS4xLjIwMTUwMzEyXCIsXG4gICAgXCJjb250YWluc1wiOiBcIjAuMS4xXCIsXG4gICAgXCJjcmVhdGUtZXJyb3JcIjogXCIwLjMuMVwiLFxuICAgIFwiZGVmaW5lZFwiOiBcIjEuMC4wXCIsXG4gICAgXCJkZXNwb3RcIjogXCIxLjEuM1wiLFxuICAgIFwiZG9jdW1lbnQtdmlzaWJpbGl0eVwiOiBcIjEuMC4xXCIsXG4gICAgXCJlbGVtZW50LWNsb3Nlc3RcIjogXCIyLjAuMlwiLFxuICAgIFwiZmlsZXNpemVcIjogXCIzLjUuMTBcIixcbiAgICBcImdldC1mb3JtLWRhdGFcIjogXCIxLjIuNVwiLFxuICAgIFwiaGlkZGVuXCI6IFwiMS4xLjFcIixcbiAgICBcImh1bWFuaXplLWR1cmF0aW9uXCI6IFwiMy4xMC4xXCIsXG4gICAgXCJoeXBlcnNjcmlwdFwiOiBcIjIuMC4yXCIsXG4gICAgXCJpbnNlcnQtY3NzXCI6IFwiMi4wLjBcIixcbiAgICBcImlwaG9uZS1pbmxpbmUtdmlkZW9cIjogXCIyLjIuMlwiLFxuICAgIFwiaXMtcG93ZXItb2YtdHdvXCI6IFwiMS4wLjBcIixcbiAgICBcImtleW1pcnJvclwiOiBcIjAuMS4xXCIsXG4gICAgXCJtZXJnZS1yZWN1cnNpdmVcIjogXCIwLjAuM1wiLFxuICAgIFwibnVtYmVyLWlzLWludGVnZXJcIjogXCIxLjAuMVwiLFxuICAgIFwicmVhZHlzdGF0ZVwiOiBcIjAuMy4wXCIsXG4gICAgXCJyZXF1ZXN0LWZyYW1lXCI6IFwiMS41LjNcIixcbiAgICBcInN1cGVyYWdlbnRcIjogXCIzLjUuMlwiLFxuICAgIFwidWEtcGFyc2VyLWpzXCI6IFwiMC43LjE0XCIsXG4gICAgXCJ3ZWJzb2NrZXQtc3RyZWFtXCI6IFwiNS4wLjFcIlxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJiYWJlbC1wb2x5ZmlsbFwiOiBcIjYuMjMuMFwiLFxuICAgIFwiYmFiZWwtcHJlc2V0LWVudlwiOiBcIjEuNi4wXCIsXG4gICAgXCJiYWJlbGlmeVwiOiBcIjcuMy4wXCIsXG4gICAgXCJib2R5LXBhcnNlclwiOiBcIjEuMTcuMlwiLFxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIjE0LjQuMFwiLFxuICAgIFwiY29ubmVjdC1zZW5kLWpzb25cIjogXCIxLjAuMFwiLFxuICAgIFwiZGVsXCI6IFwiMy4wLjBcIixcbiAgICBcImdsb2JcIjogXCI3LjEuMlwiLFxuICAgIFwiZ3VscFwiOiBcIjMuOS4xXCIsXG4gICAgXCJndWxwLWF1dG9wcmVmaXhlclwiOiBcIjQuMC4wXCIsXG4gICAgXCJndWxwLWJ1bXBcIjogXCIyLjcuMFwiLFxuICAgIFwiZ3VscC1ieXRlZGlmZlwiOiBcIjEuMC4wXCIsXG4gICAgXCJndWxwLWNvbmNhdFwiOiBcIjIuNi4xXCIsXG4gICAgXCJndWxwLWNvbm5lY3RcIjogXCI1LjAuMFwiLFxuICAgIFwiZ3VscC1jc3NuYW5vXCI6IFwiMi4xLjJcIixcbiAgICBcImd1bHAtZGVyZXF1aXJlXCI6IFwiMi4xLjBcIixcbiAgICBcImd1bHAtaWZcIjogXCIyLjAuMlwiLFxuICAgIFwiZ3VscC1pbmplY3Qtc3RyaW5nXCI6IFwiMS4xLjBcIixcbiAgICBcImd1bHAtbG9hZC1wbHVnaW5zXCI6IFwiMS41LjBcIixcbiAgICBcImd1bHAtcGx1bWJlclwiOiBcIjEuMS4wXCIsXG4gICAgXCJndWxwLXJlbmFtZVwiOiBcIjEuMi4yXCIsXG4gICAgXCJndWxwLXNvdXJjZW1hcHNcIjogXCIyLjYuMFwiLFxuICAgIFwiZ3VscC1zdGFuZGFyZFwiOiBcIjEwLjAuMFwiLFxuICAgIFwiZ3VscC1zdHlsdXNcIjogXCIyLjYuMFwiLFxuICAgIFwiZ3VscC10b2RvXCI6IFwiNS40LjBcIixcbiAgICBcImd1bHAtdWdsaWZ5XCI6IFwiMy4wLjBcIixcbiAgICBcImd1bHAtdXRpbFwiOiBcIjMuMC44XCIsXG4gICAgXCJtaW5pbWlzdFwiOiBcIjEuMi4wXCIsXG4gICAgXCJuaWJcIjogXCIxLjEuMlwiLFxuICAgIFwicm91dGVyXCI6IFwiMS4zLjFcIixcbiAgICBcInNzbC1yb290LWNhc1wiOiBcIjEuMi4zXCIsXG4gICAgXCJzdGFuZGFyZFwiOiBcIjEwLjAuM1wiLFxuICAgIFwidGFwLXNwZWNcIjogXCI0LjEuMVwiLFxuICAgIFwidGFwZVwiOiBcIjQuOC4wXCIsXG4gICAgXCJ0YXBlLXJ1blwiOiBcIjMuMC4wXCIsXG4gICAgXCJ2aW55bC1idWZmZXJcIjogXCIxLjAuMFwiLFxuICAgIFwidmlueWwtc291cmNlLXN0cmVhbVwiOiBcIjEuMS4wXCIsXG4gICAgXCJ3YXRjaGlmeVwiOiBcIjMuOS4wXCJcbiAgfVxufVxuIiwiaW1wb3J0IG1lcmdlIGZyb20gJ21lcmdlLXJlY3Vyc2l2ZSdcbmltcG9ydCByZWFkeXN0YXRlIGZyb20gJ3JlYWR5c3RhdGUnXG5pbXBvcnQgdXRpbCBmcm9tICd1dGlsJ1xuXG5pbXBvcnQgZGVmYXVsdE9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJ1xuaW1wb3J0IENvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9ldmVudHMnXG5pbXBvcnQgQ29sbGVjdExvZ2dlciBmcm9tICcuL3V0aWwvY29sbGVjdExvZ2dlcidcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi91dGlsL2V2ZW50RW1pdHRlcidcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi93cmFwcGVycy9jb250YWluZXInXG5pbXBvcnQgT3B0aW9uc1dyYXBwZXIgZnJvbSAnLi93cmFwcGVycy9vcHRpb25zV3JhcHBlcidcbmltcG9ydCBSZXBsYXkgZnJvbSAnLi93cmFwcGVycy92aXN1YWxzL3JlcGxheSdcbmltcG9ydCBCcm93c2VyIGZyb20gJy4vdXRpbC9icm93c2VyJ1xuaW1wb3J0IFJlc291cmNlIGZyb20gJy4vcmVzb3VyY2UnXG5cbnZhciBjb2xsZWN0TG9nZ2VyXG52YXIgYnJvd3NlclxuXG5mdW5jdGlvbiBhZGp1c3RPcHRpb25zIChvcHRpb25zID0ge30pIHtcbiAgY29uc3QgbG9jYWxPcHRpb25zID0gbWVyZ2UucmVjdXJzaXZlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuXG4gIGNvbGxlY3RMb2dnZXIgPSBjb2xsZWN0TG9nZ2VyIHx8IG5ldyBDb2xsZWN0TG9nZ2VyKGxvY2FsT3B0aW9ucylcblxuICBsb2NhbE9wdGlvbnMubG9nZ2VyID0gY29sbGVjdExvZ2dlclxuICBsb2NhbE9wdGlvbnMuZGVidWcgPSBsb2NhbE9wdGlvbnMubG9nZ2VyLmRlYnVnXG5cbiAgT3B0aW9uc1dyYXBwZXIuYWRkRnVuY3Rpb25zKGxvY2FsT3B0aW9ucylcblxuICByZXR1cm4gbG9jYWxPcHRpb25zXG59XG5cbmZ1bmN0aW9uIGdldEJyb3dzZXIgKGxvY2FsT3B0aW9ucykge1xuICBpZiAoIWJyb3dzZXIpIHtcbiAgICBicm93c2VyID0gbmV3IEJyb3dzZXIobG9jYWxPcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIGJyb3dzZXJcbn1cblxuY29uc3QgVmlkZW9tYWlsQ2xpZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgY29uc3QgbG9jYWxPcHRpb25zID0gYWRqdXN0T3B0aW9ucyhvcHRpb25zKVxuICBjb25zdCBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyKGxvY2FsT3B0aW9ucylcbiAgY29uc3QgZGVidWcgPSBsb2NhbE9wdGlvbnMuZGVidWdcblxuICB2YXIgcmVwbGF5XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgbG9jYWxPcHRpb25zLCAnVmlkZW9tYWlsQ2xpZW50JylcblxuICAvLyBleHBvc2UgYWxsIHBvc3NpYmxlIGV2ZW50c1xuICB0aGlzLmV2ZW50cyA9IEV2ZW50c1xuXG4gIGZ1bmN0aW9uIGJ1aWxkICgpIHtcbiAgICB2YXIgYnVpbGRpbmcgPSBmYWxzZVxuXG4gICAgcmVhZHlzdGF0ZS5pbnRlcmFjdGl2ZShmdW5jdGlvbiAocHJldmlvdXNTdGF0ZSkge1xuICAgICAgZGVidWcoXG4gICAgICAgICdDbGllbnQ6IGludGVyYWN0aXZlKCksJyxcbiAgICAgICAgJ3ByZXZpb3VzU3RhdGUgPScsIHByZXZpb3VzU3RhdGUgKyAnLCcsXG4gICAgICAgICchYnVpbGRpbmcgPScsICFidWlsZGluZyArICcsJyxcbiAgICAgICAgJyFpc0J1aWx0KCkgPScsICFjb250YWluZXIuaXNCdWlsdCgpXG4gICAgICApXG5cbiAgICAgIC8vIGl0IGNhbiBoYXBwZW4gdGhhdCBpdCBnZXRzIGNhbGxlZCB0d2ljZSwgaS5FLiB3aGVuIGFuIGVycm9yIGlzIHRocm93blxuICAgICAgLy8gaW4gdGhlIG1pZGRsZSBvZiB0aGUgYnVpbGQoKSBmblxuICAgICAgaWYgKCFidWlsZGluZyAmJiAhY29udGFpbmVyLmlzQnVpbHQoKSkge1xuICAgICAgICBidWlsZGluZyA9IHRydWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb250YWluZXIuYnVpbGQoKVxuICAgICAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgICAgICB0aHJvdyBleGNcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBidWlsZGluZyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdGhpcy5zaG93ID0gKCkgPT4ge1xuICAgIGlmIChjb250YWluZXIuaXNCdWlsdCgpKSB7XG4gICAgICBjb250YWluZXIuc2hvdygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25jZShFdmVudHMuQlVJTFQsIGNvbnRhaW5lci5zaG93KVxuICAgIH1cbiAgfVxuXG4gIC8vIGF1dG9tYXRpY2FsbHkgYWRkcyBhIDx2aWRlbz4gZWxlbWVudCBpbnNpZGUgdGhlIGdpdmVuIHBhcmVudEVsZW1lbnQgYW5kIGxvYWRzXG4gIC8vIGl0IHdpdGggdGhlIHZpZGVvbWFpbFxuICB0aGlzLnJlcGxheSA9ICh2aWRlb21haWwsIHBhcmVudEVsZW1lbnQpID0+IHtcbiAgICBmdW5jdGlvbiBidWlsZFJlcGxheSAoKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcmVudEVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYXJlbnRFbGVtZW50KVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGVyZSBpcyBub25lLCB1c2UgdGhlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIG9uZVxuICAgICAgaWYgKCFwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIGlmICghY29udGFpbmVyLmhhc0VsZW1lbnQoKSkge1xuICAgICAgICAgIHJlYWR5c3RhdGUucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZXBsYXkgdmlkZW8gd2l0aG91dCBhIGNvbnRhaW5lciBvciBwYXJlbnQgZWxlbWVudC4nKVxuICAgICAgICB9XG5cbiAgICAgICAgcmVwbGF5ID0gY29udGFpbmVyLmdldFJlcGxheSgpXG4gICAgICAgIHBhcmVudEVsZW1lbnQgPSByZXBsYXkuZ2V0UGFyZW50RWxlbWVudCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYXkgPSBuZXcgUmVwbGF5KHBhcmVudEVsZW1lbnQsIGxvY2FsT3B0aW9ucylcbiAgICAgICAgcmVwbGF5LmJ1aWxkKClcbiAgICAgIH1cblxuICAgICAgdmlkZW9tYWlsID0gY29udGFpbmVyLmFkZFBsYXllckRpbWVuc2lvbnModmlkZW9tYWlsLCBwYXJlbnRFbGVtZW50KVxuXG4gICAgICBpZiAodmlkZW9tYWlsKSB7XG4gICAgICAgIGlmIChjb250YWluZXIuaXNPdXRzaWRlRWxlbWVudE9mKHBhcmVudEVsZW1lbnQpKSB7XG4gICAgICAgICAgLy8gcmVwbGF5IGVsZW1lbnQgbXVzdCBiZSBvdXRzaWRlIG9mIHRoZSBjb250YWluZXJcbiAgICAgICAgICBjb250YWluZXIuaGlkZUZvcm0oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lci5sb2FkRm9ybSh2aWRlb21haWwpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzbGlnaHQgZGVsYXkgbmVlZGVkIHRvIGF2b2lkIEhUVFAgNDE2IGVycm9ycyAocmVxdWVzdCByYW5nZSB1bmF2YWlsYWJsZSlcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVwbGF5LnNldFZpZGVvbWFpbCh2aWRlb21haWwpXG5cbiAgICAgICAgICBjb250YWluZXIuc2hvd1JlcGxheU9ubHkoKVxuICAgICAgICB9LCAyZTMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVhZHlzdGF0ZS5pbnRlcmFjdGl2ZShidWlsZFJlcGxheSlcbiAgfVxuXG4gIHRoaXMuc3RhcnRPdmVyID0gKCkgPT4ge1xuICAgIHJlcGxheSAmJiByZXBsYXkuaGlkZSgpXG4gICAgY29udGFpbmVyLnN0YXJ0T3ZlcigpXG4gIH1cblxuICB0aGlzLnVubG9hZCA9IChlKSA9PiB7XG4gICAgcmVhZHlzdGF0ZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICAgIGNvbnRhaW5lci51bmxvYWQoZSlcbiAgfVxuXG4gIHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb250YWluZXIuaGlkZSgpXG4gIH1cblxuICB0aGlzLmdldCA9IGZ1bmN0aW9uIChrZXksIGNiKSB7XG4gICAgbmV3IFJlc291cmNlKGxvY2FsT3B0aW9ucykuZ2V0KGtleSwgZnVuY3Rpb24gKGVyciwgdmlkZW9tYWlsKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKG51bGwsIGNvbnRhaW5lci5hZGRQbGF5ZXJEaW1lbnNpb25zKHZpZGVvbWFpbCkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHRoaXMuY2FuUmVjb3JkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRCcm93c2VyKGxvY2FsT3B0aW9ucykuY2FuUmVjb3JkKClcbiAgfVxuXG4gIC8vIHJldHVybiB0cnVlIHdoZW4gYSB2aWRlbyBoYXMgYmVlbiByZWNvcmRlZCBidXQgaXMgbm90IHNlbnQgeWV0XG4gIHRoaXMuaXNEaXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmlzRGlydHkoKVxuICB9XG5cbiAgdGhpcy5zdWJtaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29udGFpbmVyLnN1Ym1pdCgpXG4gIH1cblxuICB0aGlzLmdldExvZ0xpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChsb2NhbE9wdGlvbnMubG9nZ2VyICYmIGxvY2FsT3B0aW9ucy5sb2dnZXIuZ2V0TGluZXMpIHtcbiAgICAgIHJldHVybiBsb2NhbE9wdGlvbnMubG9nZ2VyLmdldExpbmVzKClcbiAgICB9XG4gIH1cblxuICBidWlsZCgpXG59XG5cbnV0aWwuaW5oZXJpdHMoVmlkZW9tYWlsQ2xpZW50LCBFdmVudEVtaXR0ZXIpXG5cbk9iamVjdC5rZXlzKENvbnN0YW50cy5wdWJsaWMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgVmlkZW9tYWlsQ2xpZW50W25hbWVdID0gQ29uc3RhbnRzLnB1YmxpY1tuYW1lXVxufSlcblxuLy8ganVzdCBhbm90aGVyIGNvbnZlbmllbnQgdGhpbmdcblZpZGVvbWFpbENsaWVudC5ldmVudHMgPSBFdmVudHNcblxuZXhwb3J0IGRlZmF1bHQgVmlkZW9tYWlsQ2xpZW50XG4iLCIvLyBjb25zdGFudHMgKGNoYW5naW5nIHRoZXNlIG9ubHkgYnJlYWsgZG93biBmdW5jdGlvbmFsaXR5LCBzbyBiZSBjYXJlZnVsKVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFNJVEVfTkFNRV9MQUJFTDogJ3gtdmlkZW9tYWlsLXNpdGUtbmFtZScsXG5cbiAgcHVibGljOiB7XG4gICAgRU5DX1RZUEVfQVBQX0pTT046ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICBFTkNfVFlQRV9GT1JNOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICB9XG59XG4iLCJpbXBvcnQga2V5bWlycm9yIGZyb20gJ2tleW1pcnJvcidcblxuZXhwb3J0IGRlZmF1bHQga2V5bWlycm9yKHtcbiAgQlVJTFQ6IG51bGwsIC8vIGFsbCBkb20gZWxlbWVudHMgYXJlIHJlYWR5LCBhcmUgaW4gdGhlIERPTVxuICBGT1JNX1JFQURZOiBudWxsLCAvLyBmb3JtIGlzIHJlYWR5LCBhdmFpbGFibGUgaW4gdGhlIERPTVxuICBMT0FESU5HX1VTRVJfTUVESUE6IG51bGwsIC8vIGFza2luZyBmb3Igd2ViY2FtIGFjY2Vzc1xuICBVU0VSX01FRElBX1JFQURZOiBudWxsLCAvLyB1c2VyIG1lZGlhICg9IHdlYmNhbSkgaXMgcmVhZHksIGxvYWRlZFxuICBDT05ORUNUSU5HOiBudWxsLCAvLyBzb2NrZXQgaXMgY29ubmVjdGluZyB0byBzZXJ2ZXJcbiAgQ09OTkVDVEVEOiBudWxsLCAvLyBzb2NrZXQgaXMgY29ubmVjdGVkIHRvIHNlcnZlclxuICBESVNDT05ORUNURUQ6IG51bGwsIC8vIHNvY2tldCB0byBzZXJ2ZXIgaXMgZGlzY29ubmVjdGVkXG4gIENPVU5URE9XTjogbnVsbCwgLy8gY291bnRkb3duIGZvciByZWNvcmRpbmcgaGFzIHN0YXJ0ZWRcbiAgUkVDT1JESU5HOiBudWxsLCAvLyB3ZWJjYW0gaXMgcmVjb3JkaW5nXG4gIFNUT1BQSU5HOiBudWxsLCAvLyByZWNvcmRpbmcgaXMgYmVpbmcgc3RvcHBlZCAoPSBwcmV2aWV3KVxuICBQUk9HUkVTUzogbnVsbCwgLy8gc3RhcnQgc2VuZGluZ1xuICBCRUdJTl9BVURJT19FTkNPRElORzogbnVsbCwgLy8gZW5jb2RpbmcgdmlkZW9cbiAgQkVHSU5fVklERU9fRU5DT0RJTkc6IG51bGwsIC8vIGVuY29kaW5nIHZpZGVvXG4gIFJFU0VUVElORzogbnVsbCwgLy8gcmVzZXR0aW5nIGV2ZXJ5dGhpbmcgdG8gZ28gYmFjayB0byBpbml0aWFsIHN0YXRlXG4gIFBBVVNFRDogbnVsbCwgLy8gcmVjb3JkaW5nIGlzIGJlaW5nIHBhdXNlZFxuICBSRVNVTUlORzogbnVsbCwgLy8gcmVjb3JkaW5nIGlzIHJlc3VtZWRcbiAgUFJFVklFVzogbnVsbCwgLy8gdmlkZW8gcHJldmlldyBpcyBzZXRcbiAgUFJFVklFV19TSE9XTjogbnVsbCwgLy8gdmlkZW8gcHJldmlldyBpcyBzaG93blxuICBSRVBMQVlfU0hPV046IG51bGwsIC8vIHN1Ym1pdHRlZCB2aWRlbyBpcyBzaG93blxuICBJTlZBTElEOiBudWxsLCAvLyBmb3JtIGlzIGludmFsaWRcbiAgVkFMSURBVElORzogbnVsbCwgLy8gZm9ybSBpcyBiZWluZyB2YWxpZGF0ZWRcbiAgVkFMSUQ6IG51bGwsIC8vIGZvcm0gaXMgdmFsaWRcbiAgU1VCTUlUVElORzogbnVsbCwgLy8gZm9ybSBpcyBiZWluZyBzdWJtaXR0ZWRcbiAgU1VCTUlUVEVEOiBudWxsLCAvLyBmb3JtIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzdWJtaXR0ZWRcbiAgRVJST1I6IG51bGwsIC8vIGFuIGVycm9yIG9jY3VyZWRcbiAgQkxPQ0tJTkc6IG51bGwsIC8vIHNvbWV0aGluZyBzZXJpb3VzLCBtb3N0IGxpa2VseSBhbiBlcnJvciwgaXMgc2hvd24gYW5kIGJsb2Nrc1xuICBTRU5ESU5HX0ZJUlNUX0ZSQU1FOiBudWxsLCAvLyBlbWl0dGVkIGJlZm9yZSB0aGUgZmlyc3QgZnJhbWUgaXMgYmVpbmcgY29tcHV0ZWRcbiAgRklSU1RfRlJBTUVfU0VOVDogbnVsbCwgLy8gZW1pdHRlZCBvbmNlIHdoZW4gZmlzdCBmcmFtZSBoYXMgYmVlbiBzZW50IHRvIHNlcnZlclxuICBISURFOiBudWxsLCAvLyBlbWl0dGVkIHdoZW4gaGlkZGVuXG4gIE5PVElGWUlORzogbnVsbCwgLy8gbm90aWZpZXMgdXNlciBhYm91dCBzb21ldGhpbmcgKG5vdCBibG9ja2luZylcbiAgRU5BQkxJTkdfQVVESU86IG51bGwsIC8vIGFib3V0IHRvIGVuYWJsZSBhdWRpb1xuICBESVNBQkxJTkdfQVVESU86IG51bGwsIC8vIGFib3V0IHRvIGRpc2FibGUgYXVkaW9cbiAgTE9BREVEX01FVEFfREFUQTogbnVsbCwgLy8gcmFpc2VkIHdoZW4gd2ViY2FtIGtub3dzIGl0cyBkaW1lbnNpb25zXG4gIEVWRU5UX0VNSVRURUQ6IG51bGwsIC8vIGZvciBkZWJ1Z2dpbmcgb25seSwgaXMgZW1pdHRlZCB3aGVuIGFuIGV2ZW50IGlzIGVtaXR0ZWQgbG9sLFxuICBHT0lOR19CQUNLOiBudWxsLCAvLyBnb2luZyBiYWNrLCBzdGFydGluZyBhbGwgb3ZlciBhZ2FpbixcbiAgQVNLSU5HX1dFQkNBTV9QRVJNSVNTSU9OOiBudWxsLCAvLyB3aGVuIGFib3V0IHRvIGFzayBmb3Igd2ViY2FtIHBlcm1pc3Npb25zXG4gIFZJU0lCTEU6IG51bGwsIC8vIGRvY3VtZW50IGp1c3QgYmVjYW1lIHZpc2libGVcbiAgSU5WSVNJQkxFOiBudWxsICAvLyBkb2N1bWVudCBqdXN0IGJlY2FtZSBJTnZpc2libGVcbn0pXG4iLCJpbXBvcnQge3ZlcnNpb259IGZyb20gJy4uL3BhY2thZ2UuanNvbidcblxuY29uc3QgUFJPRFVDVElPTiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBsb2dnZXI6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmluZSBsb2dnaW5nIGluc3RhbmNlLiBsZWF2ZSBudWxsIGZvciBkZWZhdWx0LCBjb25zb2xlLlxuICBsb2dTdGFja1NpemU6IDMwLCAgICAgICAgICAgICAgICAgICAgIC8vIGxpbWl0cyB0aGUgc3RhY2sgc2l6ZSBvZiBsb2cgb3V0cHV0cyB0byBjb2xsZWN0XG4gIHZlcmJvc2U6ICFQUk9EVUNUSU9OLCAgICAgICAgICAgICAgICAgLy8gc2V0IHRydWUgdG8gbG9nIG1vcmUgaW5mb1xuICBiYXNlVXJsOiAnaHR0cHM6Ly92aWRlb21haWwuaW8nLCAgICAgIC8vIGxlYXZlIGFzIGl0LCBwZXJtYW5lbnQgdXJsIHRvIHBvc3QgdmlkZW9zXG4gIHNvY2tldFVybDogJ3dzczovL3ZpZGVvbWFpbC5pbycsICAgICAgLy8gbGVhdmUgYXMgaXQsIHBlcm1hbmVudCB1cmwgdG8gc2VuZCBmcmFtZXNcbiAgc2l0ZU5hbWU6ICd2aWRlb21haWwtY2xpZW50LWRlbW8nLCAgICAvLyBSZXF1aXJlZCBmb3IgdGhlIEFQSS4gSWYgeW91IGNoYW5nZSBpdCwgY29udGFjdCBtZVxuICBjYWNoZTogdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZHVjZXMgR0VUIHF1ZXJpZXMgd2hlbiBsb2FkaW5nIHZpZGVvc1xuICBpbnNlcnRDc3M6IHRydWUsICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydHMgcHJlZGVmaW5lZCBDU1MsIHNlZSBleGFtcGxlc1xuICBlbmFibGVQYXVzZTogdHJ1ZSwgICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsZSBwYXVzZS9yZXN1bWUgYnV0dG9uXG4gIGVuYWJsZUF1dG9QYXVzZTogdHJ1ZSwgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBwYXVzZXMgd2hlbiB3aW5kb3cgYmVjb21lcyBpbmFjdGl2ZVxuICBlbmFibGVTcGFjZTogdHJ1ZSwgICAgICAgICAgICAgICAgICAgIC8vIGhpdHRpbmcgc3BhY2UgY2FuIHBhdXNlIHJlY29yZGluZ1xuICBkaXNhYmxlU3VibWl0OiBmYWxzZSwgICAgICAgICAgICAgICAgIC8vIHNldCB0aGlzIHRvIHRydWUgaWYgeW91IGRvIG5vdCB3YW50IHRvIHN1Ym1pdCB2aWRlb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGp1c3Qgd2FudCB0byByZWNvcmQgYW5kIHJlcGxheSB0aGVzZSB0ZW1wb3JhcmlseVxuICBlbmFibGVBdXRvVmFsaWRhdGlvbjogdHJ1ZSwgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgdmFsaWRhdGVzIGFsbCBmb3JtIGlucHV0cyBpZiBhbnkgZXhpc3QgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgL2VuYWJsZSBkaXNhYmxlIHN1Ym1pdCBidXR0b24gYWZ0ZXIgcmVjb3JkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBzb21ldGhpbmcgZWxzZSBzZWVtcyBpbnZhbGlkLlxuXG4gIGVuY3R5cGU6ICdhcHBsaWNhdGlvbi9qc29uJywgICAgICAgICAgLy8gZW5jdHlwZSBmb3IgdGhlIGZvcm0gc3VibWlzc2lvbi4gY3VycmVudGx5IGltcGxlbWVudGVkIGFyZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnYXBwbGljYXRpb24vanNvbicgYW5kICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG5cbiAgLy8gZGVmYXVsdCBDU1Mgc2VsZWN0b3JzIHlvdSBjYW4gYWx0ZXIsIHNlZSBleGFtcGxlc1xuICBzZWxlY3RvcnM6IHtcbiAgICBjb250YWluZXJJZDogJ3ZpZGVvbWFpbCcsXG4gICAgcmVwbGF5Q2xhc3M6ICdyZXBsYXknLFxuICAgIHVzZXJNZWRpYUNsYXNzOiAndXNlck1lZGlhJyxcbiAgICB2aXN1YWxzQ2xhc3M6ICd2aXN1YWxzJyxcbiAgICBidXR0b25DbGFzczogbnVsbCwgICAgICAgICAgICAgICAgICAvLyBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgZGVmYXVsdCBjbGFzcyBmb3IgYWxsIGJ1dHRvbnNcbiAgICBidXR0b25zQ2xhc3M6ICdidXR0b25zJyxcblxuICAgIHJlY29yZEJ1dHRvbkNsYXNzOiAncmVjb3JkJyxcbiAgICBwYXVzZUJ1dHRvbkNsYXNzOiAncGF1c2UnLFxuICAgIHJlc3VtZUJ1dHRvbkNsYXNzOiAncmVzdW1lJyxcbiAgICBwcmV2aWV3QnV0dG9uQ2xhc3M6ICdwcmV2aWV3JyxcbiAgICByZWNvcmRBZ2FpbkJ1dHRvbkNsYXNzOiAncmVjb3JkQWdhaW4nLFxuICAgIHN1Ym1pdEJ1dHRvbkNsYXNzOiAnc3VibWl0JyxcblxuICAgIHN1YmplY3RJbnB1dE5hbWU6ICdzdWJqZWN0JywgICAgICAgICAvLyB0aGUgZm9ybSBpbnB1dCBuYW1lIGZvciBzdWJqZWN0XG4gICAgZnJvbUlucHV0TmFtZTogJ2Zyb20nLCAgICAgICAgICAgICAgIC8vIHRoZSBmb3JtIGlucHV0IG5hbWUgZm9yIHRoZSBmcm9tIGVtYWlsXG4gICAgdG9JbnB1dE5hbWU6ICd0bycsICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmb3JtIGlucHV0IG5hbWUgZm9yIHRoZSB0byBlbWFpbFxuICAgIGJvZHlJbnB1dE5hbWU6ICdib2R5JywgICAgICAgICAgICAgICAvLyB0aGUgZm9ybSBpbnB1dCBuYW1lIGZvciB0aGUgbWVzc2FnZSAoYm9keSlcblxuICAgIGtleUlucHV0TmFtZTogJ3ZpZGVvbWFpbF9rZXknLFxuICAgIHBhcmVudEtleUlucHV0TmFtZTogJ3ZpZGVvbWFpbF9wYXJlbnRfa2V5JyxcbiAgICBhbGlhc0lucHV0TmFtZTogJ3ZpZGVvbWFpbF9hbGlhcycsXG5cbiAgICBmb3JtSWQ6IG51bGwsICAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBkZXRlY3RzIGZvcm0gaWYgYW55XG4gICAgc3VibWl0QnV0dG9uSWQ6IG51bGwsICAgICAgICAgICAgIC8vIHNlbWktYXV0b21hdGljYWxseSBkZXRlY3RzIHN1Ym1pdCBidXR0b24gaW4gdGhlIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGlmIHRoYXQgZG9lcyBub3Qgd29yaywgdHJ5IHVzaW5nIHRoZVxuICAgIHN1Ym1pdEJ1dHRvblNlbGVjdG9yOiBudWxsICAgICAgICAvLyBzdWJtaXRCdXR0b25TZWxlY3RvclxuICB9LFxuXG4gIGF1ZGlvOiB7XG4gICAgZW5hYmxlZDogZmFsc2UsICAgICAgICAgICAgICAgICAgIC8vIHNldCB0byB0cnVlIGZvciBleHBlcmltZW50aWFsIGF1ZGlvIHJlY29yZGluZ1xuICAgICdzd2l0Y2gnOiBmYWxzZSwgICAgICAgICAgICAgICAgICAvLyBlbmFibGVzIGEgc3dpdGNoZXIgZm9yIGF1ZGlvIHJlY29yZGluZyAob24vb2ZmKVxuICAgIHZvbHVtZTogMC4yLCAgICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIGJldHdlZW4gMCAuLiAxIGJ1dCAwLjIwIGlzIHJlY29tbWVkZWQgdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzdG9ydGluZyBhdCB0aGUgaGlnaGVyIHZvbHVtZSBwZWFrc1xuICAgIGJ1ZmZlclNpemU6IDEwMjQgICAgICAgICAgICAgICAgICAvLyBkZWNpZGVzIGhvdyBvZnRlbiB0aGUgYXVkaW8gaXMgYmVpbmcgc2FtcGxlZCwgbXVzdCBiZSBhIHBvd2VyIG9mIHR3by5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGhpZ2hlciB0aGUgbGVzcyB0cmFmZmljLCBidXQgaGFyZGVyIHRvIGFkanVzdCB3aXRoIHJ1YmJlcmJhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gbWF0Y2ggd2l0aCB0aGUgdmlkZW8gbGVuZ3RoIG9uIHNlcnZlciBzaWRlIGR1cmluZyBlbmNvZGluZ1xuICB9LFxuXG4gIHZpZGVvOiB7XG4gICAgZnBzOiAxNSwgICAgICAgICAgICAgICAgICAgIC8vIGRlcGVuZHMgb24geW91ciBjb25uZWN0aW9uXG4gICAgbGltaXRTZWNvbmRzOiAzMCwgICAgICAgICAgIC8vIHJlY29yZGluZyBhdXRvbWF0aWNhbGx5IHN0b3BzIGFmdGVyIHRoYXQgbGltaXRcbiAgICBjb3VudGRvd246IDMsICAgICAgICAgICAgICAgLy8gc2V0IGl0IHRvIDAgb3IgZmFsc2UgdG8gZGlzYWJsZSBpdFxuXG4gICAgLy8gaXQgaXMgcmVjb21tZW5kZWQgdG8gc2V0IG9uZSBkaW1lbnNpb24gb25seSBhbmQgbGVhdmUgdGhlIG90aGVyIG9uZSB0byBhdXRvXG4gICAgLy8gYmVjYXVzZSBlYWNoIHdlYmNhbSBoYXMgYSBkaWZmZXJlbnQgYXNwZWN0IHJhdGlvXG5cbiAgICB3aWR0aDogJ2F1dG8nLCAgICAgIC8vIG9yIHVzZSBhbiBpbnRlZ2VyIGZvciBleGFjdCBwaXhlbHNcbiAgICBoZWlnaHQ6ICdhdXRvJyAgICAgIC8vIG9yIHVzZSBhbiBpbnRlZ2VyIGZvciBleGFjdCBwaXhlbHNcbiAgfSxcblxuICBpbWFnZToge1xuICAgIHF1YWxpdHk6IDAuNCxcbiAgICB0eXBlczogWyd3ZWJwJywgJ2pwZWcnXSAgIC8vIHJlY29tbWVuZGVkIHNldHRpbmdzIHRvIG1ha2UgbW9zdCBvZiBhbGwgYnJvd3NlcnNcbiAgfSxcblxuICAvLyBhbHRlciB0aGVzZSB0ZXh0IGZvciBpbnRlcm5hdGlvbmFsaXNhdGlvblxuICB0ZXh0OiB7XG4gICAgcGF1c2VkSGVhZGVyOiAnUGF1c2VkJyxcbiAgICBwYXVzZWRIaW50OiBudWxsLFxuICAgIHNlbmRpbmc6ICdUZWxlcG9ydGluZycsXG4gICAgZW5jb2Rpbmc6ICdFbmNvZGluZycsXG4gICAgbGltaXRSZWFjaGVkOiAnTGltaXQgcmVhY2hlZCcsXG4gICAgYnV0dG9uczoge1xuICAgICAgJ3JlY29yZCc6ICdSZWNvcmQgdmlkZW8nLFxuICAgICAgJ3JlY29yZEFnYWluJzogJ1JlY29yZCBhZ2FpbicsXG4gICAgICAncmVzdW1lJzogJ1Jlc3VtZScsXG4gICAgICAncGF1c2UnOiAnUGF1c2UnLFxuICAgICAgJ3ByZXZpZXcnOiAnUHJldmlldydcbiAgICB9XG4gIH0sXG5cbiAgbm90aWZpZXI6IHtcbiAgICBlbnRlcnRhaW46IGZhbHNlLCAgIC8vIHdoZW4gdHJ1ZSwgdXNlciBpcyBlbnRlcnRhaW5lZCB3aGlsZSB3YWl0aW5nLCBzZWUgZXhhbXBsZXNcbiAgICBlbnRlcnRhaW5DbGFzczogJ2JnJyxcbiAgICBlbnRlcnRhaW5MaW1pdDogNixcbiAgICBlbnRlcnRhaW5JbnRlcnZhbDogOTAwMFxuICB9LFxuXG4gIHRpbWVvdXRzOiB7XG4gICAgdXNlck1lZGlhOiAxMWUzLCAgICAgICAgIC8vIGluIG1pbGxpc2Vjb25kcywgaW5jcmVhc2UgaWYgeW91IHdhbnQgdXNlciBnaXZlIG1vcmUgdGltZSB0byBlbmFibGUgd2ViY2FtXG4gICAgY29ubmVjdGlvbjogMWU0LCAgICAgICAgIC8vIGluIHNlY29uZHMsIGluY3JlYXNlIGlmIGFwaSBpcyBzbG93XG4gICAgcGluZ0ludGVydmFsOiA0NWUzICAgICAgIC8vIGluIG1pbGxpc2Vjb25kcywga2VlcHMgd2Vic3RyZWFtIChjb25uZWN0aW9uKSBhbGl2ZSB3aGVuIHBhdXNpbmdcbiAgfSxcblxuICBjYWxsYmFja3M6IHtcbiAgICAvLyBhIGN1c3RvbSBjYWxsYmFjayB0byB0d2VhayBmb3JtIGRhdGEgYmVmb3JlIHBvc3RpbmcgdG8gc2VydmVyXG4gICAgLy8gdGhpcyBpcyBmb3IgYWR2YW5jZWQgdXNlIG9ubHkgYW5kIHNob3VsZG4ndCBiZSB1c2VkIGlmIHBvc3NpYmxlXG4gICAgYWRqdXN0Rm9ybURhdGFCZWZvcmVQb3N0aW5nOiBudWxsXG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBmcm9tOiBudWxsLCAgICAgICAvLyBkZWZpbmUgZGVmYXVsdCBGUk9NIGVtYWlsIGFkZHJlc3NcbiAgICB0bzogbnVsbCwgICAgICAgICAvLyBkZWZpbmUgZGVmYXVsdCBUTyBlbWFpbCBhZGRyZXNzXG4gICAgc3ViamVjdDogbnVsbCwgICAgLy8gZGVmaW5lIGRlZmF1bHQgc3ViamVjdCBsaW5lXG4gICAgYm9keTogbnVsbCAgICAgICAgLy8gZGVmaW5lIGRlZmF1bHQgYm9keSBjb250ZW50XG4gIH0sXG5cbiAgLy8gc2hvdyBlcnJvcnMgaW5zaWRlIHRoZSBjb250YWluZXI/XG4gIGRpc3BsYXlFcnJvcnM6IHRydWUsXG5cbiAgLy8gdHJ1ZSA9IGFsbCBmb3JtIGlucHV0cyBnZXQgZGlzYWJsZWQgYW5kIGRpc2FwcGVhciB3aGVuIGJyb3dzZXIgY2FuJ3QgcmVjb3JkXG4gIGFkanVzdEZvcm1PbkJyb3dzZXJFcnJvcjogZmFsc2UsXG5cbiAgLy8gd2hlbiB0cnVlLCBhbnkgZXJyb3JzIHdpbGwgYmUgc2VudCB0byB0aGUgdmlkZW9tYWlsIHNlcnZlciBmb3IgYW5hbHlzaXNcbiAgLy8gcHM6IGNhbiBiZSBhIGZ1bmN0aW9uIHRvbyByZXR1cm5pbmcgYSBib29sZWFuXG4gIHJlcG9ydEVycm9yczogZmFsc2UsXG5cbiAgLy8ganVzdCBmb3IgdGVzdGluZyBwdXJwb3NlcyB0byBzaW11bGF0ZSBicm93c2VyIGFnZW50IGhhbmRsaW5nXG4gIGZha2VVYVN0cmluZzogbnVsbCxcblxuICAvLyB0b2RvIHBhc3Mgb24gdmVyc2lvbiB0byBzZXJ2ZXJcbiAgdmVyc2lvbjogdmVyc2lvblxufVxuIiwiaW1wb3J0IHN1cGVyYWdlbnQgZnJvbSAnc3VwZXJhZ2VudCdcbmltcG9ydCBDb25zdGFudHMgZnJvbSAnLi9jb25zdGFudHMnXG5cbmNvbnN0IENBQ0hFX0tFWSA9ICdhbGlhcydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgY29uc3QgY2FjaGUgPSB7fVxuXG4gIGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFZhbHVlICh2aWRlb21haWwsIG5hbWUpIHtcbiAgICBpZiAob3B0aW9ucy5kZWZhdWx0c1tuYW1lXSAmJiAhdmlkZW9tYWlsW25hbWVdKSB7XG4gICAgICB2aWRlb21haWxbbmFtZV0gPSBvcHRpb25zLmRlZmF1bHRzW25hbWVdXG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZGVvbWFpbFxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlEZWZhdWx0VmFsdWVzICh2aWRlb21haWwpIHtcbiAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgdmlkZW9tYWlsID0gYXBwbHlEZWZhdWx0VmFsdWUodmlkZW9tYWlsLCAnZnJvbScpXG4gICAgICB2aWRlb21haWwgPSBhcHBseURlZmF1bHRWYWx1ZSh2aWRlb21haWwsICd0bycpXG4gICAgICB2aWRlb21haWwgPSBhcHBseURlZmF1bHRWYWx1ZSh2aWRlb21haWwsICdzdWJqZWN0JylcbiAgICAgIHZpZGVvbWFpbCA9IGFwcGx5RGVmYXVsdFZhbHVlKHZpZGVvbWFpbCwgJ2JvZHknKVxuICAgIH1cblxuICAgIHJldHVybiB2aWRlb21haWxcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhY2tFcnJvciAoZXJyLCByZXMpIHtcbiAgICBpZiAocmVzICYmIHJlcy5ib2R5ICYmIHJlcy5ib2R5LmVycm9yKSB7XG4gICAgICAvLyB1c2UgdGhlIHNlcnZlciBnZW5lcmF0ZWQgdGV4dCBpbnN0ZWFkIG9mIHRoZSBzdXBlcmFnZW50J3MgZGVmYXVsdCB0ZXh0XG4gICAgICBlcnIgPSByZXMuYm9keS5lcnJvclxuXG4gICAgICBpZiAoIWVyci5tZXNzYWdlICYmIHJlcy50ZXh0KSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gcmVzLnRleHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXJyXG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaCAoYWxpYXMsIGNiKSB7XG4gICAgc3VwZXJhZ2VudFxuICAgICAgLmdldCgnL3ZpZGVvbWFpbC8nICsgYWxpYXMgKyAnL3NuYXBzaG90JylcbiAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAgICAgIC5zZXQoQ29uc3RhbnRzLlNJVEVfTkFNRV9MQUJFTCwgb3B0aW9ucy5zaXRlTmFtZSlcbiAgICAgIC50aW1lb3V0KG9wdGlvbnMudGltZW91dHMuY29ubmVjdGlvbilcbiAgICAgIC5lbmQoZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgIGVyciA9IHBhY2tFcnJvcihlcnIsIHJlcylcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2IoZXJyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHZpZGVvbWFpbCA9IHJlcy5ib2R5XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5jYWNoZSkge1xuICAgICAgICAgICAgY2FjaGVbQ0FDSEVfS0VZXSA9IHZpZGVvbWFpbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNiKG51bGwsIHZpZGVvbWFpbClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlIChtZXRob2QsIHZpZGVvbWFpbCwgaWRlbnRpZmllciwgY2IpIHtcbiAgICBpZiAoIWNiKSB7XG4gICAgICBjYiA9IGlkZW50aWZpZXJcbiAgICAgIGlkZW50aWZpZXIgPSBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSB7fVxuXG4gICAgdmFyIHVybCA9IG9wdGlvbnMuYmFzZVVybCArICcvdmlkZW9tYWlsLydcbiAgICB2YXIgcmVxdWVzdFxuXG4gICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgIHVybCArPSBpZGVudGlmaWVyXG4gICAgfVxuXG4gICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQobWV0aG9kLCB1cmwpXG5cbiAgICBxdWVyeVBhcmFtc1tDb25zdGFudHMuU0lURV9OQU1FX0xBQkVMXSA9IG9wdGlvbnMuc2l0ZU5hbWVcblxuICAgIHJlcXVlc3RcbiAgICAgIC5xdWVyeShxdWVyeVBhcmFtcylcbiAgICAgIC5zZW5kKHZpZGVvbWFpbClcbiAgICAgIC50aW1lb3V0KG9wdGlvbnMudGltZW91dClcbiAgICAgIC5lbmQoZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgIGVyciA9IHBhY2tFcnJvcihlcnIsIHJlcylcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2IoZXJyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvcHRpb25zLmNhY2hlICYmIHZpZGVvbWFpbFtDQUNIRV9LRVldKSB7XG4gICAgICAgICAgICBjYWNoZVt2aWRlb21haWxbQ0FDSEVfS0VZXV0gPSByZXMuYm9keS52aWRlb21haWxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYihudWxsLCByZXMuYm9keS52aWRlb21haWwsIHJlcy5ib2R5KVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoYWxpYXMsIGNiKSB7XG4gICAgaWYgKG9wdGlvbnMuY2FjaGUgJiYgY2FjaGVbYWxpYXNdKSB7XG4gICAgICAvLyBrZWVwIGFsbCBjYWxsYmFja3MgYXN5bmNcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjYihudWxsLCBjYWNoZVthbGlhc10pXG4gICAgICB9LCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICBmZXRjaChhbGlhcywgY2IpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSB7fVxuICAgIGNvbnN0IHVybCA9IG9wdGlvbnMuYmFzZVVybCArICcvY2xpZW50LWVycm9yLydcbiAgICBjb25zdCByZXF1ZXN0ID0gc3VwZXJhZ2VudCgncG9zdCcsIHVybClcblxuICAgIHF1ZXJ5UGFyYW1zW0NvbnN0YW50cy5TSVRFX05BTUVfTEFCRUxdID0gb3B0aW9ucy5zaXRlTmFtZVxuXG4gICAgcmVxdWVzdFxuICAgICAgLnF1ZXJ5KHF1ZXJ5UGFyYW1zKVxuICAgICAgLnNlbmQoZXJyKVxuICAgICAgLnRpbWVvdXQob3B0aW9ucy50aW1lb3V0KVxuICAgICAgLmVuZChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgZXJyID0gcGFja0Vycm9yKGVyciwgcmVzKVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2IgJiYgY2IoZXJyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiICYmIGNiKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIHRoaXMucG9zdCA9IGZ1bmN0aW9uICh2aWRlb21haWwsIGNiKSB7XG4gICAgdmlkZW9tYWlsID0gYXBwbHlEZWZhdWx0VmFsdWVzKHZpZGVvbWFpbClcblxuICAgIGlmIChvcHRpb25zLmNhbGxiYWNrcy5hZGp1c3RGb3JtRGF0YUJlZm9yZVBvc3RpbmcpIHtcbiAgICAgIG9wdGlvbnMuY2FsbGJhY2tzLmFkanVzdEZvcm1EYXRhQmVmb3JlUG9zdGluZyhcbiAgICAgICAgdmlkZW9tYWlsLFxuICAgICAgICBmdW5jdGlvbiAoZXJyLCBhZGp1c3RlZFZpZGVvbWFpbCkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JpdGUoJ3Bvc3QnLCBhZGp1c3RlZFZpZGVvbWFpbCwgY2IpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHdyaXRlKCdwb3N0JywgdmlkZW9tYWlsLCBjYilcbiAgICB9XG4gIH1cblxuICB0aGlzLnB1dCA9IGZ1bmN0aW9uICh2aWRlb21haWwsIGNiKSB7XG4gICAgd3JpdGUoJ3B1dCcsIHZpZGVvbWFpbCwgdmlkZW9tYWlsLmtleSwgY2IpXG4gIH1cblxuICB0aGlzLmZvcm0gPSBmdW5jdGlvbiAoZm9ybURhdGEsIHVybCwgY2IpIHtcbiAgICB2YXIgZm9ybVR5cGVcblxuICAgIHN3aXRjaCAob3B0aW9ucy5lbmN0eXBlKSB7XG4gICAgICBjYXNlIENvbnN0YW50cy5wdWJsaWMuRU5DX1RZUEVfQVBQX0pTT046XG4gICAgICAgIGZvcm1UeXBlID0gJ2pzb24nXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIENvbnN0YW50cy5wdWJsaWMuRU5DX1RZUEVfRk9STTpcbiAgICAgICAgZm9ybVR5cGUgPSAnZm9ybSdcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGtlZXAgYWxsIGNhbGxiYWNrcyBhc3luY1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjYihuZXcgRXJyb3IoJ0ludmFsaWQgZW5jdHlwZSBnaXZlbjogJyArIG9wdGlvbnMuZW5jdHlwZSkpXG4gICAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgaWYgKGZvcm1UeXBlKSB7XG4gICAgICBzdXBlcmFnZW50XG4gICAgICAgIC5wb3N0KHVybClcbiAgICAgICAgLnR5cGUoZm9ybVR5cGUpXG4gICAgICAgIC5zZW5kKGZvcm1EYXRhKVxuICAgICAgICAudGltZW91dChvcHRpb25zLnRpbWVvdXQpXG4gICAgICAgIC5lbmQoZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgZXJyID0gcGFja0Vycm9yKGVyciwgcmVzKVxuXG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2IoZXJyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYihudWxsLCByZXMpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9J0Atd2Via2l0LWtleWZyYW1lcyBhezAle29wYWNpdHk6Ljl9MzUle29wYWNpdHk6Ljl9NTAle29wYWNpdHk6LjF9ODUle29wYWNpdHk6LjF9dG97b3BhY2l0eTouOX19QGtleWZyYW1lcyBhezAle29wYWNpdHk6Ljl9MzUle29wYWNpdHk6Ljl9NTAle29wYWNpdHk6LjF9ODUle29wYWNpdHk6LjF9dG97b3BhY2l0eTouOX19LklJVjo6LXdlYmtpdC1tZWRpYS1jb250cm9scy1wbGF5LWJ1dHRvbiwuSUlWOjotd2Via2l0LW1lZGlhLWNvbnRyb2xzLXN0YXJ0LXBsYXliYWNrLWJ1dHRvbntvcGFjaXR5OjA7cG9pbnRlci1ldmVudHM6bm9uZTt3aWR0aDo1cHh9LnZpZGVvbWFpbCAudmlzdWFsc3twb3NpdGlvbjpyZWxhdGl2ZX0udmlkZW9tYWlsIC52aXN1YWxzIHZpZGVvLnJlcGxheXstby1vYmplY3QtZml0OnNjYWxlLWRvd247b2JqZWN0LWZpdDpzY2FsZS1kb3dufS52aWRlb21haWwgLnJlcGxheSwudmlkZW9tYWlsIC51c2VyTWVkaWF7d2lkdGg6MTAwJSFpbXBvcnRhbnR9LnZpZGVvbWFpbCAuY291bnRkb3duLC52aWRlb21haWwgLnBhdXNlZEhlYWRlciwudmlkZW9tYWlsIC5wYXVzZWRIaW50LC52aWRlb21haWwgLnJlY29yZE5vdGUsLnZpZGVvbWFpbCAucmVjb3JkVGltZXJ7bWFyZ2luOjA7aGVpZ2h0OmF1dG99LnZpZGVvbWFpbCAuY291bnRkb3duLC52aWRlb21haWwgLnBhdXNlZCwudmlkZW9tYWlsIC5yZWNvcmROb3RlLC52aWRlb21haWwgLnJlY29yZFRpbWVyLC52aWRlb21haWwgbm9zY3JpcHR7cG9zaXRpb246YWJzb2x1dGV9LnZpZGVvbWFpbCAuY291bnRkb3duLC52aWRlb21haWwgLnBhdXNlZEhlYWRlciwudmlkZW9tYWlsIC5wYXVzZWRIaW50LC52aWRlb21haWwgLnJlY29yZE5vdGUsLnZpZGVvbWFpbCAucmVjb3JkVGltZXIsLnZpZGVvbWFpbCBub3NjcmlwdHtmb250LXdlaWdodDo3MDB9LnZpZGVvbWFpbCAuY291bnRkb3duLC52aWRlb21haWwgLnBhdXNlZCwudmlkZW9tYWlsIG5vc2NyaXB0e3dpZHRoOjEwMCU7dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfS52aWRlb21haWwgLmNvdW50ZG93biwudmlkZW9tYWlsIC5wYXVzZWRIZWFkZXIsLnZpZGVvbWFpbCAucGF1c2VkSGludHt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LXNoYWRvdzowIDAgMnB4ICNmZmZ9LnZpZGVvbWFpbCAuY291bnRkb3duLC52aWRlb21haWwgLnBhdXNlZEhlYWRlcntvcGFjaXR5Oi44NTtmb250LXNpemU6NDQwJX0udmlkZW9tYWlsIC5wYXVzZWRIaW50e2ZvbnQtc2l6ZToxNTAlfS52aWRlb21haWwgLnJlY29yZE5vdGUsLnZpZGVvbWFpbCAucmVjb3JkVGltZXJ7cmlnaHQ6LjdlbTtiYWNrZ3JvdW5kOmhzbGEoMCwwJSw0JSwuOCk7cGFkZGluZzouNGVtIC40ZW0gLjNlbTt0cmFuc2l0aW9uOmFsbCAxcyBlYXNlO2NvbG9yOiMwMGQ4MTQ7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO29wYWNpdHk6Ljl9LnZpZGVvbWFpbCAucmVjb3JkTm90ZS5uZWFyLC52aWRlb21haWwgLnJlY29yZFRpbWVyLm5lYXJ7Y29sb3I6I2ViOTM2OX0udmlkZW9tYWlsIC5yZWNvcmROb3RlLm5pZ2gsLnZpZGVvbWFpbCAucmVjb3JkVGltZXIubmlnaHtjb2xvcjojZWE0YjJhfS52aWRlb21haWwgLnJlY29yZFRpbWVye3RvcDouN2VtfS52aWRlb21haWwgLnJlY29yZE5vdGV7dG9wOjMuNmVtfS52aWRlb21haWwgLnJlY29yZE5vdGU6YmVmb3Jle2NvbnRlbnQ6XCJSRUNcIjstd2Via2l0LWFuaW1hdGlvbjphIDFzIGluZmluaXRlO2FuaW1hdGlvbjphIDFzIGluZmluaXRlfS52aWRlb21haWwgLm5vdGlmaWVye292ZXJmbG93OmhpZGRlbjtib3gtc2l6aW5nOmJvcmRlci1ib3g7aGVpZ2h0OjEwMCV9LnZpZGVvbWFpbCAucmFkaW9Hcm91cHtkaXNwbGF5OmJsb2NrfS52aWRlb21haWwgdmlkZW97bWFyZ2luLWJvdHRvbTowfSciLCJpbXBvcnQgaXNQT1QgZnJvbSAnaXMtcG93ZXItb2YtdHdvJ1xuaW1wb3J0IEF1ZGlvU2FtcGxlIGZyb20gJ2F1ZGlvLXNhbXBsZSdcblxuaW1wb3J0IFZpZGVvbWFpbEVycm9yIGZyb20gJy4vdmlkZW9tYWlsRXJyb3InXG5cbmNvbnN0IENIQU5ORUxTID0gMVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAodXNlck1lZGlhLCBvcHRpb25zKSB7XG4gIHZhciBzY3JpcHRQcm9jZXNzb3JcblxuICBmdW5jdGlvbiBnZXRBdWRpb0NvbnRleHQgKCkge1xuICAgIC8vIGluc3RhbnRpYXRlIG9ubHkgb25jZVxuICAgIGlmICghd2luZG93LnZjQXVkaW9Db250ZXh0KSB7XG4gICAgICBjb25zdCBBdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHRcbiAgICAgIHdpbmRvdy52Y0F1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKVxuICAgIH1cblxuICAgIHJldHVybiB3aW5kb3cudmNBdWRpb0NvbnRleHRcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQXVkaW9Qcm9jZXNzIChlLCBjYikge1xuICAgIGlmICghdXNlck1lZGlhLmlzUmVjb3JkaW5nKCkgfHwgdXNlck1lZGlhLmlzUGF1c2VkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBGbG9hdDMyQXJyYXkgY29udGFpbmluZyB0aGUgUENNIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGFubmVsLFxuICAgIC8vIGRlZmluZWQgYnkgdGhlIGNoYW5uZWwgcGFyYW1ldGVyICh3aXRoIDAgcmVwcmVzZW50aW5nIHRoZSBmaXJzdCBjaGFubmVsKVxuICAgIGNvbnN0IGZsb2F0MzJBcnJheSA9IGUuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMClcblxuICAgIGNiKG5ldyBBdWRpb1NhbXBsZShmbG9hdDMyQXJyYXkpKVxuICB9XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKGxvY2FsTWVkaWFTdHJlYW0pIHtcbiAgICBvcHRpb25zLmRlYnVnKCdBdWRpb1JlY29yZGVyOiBpbml0KCknKVxuXG4gICAgLy8gY3JlYXRlcyBhbiBhdWRpbyBub2RlIGZyb20gdGhlIG1pY3JvcGhvbmUgaW5jb21pbmcgc3RyZWFtXG4gICAgY29uc3Qgdm9sdW1lID0gZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlR2FpbigpXG5cbiAgICB2YXIgYXVkaW9JbnB1dFxuXG4gICAgdHJ5IHtcbiAgICAgIGF1ZGlvSW5wdXQgPSBnZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShsb2NhbE1lZGlhU3RyZWFtKVxuICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgICAnV2ViY2FtIGhhcyBubyBhdWRpbycsXG4gICAgICAgIGV4Yy50b1N0cmluZygpLFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKCFpc1BPVChvcHRpb25zLmF1ZGlvLmJ1ZmZlclNpemUpKSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ0F1ZGlvIGJ1ZmZlciBzaXplIG11c3QgYmUgYSBwb3dlciBvZiB0d28uJywgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLmF1ZGlvLnZvbHVtZSB8fCBvcHRpb25zLmF1ZGlvLnZvbHVtZSA+IDEpIHtcbiAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnQXVkaW8gdm9sdW1lIG11c3QgYmUgYmV0d2VlbiB6ZXJvIGFuZCBvbmUuJywgb3B0aW9ucylcbiAgICB9XG5cbiAgICB2b2x1bWUuZ2Fpbi52YWx1ZSA9IG9wdGlvbnMuYXVkaW8udm9sdW1lXG5cbiAgICAvLyBDcmVhdGUgYSBTY3JpcHRQcm9jZXNzb3JOb2RlIHdpdGggdGhlIGdpdmVuIGJ1ZmZlclNpemUgYW5kXG4gICAgLy8gYSBzaW5nbGUgaW5wdXQgYW5kIG91dHB1dCBjaGFubmVsXG4gICAgc2NyaXB0UHJvY2Vzc29yID0gZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKFxuICAgICAgb3B0aW9ucy5hdWRpby5idWZmZXJTaXplLFxuICAgICAgQ0hBTk5FTFMsXG4gICAgICBDSEFOTkVMU1xuICAgIClcblxuICAgIC8vIGNvbm5lY3Qgc3RyZWFtIHRvIG91ciBzY3JpcHRQcm9jZXNzb3JcbiAgICBhdWRpb0lucHV0LmNvbm5lY3Qoc2NyaXB0UHJvY2Vzc29yKVxuXG4gICAgLy8gY29ubmVjdCBvdXIgc2NyaXB0UHJvY2Vzc29yIHRvIHRoZSBwcmV2aW91cyBkZXN0aW5hdGlvblxuICAgIHNjcmlwdFByb2Nlc3Nvci5jb25uZWN0KGdldEF1ZGlvQ29udGV4dCgpLmRlc3RpbmF0aW9uKVxuXG4gICAgLy8gY29ubmVjdCB2b2x1bWVcbiAgICBhdWRpb0lucHV0LmNvbm5lY3Qodm9sdW1lKVxuICAgIHZvbHVtZS5jb25uZWN0KHNjcmlwdFByb2Nlc3NvcilcbiAgfVxuXG4gIHRoaXMucmVjb3JkID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgb3B0aW9ucy5kZWJ1ZygnQXVkaW9SZWNvcmRlcjogcmVjb3JkKCknKVxuXG4gICAgc2NyaXB0UHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIG9uQXVkaW9Qcm9jZXNzKGUsIGNiKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvcHRpb25zLmRlYnVnKCdBdWRpb1JlY29yZGVyOiBzdG9wKCknKVxuXG4gICAgaWYgKHNjcmlwdFByb2Nlc3Nvcikge1xuICAgICAgc2NyaXB0UHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvQ29udGV4dC9jbG9zZVxuICAgIGdldEF1ZGlvQ29udGV4dCgpLmNsb3NlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBvcHRpb25zLmRlYnVnKCdBdWRpb1JlY29yZGVyOiBhdWRpbyBjb250ZXh0IGlzIGNsb3NlZCcpXG4gICAgICBkZWxldGUgd2luZG93LnZjQXVkaW9Db250ZXh0XG4gICAgfSlcbiAgfVxuXG4gIHRoaXMuZ2V0U2FtcGxlUmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZ2V0QXVkaW9Db250ZXh0KCkpIHtcbiAgICAgIHJldHVybiBnZXRBdWRpb0NvbnRleHQoKS5zYW1wbGVSYXRlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IFVBUGFyc2VyIGZyb20gJ3VhLXBhcnNlci1qcydcbmltcG9ydCBkZWZpbmVkIGZyb20gJ2RlZmluZWQnXG5pbXBvcnQgVmlkZW9tYWlsRXJyb3IgZnJvbSAnLi92aWRlb21haWxFcnJvcidcblxuY29uc3QgQnJvd3NlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgY29uc3QgZmlyZWZveERvd25sb2FkID0gJ2h0dHA6Ly93d3cubW96aWxsYS5vcmcvZmlyZWZveC91cGRhdGUvJ1xuICBjb25zdCBlZGdlRG93bmxvYWQgPSAnaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS9lbi11cy9kb3dubG9hZC9kZXRhaWxzLmFzcHg/aWQ9NDgxMjYnXG4gIGNvbnN0IGNocm9tZURvd25sb2FkID0gJ2h0dHA6Ly93d3cuZ29vZ2xlLmNvbS9jaHJvbWUvJ1xuICBjb25zdCBjaHJvbWl1bURvd25sb2FkID0gJ2h0dHA6Ly93d3cuY2hyb21pdW0ub3JnL2dldHRpbmctaW52b2x2ZWQvZG93bmxvYWQtY2hyb21pdW0nXG4gIGNvbnN0IGJyb3dzZUhhcHB5TGluayA9ICdodHRwOi8vYnJvd3NlaGFwcHkuY29tJ1xuICBjb25zdCB1YSA9IGRlZmluZWQob3B0aW9ucy5mYWtlVWFTdHJpbmcsIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHdpbmRvdy5uYXZpZ2F0b3IgJiZcbiAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudFxuICApLCAnJylcblxuICBjb25zdCB1YVBhcnNlciA9IG5ldyBVQVBhcnNlcih1YSkuZ2V0UmVzdWx0KClcblxuICBjb25zdCBpc0lPUyA9IHVhUGFyc2VyLm9zLm5hbWUgPT09ICdpT1MnXG4gIGNvbnN0IGlzQ2hyb21lID0gdWFQYXJzZXIuYnJvd3Nlci5uYW1lID09PSAnQ2hyb21lJ1xuICBjb25zdCBpc0Nocm9taXVtID0gdWFQYXJzZXIuYnJvd3Nlci5uYW1lID09PSAnQ2hyb21pdW0nXG4gIGNvbnN0IGZpcmVmb3ggPSB1YVBhcnNlci5icm93c2VyLm5hbWUgPT09ICdGaXJlZm94J1xuICBjb25zdCBvc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHVhUGFyc2VyLm9zLnZlcnNpb24pXG4gIGNvbnN0IGlzV2luZG93cyA9IHVhUGFyc2VyLm9zLm5hbWUgPT09ICdXaW5kb3dzJ1xuICBjb25zdCBpc0VkZ2UgPSB1YVBhcnNlci5icm93c2VyLm5hbWUgPT09ICdFZGdlJyB8fCAoaXNXaW5kb3dzICYmIG9zVmVyc2lvbiA+PSAxMClcbiAgY29uc3QgaXNJRSA9IC9JRS8udGVzdCh1YVBhcnNlci5icm93c2VyLm5hbWUpXG4gIGNvbnN0IGlzU2FmYXJpID0gL1NhZmFyaS8udGVzdCh1YVBhcnNlci5icm93c2VyLm5hbWUpXG4gIGNvbnN0IGlzT3BlcmEgPSAvT3BlcmEvLnRlc3QodWFQYXJzZXIuYnJvd3Nlci5uYW1lKVxuICBjb25zdCBpc0FuZHJvaWQgPSAvQW5kcm9pZC8udGVzdCh1YVBhcnNlci5vcy5uYW1lKVxuICBjb25zdCBjaHJvbWVCYXNlZCA9IGlzQ2hyb21lIHx8IGlzQ2hyb21pdW1cbiAgY29uc3Qgb2tCcm93c2VyID0gY2hyb21lQmFzZWQgfHwgZmlyZWZveCB8fCBpc0FuZHJvaWQgfHwgaXNPcGVyYSB8fCBpc0VkZ2VcblxuICBjb25zdCBzZWxmID0gdGhpc1xuXG4gIHZhciB2aWRlb1R5cGVcblxuICBmdW5jdGlvbiBnZXRSZWNvbW1lbmRhdGlvbiAoKSB7XG4gICAgdmFyIHdhcm5pbmdcblxuICAgIGlmIChmaXJlZm94KSB7XG4gICAgICB3YXJuaW5nID0gJ1Byb2JhYmx5IHlvdSBuZWVkIHRvIDxhIGhyZWY9XCInICsgZmlyZWZveERvd25sb2FkICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICd1cGdyYWRlIEZpcmVmb3g8L2E+IHRvIGZpeCB0aGlzLidcbiAgICB9IGVsc2UgaWYgKGlzQ2hyb21lKSB7XG4gICAgICB3YXJuaW5nID0gJ1Byb2JhYmx5IHlvdSBuZWVkIHRvIDxhIGhyZWY9XCInICsgY2hyb21lRG93bmxvYWQgKyAnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgJ3VwZ3JhZGUgQ2hyb21lPC9hPiB0byBmaXggdGhpcy4nXG4gICAgfSBlbHNlIGlmIChpc0Nocm9taXVtKSB7XG4gICAgICB3YXJuaW5nID0gJzxhIGhyZWY9XCInICsgY2hyb21pdW1Eb3dubG9hZCArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAnVXBncmFkZSBDaHJvbWl1bTwvYT4gdG8gZml4IHRoaXMuJ1xuICAgIH0gZWxzZSBpZiAoaXNJRSkge1xuICAgICAgd2FybmluZyA9ICdJbnN0ZWFkIG9mIEludGVybmV0IEV4cGxvcmVyIGJldHRlciBwaWNrJyArXG4gICAgICAgICAgICAgICAgICAgICAgJyA8YSBocmVmPVwiJyArIGNocm9tZURvd25sb2FkICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiPkNocm9tZTwvYT4sJyArXG4gICAgICAgICAgICAgICAgICAgICAgJyA8YSBocmVmPVwiJyArIGZpcmVmb3hEb3dubG9hZCArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj5GaXJlZm94PC9hPiwnICtcbiAgICAgICAgICAgICAgICAgICAgICAnIDxhIGhyZWY9XCInICsgZWRnZURvd25sb2FkICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiPkVkZ2U8L2E+IG9yIEFuZHJvaWQuJ1xuICAgIH0gZWxzZSBpZiAoaXNTYWZhcmkpIHtcbiAgICAgIHdhcm5pbmcgPSAnU2FmYXJpIGhhcyBubyB3ZWJjYW0gc3VwcG9ydCB5ZXQuPGJyLz5CZXR0ZXIgcGljaycgK1xuICAgICAgICAgICAgICAgICAgICAgICcgPGEgaHJlZj1cIicgKyBjaHJvbWVEb3dubG9hZCArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj5DaHJvbWU8L2E+LCcgK1xuICAgICAgICAgICAgICAgICAgICAgICcgPGEgaHJlZj1cIicgKyBmaXJlZm94RG93bmxvYWQgKyAnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+RmlyZWZveDwvYT4gb3IgQW5kcm9pZC4nXG4gICAgfVxuXG4gICAgcmV0dXJuIHdhcm5pbmdcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVzZXJNZWRpYVdhcm5pbmcgKCkge1xuICAgIHZhciB3YXJuaW5nXG5cbiAgICBpZiAoaXNJT1MpIHtcbiAgICAgIHdhcm5pbmcgPSAnT24gaVBhZHMvaVBob25lcyB0aGlzIHdlYmNhbSBmZWF0dXJlIGlzIG1pc3NpbmcuPGJyLz48YnIvPicgK1xuICAgICAgICAgICAgICAgICdGb3Igbm93LCB3ZSByZWNvbW1lbmQgeW91IHRvIHVzZSBhIGRlc2t0b3AgY29tcHV0ZXIgb3IgYW4gQW5kcm9pZCBkZXZpY2UuJ1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nID0gZ2V0UmVjb21tZW5kYXRpb24oKVxuICAgIH1cblxuICAgIGlmICghd2FybmluZykge1xuICAgICAgaWYgKHNlbGYuaXNDaHJvbWVCYXNlZCgpIHx8IHNlbGYuaXNGaXJlZm94KCkpIHtcbiAgICAgICAgd2FybmluZyA9ICdGb3IgdGhlIHdlYmNhbSBmZWF0dXJlLCB5b3VyIGJyb3dzZXIgbmVlZHMgYW4gdXBncmFkZS4nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nID0gJ0hlbmNlIHdlIHJlY29tbWVuZCB5b3UgdG8gdXNlIGVpdGhlciAnICtcbiAgICAgICAgICAgICAgICAgICc8YSBocmVmPVwiJyArIGNocm9tZURvd25sb2FkICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiPkNocm9tZTwvYT4sICcgK1xuICAgICAgICAgICAgICAgICAgJzxhIGhyZWY9XCInICsgZmlyZWZveERvd25sb2FkICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiPkZpcmVmb3g8L2E+LCAnICtcbiAgICAgICAgICAgICAgICAgICc8YSBocmVmPVwiJyArIGVkZ2VEb3dubG9hZCArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj5FZGdlPC9hPiBvciBBbmRyb2lkLidcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd2FybmluZ1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGxheWJhY2tXYXJuaW5nICgpIHtcbiAgICB2YXIgd2FybmluZyA9IGdldFJlY29tbWVuZGF0aW9uKClcblxuICAgIGlmICghd2FybmluZykge1xuICAgICAgd2FybmluZyA9ICc8YSBocmVmPVwiJyArIGJyb3dzZUhhcHB5TGluayArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj5VcGdyYWRpbmcgeW91ciBicm93c2VyPC9hPiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaWdodCBoZWxwLidcbiAgICB9XG5cbiAgICByZXR1cm4gd2FybmluZ1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuUGxheVR5cGUgKHZpZGVvLCB0eXBlKSB7XG4gICAgdmFyIGNhblBsYXlUeXBlXG5cbiAgICBpZiAodmlkZW8gJiYgdmlkZW8uY2FuUGxheVR5cGUpIHtcbiAgICAgIGNhblBsYXlUeXBlID0gdmlkZW8uY2FuUGxheVR5cGUoJ3ZpZGVvLycgKyB0eXBlKVxuICAgIH1cblxuICAgIHJldHVybiBjYW5QbGF5VHlwZVxuICB9XG5cbiAgICAvLyBqdXN0IHRlbXBvcmFyeVxuICB0aGlzLmNhblJlY29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBoYXNOYXZpZ2F0b3IgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICAgIHZhciBjYW5SZWNvcmQgPSBmYWxzZVxuXG4gICAgaWYgKGhhc05hdmlnYXRvciAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgICBjYW5SZWNvcmQgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBnZXRVc2VyTWVkaWFUeXBlID0gaGFzTmF2aWdhdG9yICYmIHR5cGVvZiBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhX1xuXG4gICAgICBjYW5SZWNvcmQgPSBnZXRVc2VyTWVkaWFUeXBlID09PSAnZnVuY3Rpb24nXG4gICAgfVxuXG4gICAgcmV0dXJuIGNhblJlY29yZFxuICB9XG5cbiAgdGhpcy5jaGVja1JlY29yZGluZ0NhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXJyXG5cbiAgICBpZiAoIW9rQnJvd3NlciB8fCAhdGhpcy5jYW5SZWNvcmQoKSkge1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gW11cblxuICAgICAgaWYgKGlzSU9TKSB7XG4gICAgICAgIGNsYXNzTGlzdC5wdXNoKFZpZGVvbWFpbEVycm9yLklPU19QUk9CTEVNKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3NMaXN0LnB1c2goVmlkZW9tYWlsRXJyb3IuQlJPV1NFUl9QUk9CTEVNKVxuICAgICAgfVxuXG4gICAgICBlcnIgPSBWaWRlb21haWxFcnJvci5jcmVhdGUoe1xuICAgICAgICBtZXNzYWdlOiAnU29ycnksIHlvdXIgYnJvd3NlciBpcyB1bmFibGUgdG8gdXNlIHdlYmNhbXMnXG4gICAgICB9LCBnZXRVc2VyTWVkaWFXYXJuaW5nKCksIG9wdGlvbnMsIHtcbiAgICAgICAgY2xhc3NMaXN0OiBjbGFzc0xpc3RcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGVyclxuICB9XG5cbiAgdGhpcy5jaGVja1BsYXliYWNrQ2FwYWJpbGl0aWVzID0gZnVuY3Rpb24gKHZpZGVvKSB7XG4gICAgb3B0aW9ucy5kZWJ1ZygnQnJvd3NlcjogY2hlY2tQbGF5YmFja0NhcGFiaWxpdGllcygpJylcblxuICAgIHZhciBlcnJcbiAgICB2YXIgbWVzc2FnZVxuXG4gICAgaWYgKCF2aWRlbykge1xuICAgICAgbWVzc2FnZSA9ICdObyBIVE1MNSBzdXBwb3J0IGZvciB2aWRlbyB0YWchJ1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZ2V0VmlkZW9UeXBlKHZpZGVvKSkge1xuICAgICAgbWVzc2FnZSA9ICdZb3VyIG9sZCBicm93c2VyIGNhbm5vdCBzdXBwb3J0IG1vZGVybiB2aWRlbyBjb2RlY3MnXG4gICAgfSBlbHNlIGlmICghdmlkZW8uc2V0QXR0cmlidXRlKSB7XG4gICAgICAvLyBmaXhlcyBcIk5vdCBpbXBsZW1lbnRlZFwiIGVycm9yIG9uIG9sZGVyIGJyb3dzZXJzXG4gICAgICBtZXNzYWdlID0gJ1VuYWJsZSB0byBzZXQgdmlkZW8gYXR0cmlidXRlcyBpbiB5b3VyIG9sZCBicm93c2VyJ1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICBlcnIgPSBWaWRlb21haWxFcnJvci5jcmVhdGUobWVzc2FnZSwgZ2V0UGxheWJhY2tXYXJuaW5nKCksIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVyclxuICB9XG5cbiAgdGhpcy5jaGVja0J1ZmZlclR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlcnJcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93LmF0b2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnIgPSBWaWRlb21haWxFcnJvci5jcmVhdGUoJ2F0b2IgaXMgbm90IHN1cHBvcnRlZCcsIG9wdGlvbnMpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93LkFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZXJyID0gVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdBcnJheUJ1ZmZlcnMgYXJlIG5vdCBzdXBwb3J0ZWQnLCBvcHRpb25zKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5VaW50OEFycmF5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZXJyID0gVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdVaW50OEFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCcsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVyclxuICB9XG5cbiAgdGhpcy5nZXRWaWRlb1R5cGUgPSBmdW5jdGlvbiAodmlkZW8pIHtcbiAgICBpZiAoIXZpZGVvVHlwZSkge1xuICAgICAgLy8gdGhlcmUgaXMgYSBidWcgaW4gY2FuUGxheVR5cGUgd2l0aGluIGNocm9tZSBmb3IgbXA0XG4gICAgICBpZiAoY2FuUGxheVR5cGUodmlkZW8sICdtcDQnKSAmJiAhY2hyb21lQmFzZWQpIHtcbiAgICAgICAgdmlkZW9UeXBlID0gJ21wNCdcbiAgICAgIH0gZWxzZSBpZiAoY2FuUGxheVR5cGUodmlkZW8sICd3ZWJtJykpIHtcbiAgICAgICAgdmlkZW9UeXBlID0gJ3dlYm0nXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZGVvVHlwZVxuICB9XG5cbiAgdGhpcy5nZXROb0FjY2Vzc0lzc3VlID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAnVW5hYmxlIHRvIGFjY2VzcyB3ZWJjYW0nXG4gICAgdmFyIGV4cGxhbmF0aW9uXG5cbiAgICBpZiAodGhpcy5pc0Nocm9tZUJhc2VkKCkpIHtcbiAgICAgIGV4cGxhbmF0aW9uID0gJ0NsaWNrIG9uIHRoZSBhbGxvdyBidXR0b24gdG8gZ3JhbnQgYWNjZXNzIHRvIHlvdXIgd2ViY2FtLidcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNGaXJlZm94KCkpIHtcbiAgICAgIGV4cGxhbmF0aW9uID0gJ1BsZWFzZSBncmFudCBGaXJlZm94IGFjY2VzcyB0byB5b3VyIHdlYmNhbS4nXG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGxhbmF0aW9uID0gJ1lvdXIgc3lzdGVtIGRvZXMgbm90IGxldCB5b3VyIGJyb3dzZXIgYWNjZXNzIHlvdXIgd2ViY2FtLidcbiAgICB9XG5cbiAgICByZXR1cm4gVmlkZW9tYWlsRXJyb3IuY3JlYXRlKG1lc3NhZ2UsIGV4cGxhbmF0aW9uLCBvcHRpb25zKVxuICB9XG5cbiAgdGhpcy5pc0Nocm9tZUJhc2VkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaHJvbWVCYXNlZFxuICB9XG5cbiAgdGhpcy5pc0ZpcmVmb3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZpcmVmb3hcbiAgfVxuXG4gIHRoaXMuaXNFZGdlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc0VkZ2VcbiAgfVxuXG4gIHRoaXMuaXNNb2JpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVhUGFyc2VyLmRldmljZS50eXBlID09PSAnbW9iaWxlJ1xuICB9XG5cbiAgdGhpcy5nZXRVc2VmdWxEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBicm93c2VyOiB1YVBhcnNlci5icm93c2VyLFxuICAgICAgZGV2aWNlOiB1YVBhcnNlci5kZXZpY2UsXG4gICAgICBvczogdWFQYXJzZXIub3MsXG4gICAgICBlbmdpbmU6IHVhUGFyc2VyLmVuZ2luZSxcbiAgICAgIHVzZXJBZ2VudDogdWFcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnJvd3NlclxuXG4vLyBzbyB0aGF0IHdlIGFsc28gY2FuIHJlcXVpcmUoKSBpdCBmcm9tIHZpZGVvbWFpbEVycm9yLmpzIHdpdGhpblxubW9kdWxlLmV4cG9ydHMgPSBCcm93c2VyXG4iLCJpbXBvcnQgdXRpbCBmcm9tICd1dGlsJ1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi9icm93c2VyJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAobG9jYWxPcHRpb25zID0ge30pIHtcbiAgY29uc3QgYnJvd3NlciA9IG5ldyBCcm93c2VyKGxvY2FsT3B0aW9ucylcbiAgY29uc3QgbG9nZ2VyID0gbG9jYWxPcHRpb25zLmxvZ2dlciB8fCBjb25zb2xlXG4gIGNvbnN0IGNvbnRhaW5lcklkID0gKGxvY2FsT3B0aW9ucy5zZWxlY3RvcnMgJiYgbG9jYWxPcHRpb25zLnNlbGVjdG9ycy5jb250YWluZXJJZCkgfHwgJ3VuZGVmaW5lZCBjb250YWluZXIgaWQnXG4gIGNvbnN0IHN0YWNrID0gW11cblxuICBmdW5jdGlvbiBsaWZvIChsZXZlbCwgcGFyYW1ldGVycykge1xuICAgIGNvbnN0IGxpbmUgPSB1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBwYXJhbWV0ZXJzKVxuXG4gICAgaWYgKHN0YWNrLmxlbmd0aCA+IGxvY2FsT3B0aW9ucy5sb2dTdGFja1NpemUpIHtcbiAgICAgIHN0YWNrLnBvcCgpXG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCgnWycgKyBsZXZlbCArICddICcgKyBsaW5lKVxuXG4gICAgcmV0dXJuIGxpbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENvbnRhaW5lcklkIChmaXJzdEFyZ3VtZW50KSB7XG4gICAgcmV0dXJuICcjJyArIGNvbnRhaW5lcklkICsgJyBbJyArIG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCkgKyAnXSA+ICcgKyBmaXJzdEFyZ3VtZW50XG4gIH1cblxuICAvLyB3b3JrYXJvdW5kOiBzaW5jZSB3ZSBjYW5ub3Qgb3ZlcndyaXRlIGNvbnNvbGUubG9nIHdpdGhvdXQgaGF2aW5nIHRoZSBjb3JyZWN0IGZpbGUgYW5kIGxpbmUgbnVtYmVyXG4gIC8vIHdlJ2xsIHVzZSBncm91cENvbGxhcHNlZCgpIGFuZCB0cmFjZSgpIGluc3RlYWQgdG8gZ2V0IHRoZXNlLlxuICB0aGlzLmRlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGFsd2F5cyBhZGQgaXQgZm9yIGJldHRlciBjbGllbnQgZXJyb3IgcmVwb3J0c1xuICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcbiAgICBhcmdzWzBdID0gYWRkQ29udGFpbmVySWQoYXJnc1swXSlcblxuICAgIGNvbnN0IG91dHB1dCA9IGxpZm8oJ2RlYnVnJywgYXJncylcblxuICAgIGlmIChsb2NhbE9wdGlvbnMudmVyYm9zZSkge1xuICAgICAgaWYgKGJyb3dzZXIuaXNGaXJlZm94KCkpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKG91dHB1dClcbiAgICAgIH0gZWxzZSBpZiAobG9nZ2VyLmdyb3VwQ29sbGFwc2VkKSB7XG4gICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChvdXRwdXQpXG4gICAgICAgIGxvZ2dlci50cmFjZSgnVHJhY2UnKVxuICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKVxuICAgICAgfSBlbHNlIGlmIChsb2dnZXIuZGVidWcpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKG91dHB1dClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxhc3QgcmVzb3J0IGlmIGV2ZXJ5dGhpbmcgZWxzZSBmYWlscyBmb3IgYW55IHdlaXJkIHJlYXNvbnNcbiAgICAgICAgY29uc29sZS5sb2cob3V0cHV0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuICAgIGFyZ3NbMF0gPSBhZGRDb250YWluZXJJZChhcmdzWzBdKVxuXG4gICAgbG9nZ2VyLmVycm9yKGxpZm8oJ2Vycm9yJywgYXJncykpXG4gIH1cblxuICB0aGlzLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuICAgIGFyZ3NbMF0gPSBhZGRDb250YWluZXJJZChhcmdzWzBdKVxuXG4gICAgbG9nZ2VyLndhcm4obGlmbygnd2FybicsIGFyZ3MpKVxuICB9XG5cbiAgdGhpcy5nZXRMaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RhY2tcbiAgfVxufVxuIiwiaW1wb3J0IGRlc3BvdCBmcm9tICdkZXNwb3QnXG5cbmltcG9ydCBWaWRlb21haWxFcnJvciBmcm9tICcuL3ZpZGVvbWFpbEVycm9yJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLy4uL2V2ZW50cydcblxuLy8gVE9ETzogTUFLRSBFVkVOVCBFTUlUVElORyBJTiBERVNQT1QgTk9UIEdMT0JBTCBCVVQgQlkgQ09OVEFJTkVSIElEIElOU1RFQURcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG9wdGlvbnMsIG5hbWUpIHtcbiAgdGhpcy5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcblxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnWW91IGNhbm5vdCBlbWl0IHdpdGhvdXQgYW4gZXZlbnQuJywgb3B0aW9ucylcbiAgICB9XG5cbiAgICAvLyBBdXRvbWF0aWNhbGx5IGNvbnZlcnQgZXJyb3JzIHRvIHZpZGVvbWFpbCBlcnJvcnNcbiAgICBpZiAoZXZlbnQgPT09IEV2ZW50cy5FUlJPUikge1xuICAgICAgdmFyIGVyciA9IGFyZ3NbMV1cblxuICAgICAgZXJyID0gVmlkZW9tYWlsRXJyb3IuY3JlYXRlKGVyciwgb3B0aW9ucylcblxuICAgICAgYXJnc1sxXSA9IGVyclxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICBpZiAoZXZlbnQgIT09ICdyZW1vdmVMaXN0ZW5lcicgJiYgZXZlbnQgIT09ICduZXdMaXN0ZW5lcicpIHtcbiAgICAgICAgdmFyIG1vcmVBcmd1bWVudHNcblxuICAgICAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgICAgIG1vcmVBcmd1bWVudHMgPSBhcmdzLnNsaWNlKDEpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9yZUFyZ3VtZW50cykge1xuICAgICAgICAgIG9wdGlvbnMuZGVidWcoJyVzIGVtaXRzOiAlcycsIG5hbWUsIGV2ZW50LCBtb3JlQXJndW1lbnRzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMuZGVidWcoJyVzIGVtaXRzOiAlcycsIG5hbWUsIGV2ZW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gZGVzcG90LmVtaXQuYXBwbHkoZGVzcG90LCBhcmdzKVxuXG4gICAgLy8gVG9kbzogaGF2ZSB0aGlzIGVtaXR0ZWQgdGhyb3VnaCBhIGNvbmZpZ3VyYXRpb24gYmVjYXVzZSBpdCBpcyBwcmV0dHkgbm9pc3lcbiAgICAvLyBpZiAoZXZlbnQgIT09IEV2ZW50cy5FVkVOVF9FTUlUVEVEKVxuICAgIC8vICAgICB0aGlzLmVtaXQoRXZlbnRzLkVWRU5UX0VNSVRURUQsIGV2ZW50KVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgdGhpcy5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNiKSB7XG4gICAgcmV0dXJuIGRlc3BvdC5vbihldmVudE5hbWUsIGNiKVxuICB9XG5cbiAgdGhpcy5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2IpIHtcbiAgICByZXR1cm4gZGVzcG90Lm9uY2UoZXZlbnROYW1lLCBjYilcbiAgfVxuXG4gIHRoaXMubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiBkZXNwb3QubGlzdGVuZXJzKGV2ZW50TmFtZSlcbiAgfVxuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYikge1xuICAgIHJldHVybiBkZXNwb3QucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBjYilcbiAgfVxuXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3BvdC5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICB9XG59XG4iLCJpbXBvcnQgZmlsZXNpemUgZnJvbSAnZmlsZXNpemUnXG5pbXBvcnQgaHVtYW5pemVEdXJhdGlvbiBmcm9tICdodW1hbml6ZS1kdXJhdGlvbidcblxuLy8gdG9kbyBnZXQgcmlkIG9mIHRoaXMgY2xhc3MgYW5kIHVzZSB0aG9zZSBpbXBvcnRzIGRpcmVjdGx5XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZmlsZXNpemU6IGZ1bmN0aW9uIChieXRlcywgcm91bmQpIHtcbiAgICByZXR1cm4gZmlsZXNpemUoYnl0ZXMsIHtcbiAgICAgIHJvdW5kOiByb3VuZFxuICAgIH0pXG4gIH0sXG5cbiAgdG9UaW1lOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBodW1hbml6ZUR1cmF0aW9uKHQpXG4gIH1cbn1cbiIsIi8vIHRha2VuIGZyb21cbi8vIGh0dHBzOi8vYmJjLmdpdGh1Yi5pby90YWwvanNkb2MvZXZlbnRzX21lZGlhZXZlbnQuanMuaHRtbFxuXG5leHBvcnQgZGVmYXVsdCBbXG4gIC8vIFRoZSB1c2VyIGFnZW50IGJlZ2lucyBsb29raW5nIGZvciBtZWRpYSBkYXRhLCBhcyBwYXJ0IG9mXG4gIC8vIHRoZSByZXNvdXJjZSBzZWxlY3Rpb24gYWxnb3JpdGhtLlxuICAnbG9hZHN0YXJ0JyxcblxuICAvLyBUaGUgdXNlciBhZ2VudCBpcyBpbnRlbnRpb25hbGx5IG5vdCBjdXJyZW50bHkgZmV0Y2hpbmcgbWVkaWEgZGF0YSxcbiAgLy8gYnV0IGRvZXMgbm90IGhhdmUgdGhlIGVudGlyZSBtZWRpYSByZXNvdXJjZSBkb3dubG9hZGVkLiBuZXR3b3JrU3RhdGUgZXF1YWxzIE5FVFdPUktfSURMRVxuICAnc3VzcGVuZCcsXG5cbiAgLy8gUGxheWJhY2sgaGFzIGJlZ3VuLiBGaXJlZCBhZnRlciB0aGUgcGxheSgpIG1ldGhvZCBoYXMgcmV0dXJuZWQsXG4gIC8vIG9yIHdoZW4gdGhlIGF1dG9wbGF5IGF0dHJpYnV0ZSBoYXMgY2F1c2VkIHBsYXliYWNrIHRvIGJlZ2luLlxuICAvLyBwYXVzZWQgaXMgbmV3bHkgZmFsc2UuXG4gIC8vICdwbGF5JywgY29tbWVudGVkIG91dCBzaW5jZSBpdCBoYXMgc3BlY2lhbCB0cmVhdG1lbnRcblxuICAvLyBUaGUgdXNlciBhZ2VudCBoYXMganVzdCBkZXRlcm1pbmVkIHRoZSBkdXJhdGlvbiBhbmQgZGltZW5zaW9ucyBvZiB0aGVcbiAgLy8gbWVkaWEgcmVzb3VyY2UgYW5kIHRoZSB0aW1lZCB0cmFja3MgYXJlIHJlYWR5LlxuICAvLyByZWFkeVN0YXRlIGlzIG5ld2x5IGVxdWFsIHRvIEhBVkVfTUVUQURBVEEgb3IgZ3JlYXRlciBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gIC8vICdsb2FkZWRtZXRhZGF0YScsIGNvbW1lbnRlZCBvdXQgc2luY2UgaXQgaGFzIHNwZWNpYWwgdHJlYXRtZW50XG5cbiAgLy8gVGhlIHVzZXIgYWdlbnQgaXMgZmV0Y2hpbmcgbWVkaWEgZGF0YS5cbiAgJ3Byb2dyZXNzJyxcblxuICAvLyBUaGUgdXNlciBhZ2VudCBpcyBpbnRlbnRpb25hbGx5IG5vdCBjdXJyZW50bHkgZmV0Y2hpbmcgbWVkaWEgZGF0YSxcbiAgLy8gYnV0IGRvZXMgbm90IGhhdmUgdGhlIGVudGlyZSBtZWRpYSByZXNvdXJjZSBkb3dubG9hZGVkLlxuICAvLyAnc3VzcGVuZCcsIC8vIGNvbW1lbnRlZCBvdXQsIHdlIGFyZSBhbHJlYWR5IGxpc3RlbmluZyB0byBpdCBpbiBjb2RlXG5cbiAgLy8gRXZlbnQgVGhlIHVzZXIgYWdlbnQgc3RvcHMgZmV0Y2hpbmcgdGhlIG1lZGlhIGRhdGEgYmVmb3JlIGl0IGlzIGNvbXBsZXRlbHkgZG93bmxvYWRlZCxcbiAgLy8gYnV0IG5vdCBkdWUgdG8gYW4gZXJyb3IuICBlcnJvciBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgY29kZSBNRURJQV9FUlJfQUJPUlRFRC5cbiAgJ2Fib3J0JyxcblxuICAvLyBBIG1lZGlhIGVsZW1lbnQgd2hvc2UgbmV0d29ya1N0YXRlIHdhcyBwcmV2aW91c2x5IG5vdCBpbiB0aGUgTkVUV09SS19FTVBUWVxuICAvLyBzdGF0ZSBoYXMganVzdCBzd2l0Y2hlZCB0byB0aGF0IHN0YXRlIChlaXRoZXIgYmVjYXVzZSBvZiBhIGZhdGFsIGVycm9yXG4gIC8vIGR1cmluZyBsb2FkIHRoYXQncyBhYm91dCB0byBiZSByZXBvcnRlZCwgb3IgYmVjYXVzZSB0aGUgbG9hZCgpIG1ldGhvZCB3YXNcbiAgLy8gaW52b2tlZCB3aGlsZSB0aGUgcmVzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobSB3YXMgYWxyZWFkeSBydW5uaW5nKS5cbiAgJ2VtcHRpZWQnLFxuXG4gIC8vIFRoZSB1c2VyIGFnZW50IGlzIHRyeWluZyB0byBmZXRjaCBtZWRpYSBkYXRhLCBidXQgZGF0YSBpc1xuICAvLyB1bmV4cGVjdGVkbHkgbm90IGZvcnRoY29taW5nXG4gICdzdGFsbGVkJyxcblxuICAvLyBQbGF5YmFjayBoYXMgYmVlbiBwYXVzZWQuIEZpcmVkIGFmdGVyIHRoZSBwYXVzZSgpIG1ldGhvZCBoYXMgcmV0dXJuZWQuXG4gIC8vIHBhdXNlZCBpcyBuZXdseSB0cnVlLlxuICAncGF1c2UnLFxuXG4gICAvLyBUaGUgdXNlciBhZ2VudCBjYW4gcmVuZGVyIHRoZSBtZWRpYSBkYXRhIGF0IHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uXG4gICAvLyBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAvLyByZWFkeVN0YXRlIG5ld2x5IGluY3JlYXNlZCB0byBIQVZFX0NVUlJFTlRfREFUQSBvciBncmVhdGVyIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgJ2xvYWRlZGRhdGEnLFxuXG4gIC8vIFBsYXliYWNrIGhhcyBzdG9wcGVkIGJlY2F1c2UgdGhlIG5leHQgZnJhbWUgaXMgbm90IGF2YWlsYWJsZSwgYnV0IHRoZSB1c2VyXG4gIC8vIGFnZW50IGV4cGVjdHMgdGhhdCBmcmFtZSB0byBiZWNvbWUgYXZhaWxhYmxlIGluIGR1ZSBjb3Vyc2UuXG4gIC8vIHJlYWR5U3RhdGUgaXMgbmV3bHkgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIEhBVkVfQ1VSUkVOVF9EQVRBLFxuICAvLyBhbmQgcGF1c2VkIGlzIGZhbHNlLiBFaXRoZXIgc2Vla2luZyBpcyB0cnVlLCBvciB0aGUgY3VycmVudCBwbGF5YmFja1xuICAvLyBwb3NpdGlvbiBpcyBub3QgY29udGFpbmVkIGluIGFueSBvZiB0aGUgcmFuZ2VzIGluIGJ1ZmZlcmVkLlxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgcGxheWJhY2sgdG8gc3RvcCBmb3IgdHdvIG90aGVyIHJlYXNvbnMgd2l0aG91dFxuICAvLyBwYXVzZWQgYmVpbmcgZmFsc2UsIGJ1dCB0aG9zZSB0d28gcmVhc29ucyBkbyBub3QgZmlyZSB0aGlzIGV2ZW50OlxuICAvLyBtYXliZSBwbGF5YmFjayBlbmRlZCwgb3IgcGxheWJhY2sgc3RvcHBlZCBkdWUgdG8gZXJyb3JzLlxuICAnd2FpdGluZycsXG5cbiAgLy8gUGxheWJhY2sgaGFzIHN0YXJ0ZWQuIHJlYWR5U3RhdGUgaXMgbmV3bHkgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXG4gIC8vIEhBVkVfRlVUVVJFX0RBVEEsIHBhdXNlZCBpcyBmYWxzZSwgc2Vla2luZyBpcyBmYWxzZSxcbiAgLy8gb3IgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgY29udGFpbmVkIGluIG9uZSBvZiB0aGUgcmFuZ2VzIGluIGJ1ZmZlcmVkLlxuICAncGxheWluZycsXG5cbiAgLy8gVGhlIHVzZXIgYWdlbnQgY2FuIHJlc3VtZSBwbGF5YmFjayBvZiB0aGUgbWVkaWEgZGF0YSxcbiAgLy8gYnV0IGVzdGltYXRlcyB0aGF0IGlmIHBsYXliYWNrIHdlcmUgdG8gYmUgc3RhcnRlZCBub3csIHRoZSBtZWRpYSByZXNvdXJjZVxuICAvLyBjb3VsZCBub3QgYmUgcmVuZGVyZWQgYXQgdGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZSB1cCB0byBpdHMgZW5kIHdpdGhvdXRcbiAgLy8gaGF2aW5nIHRvIHN0b3AgZm9yIGZ1cnRoZXIgYnVmZmVyaW5nIG9mIGNvbnRlbnQuXG4gIC8vIHJlYWR5U3RhdGUgbmV3bHkgaW5jcmVhc2VkIHRvIEhBVkVfRlVUVVJFX0RBVEEgb3IgZ3JlYXRlci5cbiAgJ2NhbnBsYXknLFxuXG4gIC8vIFRoZSB1c2VyIGFnZW50IGVzdGltYXRlcyB0aGF0IGlmIHBsYXliYWNrIHdlcmUgdG8gYmUgc3RhcnRlZCBub3csXG4gIC8vIHRoZSBtZWRpYSByZXNvdXJjZSBjb3VsZCBiZSByZW5kZXJlZCBhdCB0aGUgY3VycmVudCBwbGF5YmFjayByYXRlXG4gIC8vIGFsbCB0aGUgd2F5IHRvIGl0cyBlbmQgd2l0aG91dCBoYXZpbmcgdG8gc3RvcCBmb3IgZnVydGhlciBidWZmZXJpbmcuXG4gIC8vIHJlYWR5U3RhdGUgaXMgbmV3bHkgZXF1YWwgdG8gSEFWRV9FTk9VR0hfREFUQS5cbiAgJ2NhbnBsYXl0aHJvdWdoJyxcblxuICAvLyBUaGUgc2Vla2luZyBJREwgYXR0cmlidXRlIGNoYW5nZWQgdG8gdHJ1ZSBhbmQgdGhlIHNlZWsgb3BlcmF0aW9uIGlzXG4gIC8vIHRha2luZyBsb25nIGVub3VnaCB0aGF0IHRoZSB1c2VyIGFnZW50IGhhcyB0aW1lIHRvIGZpcmUgdGhlIGV2ZW50LlxuICAnc2Vla2luZycsXG5cbiAgLy8gVGhlIHNlZWtpbmcgSURMIGF0dHJpYnV0ZSBjaGFuZ2VkIHRvIGZhbHNlLlxuICAnc2Vla2VkJyxcblxuICAvLyBQbGF5YmFjayBoYXMgc3RvcHBlZCBiZWNhdXNlIHRoZSBlbmQgb2YgdGhlIG1lZGlhIHJlc291cmNlIHdhcyByZWFjaGVkLlxuICAvLyBjdXJyZW50VGltZSBlcXVhbHMgdGhlIGVuZCBvZiB0aGUgbWVkaWEgcmVzb3VyY2U7IGVuZGVkIGlzIHRydWUuXG4gICdlbmRlZCcsXG5cbiAgLy8gRWl0aGVyIHRoZSBkZWZhdWx0UGxheWJhY2tSYXRlIG9yIHRoZSBwbGF5YmFja1JhdGUgYXR0cmlidXRlXG4gIC8vIGhhcyBqdXN0IGJlZW4gdXBkYXRlZC5cbiAgJ3JhdGVjaGFuZ2UnLFxuXG4gIC8vIFRoZSBkdXJhdGlvbiBhdHRyaWJ1dGUgaGFzIGp1c3QgYmVlbiB1cGRhdGVkLlxuICAnZHVyYXRpb25jaGFuZ2UnLFxuXG4gIC8vIEVpdGhlciB0aGUgdm9sdW1lIGF0dHJpYnV0ZSBvciB0aGUgbXV0ZWQgYXR0cmlidXRlIGhhcyBjaGFuZ2VkLlxuICAvLyBGaXJlZCBhZnRlciB0aGUgcmVsZXZhbnQgYXR0cmlidXRlJ3Mgc2V0dGVyIGhhcyByZXR1cm5lZC5cbiAgJ3ZvbHVtZWNoYW5nZSdcblxuICAvLyBjb21tZW50ZWQgb3V0LCBoYXBwZW4gdG9vIG9mdGVuXG5cbiAgLy8gVGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gY2hhbmdlZCBhcyBwYXJ0IG9mIG5vcm1hbCBwbGF5YmFjayBvciBpblxuICAvLyBhbiBlc3BlY2lhbGx5IGludGVyZXN0aW5nIHdheSwgZm9yIGV4YW1wbGUgZGlzY29udGludW91c2x5LlxuICAvLyAndGltZXVwZGF0ZSdcbl1cbiIsImNvbnN0IERBU0ggPSAnLSAnXG5jb25zdCBTRVBBUkFUT1IgPSAnPGJyLz4nICsgREFTSFxuXG5mdW5jdGlvbiBhcnJheVRvU3RyaW5nIChhcnJheSkge1xuICBpZiAoYXJyYXkubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxpbmVzID0gW11cblxuICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudG9TdHJpbmcpIHtcbiAgICAgICAgbGluZXMucHVzaChlbGVtZW50LnRvU3RyaW5nKCkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBEQVNIICsgbGluZXMuam9pbihTRVBBUkFUT1IpXG4gIH1cbn1cblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcgKG9iamVjdCwgb3B0aW9ucykge1xuICBjb25zdCBwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KVxuICBjb25zdCBleGNsdWRlcyA9IChvcHRpb25zICYmIG9wdGlvbnMuZXhjbHVkZXMpIHx8IG51bGxcbiAgY29uc3QgbGluZXMgPSBbXVxuICB2YXIgc0xpbmVzXG5cbiAgaWYgKHByb3BlcnR5TmFtZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBleGNsdWRlID0gZmFsc2VcblxuICAgIHByb3BlcnR5TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKGV4Y2x1ZGVzKSB7XG4gICAgICAgIGV4Y2x1ZGUgPSBleGNsdWRlcy5pbmRleE9mKG5hbWUpID49IDBcbiAgICAgIH1cblxuICAgICAgaWYgKCFleGNsdWRlICYmIG9iamVjdFtuYW1lXSAmJiBvYmplY3RbbmFtZV0udG9TdHJpbmcpIHtcbiAgICAgICAgbGluZXMucHVzaChvYmplY3RbbmFtZV0udG9TdHJpbmcoKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHNMaW5lcyA9IGxpbmVzLmpvaW4oKVxuICB9IGVsc2UgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICBzTGluZXMgPSBEQVNIICsgbGluZXMuam9pbihTRVBBUkFUT1IpXG4gIH1cblxuICByZXR1cm4gc0xpbmVzXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChhbnl0aGluZywgb3B0aW9ucykge1xuICBpZiAoYW55dGhpbmcgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFueXRoaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAndW5kZWZpbmVkJ1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhbnl0aGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYW55dGhpbmdcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFueXRoaW5nKSkge1xuICAgIHJldHVybiBhcnJheVRvU3RyaW5nKGFueXRoaW5nKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhbnl0aGluZyA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYW55dGhpbmcsIG9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFueXRoaW5nLnRvU3RyaW5nKClcbiAgfVxufVxuIiwiaW1wb3J0ICdjbGFzc2xpc3QuanMnXG5cbi8vIG5lZWRlZCBmb3IgSUUgMTFcbmltcG9ydCAnZWxlbWVudC1jbG9zZXN0J1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanVsaWVuZXRpZS9yZXF1ZXN0LWZyYW1lXG5pbXBvcnQgcmVxdWVzdEZyYW1lIGZyb20gJ3JlcXVlc3QtZnJhbWUnXG5cbi8vIHVzZSB0aG9zZSBkZWZhdWx0IHBhcmFtcyBmb3IgdW5pdCB0ZXN0c1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHdpbmRvdyA9IHt9LCBuYXZpZ2F0b3IgPSB7fSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vanVsaWVuZXRpZS9yZXF1ZXN0LWZyYW1lL2lzc3Vlcy82XG4gIGlmICghd2luZG93LnNjcmVlbikge1xuICAgIHdpbmRvdy5zY3JlZW4gPSB7fVxuICB9XG5cbiAgcmVxdWVzdEZyYW1lKCduYXRpdmUnKVxuXG4gIC8vIGF2b2lkcyB3YXJuaW5nIFwibmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSBoYXMgYmVlbiByZXBsYWNlZCBieSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYVwiLFxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLWNsaWVudC9pc3N1ZXMvNzlcbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAvLyBkbyBub3Qgc2hpbVxuICB9IGVsc2Uge1xuICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWFfID1cbiAgICAgICAgICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYVxuICB9XG5cbiAgaWYgKCF3aW5kb3cuQXVkaW9Db250ZXh0ICYmIHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpIHtcbiAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dFxuICB9XG5cbiAgaWYgKCF3aW5kb3cuVVJMKSB7XG4gICAgd2luZG93LlVSTCA9IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkxcbiAgfVxuXG4gIGNvbnN0IG1ldGhvZHMgPSBbXG4gICAgJ2RlYnVnJywgJ2dyb3VwQ29sbGFwc2VkJywgJ2dyb3VwRW5kJywgJ2Vycm9yJyxcbiAgICAnZXhjZXB0aW9uJywgJ2luZm8nLCAnbG9nJywgJ3RyYWNlJywgJ3dhcm4nXG4gIF1cblxuICB2YXIgY29uc29sZSA9IHt9XG5cbiAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlXG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmNvbnNvbGUgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgdmFyIG1ldGhvZFxuICB2YXIgbGVuZ3RoID0gbWV0aG9kcy5sZW5ndGhcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBtZXRob2QgPSBtZXRob2RzW2xlbmd0aF1cblxuICAgIGlmICghY29uc29sZVttZXRob2RdKSB7XG4gICAgICBjb25zb2xlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7fVxuICAgIH1cbiAgfVxufVxuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3Rncmllc3Nlci9jcmVhdGUtZXJyb3JcbmltcG9ydCBjcmVhdGVFcnJvciBmcm9tICdjcmVhdGUtZXJyb3InXG5pbXBvcnQgdXRpbCBmcm9tICd1dGlsJ1xuXG5pbXBvcnQgb3JpZ2luYWxQcmV0dHkgZnJvbSAnLi9wcmV0dHknXG5pbXBvcnQgUmVzb3VyY2UgZnJvbSAnLi8uLi9yZXNvdXJjZSdcblxuY29uc3QgVklERU9NQUlMX0VSUl9OQU1FID0gJ1ZpZGVvbWFpbCBFcnJvcidcblxuY29uc3QgVmlkZW9tYWlsRXJyb3IgPSBjcmVhdGVFcnJvcihFcnJvciwgVklERU9NQUlMX0VSUl9OQU1FLCB7XG4gICdleHBsYW5hdGlvbic6IHVuZGVmaW5lZCxcbiAgJ2xvZ0xpbmVzJzogdW5kZWZpbmVkLFxuICAndXNlcmFnZW50JzogdW5kZWZpbmVkLFxuICAndXJsJzogdW5kZWZpbmVkLFxuICAnc3RhY2snOiB1bmRlZmluZWRcbn0pXG5cbi8vIHNoaW0gcHJldHR5IHRvIGV4Y2x1ZGUgc3RhY2sgYWx3YXlzXG5jb25zdCBwcmV0dHkgPSBmdW5jdGlvbiAoYW55dGhpbmcpIHtcbiAgcmV0dXJuIG9yaWdpbmFsUHJldHR5KGFueXRoaW5nLCB7ZXhjbHVkZXM6IFsnc3RhY2snXX0pXG59XG5cbi8vIHN0YXRpYyBhbmQgcHVibGljIGF0dHJpYnV0ZSBvZiB0aGlzIGNsYXNzXG5WaWRlb21haWxFcnJvci5QRVJNSVNTSU9OX0RFTklFRCA9ICdQRVJNSVNTSU9OX0RFTklFRCdcblZpZGVvbWFpbEVycm9yLk5PVF9BTExPV0VEX0VSUk9SID0gJ05vdEFsbG93ZWRFcnJvcidcblZpZGVvbWFpbEVycm9yLk5PVF9DT05ORUNURUQgPSAnTm90IGNvbm5lY3RlZCdcblZpZGVvbWFpbEVycm9yLkRPTV9FWENFUFRJT04gPSAnRE9NRXhjZXB0aW9uJ1xuVmlkZW9tYWlsRXJyb3IuU1RBUlRJTkdfRkFJTEVEID0gJ1N0YXJ0aW5nIHZpZGVvIGZhaWxlZCdcblZpZGVvbWFpbEVycm9yLk1FRElBX0RFVklDRV9OT1RfU1VQUE9SVEVEID0gJ01lZGlhRGV2aWNlTm90U3VwcG9ydGVkJ1xuVmlkZW9tYWlsRXJyb3IuQlJPV1NFUl9QUk9CTEVNID0gJ2Jyb3dzZXItcHJvYmxlbSdcblZpZGVvbWFpbEVycm9yLldFQkNBTV9QUk9CTEVNID0gJ3dlYmNhbS1wcm9ibGVtJ1xuVmlkZW9tYWlsRXJyb3IuSU9TX1BST0JMRU0gPSAnaW9zLXByb2JsZW0nXG5cbi8vIHN0YXRpYyBmdW5jdGlvbiB0byBjb252ZXJ0IGFuIGVycm9yIGludG8gYSB2aWRlb21haWwgZXJyb3JcblZpZGVvbWFpbEVycm9yLmNyZWF0ZSA9IGZ1bmN0aW9uIChlcnIsIGV4cGxhbmF0aW9uLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gIGlmIChlcnIgJiYgZXJyLm5hbWUgPT09IFZJREVPTUFJTF9FUlJfTkFNRSkge1xuICAgIHJldHVybiBlcnJcbiAgfVxuXG4gIGlmICghb3B0aW9ucyAmJiBleHBsYW5hdGlvbikge1xuICAgIG9wdGlvbnMgPSBleHBsYW5hdGlvblxuICAgIGV4cGxhbmF0aW9uID0gdW5kZWZpbmVkXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fVxuXG4gIC8vIGJlIHN1cGVyIHJvYnVzdFxuICBjb25zdCBkZWJ1ZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpIHx8IGNvbnNvbGUubG9nXG5cbiAgZGVidWcoJ1ZpZGVvbWFpbEVycm9yOiBjcmVhdGUoKScpXG5cbiAgY29uc3QgY2xhc3NMaXN0ID0gcGFyYW1ldGVycy5jbGFzc0xpc3QgfHwgW11cblxuICAvLyBSZXF1aXJlIEJyb3dzZXIgaGVyZSwgbm90IGF0IHRoZSB0b3Agb2YgdGhlIGZpbGUgdG8gYXZvaWRcbiAgLy8gcmVjdXJzaW9uLiBCZWNhdXNlIHRoZSBCcm93c2VyIGNsYXNzIGlzIHJlcXVpcmluZyB0aGlzIGZpbGUgYXMgd2VsbC5cbiAgY29uc3QgQnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpXG4gIGNvbnN0IGJyb3dzZXIgPSBuZXcgQnJvd3NlcihvcHRpb25zKVxuXG4gIHZhciBlcnJUeXBlXG4gIHZhciBtZXNzYWdlXG4gIHZhciBzdGFja1xuXG4gICAgLy8gd2hvbGUgY29kZSBpcyB1Z2x5IGJlY2F1c2UgYWxsIGJyb3dzZXJzIGJlaGF2ZSBzbyBkaWZmZXJlbnRseSA6KFxuXG4gIGlmICh0eXBlb2YgZXJyID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChlcnIuY29kZSA9PT0gMSAmJiBlcnIuUEVSTUlTU0lPTl9ERU5JRUQgPT09IDEpIHtcbiAgICAgIGVyclR5cGUgPSBWaWRlb21haWxFcnJvci5QRVJNSVNTSU9OX0RFTklFRFxuICAgIH0gZWxzZSBpZiAoZXJyLmNvbnN0cnVjdG9yICYmIGVyci5jb25zdHJ1Y3Rvci5uYW1lID09PSBWaWRlb21haWxFcnJvci5ET01fRVhDRVBUSU9OKSB7XG4gICAgICBlcnJUeXBlID0gVmlkZW9tYWlsRXJyb3IuRE9NX0VYQ0VQVElPTlxuICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2UgPT09IFZpZGVvbWFpbEVycm9yLlNUQVJUSU5HX0ZBSUxFRCkge1xuICAgICAgZXJyVHlwZSA9IGVyci5tZXNzYWdlXG4gICAgfSBlbHNlIGlmIChlcnIubmFtZSkge1xuICAgICAgZXJyVHlwZSA9IGVyci5uYW1lXG4gICAgfSBlbHNlIGlmIChlcnIudHlwZSA9PT0gJ2Vycm9yJyAmJiBlcnIudGFyZ2V0LmJ1ZmZlcmVkQW1vdW50ID09PSAwKSB7XG4gICAgICBlcnJUeXBlID0gVmlkZW9tYWlsRXJyb3IuTk9UX0NPTk5FQ1RFRFxuICAgIH1cbiAgfSBlbHNlIGlmIChlcnIgPT09IFZpZGVvbWFpbEVycm9yLk5PVF9DT05ORUNURUQpIHtcbiAgICBlcnJUeXBlID0gVmlkZW9tYWlsRXJyb3IuTk9UX0NPTk5FQ1RFRFxuICB9IGVsc2Uge1xuICAgIGVyclR5cGUgPSBlcnJcbiAgfVxuXG4gIGlmIChlcnIgJiYgZXJyLnN0YWNrKSB7XG4gICAgc3RhY2sgPSBlcnIuc3RhY2tcbiAgfVxuXG4gIHN3aXRjaCAoZXJyVHlwZSkge1xuICAgIGNhc2UgJ1NvdXJjZVVuYXZhaWxhYmxlRXJyb3InOlxuICAgICAgbWVzc2FnZSA9ICdTb3VyY2Ugb2YgeW91ciB3ZWJjYW0gY2Fubm90IGJlIGFjY2Vzc2VkJ1xuICAgICAgZXhwbGFuYXRpb24gPSAnUHJvYmFibHkgaXQgaXMgbG9ja2VkIGZyb20gYW5vdGhlciBwcm9jZXNzIG9yIGhhcyBhIGhhcmR3YXJlIGVycm9yLidcblxuICAgICAgaWYgKGVyci5tZXNzYWdlKSB7XG4gICAgICAgIGVyci5tZXNzYWdlICs9ICcgRGV0YWlsczogJyArIGVyci5tZXNzYWdlXG4gICAgICB9XG5cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnTm90Rm91bmRFcnJvcic6XG4gICAgY2FzZSAnTk9fREVWSUNFU19GT1VORCc6XG4gICAgICBtZXNzYWdlID0gJ05vIHdlYmNhbSBmb3VuZCdcbiAgICAgIGV4cGxhbmF0aW9uID0gJ1lvdXIgYnJvd3NlciBjYW5ub3QgZmluZCBhIHdlYmNhbSBhdHRhY2hlZCB0byB5b3VyIG1hY2hpbmUuJ1xuICAgICAgY2xhc3NMaXN0LnB1c2goVmlkZW9tYWlsRXJyb3IuV0VCQ0FNX1BST0JMRU0pXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnUGVybWlzc2lvbkRpc21pc3NlZEVycm9yJzpcbiAgICAgIG1lc3NhZ2UgPSAnT29vcHMsIHlvdSBkaWRuXFwndCBnaXZlIG1lIGFueSBwZXJtaXNzaW9ucz8nXG4gICAgICBleHBsYW5hdGlvbiA9ICdMb29rcyBsaWtlIHlvdSBza2lwcGVkIHRoZSB3ZWJjYW0gcGVybWlzc2lvbiBkaWFsb2d1ZS48YnIvPicgK1xuICAgICAgICAgICAgICAgICAgICAnUGxlYXNlIGdyYW50IGFjY2VzcyBuZXh0IHRpbWUgdGhlIGRpYWxvZ3VlIGFwcGVhcnMuJ1xuICAgICAgY2xhc3NMaXN0LnB1c2goVmlkZW9tYWlsRXJyb3IuV0VCQ0FNX1BST0JMRU0pXG4gICAgICBicmVha1xuXG4gICAgY2FzZSBWaWRlb21haWxFcnJvci5OT1RfQUxMT1dFRF9FUlJPUjpcbiAgICBjYXNlIFZpZGVvbWFpbEVycm9yLlBFUk1JU1NJT05fREVOSUVEOlxuICAgIGNhc2UgJ1Blcm1pc3Npb25EZW5pZWRFcnJvcic6XG4gICAgICBtZXNzYWdlID0gJ1Blcm1pc3Npb24gZGVuaWVkJ1xuXG4gICAgICBpZiAoYnJvd3Nlci5pc0Nocm9tZUJhc2VkKCkgfHwgYnJvd3Nlci5pc0ZpcmVmb3goKSB8fCBicm93c2VyLmlzRWRnZSgpKSB7XG4gICAgICAgIGV4cGxhbmF0aW9uID0gJ1Blcm1pc3Npb24gdG8gYWNjZXNzIHlvdXIgd2ViY2FtIGhhcyBiZWVuIGRlbmllZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ1RoaXMgY2FuIGhhdmUgdHdvIHJlYXNvbnM6PGJyLz4nICtcbiAgICAgICAgICAgICAgICAgICAgICAnYSkgeW91IGJsb2NrZWQgYWNjZXNzIHRvIHdlYmNhbTsgb3I8YnIvPicgK1xuICAgICAgICAgICAgICAgICAgICAgICdiKSB5b3VyIHdlYmNhbSBpcyBhbHJlYWR5IGluIHVzZS4nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHBsYW5hdGlvbiA9ICdQZXJtaXNzaW9uIHRvIGFjY2VzcyB5b3VyIHdlYmNhbSBoYXMgYmVlbiBkZW5pZWQuJ1xuICAgICAgfVxuXG4gICAgICBjbGFzc0xpc3QucHVzaChWaWRlb21haWxFcnJvci5XRUJDQU1fUFJPQkxFTSlcblxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ0hBUkRXQVJFX1VOQVZBSUxBQkxFJzpcbiAgICAgIG1lc3NhZ2UgPSAnV2ViY2FtIGlzIHVuYXZhaWxhYmxlJ1xuICAgICAgZXhwbGFuYXRpb24gPSAnTWF5YmUgaXQgaXMgYWxyZWFkeSBidXN5IGluIGFub3RoZXIgd2luZG93PydcblxuICAgICAgaWYgKGJyb3dzZXIuaXNDaHJvbWVCYXNlZCgpKSB7XG4gICAgICAgIGV4cGxhbmF0aW9uICs9ICcgT3IgeW91IGhhdmUgdG8gYWxsb3cgYWNjZXNzIGFib3ZlPydcbiAgICAgIH1cblxuICAgICAgY2xhc3NMaXN0LnB1c2goVmlkZW9tYWlsRXJyb3IuV0VCQ0FNX1BST0JMRU0pXG5cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFZpZGVvbWFpbEVycm9yLk5PVF9DT05ORUNURUQ6XG4gICAgICBtZXNzYWdlID0gJ1VuYWJsZSB0byB0cmFuc2ZlciBkYXRhJ1xuICAgICAgZXhwbGFuYXRpb24gPSAnVW5hYmxlIHRvIG1haW50YWluIGEgd2Vic29ja2V0IHRvIHRoZSBzZXJ2ZXIuIEVpdGhlciBzZXJ2ZXIgb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICd5b3VyIGNvbm5lY3Rpb24gaXMgZG93bi4gVHJ5aW5nIHRvIHJlY29ubmVjdCBldmVyeSB0d28gc2Vjb25kcyDigKYnXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnTk9fVklERU9fRkVFRCc6XG4gICAgICBtZXNzYWdlID0gJ05vIHZpZGVvIGZlZWQgZm91bmQhJ1xuICAgICAgZXhwbGFuYXRpb24gPSAnWW91ciB3ZWJjYW0gaXMgYWxyZWFkeSB1c2VkIGluIGFub3RoZXIgYnJvd3Nlci4nXG4gICAgICBjbGFzc0xpc3QucHVzaChWaWRlb21haWxFcnJvci5XRUJDQU1fUFJPQkxFTSlcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFZpZGVvbWFpbEVycm9yLlNUQVJUSU5HX0ZBSUxFRDpcbiAgICAgIG1lc3NhZ2UgPSAnU3RhcnRpbmcgdmlkZW8gZmFpbGVkJ1xuICAgICAgZXhwbGFuYXRpb24gPSAnTW9zdCBsaWtlbHkgdGhpcyBoYXBwZW5zIHdoZW4gdGhlIHdlYmFtIGlzIGFscmVhZHkgYWN0aXZlIGluIGFub3RoZXIgYnJvd3Nlci4nXG4gICAgICBjbGFzc0xpc3QucHVzaChWaWRlb21haWxFcnJvci5XRUJDQU1fUFJPQkxFTSlcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdEZXZpY2VzTm90Rm91bmRFcnJvcic6XG4gICAgICBtZXNzYWdlID0gJ05vIGF2YWlsYWJsZSB3ZWJjYW0gY291bGQgYmUgZm91bmQnXG4gICAgICBleHBsYW5hdGlvbiA9ICdMb29rcyBsaWtlIHlvdSBkbyBub3QgaGF2ZSBhbnkgd2ViY2FtIGF0dGFjaGVkIHRvIHlvdXIgbWFjaGluZTsgb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICd0aGUgb25lIHlvdSBwbHVnZ2VkIGluIGlzIGFscmVhZHkgdXNlZC4nXG4gICAgICBjbGFzc0xpc3QucHVzaChWaWRlb21haWxFcnJvci5XRUJDQU1fUFJPQkxFTSlcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFZpZGVvbWFpbEVycm9yLkRPTV9FWENFUFRJT046XG4gICAgICBpZiAoZXJyLmNvZGUgPT09IDkpIHtcbiAgICAgICAgY29uc3QgbmV3VXJsID0gJ2h0dHBzOicgKyB3aW5kb3cubG9jYXRpb24uaHJlZi5zdWJzdHJpbmcod2luZG93LmxvY2F0aW9uLnByb3RvY29sLmxlbmd0aClcbiAgICAgICAgbWVzc2FnZSA9ICdTZWN1cml0eSB1cGdyYWRlIG5lZGVkJ1xuICAgICAgICBleHBsYW5hdGlvbiA9ICdDbGljayA8YSBocmVmPVwiJyArIG5ld1VybCArICdcIj5oZXJlPC9hPiB0byBzd2l0Y2ggdG8gSFRUUHMgd2hpY2ggaXMgbW9yZSBzYWZlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICcgYW5kIGVuYWJsZXMgZW5jcnlwdGVkIHZpZGVvbWFpbCB0cmFuc2ZlcnMuJ1xuICAgICAgICBjbGFzc0xpc3QucHVzaChWaWRlb21haWxFcnJvci5CUk9XU0VSX1BST0JMRU0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gVmlkZW9tYWlsRXJyb3IuRE9NX0VYQ0VQVElPTlxuICAgICAgICBleHBsYW5hdGlvbiA9IHByZXR0eShlcnIpXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgLy8gQ2hyb21lIGhhcyBhIHdlaXJkIHByb2JsZW0gd2hlcmUgaWYgeW91IHRyeSB0byBkbyBhIGdldFVzZXJNZWRpYSByZXF1ZXN0IHRvbyBlYXJseSwgaXRcbiAgICAvLyBjYW4gcmV0dXJuIGEgTWVkaWFEZXZpY2VOb3RTdXBwb3J0ZWQgZXJyb3IgKGV2ZW4gdGhvdWdoIG5vdGhpbmcgaXMgd3JvbmcgYW5kIHBlcm1pc3Npb25cbiAgICAvLyBoYXMgYmVlbiBncmFudGVkKS4gTG9vayBhdCB1c2VyTWVkaWFFcnJvckNhbGxiYWNrKCkgaW4gcmVjb3JkZXIsIHRoZXJlIHdlIGRvIG5vdFxuICAgIC8vIGVtaXQgdGhvc2Uga2luZCBvZiBlcnJvcnMgZnVydGhlciBhbmQganVzdCByZXRyeS5cbiAgICAvL1xuICAgIC8vIGJ1dCBmb3Igd2hhdGV2ZXIgcmVhc29ucywgaWYgaXQgaGFwcGVucyB0byByZWFjaCB0aGlzIGNvZGUsIHRoZW4gaW52ZXN0aWdhdGUgdGhpcyBmdXJ0aGVyLlxuICAgIGNhc2UgVmlkZW9tYWlsRXJyb3IuTUVESUFfREVWSUNFX05PVF9TVVBQT1JURUQ6XG4gICAgICBtZXNzYWdlID0gJ01lZGlhIGRldmljZSBub3Qgc3VwcG9ydGVkJ1xuICAgICAgZXhwbGFuYXRpb24gPSBwcmV0dHkoZXJyKVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBjb25zdCBvcmlnaW5hbEV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb25cblxuICAgICAgaWYgKGV4cGxhbmF0aW9uICYmIHR5cGVvZiBleHBsYW5hdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZXhwbGFuYXRpb24gPSBwcmV0dHkoZXhwbGFuYXRpb24pXG4gICAgICB9XG5cbiAgICAgIC8vIGl0IGNhbiBiZSB0aGF0IGV4cGxhbmF0aW9uIGl0c2VsZiBpcyBhbiBlcnJvciBvYmplY3RcbiAgICAgIC8vIGVycm9yIG9iamVjdHMgY2FuIGJlIHByZXR0aWZpZWQgdG8gdW5kZWZpbmVkIHNvbWV0aW1lc1xuICAgICAgaWYgKCFleHBsYW5hdGlvbiAmJiBvcmlnaW5hbEV4cGxhbmF0aW9uKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbEV4cGxhbmF0aW9uLm1lc3NhZ2UpIHtcbiAgICAgICAgICBleHBsYW5hdGlvbiA9IG9yaWdpbmFsRXhwbGFuYXRpb24ubWVzc2FnZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRyaWVkIHRvU3RyaW5nIGJlZm9yZSBidXQgbmFoXG4gICAgICAgICAgZXhwbGFuYXRpb24gPSB1dGlsLmluc3BlY3Qob3JpZ2luYWxFeHBsYW5hdGlvbiwge3Nob3dIaWRkZW46IHRydWV9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVyclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHByZXR0eShlcnIubWVzc2FnZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyICYmIGVyci5leHBsYW5hdGlvbikge1xuICAgICAgICAgIGlmICghZXhwbGFuYXRpb24pIHtcbiAgICAgICAgICAgIGV4cGxhbmF0aW9uID0gcHJldHR5KGVyci5leHBsYW5hdGlvbilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwbGFuYXRpb24gKz0gJzs8YnIvPicgKyBwcmV0dHkoZXJyLmV4cGxhbmF0aW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnIgJiYgZXJyLmRldGFpbHMpIHtcbiAgICAgICAgICB2YXIgZGV0YWlscyA9IHByZXR0eShlcnIuZGV0YWlscylcblxuICAgICAgICAgIGlmICghZXhwbGFuYXRpb24pIHtcbiAgICAgICAgICAgIGV4cGxhbmF0aW9uID0gZGV0YWlsc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHBsYW5hdGlvbiArPSAnOzxici8+JyArIGRldGFpbHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZm9yIHdlaXJkLCB1bmRlZmluZWQgY2FzZXNcbiAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICBpZiAoZXJyVHlwZSkge1xuICAgICAgICAgIG1lc3NhZ2UgPSBlcnJUeXBlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4cGxhbmF0aW9uICYmIGVycikge1xuICAgICAgICAgIGV4cGxhbmF0aW9uID0gcHJldHR5KGVyciwge2V4Y2x1ZGVzOiBbJ3N0YWNrJ119KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXZvaWQgZHVwZXNcbiAgICAgICAgaWYgKHByZXR0eShtZXNzYWdlKSA9PT0gZXhwbGFuYXRpb24pIHtcbiAgICAgICAgICBleHBsYW5hdGlvbiA9IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrXG4gIH1cblxuICB2YXIgbG9nTGluZXMgPSBudWxsXG5cbiAgaWYgKG9wdGlvbnMubG9nZ2VyICYmIG9wdGlvbnMubG9nZ2VyLmdldExpbmVzKSB7XG4gICAgbG9nTGluZXMgPSBvcHRpb25zLmxvZ2dlci5nZXRMaW5lcygpXG4gIH1cblxuICBpZiAoc3RhY2spIHtcbiAgICBtZXNzYWdlID0gbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgbWVzc2FnZS5zdGFjayA9IHN0YWNrXG4gIH1cblxuICB2YXIgZXJyQ29kZSA9ICdub25lJ1xuXG4gIGlmIChlcnIpIHtcbiAgICBlcnJDb2RlID0gJ2NvZGU9JyArIChlcnIuY29kZSA/IGVyci5jb2RlIDogJ3VuZGVmaW5lZCcpXG4gICAgZXJyQ29kZSArPSAnLCB0eXBlPScgKyAoZXJyLnR5cGUgPyBlcnIudHlwZSA6ICd1bmRlZmluZWQnKVxuICAgIGVyckNvZGUgKz0gJywgbmFtZT0nICsgKGVyci5uYW1lID8gZXJyLm5hbWUgOiAndW5kZWZpbmVkJylcbiAgfVxuXG4gIGNvbnN0IHZpZGVvbWFpbEVycm9yID0gbmV3IFZpZGVvbWFpbEVycm9yKG1lc3NhZ2UsIHtcbiAgICBleHBsYW5hdGlvbjogZXhwbGFuYXRpb24sXG4gICAgbG9nTGluZXM6IGxvZ0xpbmVzLFxuICAgIGNsaWVudDogYnJvd3Nlci5nZXRVc2VmdWxEYXRhKCksXG4gICAgdXJsOiB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICBjb2RlOiBlcnJDb2RlLFxuICAgIHN0YWNrOiBzdGFjayAvLyBoYXZlIHRvIGFzc2lnbiBpdCBtYW51YWxseSBhZ2FpbiBiZWNhdXNlIGl0IGlzIGtpbmRhIHByb3RlY3RlZFxuICB9KVxuXG4gIHZhciByZXNvdXJjZVxuICB2YXIgcmVwb3J0RXJyb3JzID0gZmFsc2VcblxuICBpZiAob3B0aW9ucy5yZXBvcnRFcnJvcnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVwb3J0RXJyb3JzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXBvcnRFcnJvcnMgPSBvcHRpb25zLnJlcG9ydEVycm9ycyh2aWRlb21haWxFcnJvcilcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwb3J0RXJyb3JzID0gb3B0aW9ucy5yZXBvcnRFcnJvcnNcbiAgICB9XG4gIH1cblxuICBpZiAocmVwb3J0RXJyb3JzKSB7XG4gICAgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2Uob3B0aW9ucylcbiAgfVxuXG4gIGlmIChyZXNvdXJjZSkge1xuICAgIHJlc291cmNlLnJlcG9ydEVycm9yKHZpZGVvbWFpbEVycm9yLCBmdW5jdGlvbiAoZXJyMikge1xuICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIHJlcG9ydCBlcnJvcicsIGVycjIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0NsYXNzIChuYW1lKSB7XG4gICAgcmV0dXJuIGNsYXNzTGlzdC5pbmRleE9mKG5hbWUpID49IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQnJvd3NlclByb2JsZW0gKCkge1xuICAgIHJldHVybiBoYXNDbGFzcyhWaWRlb21haWxFcnJvci5CUk9XU0VSX1BST0JMRU0pIHx8IHBhcmFtZXRlcnMuYnJvd3NlclByb2JsZW1cbiAgfVxuXG4gIC8vIGFkZCBzb21lIHB1YmxpYyBmdW5jdGlvbnNcblxuICAvLyB0aGlzIG9uZSBpcyB1c2VmdWwgc28gdGhhdCB0aGUgbm90aWZpZXIgY2FuIGhhdmUgZGlmZmVyZW50IGNzcyBjbGFzc2VzXG4gIHZpZGVvbWFpbEVycm9yLmdldENsYXNzTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2xhc3NMaXN0XG4gIH1cblxuICB2aWRlb21haWxFcnJvci5yZW1vdmVEaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoYXNDbGFzcyhWaWRlb21haWxFcnJvci5JT1NfUFJPQkxFTSkgfHwgYnJvd3Nlci5pc01vYmlsZSgpXG4gIH1cblxuICB2aWRlb21haWxFcnJvci5oaWRlQnV0dG9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNCcm93c2VyUHJvYmxlbSgpIHx8IGhhc0NsYXNzKFZpZGVvbWFpbEVycm9yLklPU19QUk9CTEVNKVxuICB9XG5cbiAgdmlkZW9tYWlsRXJyb3IuaGlkZUZvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGhhc0NsYXNzKFZpZGVvbWFpbEVycm9yLklPU19QUk9CTEVNKVxuICB9XG5cbiAgcmV0dXJuIHZpZGVvbWFpbEVycm9yXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZGVvbWFpbEVycm9yXG4iLCJpbXBvcnQgdXRpbCBmcm9tICd1dGlsJ1xuaW1wb3J0IGggZnJvbSAnaHlwZXJzY3JpcHQnXG5pbXBvcnQgaGlkZGVuIGZyb20gJ2hpZGRlbidcbmltcG9ydCBjb250YWlucyBmcm9tICdjb250YWlucydcblxuaW1wb3J0IEV2ZW50cyBmcm9tICcuLy4uL2V2ZW50cydcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi8uLi91dGlsL2V2ZW50RW1pdHRlcidcblxuY29uc3QgQnV0dG9ucyA9IGZ1bmN0aW9uIChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgb3B0aW9ucywgJ0J1dHRvbnMnKVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgdmFyIGJ1dHRvbnNFbGVtZW50XG4gIHZhciByZWNvcmRCdXR0b25cbiAgdmFyIHBhdXNlQnV0dG9uXG4gIHZhciByZXN1bWVCdXR0b25cbiAgdmFyIHByZXZpZXdCdXR0b25cbiAgdmFyIHJlY29yZEFnYWluQnV0dG9uXG4gIHZhciBzdWJtaXRCdXR0b25cblxuICB2YXIgYXVkaW9PblJhZGlvUGFpclxuICB2YXIgYXVkaW9PZmZSYWRpb1BhaXJcblxuICB2YXIgYnVpbHRcblxuICBmdW5jdGlvbiBoaWRlIChlbGVtZW50cykge1xuICAgIGlmIChlbGVtZW50cyAmJiAhQXJyYXkuaXNBcnJheShlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXVxuICAgIH1cblxuICAgIGVsZW1lbnRzICYmIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGhpZGRlbihlbGVtZW50LCB0cnVlKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBzaG93IChlbGVtZW50cykge1xuICAgIGlmIChlbGVtZW50cyAmJiAhQXJyYXkuaXNBcnJheShlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXVxuICAgIH1cblxuICAgIGVsZW1lbnRzICYmIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGhpZGRlbihlbGVtZW50LCBmYWxzZSlcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTaG93biAoZWxlbWVudHMpIHtcbiAgICB2YXIgaXNTaG93biA9IGVsZW1lbnRzICYmIHRydWVcblxuICAgIGlmIChlbGVtZW50cyAmJiAhQXJyYXkuaXNBcnJheShlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXVxuICAgIH1cblxuICAgIGVsZW1lbnRzICYmIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlzU2hvd24gPSBpc1Nob3duICYmIGVsZW1lbnQgJiYgIWhpZGRlbihlbGVtZW50KVxuICAgIH0pXG5cbiAgICByZXR1cm4gaXNTaG93blxuICB9XG5cbiAgZnVuY3Rpb24gZGlzYWJsZSAoZWxlbWVudHMpIHtcbiAgICBpZiAoZWxlbWVudHMgJiYgIUFycmF5LmlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50cyA9IFtlbGVtZW50c11cbiAgICB9XG5cbiAgICBlbGVtZW50cyAmJiBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnSU5QVVQnIHx8IGVsZW1lbnQudGFnTmFtZSA9PT0gJ0JVVFRPTicpIHtcbiAgICAgICAgZWxlbWVudC5kaXNhYmxlZCA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBlbmFibGUgKGVsZW1lbnRzKSB7XG4gICAgaWYgKGVsZW1lbnRzICYmICFBcnJheS5pc0FycmF5KGVsZW1lbnRzKSkge1xuICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdXG4gICAgfVxuXG4gICAgZWxlbWVudHMgJiYgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCBlbGVtZW50LnRhZ05hbWUgPT09ICdCVVRUT04nKSB7XG4gICAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlZCcpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdEJ1dHRvbiAoYnV0dG9uRWxlbWVudCwgc2hvdywgdHlwZSkge1xuICAgIGRpc2FibGUoYnV0dG9uRWxlbWVudClcblxuICAgIGlmICh0eXBlKSB7XG4gICAgICBidXR0b25FbGVtZW50LnR5cGUgPSB0eXBlXG4gICAgfSBlbHNlIGlmICghYnV0dG9uRWxlbWVudC50eXBlKSB7XG4gICAgICBidXR0b25FbGVtZW50LnR5cGUgPSAnYnV0dG9uJ1xuICAgIH1cblxuICAgICFzaG93ICYmIGhpZGUoYnV0dG9uRWxlbWVudClcblxuICAgIHJldHVybiBidXR0b25FbGVtZW50XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlQ2xpY2tIYW5kbGVyIChlbGVtZW50LCBjbGlja0hhbmRsZXIpIHtcbiAgICBjb25zdCB3cmFwcGVkQ2xpY2tIYW5kbGVyID0gKGUpID0+IHtcbiAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNsaWNrSGFuZGxlcih7ZXZlbnQ6IGV9KVxuICAgICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGV4YylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50Lm9uY2xpY2sgPSB3cmFwcGVkQ2xpY2tIYW5kbGVyXG4gIH1cblxuICBmdW5jdGlvbiBtYWtlUmFkaW9CdXR0b25QYWlyIChvcHRpb25zKSB7XG4gICAgdmFyIHJhZGlvQnV0dG9uRWxlbWVudFxuICAgIHZhciByYWRpb0J1dHRvbkdyb3VwXG5cbiAgICBpZiAob3B0aW9ucy5pZCkge1xuICAgICAgcmFkaW9CdXR0b25FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5pZClcbiAgICB9XG5cbiAgICBpZiAoIXJhZGlvQnV0dG9uRWxlbWVudCkge1xuICAgICAgcmFkaW9CdXR0b25FbGVtZW50ID0gaCgnaW5wdXQjJyArIG9wdGlvbnMuaWQsIHtcbiAgICAgICAgdHlwZTogJ3JhZGlvJyxcbiAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgY2hlY2tlZDogb3B0aW9ucy5jaGVja2VkXG4gICAgICB9KVxuXG4gICAgICByYWRpb0J1dHRvbkdyb3VwID0gaCgnc3Bhbi5yYWRpb0dyb3VwJywgcmFkaW9CdXR0b25FbGVtZW50LCBoKCdsYWJlbCcsIHtcbiAgICAgICAgJ2h0bWxGb3InOiBvcHRpb25zLmlkXG4gICAgICB9LCBvcHRpb25zLmxhYmVsKSlcblxuICAgICAgLy8gZG91YmxlIGNoZWNrIHRoYXQgc3VibWl0IGJ1dHRvbiBpcyBhbHJlYWR5IGluIHRoZSBidXR0b25zRWxlbWVudCBjb250YWluZXIgYXMgYSBjaGlsZD9cbiAgICAgIGlmIChzdWJtaXRCdXR0b24gJiYgY29udGFpbnMoYnV0dG9uc0VsZW1lbnQsIHN1Ym1pdEJ1dHRvbikpIHtcbiAgICAgICAgYnV0dG9uc0VsZW1lbnQuaW5zZXJ0QmVmb3JlKHJhZGlvQnV0dG9uR3JvdXAsIHN1Ym1pdEJ1dHRvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1dHRvbnNFbGVtZW50LmFwcGVuZENoaWxkKHJhZGlvQnV0dG9uR3JvdXApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY2hhbmdlSGFuZGxlcikge1xuICAgICAgcmFkaW9CdXR0b25FbGVtZW50Lm9uY2hhbmdlID0gb3B0aW9ucy5jaGFuZ2VIYW5kbGVyXG4gICAgfVxuXG4gICAgZGlzYWJsZShyYWRpb0J1dHRvbkVsZW1lbnQpXG5cbiAgICByZXR1cm4gW3JhZGlvQnV0dG9uRWxlbWVudCwgcmFkaW9CdXR0b25Hcm91cF1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VCdXR0b24gKGJ1dHRvbkNsYXNzLCB0ZXh0LCBjbGlja0hhbmRsZXIsIHNob3csIGlkLCB0eXBlLCBzZWxlY3Rvcikge1xuICAgIHZhciBidXR0b25FbGVtZW50XG5cbiAgICBpZiAoaWQpIHtcbiAgICAgIGJ1dHRvbkVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZClcbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBidXR0b25FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICB9IGVsc2Uge1xuICAgICAgYnV0dG9uRWxlbWVudCA9IGJ1dHRvbnNFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgYnV0dG9uQ2xhc3MpXG4gICAgfVxuXG4gICAgaWYgKCFidXR0b25FbGVtZW50KSB7XG4gICAgICBpZiAob3B0aW9ucy5zZWxlY3RvcnMuYnV0dG9uQ2xhc3MpIHtcbiAgICAgICAgYnV0dG9uQ2xhc3MgKz0gJy4nICsgb3B0aW9ucy5zZWxlY3RvcnMuYnV0dG9uQ2xhc3NcbiAgICAgIH1cblxuICAgICAgYnV0dG9uRWxlbWVudCA9IGgoJ2J1dHRvbi4nICsgYnV0dG9uQ2xhc3MpXG4gICAgICBidXR0b25FbGVtZW50ID0gYWRqdXN0QnV0dG9uKGJ1dHRvbkVsZW1lbnQsIHNob3csIHR5cGUpXG5cbiAgICAgIGJ1dHRvbkVsZW1lbnQuaW5uZXJIVE1MID0gdGV4dFxuXG4gICAgICAvLyBkb3VibGUgY2hlY2sgdGhhdCBzdWJtaXQgYnV0dG9uIGlzIGFscmVhZHkgaW4gdGhlIGJ1dHRvbnNFbGVtZW50IGNvbnRhaW5lclxuICAgICAgaWYgKHN1Ym1pdEJ1dHRvbiAmJiBjb250YWlucyhidXR0b25zRWxlbWVudCwgc3VibWl0QnV0dG9uKSkge1xuICAgICAgICBidXR0b25zRWxlbWVudC5pbnNlcnRCZWZvcmUoYnV0dG9uRWxlbWVudCwgc3VibWl0QnV0dG9uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnV0dG9uc0VsZW1lbnQuYXBwZW5kQ2hpbGQoYnV0dG9uRWxlbWVudClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnV0dG9uRWxlbWVudCA9IGFkanVzdEJ1dHRvbihidXR0b25FbGVtZW50LCBzaG93KVxuICAgIH1cblxuICAgIGlmIChjbGlja0hhbmRsZXIpIHtcbiAgICAgIHJlcGxhY2VDbGlja0hhbmRsZXIoYnV0dG9uRWxlbWVudCwgY2xpY2tIYW5kbGVyKVxuICAgIH1cblxuICAgIHJldHVybiBidXR0b25FbGVtZW50XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZEJ1dHRvbnMgKCkge1xuICAgIGlmICghb3B0aW9ucy5kaXNhYmxlU3VibWl0KSB7XG4gICAgICBpZiAoIXN1Ym1pdEJ1dHRvbikge1xuICAgICAgICBzdWJtaXRCdXR0b24gPSBtYWtlQnV0dG9uKFxuICAgICAgICAgIG9wdGlvbnMuc2VsZWN0b3JzLnN1Ym1pdEJ1dHRvbkNsYXNzLFxuICAgICAgICAgICdTdWJtaXQnLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBvcHRpb25zLnNlbGVjdG9ycy5zdWJtaXRCdXR0b25JZCxcbiAgICAgICAgICAnc3VibWl0JyxcbiAgICAgICAgICBvcHRpb25zLnNlbGVjdG9ycy5zdWJtaXRCdXR0b25TZWxlY3RvclxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNhYmxlKHN1Ym1pdEJ1dHRvbilcbiAgICAgIH1cblxuICAgICAgLy8gbm8gbmVlZCB0byBsaXN0ZW4gdG8gdGhlIHN1Ym1pdCBldmVudCB3aGVuIGl0J3MgYWxyZWFkeSBsaXN0ZW5lZFxuICAgICAgLy8gd2l0aGluIHRoZSBmb3JtIGVsZW1lbnQgY2xhc3NcbiAgICAgIGlmICghY29udGFpbmVyLmhhc0Zvcm0oKSAmJiBzdWJtaXRCdXR0b24pIHtcbiAgICAgICAgcmVwbGFjZUNsaWNrSGFuZGxlcihzdWJtaXRCdXR0b24sIHN1Ym1pdClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWNvcmRCdXR0b24gPSBtYWtlQnV0dG9uKFxuICAgICAgb3B0aW9ucy5zZWxlY3RvcnMucmVjb3JkQnV0dG9uQ2xhc3MsXG4gICAgICBvcHRpb25zLnRleHQuYnV0dG9ucy5yZWNvcmQsXG4gICAgICByZWNvcmQsXG4gICAgICBmYWxzZVxuICAgIClcblxuICAgIGlmIChvcHRpb25zLmVuYWJsZVBhdXNlKSB7XG4gICAgICBwYXVzZUJ1dHRvbiA9IG1ha2VCdXR0b24oXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0b3JzLnBhdXNlQnV0dG9uQ2xhc3MsXG4gICAgICAgIG9wdGlvbnMudGV4dC5idXR0b25zLnBhdXNlLFxuICAgICAgICBjb250YWluZXIucGF1c2UsXG4gICAgICAgIGZhbHNlXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlUGF1c2UpIHtcbiAgICAgIHJlc3VtZUJ1dHRvbiA9IG1ha2VCdXR0b24oXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0b3JzLnJlc3VtZUJ1dHRvbkNsYXNzLFxuICAgICAgICBvcHRpb25zLnRleHQuYnV0dG9ucy5yZXN1bWUsXG4gICAgICAgIGNvbnRhaW5lci5yZXN1bWUsXG4gICAgICAgIGZhbHNlXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gc2hvdyBzdG9wIG9ubHkgd2hlbiBwYXVzZSBpcyBlbmFibGVkIC0gbG9va3MgYmV0dGVyIHRoYXQgd2F5IG90aGVyd2lzZSBidXR0b25cbiAgICAvLyBtb3ZlIGxlZnQgYW5kIHJpZ2h0IGJldHdlZW4gcmVjb3JkIGFuZCBzdG9wIChwcmV2aWV3KVxuICAgIHByZXZpZXdCdXR0b24gPSBtYWtlQnV0dG9uKFxuICAgICAgb3B0aW9ucy5zZWxlY3RvcnMucHJldmlld0J1dHRvbkNsYXNzLFxuICAgICAgb3B0aW9ucy50ZXh0LmJ1dHRvbnMucHJldmlldyxcbiAgICAgIGNvbnRhaW5lci5zdG9wLFxuICAgICAgZmFsc2VcbiAgICApXG5cbiAgICByZWNvcmRBZ2FpbkJ1dHRvbiA9IG1ha2VCdXR0b24oXG4gICAgICBvcHRpb25zLnNlbGVjdG9ycy5yZWNvcmRBZ2FpbkJ1dHRvbkNsYXNzLFxuICAgICAgb3B0aW9ucy50ZXh0LmJ1dHRvbnMucmVjb3JkQWdhaW4sXG4gICAgICByZWNvcmRBZ2FpbixcbiAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgaWYgKG9wdGlvbnMuYXVkaW8gJiYgb3B0aW9ucy5hdWRpby5zd2l0Y2gpIHtcbiAgICAgIGF1ZGlvT2ZmUmFkaW9QYWlyID0gbWFrZVJhZGlvQnV0dG9uUGFpcih7XG4gICAgICAgIGlkOiAnYXVkaW9PZmZPcHRpb24nLFxuICAgICAgICBuYW1lOiAnYXVkaW8nLFxuICAgICAgICB2YWx1ZTogJ29mZicsXG4gICAgICAgIGxhYmVsOiAnQXVkaW8gT2ZmJyxcbiAgICAgICAgY2hlY2tlZDogIW9wdGlvbnMuaXNBdWRpb0VuYWJsZWQoKSxcbiAgICAgICAgY2hhbmdlSGFuZGxlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5kaXNhYmxlQXVkaW8oKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBhdWRpb09uUmFkaW9QYWlyID0gbWFrZVJhZGlvQnV0dG9uUGFpcih7XG4gICAgICAgIGlkOiAnYXVkaW9Pbk9wdGlvbicsXG4gICAgICAgIG5hbWU6ICdhdWRpbycsXG4gICAgICAgIHZhbHVlOiAnb24nLFxuICAgICAgICBsYWJlbDogJ0F1ZGlvIE9uIChCZXRhKScsXG4gICAgICAgIGNoZWNrZWQ6IG9wdGlvbnMuaXNBdWRpb0VuYWJsZWQoKSxcbiAgICAgICAgY2hhbmdlSGFuZGxlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5lbmFibGVBdWRpbygpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Gb3JtUmVhZHkgKG9wdGlvbnMpIHtcbiAgICAvLyBubyBuZWVkIHRvIHNob3cgcmVjb3JkIGJ1dHRvbiB3aGVuIGRvaW5nIGEgcmVjb3JkIGFnYWluXG4gICAgaWYgKCFpc1Nob3duKHJlY29yZEFnYWluQnV0dG9uKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnBhdXNlZCkge1xuICAgICAgICBzaG93KHJlY29yZEJ1dHRvbilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMucGF1c2VkKSB7XG4gICAgICBkaXNhYmxlKHByZXZpZXdCdXR0b24pXG4gICAgICBoaWRlKHByZXZpZXdCdXR0b24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Hb2luZ0JhY2sgKCkge1xuICAgIGhpZGUocmVjb3JkQWdhaW5CdXR0b24pXG4gICAgc2hvdyhyZWNvcmRCdXR0b24pXG4gIH1cblxuICBmdW5jdGlvbiBvblJlcGxheVNob3duICgpIHtcbiAgICBzZWxmLmhpZGUoKVxuICB9XG5cbiAgZnVuY3Rpb24gb25Vc2VyTWVkaWFSZWFkeSAob3B0aW9ucykge1xuICAgIG9uRm9ybVJlYWR5KG9wdGlvbnMpXG5cbiAgICBpZiAoaXNTaG93bihyZWNvcmRCdXR0b24pKSB7XG4gICAgICBlbmFibGUocmVjb3JkQnV0dG9uKVxuICAgIH1cblxuICAgIGlmIChpc1Nob3duKGF1ZGlvT25SYWRpb1BhaXIpKSB7XG4gICAgICBlbmFibGUoYXVkaW9PblJhZGlvUGFpcilcbiAgICB9XG5cbiAgICBpZiAoaXNTaG93bihhdWRpb09mZlJhZGlvUGFpcikpIHtcbiAgICAgIGVuYWJsZShhdWRpb09mZlJhZGlvUGFpcilcbiAgICB9XG5cbiAgICBkaXNhYmxlKHN1Ym1pdEJ1dHRvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUmVzZXR0aW5nICgpIHtcbiAgICBkaXNhYmxlKHN1Ym1pdEJ1dHRvbilcblxuICAgIHNlbGYucmVzZXQoKVxuICB9XG5cbiAgZnVuY3Rpb24gb25QcmV2aWV3ICgpIHtcbiAgICBoaWRlKHJlY29yZEJ1dHRvbilcbiAgICBoaWRlKHByZXZpZXdCdXR0b24pXG4gICAgZGlzYWJsZShhdWRpb09uUmFkaW9QYWlyKVxuICAgIGRpc2FibGUoYXVkaW9PZmZSYWRpb1BhaXIpXG5cbiAgICBzaG93KHJlY29yZEFnYWluQnV0dG9uKVxuICAgIGVuYWJsZShyZWNvcmRBZ2FpbkJ1dHRvbilcblxuICAgIGlmICghb3B0aW9ucy5lbmFibGVBdXRvVmFsaWRhdGlvbikge1xuICAgICAgZW5hYmxlKHN1Ym1pdEJ1dHRvbilcbiAgICB9XG4gIH1cblxuICB0aGlzLmVuYWJsZVN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbmFibGUoc3VibWl0QnV0dG9uKVxuICB9XG5cbiAgdGhpcy5hZGp1c3RCdXR0b25zRm9yUGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzZWxmLmlzQ291bnRpbmdEb3duKCkpIHtcbiAgICAgIHBhdXNlQnV0dG9uICYmIGhpZGUocGF1c2VCdXR0b24pXG4gICAgICBzaG93KHJlc3VtZUJ1dHRvbilcbiAgICAgIGVuYWJsZShyZXN1bWVCdXR0b24pXG4gICAgICBoaWRlKHJlY29yZEJ1dHRvbilcbiAgICAgIHNob3cocHJldmlld0J1dHRvbilcbiAgICAgIGVuYWJsZShwcmV2aWV3QnV0dG9uKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRmlyc3RGcmFtZVNlbnQgKCkge1xuICAgIGhpZGUocmVjb3JkQnV0dG9uKVxuICAgIGhpZGUocmVjb3JkQWdhaW5CdXR0b24pXG5cbiAgICBpZiAocGF1c2VCdXR0b24pIHtcbiAgICAgIHNob3cocGF1c2VCdXR0b24pXG4gICAgICBlbmFibGUocGF1c2VCdXR0b24pXG4gICAgfVxuXG4gICAgZW5hYmxlKHByZXZpZXdCdXR0b24pXG4gICAgc2hvdyhwcmV2aWV3QnV0dG9uKVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZWNvcmRpbmcgKGZyYW1lc0NvdW50KSB7XG4gICAgLy8gaXQgaXMgcG9zc2libGUgdG8gaGlkZSB3aGlsZSByZWNvcmRpbmcsIGhlbmNlXG4gICAgLy8gY2hlY2sgZnJhbWVzQ291bnQgZmlyc3QgKGNvbWluZyBmcm9tIHJlY29yZGVyKVxuICAgIGlmIChmcmFtZXNDb3VudCA+IDEpIHtcbiAgICAgIG9uRmlyc3RGcmFtZVNlbnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBkaXNhYmxlKGF1ZGlvT2ZmUmFkaW9QYWlyKVxuICAgICAgZGlzYWJsZShhdWRpb09uUmFkaW9QYWlyKVxuICAgICAgZGlzYWJsZShyZWNvcmRBZ2FpbkJ1dHRvbilcbiAgICAgIGRpc2FibGUocmVjb3JkQnV0dG9uKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUmVzdW1pbmcgKCkge1xuICAgIGhpZGUocmVzdW1lQnV0dG9uKVxuICAgIGhpZGUocmVjb3JkQnV0dG9uKVxuXG4gICAgaWYgKHBhdXNlQnV0dG9uKSB7XG4gICAgICBlbmFibGUocGF1c2VCdXR0b24pXG4gICAgICBzaG93KHBhdXNlQnV0dG9uKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU3RvcHBpbmcgKCkge1xuICAgIGRpc2FibGUocHJldmlld0J1dHRvbilcbiAgICBoaWRlKHBhdXNlQnV0dG9uKVxuICAgIGhpZGUocmVzdW1lQnV0dG9uKVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db3VudGRvd24gKCkge1xuICAgIGRpc2FibGUocmVjb3JkQnV0dG9uKVxuICAgIGRpc2FibGUoYXVkaW9PZmZSYWRpb1BhaXIpXG4gICAgZGlzYWJsZShhdWRpb09uUmFkaW9QYWlyKVxuICB9XG5cbiAgZnVuY3Rpb24gb25TdWJtaXR0aW5nICgpIHtcbiAgICBkaXNhYmxlKHN1Ym1pdEJ1dHRvbilcbiAgICBkaXNhYmxlKHJlY29yZEFnYWluQnV0dG9uKVxuICB9XG5cbiAgZnVuY3Rpb24gb25TdWJtaXR0ZWQgKCkge1xuICAgIGRpc2FibGUocHJldmlld0J1dHRvbilcbiAgICBkaXNhYmxlKHJlY29yZEFnYWluQnV0dG9uKVxuICAgIGRpc2FibGUocmVjb3JkQnV0dG9uKVxuICAgIGRpc2FibGUoc3VibWl0QnV0dG9uKVxuICB9XG5cbiAgZnVuY3Rpb24gb25JbnZhbGlkICgpIHtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVBdXRvVmFsaWRhdGlvbikge1xuICAgICAgZGlzYWJsZShzdWJtaXRCdXR0b24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25WYWxpZCAoKSB7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlQXV0b1ZhbGlkYXRpb24pIHtcbiAgICAgIGVuYWJsZShzdWJtaXRCdXR0b24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25IaWRkZW4gKCkge1xuICAgIGhpZGUocmVjb3JkQnV0dG9uKVxuICAgIGhpZGUocHJldmlld0J1dHRvbilcbiAgICBoaWRlKHJlY29yZEFnYWluQnV0dG9uKVxuICAgIGhpZGUocmVzdW1lQnV0dG9uKVxuICB9XG5cbiAgZnVuY3Rpb24gb25FbmFibGluZ0F1ZGlvICgpIHtcbiAgICBkaXNhYmxlKHJlY29yZEJ1dHRvbilcbiAgICBkaXNhYmxlKGF1ZGlvT25SYWRpb1BhaXIpXG4gICAgZGlzYWJsZShhdWRpb09mZlJhZGlvUGFpcilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRGlzYWJsaW5nQXVkaW8gKCkge1xuICAgIGRpc2FibGUocmVjb3JkQnV0dG9uKVxuICAgIGRpc2FibGUoYXVkaW9PblJhZGlvUGFpcilcbiAgICBkaXNhYmxlKGF1ZGlvT2ZmUmFkaW9QYWlyKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkQWdhaW4gKCkge1xuICAgIGRpc2FibGUocmVjb3JkQWdhaW5CdXR0b24pXG4gICAgY29udGFpbmVyLmJlZ2luV2FpdGluZygpXG4gICAgY29udGFpbmVyLnJlY29yZEFnYWluKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHN1Ym1pdCAoKSB7XG4gICAgY29udGFpbmVyLnN1Ym1pdCgpXG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmQgKHBhcmFtcykge1xuICAgIGRpc2FibGUocmVjb3JkQnV0dG9uKVxuICAgIGNvbnRhaW5lci5yZWNvcmQocGFyYW1zKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEV2ZW50cyAoKSB7XG4gICAgc2VsZi5vbihFdmVudHMuVVNFUl9NRURJQV9SRUFEWSwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9uVXNlck1lZGlhUmVhZHkob3B0aW9ucylcbiAgICB9KS5vbihFdmVudHMuUFJFVklFVywgZnVuY3Rpb24gKCkge1xuICAgICAgb25QcmV2aWV3KClcbiAgICB9KS5vbihFdmVudHMuUEFVU0VELCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmFkanVzdEJ1dHRvbnNGb3JQYXVzZSgpXG4gICAgfSkub24oRXZlbnRzLlJFQ09SRElORywgZnVuY3Rpb24gKGZyYW1lc0NvdW50KSB7XG4gICAgICBvblJlY29yZGluZyhmcmFtZXNDb3VudClcbiAgICB9KS5vbihFdmVudHMuRklSU1RfRlJBTUVfU0VOVCwgZnVuY3Rpb24gKCkge1xuICAgICAgb25GaXJzdEZyYW1lU2VudCgpXG4gICAgfSkub24oRXZlbnRzLlJFU1VNSU5HLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvblJlc3VtaW5nKClcbiAgICB9KS5vbihFdmVudHMuU1RPUFBJTkcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uU3RvcHBpbmcoKVxuICAgIH0pLm9uKEV2ZW50cy5DT1VOVERPV04sIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uQ291bnRkb3duKClcbiAgICB9KS5vbihFdmVudHMuU1VCTUlUVElORywgZnVuY3Rpb24gKCkge1xuICAgICAgb25TdWJtaXR0aW5nKClcbiAgICB9KS5vbihFdmVudHMuUkVTRVRUSU5HLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvblJlc2V0dGluZygpXG4gICAgfSkub24oRXZlbnRzLklOVkFMSUQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uSW52YWxpZCgpXG4gICAgfSkub24oRXZlbnRzLlZBTElELCBmdW5jdGlvbiAoKSB7XG4gICAgICBvblZhbGlkKClcbiAgICB9KS5vbihFdmVudHMuU1VCTUlUVEVELCBmdW5jdGlvbiAoKSB7XG4gICAgICBvblN1Ym1pdHRlZCgpXG4gICAgfSkub24oRXZlbnRzLkhJREUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uSGlkZGVuKClcbiAgICB9KS5vbihFdmVudHMuRk9STV9SRUFEWSwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9uRm9ybVJlYWR5KG9wdGlvbnMpXG4gICAgfSkub24oRXZlbnRzLlJFUExBWV9TSE9XTiwgZnVuY3Rpb24gKCkge1xuICAgICAgb25SZXBsYXlTaG93bigpXG4gICAgfSkub24oRXZlbnRzLkdPSU5HX0JBQ0ssIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uR29pbmdCYWNrKClcbiAgICB9KS5vbihFdmVudHMuRU5BQkxJTkdfQVVESU8sIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uRW5hYmxpbmdBdWRpbygpXG4gICAgfSkub24oRXZlbnRzLkRJU0FCTElOR19BVURJTywgZnVuY3Rpb24gKCkge1xuICAgICAgb25EaXNhYmxpbmdBdWRpbygpXG4gICAgfSkub24oRXZlbnRzLkVSUk9SLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAvLyBzaW5jZSBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwtY2xpZW50L2lzc3Vlcy82MFxuICAgICAgLy8gd2UgaGlkZSBhcmVhcyB0byBtYWtlIGl0IGVhc2llciBmb3IgdGhlIHVzZXJcbiAgICAgIGlmIChlcnIuaGlkZUJ1dHRvbnMgJiYgZXJyLmhpZGVCdXR0b25zKCkgJiYgb3B0aW9ucy5hZGp1c3RGb3JtT25Ccm93c2VyRXJyb3IpIHtcbiAgICAgICAgc2VsZi5oaWRlKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvcHRpb25zLmRlYnVnKCdCdXR0b25zOiByZXNldCgpJylcblxuICAgIGRpc2FibGUocGF1c2VCdXR0b24pXG4gICAgZGlzYWJsZShyZXN1bWVCdXR0b24pXG4gICAgZGlzYWJsZShyZWNvcmRCdXR0b24pXG4gICAgZGlzYWJsZShwcmV2aWV3QnV0dG9uKVxuICAgIGRpc2FibGUocmVjb3JkQWdhaW5CdXR0b24pXG4gIH1cblxuICB0aGlzLmlzUmVjb3JkQWdhaW5CdXR0b25FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhcmVjb3JkQWdhaW5CdXR0b24uZGlzYWJsZWRcbiAgfVxuXG4gIHRoaXMuaXNSZWNvcmRCdXR0b25FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhcmVjb3JkQnV0dG9uLmRpc2FibGVkXG4gIH1cblxuICB0aGlzLnNldFN1Ym1pdEJ1dHRvbiA9IGZ1bmN0aW9uIChuZXdTdWJtaXRCdXR0b24pIHtcbiAgICBzdWJtaXRCdXR0b24gPSBuZXdTdWJtaXRCdXR0b25cbiAgfVxuXG4gIHRoaXMuZ2V0U3VibWl0QnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzdWJtaXRCdXR0b25cbiAgfVxuXG4gIHRoaXMuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgYnV0dG9uc0VsZW1lbnQgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLicgKyBvcHRpb25zLnNlbGVjdG9ycy5idXR0b25zQ2xhc3MpXG5cbiAgICBpZiAoIWJ1dHRvbnNFbGVtZW50KSB7XG4gICAgICBidXR0b25zRWxlbWVudCA9IGgoJ2Rpdi4nICsgb3B0aW9ucy5zZWxlY3RvcnMuYnV0dG9uc0NsYXNzKVxuXG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYnV0dG9uc0VsZW1lbnQpXG4gICAgfVxuXG4gICAgYnVpbGRCdXR0b25zKClcblxuICAgICFidWlsdCAmJiBpbml0RXZlbnRzKClcblxuICAgIGJ1aWx0ID0gdHJ1ZVxuICB9XG5cbiAgdGhpcy51bmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgYnVpbHQgPSBmYWxzZVxuICB9XG5cbiAgdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGhpZGUoYnV0dG9uc0VsZW1lbnQpXG4gIH1cblxuICB0aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2hvdyhidXR0b25zRWxlbWVudClcbiAgfVxuXG4gIHRoaXMuaXNDb3VudGluZ0Rvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pc0NvdW50aW5nRG93bigpXG4gIH1cbn1cblxudXRpbC5pbmhlcml0cyhCdXR0b25zLCBFdmVudEVtaXR0ZXIpXG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbnNcbiIsImltcG9ydCBpbnNlcnRDc3MgZnJvbSAnaW5zZXJ0LWNzcydcbmltcG9ydCBtZXJnZSBmcm9tICdtZXJnZS1yZWN1cnNpdmUnXG5pbXBvcnQgaGlkZGVuIGZyb20gJ2hpZGRlbidcbmltcG9ydCB1dGlsIGZyb20gJ3V0aWwnXG5pbXBvcnQgVmlzaWJpbGl0eSBmcm9tICdkb2N1bWVudC12aXNpYmlsaXR5J1xuXG5pbXBvcnQgRGltZW5zaW9uIGZyb20gJy4vZGltZW5zaW9uJ1xuaW1wb3J0IFZpc3VhbHMgZnJvbSAnLi92aXN1YWxzJ1xuaW1wb3J0IEJ1dHRvbnMgZnJvbSAnLi9idXR0b25zJ1xuaW1wb3J0IEZvcm0gZnJvbSAnLi9mb3JtJ1xuXG5pbXBvcnQgUmVzb3VyY2UgZnJvbSAnLi8uLi9yZXNvdXJjZSdcbmltcG9ydCBFdmVudHMgZnJvbSAnLi8uLi9ldmVudHMnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi8uLi91dGlsL2V2ZW50RW1pdHRlcidcbmltcG9ydCBWaWRlb21haWxFcnJvciBmcm9tICcuLy4uL3V0aWwvdmlkZW9tYWlsRXJyb3InXG5pbXBvcnQgY3NzIGZyb20gJy4vLi4vc3R5bGVzL2Nzcy9tYWluLm1pbi5jc3MuanMnXG5cbnZhciBDb250YWluZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzLCBvcHRpb25zLCAnQ29udGFpbmVyJylcblxuICBjb25zdCBzZWxmID0gdGhpc1xuXG4gIGNvbnN0IHZpc2liaWxpdHkgPSBWaXNpYmlsaXR5KClcbiAgY29uc3QgdmlzdWFscyA9IG5ldyBWaXN1YWxzKHRoaXMsIG9wdGlvbnMpXG4gIGNvbnN0IGJ1dHRvbnMgPSBuZXcgQnV0dG9ucyh0aGlzLCBvcHRpb25zKVxuICBjb25zdCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZShvcHRpb25zKVxuICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCcpXG4gIGNvbnN0IGRlYnVnID0gb3B0aW9ucy5kZWJ1Z1xuXG4gIHZhciBoYXNFcnJvciA9IGZhbHNlXG4gIHZhciBzdWJtaXR0ZWQgPSBmYWxzZVxuICB2YXIgbGFzdFZhbGlkYXRpb24gPSBmYWxzZVxuXG4gIHZhciBjb250YWluZXJFbGVtZW50XG4gIHZhciBidWlsdFxuICB2YXIgZm9ybVxuXG4gIGZ1bmN0aW9uIHByZXBlbmREZWZhdWx0Q3NzICgpIHtcbiAgICBpbnNlcnRDc3MoY3NzLCB7cHJlcGVuZDogdHJ1ZX0pXG4gIH1cblxuICAgIC8vIHNpbmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC1jbGllbnQvaXNzdWVzLzg3XG4gIGZ1bmN0aW9uIGZpbmRQYXJlbnRGb3JtRWxlbWVudCAoKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lckVsZW1lbnQuY2xvc2VzdCgnZm9ybScpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRGb3JtRWxlbWVudCAoKSB7XG4gICAgdmFyIGZvcm1FbGVtZW50XG5cbiAgICBpZiAoY29udGFpbmVyRWxlbWVudC50YWdOYW1lID09PSAnRk9STScpIHtcbiAgICAgIGZvcm1FbGVtZW50ID0gY29udGFpbmVyRWxlbWVudFxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZWxlY3RvcnMuZm9ybUlkKSB7XG4gICAgICBmb3JtRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuc2VsZWN0b3JzLmZvcm1JZClcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybUVsZW1lbnQgPSBmaW5kUGFyZW50Rm9ybUVsZW1lbnQoKVxuICAgIH1cblxuICAgIHJldHVybiBmb3JtRWxlbWVudFxuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRGb3JtICgpIHtcbiAgICBkZWJ1ZygnQ29udGFpbmVyOiBidWlsZEZvcm0oKScpXG5cbiAgICBjb25zdCBmb3JtRWxlbWVudCA9IGdldEZvcm1FbGVtZW50KClcblxuICAgIGlmIChmb3JtRWxlbWVudCkge1xuICAgICAgZm9ybSA9IG5ldyBGb3JtKHNlbGYsIGZvcm1FbGVtZW50LCBvcHRpb25zKVxuXG4gICAgICBjb25zdCBzdWJtaXRCdXR0b24gPSBmb3JtLmZpbmRTdWJtaXRCdXR0b24oKVxuICAgICAgc3VibWl0QnV0dG9uICYmIGJ1dHRvbnMuc2V0U3VibWl0QnV0dG9uKHN1Ym1pdEJ1dHRvbilcblxuICAgICAgZm9ybS5idWlsZCgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRDaGlsZHJlbiAoKSB7XG4gICAgZGVidWcoJ0NvbnRhaW5lcjogYnVpbGRDaGlsZHJlbigpJylcblxuICAgIGlmICghY29udGFpbmVyRWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnU29ycnksIHlvdXIgYnJvd3NlciBpcyB0b28gb2xkIScsIG9wdGlvbnMpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3ZpZGVvbWFpbCcpXG5cbiAgICAgIGJ1dHRvbnMuYnVpbGQoKVxuICAgICAgdmlzdWFscy5idWlsZCgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0Vycm9yIChlcnIpIHtcbiAgICBoYXNFcnJvciA9IHRydWVcblxuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIG9wdGlvbnMubG9nZ2VyLmVycm9yKGVyci5zdGFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5sb2dnZXIuZXJyb3IoZXJyKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRpc3BsYXlFcnJvcnMpIHtcbiAgICAgIHZpc3VhbHMuZXJyb3IoZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICB2aXN1YWxzLnJlc2V0KClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0RXZlbnRzICgpIHtcbiAgICBkZWJ1ZygnQ29udGFpbmVyOiBpbml0RXZlbnRzKCknKVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIChlKSA9PiB7XG4gICAgICBzZWxmLnVubG9hZChlKVxuICAgIH0pXG5cbiAgICB2aXNpYmlsaXR5Lm9uQ2hhbmdlKCh2aXNpYmxlKSA9PiB7XG4gICAgICAvLyBidWlsdD8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC5pby9pc3N1ZXMvMzI2XG4gICAgICBpZiAoYnVpbHQpIHtcbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5pc0F1dG9QYXVzZUVuYWJsZWQoKSAmJiBzZWxmLmlzQ291bnRpbmdEb3duKCkpIHtcbiAgICAgICAgICAgIHNlbGYucmVzdW1lKClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLmVtaXQoRXZlbnRzLlZJU0lCTEUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaXNBdXRvUGF1c2VFbmFibGVkKCkgJiYgKHNlbGYuaXNDb3VudGluZ0Rvd24oKSB8fCBzZWxmLmlzUmVjb3JkaW5nKCkpKSB7XG4gICAgICAgICAgICBzZWxmLnBhdXNlKCdkb2N1bWVudCBpbnZpc2libGUnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuZW1pdChFdmVudHMuSU5WSVNJQkxFKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmIChvcHRpb25zLmVuYWJsZVNwYWNlKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gZS50YXJnZXQudGFnTmFtZVxuXG4gICAgICAgIGlmICh0YWdOYW1lICE9PSAnSU5QVVQnICYmIHRhZ05hbWUgIT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgICBjb25zdCBjb2RlID0gZS5rZXlDb2RlID8gZS5rZXlDb2RlIDogZS53aGljaFxuXG4gICAgICAgICAgaWYgKGNvZGUgPT09IDMyKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlUGF1c2UpIHtcbiAgICAgICAgICAgICAgdmlzdWFscy5wYXVzZU9yUmVzdW1lKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZpc3VhbHMucmVjb3JkT3JTdG9wKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gYmV0dGVyIHRvIGtlZXAgdGhlIG9uZSBhbmQgb25seSBlcnJvciBsaXN0ZW5lcnNcbiAgICAvLyBhdCBvbmUgc3BvdCwgaGVyZSwgYmVjYXVzZSB1bmxvYWQoKSB3aWxsIGRvIGEgcmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgICBzZWxmLm9uKEV2ZW50cy5FUlJPUiwgKGVycikgPT4ge1xuICAgICAgcHJvY2Vzc0Vycm9yKGVycilcbiAgICAgIHVubG9hZENoaWxkcmVuKGVycilcblxuICAgICAgaWYgKGVyci5yZW1vdmVEaW1lbnNpb25zICYmIGVyci5yZW1vdmVEaW1lbnNpb25zKCkpIHtcbiAgICAgICAgcmVtb3ZlRGltZW5zaW9ucygpXG4gICAgICB9XG4gICAgfSlcbiAgICAub24oRXZlbnRzLkxPQURFRF9NRVRBX0RBVEEsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvcnJlY3REaW1lbnNpb25zKClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zICgpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNEZWZpbmVkV2lkdGgoKSAmJiBvcHRpb25zLnZpZGVvLndpZHRoICUgMiAhPT0gMCkge1xuICAgICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdXaWR0aCBtdXN0IGJlIGRpdmlzaWJsZSBieSB0d28uJywgb3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5oYXNEZWZpbmVkSGVpZ2h0KCkgJiYgb3B0aW9ucy52aWRlby5oZWlnaHQgJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ0hlaWdodCBtdXN0IGJlIGRpdmlzaWJsZSBieSB0d28uJywgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICAgIC8vIHRoaXMgd2lsbCBqdXN0IHNldCB0aGUgd2lkdGggYnV0IG5vdCB0aGUgaGVpZ2h0IGJlY2F1c2VcbiAgICAvLyBpdCBjYW4gYmUgYSBmb3JtIHdpdGggbW9yZSBpbnB1dHMgZWxlbWVudHNcbiAgZnVuY3Rpb24gY29ycmVjdERpbWVuc2lvbnMgKCkge1xuICAgIGNvbnN0IHdpZHRoID0gdmlzdWFscy5nZXRSZWNvcmRlcldpZHRoKHRydWUpXG5cbiAgICBpZiAod2lkdGggPCAxKSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ1JlY29yZGVyIHdpZHRoIGNhbm5vdCBiZSBsZXNzIHRoYW4gMSEnLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRGltZW5zaW9ucyAoKSB7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS53aWR0aCA9ICdhdXRvJ1xuICB9XG5cbiAgZnVuY3Rpb24gdW5sb2FkQ2hpbGRyZW4gKGUpIHtcbiAgICB2aXN1YWxzLnVubG9hZChlKVxuICAgIGJ1dHRvbnMudW5sb2FkKClcbiAgICBzZWxmLmVuZFdhaXRpbmcoKVxuICB9XG5cbiAgZnVuY3Rpb24gaGlkZU15U2VsZiAoKSB7XG4gICAgaGlkZGVuKGNvbnRhaW5lckVsZW1lbnQsIHRydWUpXG4gIH1cblxuICAgIC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC1jbGllbnQvaXNzdWVzLzcxXG4gIGZ1bmN0aW9uIHRyaW1FbWFpbCAoZW1haWwpIHtcbiAgICByZXR1cm4gZW1haWwucmVwbGFjZSgvKF5bLFxcc10rKXwoWyxcXHNdKyQpL2csICcnKVxuICB9XG5cbiAgZnVuY3Rpb24gc3VibWl0VmlkZW9tYWlsIChmb3JtRGF0YSwgbWV0aG9kLCBjYikge1xuICAgIGNvbnN0IEZPUk1fRklFTERTID0ge1xuICAgICAgJ3N1YmplY3QnOiBvcHRpb25zLnNlbGVjdG9ycy5zdWJqZWN0SW5wdXROYW1lLFxuICAgICAgJ2Zyb20nOiBvcHRpb25zLnNlbGVjdG9ycy5mcm9tSW5wdXROYW1lLFxuICAgICAgJ3RvJzogb3B0aW9ucy5zZWxlY3RvcnMudG9JbnB1dE5hbWUsXG4gICAgICAnYm9keSc6IG9wdGlvbnMuc2VsZWN0b3JzLmJvZHlJbnB1dE5hbWUsXG4gICAgICAna2V5Jzogb3B0aW9ucy5zZWxlY3RvcnMua2V5SW5wdXROYW1lLFxuICAgICAgJ3BhcmVudEtleSc6IG9wdGlvbnMuc2VsZWN0b3JzLnBhcmVudEtleUlucHV0TmFtZVxuICAgIH1cblxuICAgIGNvbnN0IHZpZGVvbWFpbEZvcm1EYXRhID0ge31cblxuICAgIE9iamVjdC5rZXlzKEZPUk1fRklFTERTKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChmb3JtRGF0YS5oYXNPd25Qcm9wZXJ0eShGT1JNX0ZJRUxEU1trZXldKSkge1xuICAgICAgICB2aWRlb21haWxGb3JtRGF0YVtrZXldID0gZm9ybURhdGFbRk9STV9GSUVMRFNba2V5XV1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKHZpZGVvbWFpbEZvcm1EYXRhLmZyb20pIHtcbiAgICAgIHZpZGVvbWFpbEZvcm1EYXRhLmZyb20gPSB0cmltRW1haWwodmlkZW9tYWlsRm9ybURhdGEuZnJvbSlcbiAgICB9XG5cbiAgICBpZiAodmlkZW9tYWlsRm9ybURhdGEudG8pIHtcbiAgICAgIHZpZGVvbWFpbEZvcm1EYXRhLnRvID0gdHJpbUVtYWlsKHZpZGVvbWFpbEZvcm1EYXRhLnRvKVxuICAgIH1cblxuICAgICAgICAvLyB3aGVuIG1ldGhvZCBpcyB1bmRlZmluZWQsIHRyZWF0IGl0IGFzIGEgcG9zdFxuICAgIGlmIChpc1Bvc3QobWV0aG9kKSB8fCAhbWV0aG9kKSB7XG4gICAgICB2aWRlb21haWxGb3JtRGF0YS5yZWNvcmRpbmdTdGF0cyA9IHZpc3VhbHMuZ2V0UmVjb3JkaW5nU3RhdHMoKVxuICAgICAgdmlkZW9tYWlsRm9ybURhdGEud2lkdGggPSB2aXN1YWxzLmdldFJlY29yZGVyV2lkdGgodHJ1ZSlcbiAgICAgIHZpZGVvbWFpbEZvcm1EYXRhLmhlaWdodCA9IHZpc3VhbHMuZ2V0UmVjb3JkZXJIZWlnaHQodHJ1ZSlcblxuICAgICAgcmVzb3VyY2UucG9zdCh2aWRlb21haWxGb3JtRGF0YSwgY2IpXG4gICAgfSBlbHNlIGlmIChpc1B1dChtZXRob2QpKSB7XG4gICAgICByZXNvdXJjZS5wdXQodmlkZW9tYWlsRm9ybURhdGEsIGNiKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN1Ym1pdEZvcm0gKGZvcm1EYXRhLCB2aWRlb21haWxSZXNwb25zZSwgdXJsLCBjYikge1xuICAgIGZvcm1EYXRhW29wdGlvbnMuc2VsZWN0b3JzLmFsaWFzSW5wdXROYW1lXSA9IHZpZGVvbWFpbFJlc3BvbnNlLnZpZGVvbWFpbC5hbGlhc1xuXG4gICAgcmVzb3VyY2UuZm9ybShmb3JtRGF0YSwgdXJsLCBjYilcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmFsaXplU3VibWlzc2lvbnMgKGVyciwgbWV0aG9kLCB2aWRlb21haWwsIHJlc3BvbnNlLCBmb3JtUmVzcG9uc2UpIHtcbiAgICBzZWxmLmVuZFdhaXRpbmcoKVxuXG4gICAgaWYgKGVycikge1xuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWJtaXR0ZWQgPSB0cnVlXG5cbiAgICAgIC8vIG1lcmdlIHR3byBqc29uIHJlc3BvbnNlIGJvZGllcyB0byBmYWtlIGFzIGlmIGl0IHdlcmUgb25seSBvbmUgcmVxdWVzdFxuICAgICAgaWYgKGZvcm1SZXNwb25zZSAmJiBmb3JtUmVzcG9uc2UuYm9keSkge1xuICAgICAgICBPYmplY3Qua2V5cyhmb3JtUmVzcG9uc2UuYm9keSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmVzcG9uc2Vba2V5XSA9IGZvcm1SZXNwb25zZS5ib2R5W2tleV1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgc2VsZi5lbWl0KFxuICAgICAgICBFdmVudHMuU1VCTUlUVEVELFxuICAgICAgICB2aWRlb21haWwsXG4gICAgICAgIHJlc3BvbnNlXG4gICAgICApXG5cbiAgICAgIGlmIChmb3JtUmVzcG9uc2UgJiYgZm9ybVJlc3BvbnNlLnR5cGUgPT09ICd0ZXh0L2h0bWwnICYmIGZvcm1SZXNwb25zZS50ZXh0KSB7XG4gICAgICAgIC8vIHNlcnZlciByZXBsaWVkIHdpdGggSFRNTCBjb250ZW50cyAtIGRpc3BsYXkgdGhlc2VcbiAgICAgICAgZG9jdW1lbnQuYm9keS5pbm5lckhUTUwgPSBmb3JtUmVzcG9uc2UudGV4dFxuXG4gICAgICAgIC8vIHRvZG86IGZpZ3VyZSBvdXQgaG93IHRvIGZpcmUgZG9tJ3Mgb25sb2FkIGV2ZW50IGFnYWluXG4gICAgICAgIC8vIHRvZG86IG9yIGhvdyB0byBydW4gYWxsIHRoZSBzY3JpcHRzIG92ZXIgYWdhaW5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmFkZFBsYXllckRpbWVuc2lvbnMgPSBmdW5jdGlvbiAodmlkZW9tYWlsLCBlbGVtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZpZGVvbWFpbC5wbGF5ZXJIZWlnaHQgPSB0aGlzLmNhbGN1bGF0ZUhlaWdodCh7XG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICAgIHZpZGVvV2lkdGg6IHZpZGVvbWFpbC53aWR0aCxcbiAgICAgICAgcmF0aW86IHZpZGVvbWFpbC5oZWlnaHQgLyB2aWRlb21haWwud2lkdGhcbiAgICAgIH0sIGVsZW1lbnQpXG5cbiAgICAgIHZpZGVvbWFpbC5wbGF5ZXJXaWR0aCA9IHRoaXMuY2FsY3VsYXRlV2lkdGgoe1xuICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgICAgICB2aWRlb0hlaWdodDogdmlkZW9tYWlsLnBsYXllckhlaWdodCxcbiAgICAgICAgcmF0aW86IHZpZGVvbWFpbC5oZWlnaHQgLyB2aWRlb21haWwud2lkdGhcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB2aWRlb21haWxcbiAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGV4YylcbiAgICB9XG4gIH1cblxuICB0aGlzLmxpbWl0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICByZXR1cm4gRGltZW5zaW9uLmxpbWl0V2lkdGgoY29udGFpbmVyRWxlbWVudCwgd2lkdGgsIG9wdGlvbnMpXG4gIH1cblxuICB0aGlzLmxpbWl0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgIHJldHVybiBEaW1lbnNpb24ubGltaXRIZWlnaHQoaGVpZ2h0LCBvcHRpb25zKVxuICB9XG5cbiAgdGhpcy5jYWxjdWxhdGVXaWR0aCA9IGZ1bmN0aW9uIChmbk9wdGlvbnMpIHtcbiAgICByZXR1cm4gRGltZW5zaW9uLmNhbGN1bGF0ZVdpZHRoKG1lcmdlLnJlY3Vyc2l2ZShvcHRpb25zLCBmbk9wdGlvbnMpKVxuICB9XG5cbiAgdGhpcy5jYWxjdWxhdGVIZWlnaHQgPSBmdW5jdGlvbiAoZm5PcHRpb25zLCBlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBpZiAoY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gY29udGFpbmVyRWxlbWVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYmV0dGVyIHRoYW4gbm90aGluZ1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuYm9keVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBEaW1lbnNpb24uY2FsY3VsYXRlSGVpZ2h0KGVsZW1lbnQsIG1lcmdlLnJlY3Vyc2l2ZShvcHRpb25zLCBmbk9wdGlvbnMpKVxuICB9XG5cbiAgdGhpcy5hcmVWaXN1YWxzSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2aXN1YWxzLmlzSGlkZGVuKClcbiAgfVxuXG4gIHRoaXMuaGFzRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISFjb250YWluZXJFbGVtZW50XG4gIH1cblxuICB0aGlzLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCdDb250YWluZXI6IGJ1aWxkKCknKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLnNlbGVjdG9ycy5jb250YWluZXJJZClcblxuICAgICAgLy8gb25seSBidWlsZCB3aGVuIGEgY29udGFpbmVyIGVsZW1lbnQgaGFzdCBiZWVuIGZvdW5kLCBvdGhlcndpc2VcbiAgICAgIC8vIGJlIHNpbGVudCBhbmQgZG8gbm90aGluZ1xuICAgICAgaWYgKGNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgb3B0aW9ucy5pbnNlcnRDc3MgJiYgcHJlcGVuZERlZmF1bHRDc3MoKVxuXG4gICAgICAgICFidWlsdCAmJiBpbml0RXZlbnRzKClcbiAgICAgICAgdmFsaWRhdGVPcHRpb25zKClcbiAgICAgICAgY29ycmVjdERpbWVuc2lvbnMoKVxuICAgICAgICBidWlsZEZvcm0oKVxuICAgICAgICBidWlsZENoaWxkcmVuKClcblxuICAgICAgICBpZiAoIWhhc0Vycm9yKSB7XG4gICAgICAgICAgZGVidWcoJ0NvbnRhaW5lcjogYnVpbHQuJylcbiAgICAgICAgICBidWlsdCA9IHRydWVcbiAgICAgICAgICBzZWxmLmVtaXQoRXZlbnRzLkJVSUxUKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdDb250YWluZXI6IGJ1aWxkaW5nIGZhaWxlZCBkdWUgdG8gYW4gZXJyb3IuJylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ0NvbnRhaW5lcjogbm8gY29udGFpbmVyIGVsZW1lbnQgd2l0aCBJRCAnICsgb3B0aW9ucy5zZWxlY3RvcnMuY29udGFpbmVySWQgKyAnIGZvdW5kLiBEbyBub3RoaW5nLicpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICBpZiAodmlzdWFscy5pc05vdGlmaWVyQnVpbHQoKSkge1xuICAgICAgICBzZWxmLmVtaXQoRXZlbnRzLkVSUk9SLCBleGMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBleGNcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmdldFN1Ym1pdEJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYnV0dG9ucy5nZXRTdWJtaXRCdXR0b24oKVxuICB9XG5cbiAgdGhpcy5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lckVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgfVxuXG4gIHRoaXMuYmVnaW5XYWl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGh0bWxFbGVtZW50LmNsYXNzTGlzdCAmJiBodG1sRWxlbWVudC5jbGFzc0xpc3QuYWRkKCd3YWl0JylcbiAgfVxuXG4gIHRoaXMuZW5kV2FpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBodG1sRWxlbWVudC5jbGFzc0xpc3QgJiYgaHRtbEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnd2FpdCcpXG4gIH1cblxuICB0aGlzLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChjaGlsZClcbiAgfVxuXG4gIHRoaXMuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKGNoaWxkLCByZWZlcmVuY2UpIHtcbiAgICBjb250YWluZXJFbGVtZW50Lmluc2VydEJlZm9yZShjaGlsZCwgcmVmZXJlbmNlKVxuICB9XG5cbiAgdGhpcy51bmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGRlYnVnKCdDb250YWluZXI6IHVubG9hZCgpJywgZSlcblxuICAgIHRyeSB7XG4gICAgICB1bmxvYWRDaGlsZHJlbihlKVxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuXG4gICAgICBidWlsdCA9IHN1Ym1pdHRlZCA9IGZhbHNlXG4gICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICBzZWxmLmVtaXQoRXZlbnRzLkVSUk9SLCBleGMpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb250YWluZXJFbGVtZW50KSB7XG4gICAgICBoaWRkZW4oY29udGFpbmVyRWxlbWVudCwgZmFsc2UpXG5cbiAgICAgIHZpc3VhbHMuc2hvdygpXG5cbiAgICAgIGlmICghaGFzRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcGF1c2VkID0gc2VsZi5pc1BhdXNlZCgpXG5cbiAgICAgICAgaWYgKHBhdXNlZCkge1xuICAgICAgICAgIGJ1dHRvbnMuYWRqdXN0QnV0dG9uc0ZvclBhdXNlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpbmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC1jbGllbnQvaXNzdWVzLzYwXG4gICAgICAgIC8vIHdlIGhpZGUgYXJlYXMgdG8gbWFrZSBpdCBlYXNpZXIgZm9yIHRoZSB1c2VyXG4gICAgICAgIGJ1dHRvbnMuc2hvdygpXG5cbiAgICAgICAgaWYgKHNlbGYuaXNSZXBsYXlTaG93bigpKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5QUkVWSUVXKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuZW1pdChFdmVudHMuRk9STV9SRUFEWSwge3BhdXNlZDogcGF1c2VkfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBoYXNFcnJvciA9IGZhbHNlXG5cbiAgICB0aGlzLmlzUmVjb3JkaW5nKCkgJiYgdGhpcy5wYXVzZSgpXG5cbiAgICB2aXN1YWxzLmhpZGUoKVxuXG4gICAgaWYgKHN1Ym1pdHRlZCkge1xuICAgICAgYnV0dG9ucy5oaWRlKClcbiAgICAgIGhpZGVNeVNlbGYoKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuc2hvd1JlcGxheU9ubHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaGFzRXJyb3IgPSBmYWxzZVxuXG4gICAgdGhpcy5pc1JlY29yZGluZygpICYmIHRoaXMucGF1c2UoKVxuXG4gICAgdmlzdWFscy5zaG93UmVwbGF5T25seSgpXG5cbiAgICBzdWJtaXR0ZWQgJiYgYnV0dG9ucy5oaWRlKClcbiAgfVxuXG4gIHRoaXMuaXNOb3RpZnlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHZpc3VhbHMuaXNOb3RpZnlpbmcoKVxuICB9XG5cbiAgdGhpcy5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdmlzdWFscy5pc1BhdXNlZCgpXG4gIH1cblxuICB0aGlzLnBhdXNlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZpc3VhbHMucGF1c2UocGFyYW1zKVxuICB9XG5cbiAgdGhpcy5zdGFydE92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1Ym1pdHRlZCA9IGZhbHNlXG4gICAgICBmb3JtLnNob3coKVxuICAgICAgdmlzdWFscy5iYWNrKHRoaXMuc2hvdylcbiAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGV4YylcbiAgICB9XG4gIH1cblxuICAvLyB0aGlzIGNvZGUgbmVlZHMgYSBnb29kIHJld3JpdGUgOihcbiAgdGhpcy52YWxpZGF0ZSA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgIHZhciBydW5WYWxpZGF0aW9uID0gdHJ1ZVxuICAgIHZhciB2YWxpZFxuXG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZUF1dG9WYWxpZGF0aW9uKSB7XG4gICAgICBydW5WYWxpZGF0aW9uID0gZmFsc2VcbiAgICAgIGxhc3RWYWxpZGF0aW9uID0gdHJ1ZSAvLyBuZWVkZWQgc28gdGhhdCBpdCBjYW4gYmUgc3VibWl0dGVkIGFueXdheSwgc2VlIHN1Ym1pdCgpXG4gICAgfSBlbHNlIGlmIChmb3JjZSkge1xuICAgICAgcnVuVmFsaWRhdGlvbiA9IGZvcmNlXG4gICAgfSBlbHNlIGlmIChzZWxmLmlzTm90aWZ5aW5nKCkpIHtcbiAgICAgIHJ1blZhbGlkYXRpb24gPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAodmlzdWFscy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICBydW5WYWxpZGF0aW9uID0gdmlzdWFscy5pc1VzZXJNZWRpYUxvYWRlZCgpIHx8IHZpc3VhbHMuaXNSZXBsYXlTaG93bigpXG4gICAgfSBlbHNlIGlmICh2aXN1YWxzLmlzQ29ubmVjdGluZygpKSB7XG4gICAgICBydW5WYWxpZGF0aW9uID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAocnVuVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5lbWl0KEV2ZW50cy5WQUxJREFUSU5HKVxuXG4gICAgICBjb25zdCB2aXN1YWxzVmFsaWQgPSB2aXN1YWxzLnZhbGlkYXRlKCkgJiYgYnV0dG9ucy5pc1JlY29yZEFnYWluQnV0dG9uRW5hYmxlZCgpXG4gICAgICB2YXIgd2h5SW52YWxpZFxuXG4gICAgICBpZiAoZm9ybSkge1xuICAgICAgICB2YWxpZCA9IGZvcm0udmFsaWRhdGUoKVxuXG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgIGlmICghdGhpcy5hcmVWaXN1YWxzSGlkZGVuKCkgJiYgIXZpc3VhbHNWYWxpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZWFkeSgpIHx8IHRoaXMuaXNSZWNvcmRpbmcoKSB8fCB0aGlzLmlzUGF1c2VkKCkgfHwgdGhpcy5pc0NvdW50aW5nRG93bigpKSB7XG4gICAgICAgICAgICAgIHZhbGlkID0gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICB3aHlJbnZhbGlkID0gJ1ZpZGVvIGlzIG5vdCByZWNvcmRlZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaW52YWxpZElucHV0ID0gZm9ybS5nZXRJbnZhbGlkRWxlbWVudCgpXG5cbiAgICAgICAgICBpZiAoaW52YWxpZElucHV0KSB7XG4gICAgICAgICAgICB3aHlJbnZhbGlkID0gJ0Zvcm0gaW5wdXQgbmFtZWQgJyArIGludmFsaWRJbnB1dC5uYW1lICsgJyBpcyBpbnZhbGlkJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aHlJbnZhbGlkID0gJ0Zvcm0gaW5wdXQocygpIGFyZSBpbnZhbGlkJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWQgPSB2aXN1YWxzVmFsaWRcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgIHRoaXMuZW1pdChFdmVudHMuVkFMSUQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLklOVkFMSUQsIHdoeUludmFsaWQpXG4gICAgICB9XG5cbiAgICAgIGxhc3RWYWxpZGF0aW9uID0gdmFsaWRcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRcbiAgfVxuXG4gIHRoaXMuZGlzYWJsZUZvcm0gPSBmdW5jdGlvbiAoYnV0dG9uc1Rvbykge1xuICAgIGZvcm0gJiYgZm9ybS5kaXNhYmxlKGJ1dHRvbnNUb28pXG4gIH1cblxuICB0aGlzLmVuYWJsZUZvcm0gPSBmdW5jdGlvbiAoYnV0dG9uc1Rvbykge1xuICAgIGZvcm0gJiYgZm9ybS5lbmFibGUoYnV0dG9uc1RvbylcbiAgfVxuXG4gIHRoaXMuaGFzRm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISFmb3JtXG4gIH1cblxuICB0aGlzLmlzUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGJ1dHRvbnMuaXNSZWNvcmRCdXR0b25FbmFibGVkKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUG9zdCAobWV0aG9kKSB7XG4gICAgcmV0dXJuIG1ldGhvZCAmJiBtZXRob2QudG9VcHBlckNhc2UoKSA9PT0gJ1BPU1QnXG4gIH1cblxuICBmdW5jdGlvbiBpc1B1dCAobWV0aG9kKSB7XG4gICAgcmV0dXJuIG1ldGhvZCAmJiBtZXRob2QudG9VcHBlckNhc2UoKSA9PT0gJ1BVVCdcbiAgfVxuXG4gIHRoaXMuc3VibWl0QWxsID0gZnVuY3Rpb24gKGZvcm1EYXRhLCBtZXRob2QsIHVybCkge1xuICAgIHRoaXMuYmVnaW5XYWl0aW5nKClcbiAgICB0aGlzLmRpc2FibGVGb3JtKHRydWUpXG4gICAgdGhpcy5lbWl0KEV2ZW50cy5TVUJNSVRUSU5HKVxuXG4gICAgY29uc3QgcG9zdCA9IGlzUG9zdChtZXRob2QpXG5cbiAgICAgICAgLy8gYSBjbG9zdXJlIHNvIHRoYXQgd2UgY2FuIGFjY2VzcyBtZXRob2RcbiAgICB2YXIgc3VibWl0VmlkZW9tYWlsQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyMSwgdmlkZW9tYWlsLCB2aWRlb21haWxSZXNwb25zZSkge1xuICAgICAgaWYgKGVycjEpIHtcbiAgICAgICAgZmluYWxpemVTdWJtaXNzaW9ucyhlcnIxLCBtZXRob2QsIHZpZGVvbWFpbCwgdmlkZW9tYWlsUmVzcG9uc2UpXG4gICAgICB9IGVsc2UgaWYgKHBvc3QpIHtcbiAgICAgICAgLy8gZm9yIG5vdywgYWNjZXB0IFBPU1RzIG9ubHkgd2hpY2ggaGF2ZSBhbiBVUkwgdW5saWtlIG51bGwgYW5kXG4gICAgICAgIC8vIHRyZWF0IGFsbCBvdGhlciBzdWJtaXNzaW9ucyBhcyBkaXJlY3Qgc3VibWlzc2lvbnNcblxuICAgICAgICBpZiAoIXVybCB8fCB1cmwgPT09ICcnKSB7XG4gICAgICAgICAgLy8gZmlndXJlIG91dCBVUkwgYXV0b21hdGljYWxseSB0aGVuXG4gICAgICAgICAgdXJsID0gZG9jdW1lbnQuYmFzZVVSSVxuICAgICAgICB9XG5cbiAgICAgICAgc3VibWl0Rm9ybShmb3JtRGF0YSwgdmlkZW9tYWlsUmVzcG9uc2UsIHVybCwgZnVuY3Rpb24gKGVycjIsIGZvcm1SZXNwb25zZSkge1xuICAgICAgICAgIGZpbmFsaXplU3VibWlzc2lvbnMoZXJyMiwgbWV0aG9kLCB2aWRlb21haWwsIHZpZGVvbWFpbFJlc3BvbnNlLCBmb3JtUmVzcG9uc2UpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpdCdzIGEgZGlyZWN0IHN1Ym1pc3Npb25cbiAgICAgICAgZmluYWxpemVTdWJtaXNzaW9ucyhudWxsLCBtZXRob2QsIHZpZGVvbWFpbCwgdmlkZW9tYWlsUmVzcG9uc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3VibWl0VmlkZW9tYWlsKGZvcm1EYXRhLCBtZXRob2QsIHN1Ym1pdFZpZGVvbWFpbENhbGxiYWNrKVxuICB9XG5cbiAgdGhpcy5pc0J1aWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBidWlsdFxuICB9XG5cbiAgdGhpcy5pc1JlcGxheVNob3duID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2aXN1YWxzLmlzUmVwbGF5U2hvd24oKVxuICB9XG5cbiAgdGhpcy5pc0RpcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpc0RpcnR5ID0gZmFsc2VcblxuICAgIGlmIChmb3JtKSB7XG4gICAgICBpZiAodmlzdWFscy5pc1JlY29yZGVyVW5sb2FkZWQoKSkge1xuICAgICAgICBpc0RpcnR5ID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1JlcGxheVNob3duKCkgfHwgdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgIGlzRGlydHkgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRGlydHlcbiAgfVxuXG4gIHRoaXMuZ2V0UmVwbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2aXN1YWxzLmdldFJlcGxheSgpXG4gIH1cblxuICB0aGlzLmlzT3V0c2lkZUVsZW1lbnRPZiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyRWxlbWVudCAmJiBlbGVtZW50ICE9PSBjb250YWluZXJFbGVtZW50XG4gIH1cblxuICB0aGlzLmhpZGVGb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGZvcm0gY2hlY2sgbmVlZGVkLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLWNsaWVudC9pc3N1ZXMvMTI3XG4gICAgZm9ybSAmJiBmb3JtLmhpZGUoKVxuICB9XG5cbiAgdGhpcy5sb2FkRm9ybSA9IGZ1bmN0aW9uICh2aWRlb21haWwpIHtcbiAgICBmb3JtLmxvYWRWaWRlb21haWwodmlkZW9tYWlsKVxuICAgIHRoaXMudmFsaWRhdGUoKVxuICB9XG5cbiAgdGhpcy5lbmFibGVBdWRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICBvcHRpb25zLnNldEF1ZGlvRW5hYmxlZCh0cnVlKVxuICAgIHRoaXMuZW1pdChFdmVudHMuRU5BQkxJTkdfQVVESU8pXG4gIH1cblxuICB0aGlzLmRpc2FibGVBdWRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICBvcHRpb25zLnNldEF1ZGlvRW5hYmxlZChmYWxzZSlcbiAgICB0aGlzLmVtaXQoRXZlbnRzLkRJU0FCTElOR19BVURJTylcbiAgfVxuXG4gIHRoaXMuc3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgIGxhc3RWYWxpZGF0aW9uICYmIGZvcm0gJiYgZm9ybS5kb1RoZVN1Ym1pdCgpXG4gIH1cblxuICB0aGlzLmlzQ291bnRpbmdEb3duID0gdmlzdWFscy5pc0NvdW50aW5nRG93bi5iaW5kKHZpc3VhbHMpXG4gIHRoaXMuaXNSZWNvcmRpbmcgPSB2aXN1YWxzLmlzUmVjb3JkaW5nLmJpbmQodmlzdWFscylcbiAgdGhpcy5yZWNvcmQgPSB2aXN1YWxzLnJlY29yZC5iaW5kKHZpc3VhbHMpXG4gIHRoaXMucmVzdW1lID0gdmlzdWFscy5yZXN1bWUuYmluZCh2aXN1YWxzKVxuICB0aGlzLnN0b3AgPSB2aXN1YWxzLnN0b3AuYmluZCh2aXN1YWxzKVxuICB0aGlzLnJlY29yZEFnYWluID0gdmlzdWFscy5yZWNvcmRBZ2Fpbi5iaW5kKHZpc3VhbHMpXG59XG5cbnV0aWwuaW5oZXJpdHMoQ29udGFpbmVyLCBFdmVudEVtaXR0ZXIpXG5cbmV4cG9ydCBkZWZhdWx0IENvbnRhaW5lclxuIiwiaW1wb3J0IG51bWJlcklzSW50ZWdlciBmcm9tICdudW1iZXItaXMtaW50ZWdlcidcblxuaW1wb3J0IFZpZGVvbWFpbEVycm9yIGZyb20gJy4vLi4vdXRpbC92aWRlb21haWxFcnJvcidcblxuZnVuY3Rpb24gZ2V0T3V0ZXJXaWR0aCAoZWxlbWVudCkge1xuICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gIGlmIChyZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QucmlnaHQgLSByZWN0LmxlZnRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMFxuICB9XG59XG5cbmZ1bmN0aW9uIGZpZ3VyZU1pbkhlaWdodCAoaGVpZ2h0LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmhhc0RlZmluZWRIZWlnaHQoKSkge1xuICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBvcHRpb25zLnZpZGVvLmhlaWdodFxuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSBNYXRoLm1pbihvcHRpb25zLnZpZGVvLmhlaWdodCwgaGVpZ2h0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChudW1iZXJJc0ludGVnZXIoaGVpZ2h0KSAmJiBoZWlnaHQgPCAxKSB7XG4gICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgJ0dvdCBhIHZpZGVvIGhlaWdodCBsZXNzIHRoYW4gMSAoJyArXG4gICAgICBoZWlnaHQgK1xuICAgICAgJykgd2hpbGUgZmlndXJpbmcgb3V0IHRoZSBtaW5pbXVtIScsXG4gICAgICBvcHRpb25zXG4gICAgKVxuICB9XG5cbiAgLy8ganVzdCByZXR1cm4gaXQsIGNhbiBiZSBcImF1dG9cIlxuICByZXR1cm4gaGVpZ2h0XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICBsaW1pdFdpZHRoOiBmdW5jdGlvbiAoZWxlbWVudCwgd2lkdGgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvdXRlcldpZHRoID0gZ2V0T3V0ZXJXaWR0aChlbGVtZW50KVxuICAgIGNvbnN0IGxpbWl0ZWRXaWR0aCA9IG91dGVyV2lkdGggPiAwICYmIG91dGVyV2lkdGggPCB3aWR0aCA/IG91dGVyV2lkdGggOiB3aWR0aFxuXG4gICAgaWYgKG51bWJlcklzSW50ZWdlcihsaW1pdGVkV2lkdGgpICYmIGxpbWl0ZWRXaWR0aCA8IDEpIHtcbiAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnTGltaXRlZCB3aWR0aCBjYW5ub3QgYmUgbGVzcyB0aGFuIDEhJywgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxpbWl0ZWRXaWR0aFxuICAgIH1cbiAgfSxcblxuICAgIC8vIHRoaXMgaXMgZGlmZmljdWx0IHRvIGNvbXB1dGUgYW5kIGlzIG5vdCBlbnRpcmVseSBjb3JyZWN0LlxuICAgIC8vIGJ1dCBnb29kIGVub3VnaCBmb3Igbm93IHRvIGVuc3VyZSBzb21lIHN0YWJpbGl0eS5cbiAgbGltaXRIZWlnaHQ6IGZ1bmN0aW9uIChoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICBpZiAobnVtYmVySXNJbnRlZ2VyKGhlaWdodCkgJiYgaGVpZ2h0IDwgMSkge1xuICAgICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdQYXNzZWQgbGltaXQtaGVpZ2h0IGFyZ3VtZW50IGNhbm5vdCBiZSBsZXNzIHRoYW4gMSEnLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsaW1pdGVkSGVpZ2h0ID0gTWF0aC5taW4oXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgIClcblxuICAgICAgaWYgKGxpbWl0ZWRIZWlnaHQgPCAxKSB7XG4gICAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnTGltaXRlZCBoZWlnaHQgY2Fubm90IGJlIGxlc3MgdGhhbiAxIScsIG9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGltaXRlZEhlaWdodFxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjYWxjdWxhdGVXaWR0aDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy52aWRlb0hlaWdodCB8fCBudWxsXG4gICAgY29uc3QgcmF0aW8gPSBvcHRpb25zLnJhdGlvIHx8IG9wdGlvbnMuZ2V0UmF0aW8oKVxuXG4gICAgaGVpZ2h0ID0gZmlndXJlTWluSGVpZ2h0KGhlaWdodCwgb3B0aW9ucylcblxuICAgIGlmIChvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubGltaXRIZWlnaHQoaGVpZ2h0LCBvcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChudW1iZXJJc0ludGVnZXIoaGVpZ2h0KSAmJiBoZWlnaHQgPCAxKSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ0hlaWdodCBjYW5ub3QgYmUgc21hbGxlciB0aGFuIDEgd2hlbiBjYWxjdWxhdGluZyB3aWR0aC4nLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjYWxjdWxhdGVkV2lkdGggPSBwYXJzZUludChoZWlnaHQgLyByYXRpbylcblxuICAgICAgaWYgKGNhbGN1bGF0ZWRXaWR0aCA8IDEpIHtcbiAgICAgICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdDYWxjdWxhdGVkIHdpZHRoIGNhbm5vdCBiZSBzbWFsbGVyIHRoYW4gMSEnLCBvcHRpb25zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRXaWR0aFxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjYWxjdWxhdGVIZWlnaHQ6IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHdpZHRoID0gb3B0aW9ucy52aWRlb1dpZHRoIHx8IG51bGxcbiAgICB2YXIgaGVpZ2h0XG5cbiAgICBjb25zdCByYXRpbyA9IG9wdGlvbnMucmF0aW8gfHwgb3B0aW9ucy5nZXRSYXRpbygpXG5cbiAgICBpZiAob3B0aW9ucy5oYXNEZWZpbmVkV2lkdGgoKSkge1xuICAgICAgd2lkdGggPSBvcHRpb25zLnZpZGVvLndpZHRoXG4gICAgfVxuXG4gICAgaWYgKG51bWJlcklzSW50ZWdlcih3aWR0aCkgJiYgd2lkdGggPCAxKSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ1VuYWJsZSB0byBjYWxjdWxhdGUgaGVpZ2h0IHdoZW4gd2lkdGggaXMgbGVzcyB0aGFuIDEuJywgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgd2lkdGggPSB0aGlzLmxpbWl0V2lkdGgoZWxlbWVudCwgd2lkdGgsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgaWYgKHdpZHRoKSB7XG4gICAgICBoZWlnaHQgPSBwYXJzZUludCh3aWR0aCAqIHJhdGlvKVxuICAgIH1cblxuICAgIGlmIChudW1iZXJJc0ludGVnZXIoaGVpZ2h0KSAmJiBoZWlnaHQgPCAxKSB7XG4gICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoJ0p1c3QgY2FsY3VsYXRlZCBhIGhlaWdodCBsZXNzIHRoYW4gMSB3aGljaCBpcyB3cm9uZy4nLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmlndXJlTWluSGVpZ2h0KGhlaWdodCwgb3B0aW9ucylcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IHV0aWwgZnJvbSAndXRpbCdcbmltcG9ydCBoaWRkZW4gZnJvbSAnaGlkZGVuJ1xuaW1wb3J0IGdldEZvcm1EYXRhIGZyb20gJ2dldC1mb3JtLWRhdGEnXG5cbmltcG9ydCBFdmVudHMgZnJvbSAnLi8uLi9ldmVudHMnXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vLi4vdXRpbC9ldmVudEVtaXR0ZXInXG5pbXBvcnQgVmlkZW9tYWlsRXJyb3IgZnJvbSAnLi8uLi91dGlsL3ZpZGVvbWFpbEVycm9yJ1xuXG5jb25zdCBGb3JtID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgZm9ybUVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgb3B0aW9ucywgJ0Zvcm0nKVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgdmFyIGRpc2FibGVDb250YWluZXJWYWxpZGF0aW9uXG4gIHZhciBrZXlJbnB1dFxuXG4gIGZ1bmN0aW9uIGdldERhdGEgKCkge1xuICAgIHJldHVybiBnZXRGb3JtRGF0YShmb3JtRWxlbWVudClcbiAgfVxuXG4gIHRoaXMubG9hZFZpZGVvbWFpbCA9IGZ1bmN0aW9uICh2aWRlb21haWwpIHtcbiAgICBjb25zdCBsaW1pdCA9IGZvcm1FbGVtZW50LmVsZW1lbnRzLmxlbmd0aFxuXG4gICAgdmFyIGlucHV0XG4gICAgdmFyIG5hbWVcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgaW5wdXQgPSBmb3JtRWxlbWVudC5lbGVtZW50c1tpXVxuICAgICAgbmFtZSA9IGlucHV0Lm5hbWVcblxuICAgICAgaWYgKHZpZGVvbWFpbFtuYW1lXSkge1xuICAgICAgICBpbnB1dC52YWx1ZSA9IHZpZGVvbWFpbFtuYW1lXVxuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gb3B0aW9ucy5zZWxlY3RvcnMuc3ViamVjdElucHV0TmFtZSB8fFxuICAgICAgICAgIG5hbWUgPT09IG9wdGlvbnMuc2VsZWN0b3JzLmJvZHlJbnB1dE5hbWUpIHtcbiAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9ybUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZXRob2QnLCAncHV0JylcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm90QnV0dG9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZSAhPT0gJ0JVVFRPTicgJiYgZWxlbWVudC50eXBlICE9PSAnc3VibWl0J1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RGlzYWJsZWQgKGRpc2FibGVkLCBidXR0b25zVG9vKSB7XG4gICAgY29uc3QgbGltaXQgPSBmb3JtRWxlbWVudC5lbGVtZW50cy5sZW5ndGhcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgaWYgKGJ1dHRvbnNUb28gfHwgKCFidXR0b25zVG9vICYmIGlzTm90QnV0dG9uKGZvcm1FbGVtZW50LmVsZW1lbnRzW2ldKSkpIHtcbiAgICAgICAgZm9ybUVsZW1lbnQuZWxlbWVudHNbaV0uZGlzYWJsZWQgPSBkaXNhYmxlZFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGVBbGwgKCkge1xuICAgIGNvbnN0IGxpbWl0ID0gZm9ybUVsZW1lbnQuZWxlbWVudHMubGVuZ3RoXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgIGhpZGRlbihmb3JtRWxlbWVudC5lbGVtZW50c1tpXSwgdHJ1ZSlcbiAgICB9XG5cbiAgICBoaWRkZW4oZm9ybUVsZW1lbnQsIHRydWUpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbnB1dEVsZW1lbnRzICgpIHtcbiAgICByZXR1cm4gZm9ybUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsIHRleHRhcmVhJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlbGVjdEVsZW1lbnRzICgpIHtcbiAgICByZXR1cm4gZm9ybUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0JylcbiAgfVxuXG4gIHRoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uIChidXR0b25zVG9vKSB7XG4gICAgc2V0RGlzYWJsZWQodHJ1ZSwgYnV0dG9uc1RvbylcbiAgfVxuXG4gIHRoaXMuZW5hYmxlID0gZnVuY3Rpb24gKGJ1dHRvbnNUb28pIHtcbiAgICBzZXREaXNhYmxlZChmYWxzZSwgYnV0dG9uc1RvbylcbiAgfVxuXG4gIHRoaXMuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlQXV0b1ZhbGlkYXRpb24pIHtcbiAgICAgIGNvbnN0IGlucHV0RWxlbWVudHMgPSBnZXRJbnB1dEVsZW1lbnRzKClcbiAgICAgIHZhciBpbnB1dEVsZW1lbnRcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlucHV0RWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW5wdXRFbGVtZW50ID0gaW5wdXRFbGVtZW50c1tpXVxuXG4gICAgICAgIGlmIChpbnB1dEVsZW1lbnQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgIGlucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250YWluZXIudmFsaWRhdGUoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnZhbGlkYXRlKClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVjYXVzZSBvZiBhbmd1bGFyJ3MgZGlnZXN0IGN5Y2xlLCB2YWxpZGF0ZSBhZ2FpbiB3aGVuIGl0IGJlY2FtZSBpbnZhbGlkXG4gICAgICAgIGlucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnZhbGlkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghZGlzYWJsZUNvbnRhaW5lclZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci52YWxpZGF0ZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZWxlY3RFbGVtZW50cyA9IGdldFNlbGVjdEVsZW1lbnRzKClcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbjIgPSBzZWxlY3RFbGVtZW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgc2VsZWN0RWxlbWVudHNbal0uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci52YWxpZGF0ZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAga2V5SW5wdXQgPSBmb3JtRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPVwiJyArIG9wdGlvbnMuc2VsZWN0b3JzLmtleUlucHV0TmFtZSArICdcIl0nKVxuXG4gICAgaWYgKCFrZXlJbnB1dCkge1xuICAgICAga2V5SW5wdXQgPSBoKCdpbnB1dCcsIHtcbiAgICAgICAgbmFtZTogb3B0aW9ucy5zZWxlY3RvcnMua2V5SW5wdXROYW1lLFxuICAgICAgICB0eXBlOiAnaGlkZGVuJ1xuICAgICAgfSlcblxuICAgICAgZm9ybUVsZW1lbnQuYXBwZW5kQ2hpbGQoa2V5SW5wdXQpXG4gICAgfVxuXG4gICAgdGhpcy5vbihFdmVudHMuUFJFVklFVywgZnVuY3Rpb24gKHZpZGVvbWFpbEtleSkge1xuICAgICAgLy8gYmV3YXJlIHRoYXQgcHJldmlldyBkb2Vzbid0IGFsd2F5cyBjb21lIHdpdGggYSBrZXksIGkuRS5cbiAgICAgIC8vIGNvbnRhaW5lci5zaG93KCkgY2FuIGVtaXQgUFJFVklFVyB3aXRob3V0IGEga2V5IHdoZW4gYSByZXBsYXkgYWxyZWFkeSBleGlzdHNcbiAgICAgIC8vIChjYW4gaGFwcGVuIHdoZW4gc2hvd2luZyAtIGhpZGluZyAtIHNob3dpbmcgdmlkZW9tYWlsIG92ZXIgYWdhaW4pXG5cbiAgICAgIC8vIG9ubHkgZW1pdCBlcnJvciBpZiBrZXkgaXMgbWlzc2luZyBBTkQgdGhlIGlucHV0IGhhcyBubyBrZXkgKHZhbHVlKSB5ZXRcbiAgICAgIGlmICghdmlkZW9tYWlsS2V5ICYmICFrZXlJbnB1dC52YWx1ZSkge1xuICAgICAgICBzZWxmLmVtaXQoXG4gICAgICAgICAgRXZlbnRzLkVSUk9SLFxuICAgICAgICAgIFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnVmlkZW9tYWlsIGtleSBmb3IgcHJldmlldyBpcyBtaXNzaW5nIScsIG9wdGlvbnMpXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAodmlkZW9tYWlsS2V5KSB7XG4gICAgICAgIGtleUlucHV0LnZhbHVlID0gdmlkZW9tYWlsS2V5XG4gICAgICB9XG4gICAgICAvLyBlbHNlXG4gICAgICAvLyBsZWF2ZSBhcyBpdCBhbmQgdXNlIGV4aXN0aW5nIGtleUlucHV0LnZhbHVlXG4gICAgfSlcblxuICAgIC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC1jbGllbnQvaXNzdWVzLzkxXG4gICAgdGhpcy5vbihFdmVudHMuR09JTkdfQkFDSywgKCkgPT4ge1xuICAgICAga2V5SW5wdXQudmFsdWUgPSBudWxsXG4gICAgfSlcblxuICAgIHRoaXMub24oRXZlbnRzLkVSUk9SLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAvLyBzaW5jZSBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwtY2xpZW50L2lzc3Vlcy82MFxuICAgICAgLy8gd2UgaGlkZSBhcmVhcyB0byBtYWtlIGl0IGVhc2llciBmb3IgdGhlIHVzZXIgdG8gcHJvY2VzcyBhbiBlcnJvclxuICAgICAgLy8gKD0gbGVzcyBkaXN0cmFjdGlvbnMpXG4gICAgICBpZiAoZXJyLmhpZGVGb3JtICYmIGVyci5oaWRlRm9ybSgpICYmIG9wdGlvbnMuYWRqdXN0Rm9ybU9uQnJvd3NlckVycm9yKSB7XG4gICAgICAgIGhpZGVBbGwoKVxuICAgICAgfSBlbHNlIGlmIChlcnIuaGlkZUJ1dHRvbnMgJiYgZXJyLmhpZGVCdXR0b25zKCkgJiYgb3B0aW9ucy5hZGp1c3RGb3JtT25Ccm93c2VyRXJyb3IpIHtcbiAgICAgICAgaGlkZVN1Ym1pdEJ1dHRvbigpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMub24oRXZlbnRzLkJVSUxULCBmdW5jdGlvbiAoKSB7XG4gICAgICBzdGFydExpc3RlbmluZ1RvU3VibWl0RXZlbnRzKClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gaGlkZVN1Ym1pdEJ1dHRvbiAoKSB7XG4gICAgY29uc3Qgc3VibWl0QnV0dG9uID0gc2VsZi5maW5kU3VibWl0QnV0dG9uKClcbiAgICBoaWRkZW4oc3VibWl0QnV0dG9uLCB0cnVlKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRMaXN0ZW5pbmdUb1N1Ym1pdEV2ZW50cyAoKSB7XG4gICAgY29uc3Qgc3VibWl0QnV0dG9uID0gY29udGFpbmVyLmdldFN1Ym1pdEJ1dHRvbigpXG4gICAgc3VibWl0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2VsZi5kb1RoZVN1Ym1pdC5iaW5kKHNlbGYpKVxuICB9XG5cbiAgdGhpcy5kb1RoZVN1Ym1pdCA9IChlKSA9PiB7XG4gICAgLy8gd2hlbiB2aWRlb21haWwtY2xpZW50IGlzIGhpZGRlbiwgbGVhdmUgdGhlIGZvcm0gaGFuZGxpbmcgYXMgaXQgYW5kXG4gICAgLy8gZG8gbm90IG1lc3Mgd2l0aCBpdCBhdCBhbGxcbiAgICBpZiAoIWNvbnRhaW5lci5hcmVWaXN1YWxzSGlkZGVuKCkpIHtcbiAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgIC8vIG9ubHkgYWRqdXN0IHN1Ym1pc3Npb24gd2hlbiB0aGVyZSBpcyBhIGNvbnRhaW5lciwgb3RoZXJ3aXNlXG4gICAgICAvLyBkbyBub3RoaW5nIGFuZCBsZWF2ZSBhcyBpdCBmb3Igcm9idXN0bmVzc1xuICAgICAgaWYgKGNvbnRhaW5lci5oYXNFbGVtZW50KCkpIHtcbiAgICAgICAgY29udGFpbmVyLnN1Ym1pdEFsbChcbiAgICAgICAgICBnZXREYXRhKCksXG4gICAgICAgICAgZm9ybUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtZXRob2QnKSxcbiAgICAgICAgICBmb3JtRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FjdGlvbicpXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlIC8vIGltcG9ydGFudCB0byBzdG9wIHN1Ym1pc3Npb25cbiAgICB9XG4gIH1cblxuICB0aGlzLmdldEludmFsaWRFbGVtZW50ID0gKCkgPT4ge1xuICAgIGNvbnN0IGlucHV0RWxlbWVudHMgPSBnZXRJbnB1dEVsZW1lbnRzKClcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbnB1dEVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWlucHV0RWxlbWVudHNbaV0udmFsaWRpdHkudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0RWxlbWVudHNbaV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RFbGVtZW50cyA9IGdldFNlbGVjdEVsZW1lbnRzKClcblxuICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gc2VsZWN0RWxlbWVudHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICBpZiAoIXNlbGVjdEVsZW1lbnRzW2ldLnZhbGlkaXR5LnZhbGlkKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RFbGVtZW50c1tqXVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB0aGlzLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByZXZlbnRzIGVuZGxlc3MgdmFsaWRhdGlvbiBsb29wXG4gICAgZGlzYWJsZUNvbnRhaW5lclZhbGlkYXRpb24gPSB0cnVlXG5cbiAgICBjb25zdCBmb3JtSXNWYWxpZCA9IGZvcm1FbGVtZW50LmNoZWNrVmFsaWRpdHkoKVxuXG4gICAgZGlzYWJsZUNvbnRhaW5lclZhbGlkYXRpb24gPSBmYWxzZVxuXG4gICAgcmV0dXJuIGZvcm1Jc1ZhbGlkXG4gIH1cblxuICB0aGlzLmZpbmRTdWJtaXRCdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZvcm1FbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbdHlwZT0nc3VibWl0J11cIilcbiAgfVxuXG4gIHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3JtRWxlbWVudCAmJiBoaWRkZW4oZm9ybUVsZW1lbnQsIHRydWUpXG4gIH1cblxuICB0aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9ybUVsZW1lbnQgJiYgaGlkZGVuKGZvcm1FbGVtZW50LCBmYWxzZSlcbiAgfVxufVxuXG51dGlsLmluaGVyaXRzKEZvcm0sIEV2ZW50RW1pdHRlcilcblxuZXhwb3J0IGRlZmF1bHQgRm9ybVxuIiwiLy8gZW5oYW5jZXMgb3B0aW9ucyB3aXRoIHVzZWZ1bCBmdW5jdGlvbnMgd2UgY2FuIHJldXNlIGV2ZXJ5d2hlcmVcblxuZXhwb3J0IGRlZmF1bHQge1xuICBhZGRGdW5jdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGF1ZGlvRW5hYmxlZCA9IG9wdGlvbnMuYXVkaW8gJiYgb3B0aW9ucy5hdWRpby5lbmFibGVkXG5cbiAgICBvcHRpb25zLmhhc0RlZmluZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy52aWRlby5oZWlnaHQgJiYgb3B0aW9ucy52aWRlby5oZWlnaHQgIT09ICdhdXRvJ1xuICAgIH1cblxuICAgIG9wdGlvbnMuaGFzRGVmaW5lZFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMudmlkZW8ud2lkdGggJiYgb3B0aW9ucy52aWRlby53aWR0aCAhPT0gJ2F1dG8nXG4gICAgfVxuXG4gICAgb3B0aW9ucy5oYXNEZWZpbmVkRGltZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaGFzRGVmaW5lZFdpZHRoKCkgfHwgb3B0aW9ucy5oYXNEZWZpbmVkSGVpZ2h0KClcbiAgICB9XG5cbiAgICBvcHRpb25zLmhhc0RlZmluZWREaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaGFzRGVmaW5lZFdpZHRoKCkgJiYgb3B0aW9ucy5oYXNEZWZpbmVkSGVpZ2h0KClcbiAgICB9XG5cbiAgICBvcHRpb25zLmdldFJhdGlvID0gKCkgPT4ge1xuICAgICAgdmFyIHJhdGlvID0gMSAvLyBqdXN0IGEgZGVmYXVsdCBvbmUgd2hlbiBubyBjb21wdXRhdGlvbnMgYXJlIHBvc3NpYmxlXG5cbiAgICAgIGlmIChvcHRpb25zLmhhc0RlZmluZWREaW1lbnNpb25zKCkpIHtcbiAgICAgICAgcmF0aW8gPSBvcHRpb25zLnZpZGVvLmhlaWdodCAvIG9wdGlvbnMudmlkZW8ud2lkdGhcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhdGlvXG4gICAgfVxuXG4gICAgb3B0aW9ucy5pc0F1ZGlvRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhdWRpb0VuYWJsZWRcbiAgICB9XG5cbiAgICBvcHRpb25zLnNldEF1ZGlvRW5hYmxlZCA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICBhdWRpb0VuYWJsZWQgPSBlbmFibGVkXG4gICAgfVxuXG4gICAgb3B0aW9ucy5pc0F1dG9QYXVzZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5lbmFibGVBdXRvUGF1c2UgJiYgb3B0aW9ucy5lbmFibGVQYXVzZVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHV0aWwgZnJvbSAndXRpbCdcbmltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IGhpZGRlbiBmcm9tICdoaWRkZW4nXG5cbmltcG9ydCBSZXBsYXkgZnJvbSAnLi92aXN1YWxzL3JlcGxheSdcbmltcG9ydCBSZWNvcmRlciBmcm9tICcuL3Zpc3VhbHMvcmVjb3JkZXInXG5pbXBvcnQgTm90aWZpZXIgZnJvbSAnLi92aXN1YWxzL25vdGlmaWVyJ1xuaW1wb3J0IFJlY29yZGVySW5zaWRlcyBmcm9tICcuL3Zpc3VhbHMvaW5zaWRlL3JlY29yZGVySW5zaWRlcydcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLy4uL3V0aWwvZXZlbnRFbWl0dGVyJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLy4uL2V2ZW50cydcblxuY29uc3QgVmlzdWFscyA9IGZ1bmN0aW9uIChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgb3B0aW9ucywgJ1Zpc3VhbHMnKVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgY29uc3QgcmVwbGF5ID0gbmV3IFJlcGxheSh0aGlzLCBvcHRpb25zKVxuICBjb25zdCByZWNvcmRlciA9IG5ldyBSZWNvcmRlcih0aGlzLCByZXBsYXksIG9wdGlvbnMpXG4gIGNvbnN0IHJlY29yZGVySW5zaWRlcyA9IG5ldyBSZWNvcmRlckluc2lkZXModGhpcywgb3B0aW9ucylcblxuICBjb25zdCBub3RpZmllciA9IG5ldyBOb3RpZmllcih0aGlzLCBvcHRpb25zKVxuXG4gIGNvbnN0IGRlYnVnID0gb3B0aW9ucy5kZWJ1Z1xuXG4gIHZhciB2aXN1YWxzRWxlbWVudFxuICB2YXIgYnVpbHRcblxuICBmdW5jdGlvbiBidWlsZE5vU2NyaXB0VGFnICgpIHtcbiAgICB2YXIgbm9TY3JpcHRFbGVtZW50ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ25vc2NyaXB0JylcblxuICAgIGlmICghbm9TY3JpcHRFbGVtZW50KSB7XG4gICAgICBub1NjcmlwdEVsZW1lbnQgPSBoKCdub3NjcmlwdCcpXG4gICAgICBub1NjcmlwdEVsZW1lbnQuaW5uZXJIVE1MID0gJ1BsZWFzZSBlbmFibGUgSmF2YXNjcmlwdCdcblxuICAgICAgdmlzdWFsc0VsZW1lbnQuYXBwZW5kQ2hpbGQobm9TY3JpcHRFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQ2hpbGRyZW4gKCkge1xuICAgIGRlYnVnKCdWaXN1YWxzOiBidWlsZENoaWxkcmVuKCknKVxuXG4gICAgYnVpbGROb1NjcmlwdFRhZygpXG5cbiAgICBub3RpZmllci5idWlsZCgpXG4gICAgcmVjb3JkZXJJbnNpZGVzLmJ1aWxkKClcbiAgICByZXBsYXkuYnVpbGQoKVxuXG4gICAgZGVidWcoJ1Zpc3VhbHM6IGJ1aWx0LicpXG4gIH1cblxuICBmdW5jdGlvbiBpbml0RXZlbnRzICgpIHtcbiAgICBzZWxmXG4gICAgICAub24oRXZlbnRzLlVTRVJfTUVESUFfUkVBRFksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYnVpbHQgPSB0cnVlXG4gICAgICAgIHNlbGYuZW5kV2FpdGluZygpXG4gICAgICAgIGNvbnRhaW5lci5lbmFibGVGb3JtKGZhbHNlKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuUFJFVklFVywgKCkgPT4ge1xuICAgICAgICBzZWxmLmVuZFdhaXRpbmcoKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuQkxPQ0tJTkcsIGZ1bmN0aW9uIChibG9ja2luZ09wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFibG9ja2luZ09wdGlvbnMuaGlkZUZvcm0gJiYgIW9wdGlvbnMuYWRqdXN0Rm9ybU9uQnJvd3NlckVycm9yKSB7XG4gICAgICAgICAgLy8gZG8gbm90aGluZywgdXNlciBzdGlsbCBjYW4gZW50ZXIgZm9ybSBpbnB1dHNcbiAgICAgICAgICAvLyBjYW4gYmUgdXNlZnVsIHdoZW4geW91IGFyZSBvbiBpLkUuIHNlZWZsb3cncyBjb250YWN0IHBhZ2UgYW5kXG4gICAgICAgICAgLy8gc3RpbGwgd2FudCB0byB0aWNrIG9mZiB0aGUgd2ViY2FtIG9wdGlvblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lci5kaXNhYmxlRm9ybSh0cnVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKEV2ZW50cy5QUkVWSUVXX1NIT1dOLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRhaW5lci52YWxpZGF0ZSh0cnVlKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuTE9BREVEX01FVEFfREFUQSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb3JyZWN0RGltZW5zaW9ucygpXG4gICAgICB9KVxuICAgICAgLm9uKEV2ZW50cy5FUlJPUiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyLnJlbW92ZURpbWVuc2lvbnMgJiYgZXJyLnJlbW92ZURpbWVuc2lvbnMoKSkge1xuICAgICAgICAgIHJlbW92ZURpbWVuc2lvbnMoKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY29ycmVjdERpbWVuc2lvbnMgKCkge1xuICAgIHZpc3VhbHNFbGVtZW50LnN0eWxlLndpZHRoID0gc2VsZi5nZXRSZWNvcmRlcldpZHRoKHRydWUpICsgJ3B4J1xuICAgIHZpc3VhbHNFbGVtZW50LnN0eWxlLmhlaWdodCA9IHNlbGYuZ2V0UmVjb3JkZXJIZWlnaHQodHJ1ZSkgKyAncHgnXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVEaW1lbnNpb25zICgpIHtcbiAgICB2aXN1YWxzRWxlbWVudC5zdHlsZS53aWR0aCA9ICdhdXRvJ1xuICAgIHZpc3VhbHNFbGVtZW50LnN0eWxlLmhlaWdodCA9ICdhdXRvJ1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSZWNvcmRhYmxlICgpIHtcbiAgICByZXR1cm4gIXNlbGYuaXNOb3RpZnlpbmcoKSAmJiAhcmVwbGF5LmlzU2hvd24oKSAmJiAhc2VsZi5pc0NvdW50aW5nRG93bigpXG4gIH1cblxuICB0aGlzLmlzQ291bnRpbmdEb3duID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWNvcmRlckluc2lkZXMuaXNDb3VudGluZ0Rvd24oKVxuICB9XG5cbiAgdGhpcy5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2aXN1YWxzRWxlbWVudCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuJyArIG9wdGlvbnMuc2VsZWN0b3JzLnZpc3VhbHNDbGFzcylcblxuICAgIGlmICghdmlzdWFsc0VsZW1lbnQpIHtcbiAgICAgIHZpc3VhbHNFbGVtZW50ID0gaCgnZGl2LicgKyBvcHRpb25zLnNlbGVjdG9ycy52aXN1YWxzQ2xhc3MpXG5cbiAgICAgIGNvbnN0IGJ1dHRvbnNFbGVtZW50ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy4nICsgb3B0aW9ucy5zZWxlY3RvcnMuYnV0dG9uc0NsYXNzKVxuXG4gICAgICAvLyBtYWtlIHN1cmUgaXQncyBwbGFjZWQgYmVmb3JlIHRoZSBidXR0b25zXG4gICAgICBpZiAoYnV0dG9uc0VsZW1lbnQpIHtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZSh2aXN1YWxzRWxlbWVudCwgYnV0dG9uc0VsZW1lbnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodmlzdWFsc0VsZW1lbnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmlzdWFsc0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgndmlzdWFscycpXG4gICAgaGlkZGVuKHZpc3VhbHNFbGVtZW50LCB0cnVlKVxuXG4gICAgY29ycmVjdERpbWVuc2lvbnMoKVxuXG4gICAgIWJ1aWx0ICYmIGluaXRFdmVudHMoKVxuICAgIGJ1aWxkQ2hpbGRyZW4oKVxuXG4gICAgLy8gbmVlZGVkIGZvciByZXBsYXkgaGFuZGxpbmcgYW5kIGNvbnRhaW5lci5pc1BhcmVudEVsZW1lbnRPZigpXG4gICAgc2VsZi5wYXJlbnROb2RlID0gdmlzdWFsc0VsZW1lbnQucGFyZW50Tm9kZVxuXG4gICAgYnVpbHQgPSB0cnVlXG4gIH1cblxuICB0aGlzLnF1ZXJ5U2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdmlzdWFsc0VsZW1lbnQgJiYgdmlzdWFsc0VsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgfVxuXG4gIHRoaXMuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICB2aXN1YWxzRWxlbWVudCAmJiB2aXN1YWxzRWxlbWVudC5hcHBlbmRDaGlsZChjaGlsZClcbiAgfVxuXG4gIHRoaXMucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICB2aXN1YWxzRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZClcbiAgfVxuXG4gIHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmRXYWl0aW5nKClcbiAgICByZWNvcmRlci5yZXNldCgpXG4gIH1cblxuICB0aGlzLmJlZ2luV2FpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb250YWluZXIuYmVnaW5XYWl0aW5nKClcbiAgfVxuXG4gIHRoaXMuZW5kV2FpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb250YWluZXIuZW5kV2FpdGluZygpXG4gIH1cblxuICB0aGlzLnN0b3AgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgcmVjb3JkZXIuc3RvcChwYXJhbXMpXG4gICAgcmVjb3JkZXJJbnNpZGVzLmhpZGVQYXVzZSgpXG4gIH1cblxuICB0aGlzLmJhY2sgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICByZXBsYXkuaGlkZSgpXG4gICAgbm90aWZpZXIuaGlkZSgpXG4gICAgcmVjb3JkZXIuYmFjayhjYilcbiAgfVxuXG4gIHRoaXMucmVjb3JkQWdhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5iYWNrKCgpID0+IHtcbiAgICAgIHNlbGYub25jZShFdmVudHMuVVNFUl9NRURJQV9SRUFEWSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnJlY29yZCgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0aGlzLnVubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlY29yZGVyLnVubG9hZChlKVxuICAgICAgcmVjb3JkZXJJbnNpZGVzLnVubG9hZChlKVxuICAgICAgcmVwbGF5LnVubG9hZChlKVxuXG4gICAgICBidWlsdCA9IGZhbHNlXG4gICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICB0aGlzLmVtaXQoRXZlbnRzLkVSUk9SLCBleGMpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5pc05vdGlmeWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbm90aWZpZXIuaXNWaXNpYmxlKClcbiAgfVxuXG4gIHRoaXMuaXNSZXBsYXlTaG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVwbGF5LmlzU2hvd24oKVxuICB9XG5cbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICByZWNvcmRlci5wYXVzZShwYXJhbXMpXG4gICAgcmVjb3JkZXJJbnNpZGVzLnNob3dQYXVzZSgpXG4gIH1cblxuICB0aGlzLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVjb3JkZXJJbnNpZGVzLmlzQ291bnRpbmdEb3duKCkpIHtcbiAgICAgIHJlY29yZGVySW5zaWRlcy5yZXN1bWVDb3VudGRvd24oKVxuICAgIH0gZWxzZSB7XG4gICAgICByZWNvcmRlci5yZXN1bWUoKVxuICAgIH1cblxuICAgIHJlY29yZGVySW5zaWRlcy5oaWRlUGF1c2UoKVxuICB9XG5cbiAgdGhpcy5wYXVzZU9yUmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc1JlY29yZGFibGUuY2FsbCh0aGlzKSkge1xuICAgICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcoKSkge1xuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkZXIuaXNQYXVzZWQoKSkge1xuICAgICAgICB0aGlzLnJlc3VtZSgpXG4gICAgICB9IGVsc2UgaWYgKHJlY29yZGVyLmlzUmVhZHkoKSkge1xuICAgICAgICB0aGlzLnJlY29yZCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5yZWNvcmRPclN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzUmVjb3JkYWJsZSgpKSB7XG4gICAgICBpZiAodGhpcy5pc1JlY29yZGluZygpKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpXG4gICAgICB9IGVsc2UgaWYgKHJlY29yZGVyLmlzUmVhZHkoKSkge1xuICAgICAgICB0aGlzLnJlY29yZCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5yZWNvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9wdGlvbnMudmlkZW8uY291bnRkb3duKSB7XG4gICAgICB0aGlzLmVtaXQoRXZlbnRzLkNPVU5URE9XTilcbiAgICAgIHJlY29yZGVySW5zaWRlcy5zdGFydENvdW50ZG93bihyZWNvcmRlci5yZWNvcmQuYmluZChyZWNvcmRlcikpXG4gICAgfSBlbHNlIHsgcmVjb3JkZXIucmVjb3JkKCkgfVxuICB9XG5cbiAgdGhpcy5nZXRSZWNvcmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVjb3JkZXJcbiAgfVxuXG4gIHRoaXMuZ2V0UmVwbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXBsYXlcbiAgfVxuXG4gIHRoaXMudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlY29yZGVyLnZhbGlkYXRlKCkgJiYgdGhpcy5pc1JlcGxheVNob3duKClcbiAgfVxuXG4gIHRoaXMuZ2V0UmVjb3JkaW5nU3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlY29yZGVyLmdldFJlY29yZGluZ1N0YXRzKClcbiAgfVxuXG4gIHRoaXMuZ2V0QXVkaW9TYW1wbGVSYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWNvcmRlci5nZXRBdWRpb1NhbXBsZVJhdGUoKVxuICB9XG5cbiAgdGhpcy5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVjb3JkZXIuaXNQYXVzZWQoKVxuICB9XG5cbiAgdGhpcy5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBub3RpZmllci5lcnJvcihlcnIpXG4gIH1cblxuICB0aGlzLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZpc3VhbHNFbGVtZW50KSB7XG4gICAgICBoaWRkZW4odmlzdWFsc0VsZW1lbnQsIHRydWUpXG4gICAgICB0aGlzLmVtaXQoRXZlbnRzLkhJREUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5pc0hpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWJ1aWx0KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAodmlzdWFsc0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBoaWRkZW4odmlzdWFsc0VsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5zaG93VmlzdWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2aXN1YWxzRWxlbWVudCAmJiBoaWRkZW4odmlzdWFsc0VsZW1lbnQsIGZhbHNlKVxuICB9XG5cbiAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICF0aGlzLmlzUmVwbGF5U2hvd24oKSAmJiByZWNvcmRlci5idWlsZCgpXG4gICAgdGhpcy5zaG93VmlzdWFscygpXG4gIH1cblxuICB0aGlzLnNob3dSZXBsYXlPbmx5ID0gZnVuY3Rpb24gKCkge1xuICAgICF0aGlzLmlzUmVwbGF5U2hvd24oKSAmJiByZXBsYXkuc2hvdygpXG5cbiAgICB0aGlzLnNob3coKVxuICAgIHJlY29yZGVyLmhpZGUoKVxuICAgIG5vdGlmaWVyLmhpZGUoKVxuICB9XG5cbiAgdGhpcy5pc1JlY29yZGVyVW5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlY29yZGVyLmlzVW5sb2FkZWQoKVxuICB9XG5cbiAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlY29yZGVyLmlzQ29ubmVjdGluZygpXG4gIH1cblxuICB0aGlzLmdldFJlY29yZGVyV2lkdGggPSBmdW5jdGlvbiAocmVzcG9uc2l2ZSkge1xuICAgIHJldHVybiByZWNvcmRlci5nZXRSZWNvcmRlcldpZHRoKHJlc3BvbnNpdmUpXG4gIH1cblxuICB0aGlzLmdldFJlY29yZGVySGVpZ2h0ID0gZnVuY3Rpb24gKHJlc3BvbnNpdmUpIHtcbiAgICByZXR1cm4gcmVjb3JkZXIuZ2V0UmVjb3JkZXJIZWlnaHQocmVzcG9uc2l2ZSlcbiAgfVxuXG4gIHRoaXMubGltaXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgIHJldHVybiBjb250YWluZXIubGltaXRXaWR0aCh3aWR0aCwgb3B0aW9ucylcbiAgfVxuXG4gIHRoaXMubGltaXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5saW1pdEhlaWdodChoZWlnaHQpXG4gIH1cblxuICB0aGlzLmNhbGN1bGF0ZVdpZHRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmNhbGN1bGF0ZVdpZHRoKG9wdGlvbnMpXG4gIH1cblxuICB0aGlzLmNhbGN1bGF0ZUhlaWdodCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5jYWxjdWxhdGVIZWlnaHQob3B0aW9ucylcbiAgfVxuXG4gIHRoaXMuZ2V0UmVwbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXBsYXlcbiAgfVxuXG4gIHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC1jbGllbnQvaXNzdWVzLzEyNlxuICAgIHJldHVybiB2aXN1YWxzRWxlbWVudCAmJiB2aXN1YWxzRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICB9XG5cbiAgdGhpcy5jaGVja1RpbWVyID0gZnVuY3Rpb24gKGludGVydmFsU3VtKSB7XG4gICAgcmVjb3JkZXJJbnNpZGVzLmNoZWNrVGltZXIoaW50ZXJ2YWxTdW0pXG4gIH1cblxuICB0aGlzLmlzTm90aWZpZXJCdWlsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbm90aWZpZXIgJiYgbm90aWZpZXIuaXNCdWlsdCgpXG4gIH1cblxuICB0aGlzLmlzUmVwbGF5U2hvd24gPSByZXBsYXkuaXNTaG93bi5iaW5kKHJlcGxheSlcbiAgdGhpcy5oaWRlUmVwbGF5ID0gcmVwbGF5LmhpZGUuYmluZChyZXBsYXkpXG4gIHRoaXMuaGlkZVJlY29yZGVyID0gcmVjb3JkZXIuaGlkZS5iaW5kKHJlY29yZGVyKVxuICB0aGlzLmlzUmVjb3JkaW5nID0gcmVjb3JkZXIuaXNSZWNvcmRpbmcuYmluZChyZWNvcmRlcilcbiAgdGhpcy5pc1VzZXJNZWRpYUxvYWRlZCA9IHJlY29yZGVyLmlzVXNlck1lZGlhTG9hZGVkLmJpbmQocmVjb3JkZXIpXG4gIHRoaXMuaXNDb25uZWN0ZWQgPSByZWNvcmRlci5pc0Nvbm5lY3RlZC5iaW5kKHJlY29yZGVyKVxufVxuXG51dGlsLmluaGVyaXRzKFZpc3VhbHMsIEV2ZW50RW1pdHRlcilcblxuZXhwb3J0IGRlZmF1bHQgVmlzdWFsc1xuIiwiaW1wb3J0IGggZnJvbSAnaHlwZXJzY3JpcHQnXG5pbXBvcnQgaGlkZGVuIGZyb20gJ2hpZGRlbidcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHZpc3VhbHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcblxuICB2YXIgY291bnRkb3duRWxlbWVudFxuICB2YXIgaW50ZXJ2YWxJZFxuICB2YXIgY291bnRkb3duXG4gIHZhciBwYXVzZWRcblxuICBmdW5jdGlvbiBmaXJlIChjYikge1xuICAgIHNlbGYudW5sb2FkKClcbiAgICBzZWxmLmhpZGUoKVxuXG4gICAgLy8ga2VlcCBhbGwgY2FsbGJhY2tzIGFzeW5jXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYigpXG4gICAgfSwgMClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvdW50QmFja3dhcmQgKGNiKSB7XG4gICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgIG9wdGlvbnMuZGVidWcoJ0NvdW50ZG93bicsIGNvdW50ZG93bilcbiAgICAgIGNvdW50ZG93bi0tXG5cbiAgICAgIGlmIChjb3VudGRvd24gPCAxKSB7XG4gICAgICAgIGZpcmUoY2IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LmlubmVySFRNTCA9IGNvdW50ZG93blxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBjb3VudGRvd25FbGVtZW50LmlubmVySFRNTCA9IGNvdW50ZG93biA9IG9wdGlvbnMudmlkZW8uY291bnRkb3duXG5cbiAgICB0aGlzLnNob3coKVxuXG4gICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGNvdW50QmFja3dhcmQuYmluZCh0aGlzLCBjYiksIDk1MClcbiAgfVxuXG4gIHRoaXMucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGF1c2VkID0gdHJ1ZVxuICB9XG5cbiAgdGhpcy5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGF1c2VkID0gZmFsc2VcbiAgfVxuXG4gIHRoaXMuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY291bnRkb3duRWxlbWVudCA9IHZpc3VhbHMucXVlcnlTZWxlY3RvcignLmNvdW50ZG93bicpXG5cbiAgICBpZiAoIWNvdW50ZG93bkVsZW1lbnQpIHtcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQgPSBoKCdwLmNvdW50ZG93bicpXG5cbiAgICAgIHRoaXMuaGlkZSgpXG5cbiAgICAgIHZpc3VhbHMuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKClcbiAgICB9XG4gIH1cblxuICB0aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaGlkZGVuKGNvdW50ZG93bkVsZW1lbnQsIGZhbHNlKVxuICB9XG5cbiAgdGhpcy5pc0NvdW50aW5nRG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISFpbnRlcnZhbElkXG4gIH1cblxuICB0aGlzLnVubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpXG4gICAgcGF1c2VkID0gZmFsc2VcbiAgICBpbnRlcnZhbElkID0gbnVsbFxuICB9XG5cbiAgdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGhpZGRlbihjb3VudGRvd25FbGVtZW50LCB0cnVlKVxuICAgIHRoaXMudW5sb2FkKClcbiAgfVxufVxuIiwiaW1wb3J0IGggZnJvbSAnaHlwZXJzY3JpcHQnXG5pbXBvcnQgaGlkZGVuIGZyb20gJ2hpZGRlbidcblxuaW1wb3J0IFZpZGVvbWFpbEVycm9yIGZyb20gJy4vLi4vLi4vLi4vLi4vdXRpbC92aWRlb21haWxFcnJvcidcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHZpc3VhbHMsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLnRleHQucGF1c2VkSGVhZGVyKSB7XG4gICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdQYXVzZWQgaGVhZGVyIGNhbm5vdCBiZSBlbXB0eScsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgcGF1c2VkQmxvY2tFbGVtZW50XG4gIHZhciBwYXVzZWRIZWFkZXJFbGVtZW50XG4gIHZhciBwYXVzZWRIaW50RWxlbWVudFxuXG4gIHRoaXMuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGF1c2VkQmxvY2tFbGVtZW50ID0gdmlzdWFscy5xdWVyeVNlbGVjdG9yKCcucGF1c2VkJylcbiAgICBwYXVzZWRIZWFkZXJFbGVtZW50ID0gdmlzdWFscy5xdWVyeVNlbGVjdG9yKCcucGF1c2VkSGVhZGVyJylcbiAgICBwYXVzZWRIaW50RWxlbWVudCA9IHZpc3VhbHMucXVlcnlTZWxlY3RvcignLnBhdXNlZEhpbnQnKVxuXG4gICAgaWYgKCFwYXVzZWRIZWFkZXJFbGVtZW50KSB7XG4gICAgICBwYXVzZWRCbG9ja0VsZW1lbnQgPSBoKCdkaXYucGF1c2VkJylcbiAgICAgIHBhdXNlZEhlYWRlckVsZW1lbnQgPSBoKCdwLnBhdXNlZEhlYWRlcicpXG4gICAgICBwYXVzZWRIaW50RWxlbWVudCA9IGgoJ3AucGF1c2VkSGludCcpXG5cbiAgICAgIHRoaXMuaGlkZSgpXG5cbiAgICAgIHBhdXNlZEhlYWRlckVsZW1lbnQuaW5uZXJIVE1MID0gb3B0aW9ucy50ZXh0LnBhdXNlZEhlYWRlclxuICAgICAgcGF1c2VkSGludEVsZW1lbnQuaW5uZXJIVE1MID0gb3B0aW9ucy50ZXh0LnBhdXNlZEhpbnRcblxuICAgICAgcGF1c2VkQmxvY2tFbGVtZW50LmFwcGVuZENoaWxkKHBhdXNlZEhlYWRlckVsZW1lbnQpXG4gICAgICBwYXVzZWRCbG9ja0VsZW1lbnQuYXBwZW5kQ2hpbGQocGF1c2VkSGludEVsZW1lbnQpXG5cbiAgICAgIHZpc3VhbHMuYXBwZW5kQ2hpbGQocGF1c2VkQmxvY2tFbGVtZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGUoKVxuXG4gICAgICBwYXVzZWRIZWFkZXJFbGVtZW50LmlubmVySFRNTCA9IG9wdGlvbnMudGV4dC5wYXVzZWRIZWFkZXJcbiAgICAgIHBhdXNlZEhpbnRFbGVtZW50LmlubmVySFRNTCA9IG9wdGlvbnMudGV4dC5wYXVzZWRIaW50XG4gICAgfVxuICB9XG5cbiAgdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGhpZGRlbihwYXVzZWRCbG9ja0VsZW1lbnQsIHRydWUpXG4gIH1cblxuICB0aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaGlkZGVuKHBhdXNlZEJsb2NrRWxlbWVudCwgZmFsc2UpXG4gIH1cbn1cbiIsImltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IGhpZGRlbiBmcm9tICdoaWRkZW4nXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICh2aXN1YWxzKSB7XG4gIHZhciByZWNvcmROb3RlRWxlbWVudFxuXG4gIHRoaXMuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVjb3JkTm90ZUVsZW1lbnQgPSB2aXN1YWxzLnF1ZXJ5U2VsZWN0b3IoJy5yZWNvcmROb3RlJylcblxuICAgIGlmICghcmVjb3JkTm90ZUVsZW1lbnQpIHtcbiAgICAgIHJlY29yZE5vdGVFbGVtZW50ID0gaCgncC5yZWNvcmROb3RlJylcblxuICAgICAgdGhpcy5oaWRlKClcblxuICAgICAgdmlzdWFscy5hcHBlbmRDaGlsZChyZWNvcmROb3RlRWxlbWVudClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKClcbiAgICB9XG4gIH1cblxuICB0aGlzLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oaWRlKClcbiAgICByZWNvcmROb3RlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCduZWFyJylcbiAgICByZWNvcmROb3RlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCduaWdoJylcbiAgfVxuXG4gIHRoaXMuc2V0TmVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZWNvcmROb3RlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCduZWFyJylcbiAgfVxuXG4gIHRoaXMuc2V0TmlnaCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZWNvcmROb3RlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCduaWdoJylcbiAgfVxuXG4gIHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBoaWRkZW4ocmVjb3JkTm90ZUVsZW1lbnQsIHRydWUpXG4gIH1cblxuICB0aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaGlkZGVuKHJlY29yZE5vdGVFbGVtZW50LCBmYWxzZSlcbiAgfVxufVxuIiwiaW1wb3J0IGggZnJvbSAnaHlwZXJzY3JpcHQnXG5pbXBvcnQgaGlkZGVuIGZyb20gJ2hpZGRlbidcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHZpc3VhbHMsIHJlY29yZE5vdGUsIG9wdGlvbnMpIHtcbiAgdmFyIHJlY29yZFRpbWVyRWxlbWVudFxuXG4gIHZhciBuZWFyQ29tcHV0ZWQgPSBmYWxzZVxuICB2YXIgZW5kTmlnaENvbXB1dGVkID0gZmFsc2VcblxuICB2YXIgc3RhcnRlZFxuICB2YXIgY291bnRkb3duXG5cbiAgZnVuY3Rpb24gcGFkIChuKSB7XG4gICAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4gOiBuXG4gIH1cblxuICBmdW5jdGlvbiB0aHJlc2hvbGRSZWFjaGVkIChzZWNzLCB0aHJlc2hvbGQpIHtcbiAgICByZXR1cm4gc2VjcyA+PSBvcHRpb25zLnZpZGVvLmxpbWl0U2Vjb25kcyAqIHRocmVzaG9sZFxuICB9XG5cbiAgZnVuY3Rpb24gaXNOZWFyIChzZWNzKSB7XG4gICAgaWYgKCFuZWFyQ29tcHV0ZWQgJiYgdGhyZXNob2xkUmVhY2hlZChzZWNzLCAwLjYpKSB7XG4gICAgICBuZWFyQ29tcHV0ZWQgPSB0cnVlXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRJc05pZ2ggKHNlY3MpIHtcbiAgICBpZiAoIWVuZE5pZ2hDb21wdXRlZCAmJiB0aHJlc2hvbGRSZWFjaGVkKHNlY3MsIDAuOCkpIHtcbiAgICAgIGVuZE5pZ2hDb21wdXRlZCA9IHRydWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldE5lYXIgKCkge1xuICAgIHJlY29yZFRpbWVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCduZWFyJylcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldE5pZ2ggKCkge1xuICAgIHJlY29yZFRpbWVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCduaWdoJylcbiAgfVxuXG4gIHRoaXMuY2hlY2sgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIGNvbnN0IG5ld0NvdW50ZG93biA9IGdldFN0YXJ0U2Vjb25kcygpIC0gTWF0aC5mbG9vcihvcHRzLmludGVydmFsU3VtIC8gMWUzKVxuXG4gICAgLy8gcGVyZm9ybWFuY2Ugb3B0aW1pc2F0aW9uIChhbm90aGVyIHJlYXNvbiB3ZSBuZWVkIHJlYWN0IGhlcmUhKVxuICAgIGlmIChuZXdDb3VudGRvd24gIT09IGNvdW50ZG93bikge1xuICAgICAgY291bnRkb3duID0gbmV3Q291bnRkb3duXG4gICAgICB1cGRhdGUoKVxuICAgICAgY291bnRkb3duIDwgMSAmJiB2aXN1YWxzLnN0b3AodHJ1ZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAgIGNvbnN0IG1pbnMgPSBwYXJzZUludChjb3VudGRvd24gLyA2MCwgMTApXG4gICAgY29uc3Qgc2VjcyA9IGNvdW50ZG93biAtIG1pbnMgKiA2MFxuXG4gICAgaWYgKCFuZWFyQ29tcHV0ZWQgfHwgIWVuZE5pZ2hDb21wdXRlZCkge1xuICAgICAgY29uc3QgcmVtYWluaW5nU2Vjb25kcyA9IG9wdGlvbnMudmlkZW8ubGltaXRTZWNvbmRzIC0gY291bnRkb3duXG5cbiAgICAgIGlmIChpc05lYXIocmVtYWluaW5nU2Vjb25kcykpIHtcbiAgICAgICAgcmVjb3JkTm90ZS5zZXROZWFyKClcbiAgICAgICAgc2V0TmVhcigpXG5cbiAgICAgICAgb3B0aW9ucy5kZWJ1ZygnRW5kIGlzIG5lYXIsICcgKyBjb3VudGRvd24gKyAnIHNlY29uZHMgdG8gZ28nKVxuICAgICAgfSBlbHNlIGlmIChlbmRJc05pZ2gocmVtYWluaW5nU2Vjb25kcykpIHtcbiAgICAgICAgcmVjb3JkTm90ZS5zZXROaWdoKClcbiAgICAgICAgc2V0TmlnaCgpXG5cbiAgICAgICAgb3B0aW9ucy5kZWJ1ZygnRW5kIGlzIG5pZ2gsICcgKyBjb3VudGRvd24gKyAnIHNlY29uZHMgdG8gZ28nKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlY29yZFRpbWVyRWxlbWVudC5pbm5lckhUTUwgPSBtaW5zICsgJzonICsgcGFkKHNlY3MpXG4gIH1cblxuICBmdW5jdGlvbiBoaWRlICgpIHtcbiAgICBoaWRkZW4ocmVjb3JkVGltZXJFbGVtZW50LCB0cnVlKVxuICB9XG5cbiAgZnVuY3Rpb24gc2hvdyAoKSB7XG4gICAgcmVjb3JkVGltZXJFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ25lYXInKVxuICAgIHJlY29yZFRpbWVyRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCduaWdoJylcblxuICAgIGhpZGRlbihyZWNvcmRUaW1lckVsZW1lbnQsIGZhbHNlKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2Vjb25kc1JlY29yZGVkICgpIHtcbiAgICByZXR1cm4gZ2V0U3RhcnRTZWNvbmRzKCkgLSBjb3VudGRvd25cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN0YXJ0U2Vjb25kcyAoKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudmlkZW8ubGltaXRTZWNvbmRzXG4gIH1cblxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvdW50ZG93biA9IGdldFN0YXJ0U2Vjb25kcygpXG4gICAgbmVhckNvbXB1dGVkID0gZW5kTmlnaENvbXB1dGVkID0gZmFsc2VcbiAgICBzdGFydGVkID0gdHJ1ZVxuXG4gICAgdXBkYXRlKClcblxuICAgIHNob3coKVxuICB9XG5cbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZWNvcmROb3RlLmhpZGUoKVxuICB9XG5cbiAgdGhpcy5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVjb3JkTm90ZS5zaG93KClcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RvcHBlZCAoKSB7XG4gICAgcmV0dXJuIGNvdW50ZG93biA9PT0gbnVsbFxuICB9XG5cbiAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNTdG9wcGVkKCkgJiYgc3RhcnRlZCkge1xuICAgICAgb3B0aW9ucy5kZWJ1ZygnU3RvcHBpbmcgcmVjb3JkIHRpbWVyLiBXYXMgcmVjb3JkaW5nIGZvciBhYm91dCB+JyArIGdldFNlY29uZHNSZWNvcmRlZCgpICsgJyBzZWNvbmRzLicpXG5cbiAgICAgIGhpZGUoKVxuICAgICAgcmVjb3JkTm90ZS5zdG9wKClcblxuICAgICAgY291bnRkb3duID0gbnVsbFxuICAgICAgc3RhcnRlZCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgdGhpcy5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZWNvcmRUaW1lckVsZW1lbnQgPSB2aXN1YWxzLnF1ZXJ5U2VsZWN0b3IoJy5yZWNvcmRUaW1lcicpXG5cbiAgICBpZiAoIXJlY29yZFRpbWVyRWxlbWVudCkge1xuICAgICAgcmVjb3JkVGltZXJFbGVtZW50ID0gaCgncC5yZWNvcmRUaW1lcicpXG5cbiAgICAgIGhpZGUoKVxuXG4gICAgICB2aXN1YWxzLmFwcGVuZENoaWxkKHJlY29yZFRpbWVyRWxlbWVudClcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZSgpXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgdXRpbCBmcm9tICd1dGlsJ1xuXG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vLi4vLi4vLi4vZXZlbnRzJ1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLy4uLy4uLy4uL3V0aWwvZXZlbnRFbWl0dGVyJ1xuXG5pbXBvcnQgQ291bnRkb3duIGZyb20gJy4vcmVjb3JkZXIvY291bnRkb3duJ1xuaW1wb3J0IFBhdXNlZE5vdGUgZnJvbSAnLi9yZWNvcmRlci9wYXVzZWROb3RlJ1xuaW1wb3J0IFJlY29yZE5vdGUgZnJvbSAnLi9yZWNvcmRlci9yZWNvcmROb3RlJ1xuaW1wb3J0IFJlY29yZFRpbWVyIGZyb20gJy4vcmVjb3JkZXIvcmVjb3JkVGltZXInXG5cbmNvbnN0IFJlY29yZGVySW5zaWRlcyA9IGZ1bmN0aW9uICh2aXN1YWxzLCBvcHRpb25zKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMsIG9wdGlvbnMsICdSZWNvcmRlckluc2lkZXMnKVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGNvbnN0IGRlYnVnID0gb3B0aW9ucy5kZWJ1Z1xuXG4gIGNvbnN0IHJlY29yZE5vdGUgPSBuZXcgUmVjb3JkTm90ZSh2aXN1YWxzKVxuICBjb25zdCByZWNvcmRUaW1lciA9IG5ldyBSZWNvcmRUaW1lcih2aXN1YWxzLCByZWNvcmROb3RlLCBvcHRpb25zKVxuXG4gIHZhciBjb3VudGRvd25cbiAgdmFyIHBhdXNlZE5vdGVcbiAgdmFyIGJ1aWx0XG5cbiAgaWYgKG9wdGlvbnMudmlkZW8uY291bnRkb3duKSB7XG4gICAgY291bnRkb3duID0gbmV3IENvdW50ZG93bih2aXN1YWxzLCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuZW5hYmxlUGF1c2UpIHtcbiAgICBwYXVzZWROb3RlID0gbmV3IFBhdXNlZE5vdGUodmlzdWFscywgb3B0aW9ucylcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0UmVjb3JkaW5nICgpIHtcbiAgICByZWNvcmRUaW1lci5zdGFydCgpXG4gIH1cblxuICBmdW5jdGlvbiByZXN1bWVSZWNvcmRpbmcgKCkge1xuICAgIHJlY29yZFRpbWVyLnJlc3VtZSgpXG4gIH1cblxuICBmdW5jdGlvbiBzdG9wUmVjb3JkaW5nICgpIHtcbiAgICByZWNvcmRUaW1lci5zdG9wKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdXNlUmVjb3JkaW5nICgpIHtcbiAgICBpZiAoc2VsZi5pc0NvdW50aW5nRG93bigpKSB7XG4gICAgICBjb3VudGRvd24ucGF1c2UoKVxuICAgIH0gZWxzZSB7XG4gICAgICByZWNvcmRUaW1lci5wYXVzZSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZXNldHRpbmcgKCkge1xuICAgIHNlbGYuaGlkZVBhdXNlKClcbiAgICBzZWxmLmhpZGVDb3VudGRvd24oKVxuICAgIHJlY29yZFRpbWVyLnN0b3AoKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEV2ZW50cyAoKSB7XG4gICAgc2VsZlxuICAgICAgLm9uKEV2ZW50cy5SRUNPUkRJTkcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RhcnRSZWNvcmRpbmcoKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuUkVTVU1JTkcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzdW1lUmVjb3JkaW5nKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLlNUT1BQSU5HLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0b3BSZWNvcmRpbmcoKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuUEFVU0VELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhdXNlUmVjb3JkaW5nKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLlJFU0VUVElORywgb25SZXNldHRpbmcpXG4gICAgICAub24oRXZlbnRzLkhJREUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5oaWRlQ291bnRkb3duKClcbiAgICAgIH0pXG4gIH1cblxuICB0aGlzLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCdSZWNvcmRlckluc2lkZXM6IGJ1aWxkKCknKVxuXG4gICAgY291bnRkb3duICYmIGNvdW50ZG93bi5idWlsZCgpXG4gICAgcGF1c2VkTm90ZSAmJiBwYXVzZWROb3RlLmJ1aWxkKClcblxuICAgIHJlY29yZE5vdGUuYnVpbGQoKVxuICAgIHJlY29yZFRpbWVyLmJ1aWxkKClcblxuICAgICFidWlsdCAmJiBpbml0RXZlbnRzKClcblxuICAgIGJ1aWx0ID0gdHJ1ZVxuICB9XG5cbiAgdGhpcy51bmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY291bnRkb3duICYmIGNvdW50ZG93bi51bmxvYWQoKVxuXG4gICAgYnVpbHQgPSBmYWxzZVxuICB9XG5cbiAgdGhpcy5zaG93UGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGF1c2VkTm90ZSAmJiBwYXVzZWROb3RlLnNob3coKVxuICB9XG5cbiAgdGhpcy5oaWRlUGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGF1c2VkTm90ZSAmJiBwYXVzZWROb3RlLmhpZGUoKVxuICB9XG5cbiAgdGhpcy5oaWRlQ291bnRkb3duID0gZnVuY3Rpb24gKCkge1xuICAgIGNvdW50ZG93biAmJiBjb3VudGRvd24uaGlkZSgpXG4gIH1cblxuICB0aGlzLnN0YXJ0Q291bnRkb3duID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgY291bnRkb3duICYmIGNvdW50ZG93bi5zdGFydChjYilcbiAgfVxuXG4gIHRoaXMucmVzdW1lQ291bnRkb3duID0gZnVuY3Rpb24gKCkge1xuICAgIGNvdW50ZG93biAmJiBjb3VudGRvd24ucmVzdW1lKClcbiAgfVxuXG4gIHRoaXMuaXNDb3VudGluZ0Rvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvdW50ZG93biAmJiBjb3VudGRvd24uaXNDb3VudGluZ0Rvd24oKVxuICB9XG5cbiAgdGhpcy5jaGVja1RpbWVyID0gZnVuY3Rpb24gKGludGVydmFsU3VtKSB7XG4gICAgcmVjb3JkVGltZXIuY2hlY2soaW50ZXJ2YWxTdW0pXG4gIH1cbn1cblxudXRpbC5pbmhlcml0cyhSZWNvcmRlckluc2lkZXMsIEV2ZW50RW1pdHRlcilcblxuZXhwb3J0IGRlZmF1bHQgUmVjb3JkZXJJbnNpZGVzXG4iLCJpbXBvcnQgdXRpbCBmcm9tICd1dGlsJ1xuaW1wb3J0IGggZnJvbSAnaHlwZXJzY3JpcHQnXG5pbXBvcnQgaGlkZGVuIGZyb20gJ2hpZGRlbidcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLy4uLy4uL3V0aWwvZXZlbnRFbWl0dGVyJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLy4uLy4uL2V2ZW50cydcblxuY29uc3QgTm90aWZpZXIgPSBmdW5jdGlvbiAodmlzdWFscywgb3B0aW9ucykge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzLCBvcHRpb25zLCAnTm90aWZpZXInKVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGNvbnN0IGRlYnVnID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnXG5cbiAgdmFyIG5vdGlmeUVsZW1lbnRcbiAgdmFyIG1lc3NhZ2VFbGVtZW50XG4gIHZhciBleHBsYW5hdGlvbkVsZW1lbnRcbiAgdmFyIGVudGVydGFpblRpbWVvdXRJZFxuICB2YXIgZW50ZXJ0YWluaW5nXG4gIHZhciBidWlsdFxuXG4gIGZ1bmN0aW9uIG9uU3RvcHBpbmcgKGxpbWl0UmVhY2hlZCkge1xuICAgIHZhciBsZWFkID0gJydcblxuICAgIHZpc3VhbHMuYmVnaW5XYWl0aW5nKClcblxuICAgIGlmIChsaW1pdFJlYWNoZWQpIHtcbiAgICAgIGRlYnVnKCdMaW1pdCByZWFjaGVkJylcbiAgICAgIGxlYWQgKz0gb3B0aW9ucy50ZXh0LmxpbWl0UmVhY2hlZCArICcuPGJyLz4nXG4gICAgfVxuXG4gICAgbGVhZCArPSBvcHRpb25zLnRleHQuc2VuZGluZyArICcg4oCmJ1xuXG4gICAgc2VsZi5ub3RpZnkobGVhZCwgbnVsbCwge1xuICAgICAgc3RpbGxXYWl0OiB0cnVlLFxuICAgICAgZW50ZXJ0YWluOiBvcHRpb25zLm5vdGlmaWVyLmVudGVydGFpblxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbm5lY3RpbmcgKCkge1xuICAgIHNlbGYubm90aWZ5KCdDb25uZWN0aW5nIOKApicpXG4gIH1cblxuICBmdW5jdGlvbiBvbkxvYWRpbmdVc2VyTWVkaWEgKCkge1xuICAgIHNlbGYubm90aWZ5KCdMb2FkaW5nIHdlYmNhbSDigKYnKVxuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9ncmVzcyAoZnJhbWVQcm9ncmVzcywgc2FtcGxlUHJvZ3Jlc3MpIHtcbiAgICB2YXIgb3ZlcmFsbFByb2dyZXNzXG5cbiAgICBpZiAob3B0aW9ucy5pc0F1ZGlvRW5hYmxlZCgpKSB7XG4gICAgICBvdmVyYWxsUHJvZ3Jlc3MgPSAnVmlkZW86ICcgKyBmcmFtZVByb2dyZXNzXG5cbiAgICAgIGlmIChzYW1wbGVQcm9ncmVzcykge1xuICAgICAgICBvdmVyYWxsUHJvZ3Jlc3MgKz0gJywgQXVkaW86ICcgKyBzYW1wbGVQcm9ncmVzc1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdmVyYWxsUHJvZ3Jlc3MgPSBmcmFtZVByb2dyZXNzXG4gICAgfVxuXG4gICAgc2VsZi5zZXRFeHBsYW5hdGlvbihvdmVyYWxsUHJvZ3Jlc3MpXG4gIH1cblxuICBmdW5jdGlvbiBvbkJlZ2luVmlkZW9FbmNvZGluZyAoKSB7XG4gICAgdmlzdWFscy5iZWdpbldhaXRpbmcoKVxuXG4gICAgY29uc3QgbGVhZCA9IG9wdGlvbnMudGV4dC5lbmNvZGluZyArICcg4oCmJ1xuXG4gICAgc2VsZi5ub3RpZnkobGVhZCwgbnVsbCwge1xuICAgICAgc3RpbGxXYWl0OiB0cnVlLFxuICAgICAgZW50ZXJ0YWluOiBvcHRpb25zLm5vdGlmaWVyLmVudGVydGFpblxuICAgIH0pXG5cbiAgICBoaWRlRXhwbGFuYXRpb24oKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEV2ZW50cyAoKSB7XG4gICAgZGVidWcoJ05vdGlmaWVyOiBpbml0RXZlbnRzKCknKVxuXG4gICAgc2VsZlxuICAgICAgLm9uKEV2ZW50cy5DT05ORUNUSU5HLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uQ29ubmVjdGluZygpXG4gICAgICB9KVxuICAgICAgLm9uKEV2ZW50cy5MT0FESU5HX1VTRVJfTUVESUEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25Mb2FkaW5nVXNlck1lZGlhKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLlVTRVJfTUVESUFfUkVBRFksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5oaWRlKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLkxPQURFRF9NRVRBX0RBVEEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29ycmVjdERpbWVuc2lvbnMoKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuUFJFVklFVywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmhpZGUoKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuU1RPUFBJTkcsIGZ1bmN0aW9uIChsaW1pdFJlYWNoZWQpIHtcbiAgICAgICAgb25TdG9wcGluZyhsaW1pdFJlYWNoZWQpXG4gICAgICB9KVxuICAgICAgLm9uKEV2ZW50cy5QUk9HUkVTUywgZnVuY3Rpb24gKGZyYW1lUHJvZ3Jlc3MsIHNhbXBsZVByb2dyZXNzKSB7XG4gICAgICAgIG9uUHJvZ3Jlc3MoZnJhbWVQcm9ncmVzcywgc2FtcGxlUHJvZ3Jlc3MpXG4gICAgICB9KVxuICAgICAgLm9uKEV2ZW50cy5CRUdJTl9WSURFT19FTkNPRElORywgZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkJlZ2luVmlkZW9FbmNvZGluZygpXG4gICAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY29ycmVjdERpbWVuc2lvbnMgKCkge1xuICAgIG5vdGlmeUVsZW1lbnQuc3R5bGUud2lkdGggPSB2aXN1YWxzLmdldFJlY29yZGVyV2lkdGgodHJ1ZSkgKyAncHgnXG4gICAgbm90aWZ5RWxlbWVudC5zdHlsZS5oZWlnaHQgPSB2aXN1YWxzLmdldFJlY29yZGVySGVpZ2h0KHRydWUpICsgJ3B4J1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdyAoKSB7XG4gICAgbm90aWZ5RWxlbWVudCAmJiBoaWRkZW4obm90aWZ5RWxlbWVudCwgZmFsc2UpXG4gIH1cblxuICBmdW5jdGlvbiBydW5FbnRlcnRhaW5tZW50ICgpIHtcbiAgICBpZiAob3B0aW9ucy5ub3RpZmllci5lbnRlcnRhaW4pIHtcbiAgICAgIGlmICghZW50ZXJ0YWluaW5nKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbUJhY2tncm91bmRDbGFzcyA9IE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiBvcHRpb25zLm5vdGlmaWVyLmVudGVydGFpbkxpbWl0KSArIDEpXG5cbiAgICAgICAgbm90aWZ5RWxlbWVudC5jbGFzc05hbWUgPSAnbm90aWZpZXIgZW50ZXJ0YWluICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubm90aWZpZXIuZW50ZXJ0YWluQ2xhc3MgK1xuICAgICAgICAgICAgICAgIHJhbmRvbUJhY2tncm91bmRDbGFzc1xuXG4gICAgICAgIGVudGVydGFpblRpbWVvdXRJZCA9IHNldFRpbWVvdXQocnVuRW50ZXJ0YWlubWVudCwgb3B0aW9ucy5ub3RpZmllci5lbnRlcnRhaW5JbnRlcnZhbClcbiAgICAgICAgZW50ZXJ0YWluaW5nID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYW5jZWxFbnRlcnRhaW5tZW50KClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWxFbnRlcnRhaW5tZW50ICgpIHtcbiAgICBpZiAobm90aWZ5RWxlbWVudCkge1xuICAgICAgbm90aWZ5RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdlbnRlcnRhaW4nKVxuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChlbnRlcnRhaW5UaW1lb3V0SWQpXG4gICAgZW50ZXJ0YWluVGltZW91dElkID0gbnVsbFxuICAgIGVudGVydGFpbmluZyA9IGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBzZXRNZXNzYWdlIChtZXNzYWdlLCBtZXNzYWdlT3B0aW9ucykge1xuICAgIGNvbnN0IHByb2JsZW0gPSBtZXNzYWdlT3B0aW9ucy5wcm9ibGVtID8gbWVzc2FnZU9wdGlvbnMucHJvYmxlbSA6IGZhbHNlXG5cbiAgICBpZiAobWVzc2FnZUVsZW1lbnQpIHtcbiAgICAgIG1lc3NhZ2VFbGVtZW50LmlubmVySFRNTCA9IChwcm9ibGVtID8gJyYjeDI2Mzk7ICcgOiAnJykgKyBtZXNzYWdlXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMubG9nZ2VyLndhcm4oXG4gICAgICAgICdVbmFibGUgdG8gc2hvdyBmb2xsb3dpbmcgYmVjYXVzZSBtZXNzYWdlRWxlbWVudCBpcyBlbXB0eTonLFxuICAgICAgICBtZXNzYWdlXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgdGhpcy5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyLm1lc3NhZ2UgPyBlcnIubWVzc2FnZS50b1N0cmluZygpIDogZXJyLnRvU3RyaW5nKClcbiAgICBjb25zdCBleHBsYW5hdGlvbiA9IGVyci5leHBsYW5hdGlvbiA/IGVyci5leHBsYW5hdGlvbi50b1N0cmluZygpIDogbnVsbFxuXG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICBvcHRpb25zLmRlYnVnKCdXZWlyZCBlbXB0eSBtZXNzYWdlIGdlbmVyYXRlZCBmb3IgZXJyb3InLCBlcnIpXG4gICAgfVxuXG4gICAgc2VsZi5ub3RpZnkobWVzc2FnZSwgZXhwbGFuYXRpb24sIHtcbiAgICAgIGJsb2NraW5nOiB0cnVlLFxuICAgICAgcHJvYmxlbTogdHJ1ZSxcbiAgICAgIGhpZGVGb3JtOiBlcnIuaGlkZUZvcm0gJiYgZXJyLmhpZGVGb3JtKCksXG4gICAgICBjbGFzc0xpc3Q6IGVyci5nZXRDbGFzc0xpc3QgJiYgZXJyLmdldENsYXNzTGlzdCgpLFxuICAgICAgcmVtb3ZlRGltZW5zaW9uczogZXJyLnJlbW92ZURpbWVuc2lvbnMgJiYgZXJyLnJlbW92ZURpbWVuc2lvbnMoKVxuICAgIH0pXG4gIH1cblxuICB0aGlzLnNldEV4cGxhbmF0aW9uID0gZnVuY3Rpb24gKGV4cGxhbmF0aW9uKSB7XG4gICAgaWYgKCFleHBsYW5hdGlvbkVsZW1lbnQpIHtcbiAgICAgIGV4cGxhbmF0aW9uRWxlbWVudCA9IGgoJ3AnKVxuXG4gICAgICBpZiAobm90aWZ5RWxlbWVudCkge1xuICAgICAgICBub3RpZnlFbGVtZW50LmFwcGVuZENoaWxkKGV4cGxhbmF0aW9uRWxlbWVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMubG9nZ2VyLndhcm4oXG4gICAgICAgICAgJ1VuYWJsZSB0byBzaG93IGV4cGxhbmF0aW9uIGJlY2F1c2Ugbm90aWZ5RWxlbWVudCBpcyBlbXB0eTonLFxuICAgICAgICAgIGV4cGxhbmF0aW9uXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBsYW5hdGlvbkVsZW1lbnQuaW5uZXJIVE1MID0gZXhwbGFuYXRpb25cblxuICAgIGhpZGRlbihleHBsYW5hdGlvbkVsZW1lbnQsIGZhbHNlKVxuICB9XG5cbiAgdGhpcy5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvcHRpb25zLmRlYnVnKCdOb3RpZmllcjogYnVpbGQoKScpXG5cbiAgICBub3RpZnlFbGVtZW50ID0gdmlzdWFscy5xdWVyeVNlbGVjdG9yKCcubm90aWZpZXInKVxuXG4gICAgaWYgKCFub3RpZnlFbGVtZW50KSB7XG4gICAgICBub3RpZnlFbGVtZW50ID0gaCgnLm5vdGlmaWVyJykgLy8gZGVmYXVsdHMgdG8gZGl2XG5cbiAgICAgIHRoaXMuaGlkZSgpXG5cbiAgICAgIHZpc3VhbHMuYXBwZW5kQ2hpbGQobm90aWZ5RWxlbWVudClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKClcbiAgICB9XG5cbiAgICAhYnVpbHQgJiYgaW5pdEV2ZW50cygpXG5cbiAgICBidWlsdCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGVFeHBsYW5hdGlvbiAoKSB7XG4gICAgaWYgKGV4cGxhbmF0aW9uRWxlbWVudCkge1xuICAgICAgZXhwbGFuYXRpb25FbGVtZW50LmlubmVySFRNTCA9IG51bGxcbiAgICAgIGhpZGRlbihleHBsYW5hdGlvbkVsZW1lbnQsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGNhbmNlbEVudGVydGFpbm1lbnQoKVxuXG4gICAgaWYgKG5vdGlmeUVsZW1lbnQpIHtcbiAgICAgIGhpZGRlbihub3RpZnlFbGVtZW50LCB0cnVlKVxuICAgICAgbm90aWZ5RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdibG9ja2luZycpXG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2VFbGVtZW50KSB7XG4gICAgICBtZXNzYWdlRWxlbWVudC5pbm5lckhUTUwgPSBudWxsXG4gICAgfVxuXG4gICAgaGlkZUV4cGxhbmF0aW9uKClcbiAgfVxuXG4gIHRoaXMuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghYnVpbHQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm90aWZ5RWxlbWVudCAmJiAhaGlkZGVuKG5vdGlmeUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5pc0J1aWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBidWlsdFxuICB9XG5cbiAgdGhpcy5ub3RpZnkgPSBmdW5jdGlvbiAobWVzc2FnZSwgZXhwbGFuYXRpb24sIG5vdGlmeU9wdGlvbnMpIHtcbiAgICBvcHRpb25zLmRlYnVnKCdOb3RpZmllcjogbm90aWZ5KCknKVxuXG4gICAgaWYgKCFub3RpZnlPcHRpb25zKSB7XG4gICAgICBub3RpZnlPcHRpb25zID0ge31cbiAgICB9XG5cbiAgICBjb25zdCBzdGlsbFdhaXQgPSBub3RpZnlPcHRpb25zLnN0aWxsV2FpdCA/IG5vdGlmeU9wdGlvbnMuc3RpbGxXYWl0IDogZmFsc2VcbiAgICBjb25zdCBlbnRlcnRhaW4gPSBub3RpZnlPcHRpb25zLmVudGVydGFpbiA/IG5vdGlmeU9wdGlvbnMuZW50ZXJ0YWluIDogZmFsc2VcbiAgICBjb25zdCBibG9ja2luZyA9IG5vdGlmeU9wdGlvbnMuYmxvY2tpbmcgPyBub3RpZnlPcHRpb25zLmJsb2NraW5nIDogZmFsc2VcbiAgICBjb25zdCBoaWRlRm9ybSA9IG5vdGlmeU9wdGlvbnMuaGlkZUZvcm0gPyBub3RpZnlPcHRpb25zLmhpZGVGb3JtIDogZmFsc2VcbiAgICBjb25zdCBjbGFzc0xpc3QgPSBub3RpZnlPcHRpb25zLmNsYXNzTGlzdCA/IG5vdGlmeU9wdGlvbnMuY2xhc3NMaXN0IDogZmFsc2VcbiAgICBjb25zdCByZW1vdmVEaW1lbnNpb25zID0gbm90aWZ5T3B0aW9ucy5yZW1vdmVEaW1lbnNpb25zID8gbm90aWZ5T3B0aW9ucy5yZW1vdmVEaW1lbnNpb25zIDogZmFsc2VcblxuICAgIGlmICghbWVzc2FnZUVsZW1lbnQgJiYgbm90aWZ5RWxlbWVudCkge1xuICAgICAgbWVzc2FnZUVsZW1lbnQgPSBoKCdoMicpXG5cbiAgICAgIGlmIChleHBsYW5hdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgbm90aWZ5RWxlbWVudC5pbnNlcnRCZWZvcmUobWVzc2FnZUVsZW1lbnQsIGV4cGxhbmF0aW9uRWxlbWVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vdGlmeUVsZW1lbnQuYXBwZW5kQ2hpbGQobWVzc2FnZUVsZW1lbnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vdGlmeUVsZW1lbnQpIHtcbiAgICAgIC8vIHJlc2V0XG4gICAgICBpZiAoIWVudGVydGFpbikge1xuICAgICAgICBub3RpZnlFbGVtZW50LmNsYXNzTmFtZSA9ICdub3RpZmllcidcbiAgICAgIH1cblxuICAgICAgaWYgKGNsYXNzTGlzdCkge1xuICAgICAgICBjbGFzc0xpc3QuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgbm90aWZ5RWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbW92ZURpbWVuc2lvbnMpIHtcbiAgICAgICAgbm90aWZ5RWxlbWVudC5zdHlsZS53aWR0aCA9ICdhdXRvJ1xuICAgICAgICBub3RpZnlFbGVtZW50LnN0eWxlLmhlaWdodCA9ICdhdXRvJ1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChibG9ja2luZykge1xuICAgICAgbm90aWZ5RWxlbWVudCAmJiBub3RpZnlFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2Jsb2NraW5nJylcbiAgICAgIHRoaXMuZW1pdChFdmVudHMuQkxPQ0tJTkcsIHtoaWRlRm9ybTogaGlkZUZvcm19KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoRXZlbnRzLk5PVElGWUlORylcbiAgICB9XG5cbiAgICB2aXN1YWxzLmhpZGVSZXBsYXkoKVxuICAgIHZpc3VhbHMuaGlkZVJlY29yZGVyKClcblxuICAgIHNldE1lc3NhZ2UobWVzc2FnZSwgbm90aWZ5T3B0aW9ucylcblxuICAgIGV4cGxhbmF0aW9uICYmIHRoaXMuc2V0RXhwbGFuYXRpb24oZXhwbGFuYXRpb24pXG5cbiAgICBpZiAoZW50ZXJ0YWluKSB7XG4gICAgICBydW5FbnRlcnRhaW5tZW50KClcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuY2VsRW50ZXJ0YWlubWVudCgpXG4gICAgfVxuXG4gICAgLy8ganVzdCBhcyBhIHNhZmV0eSBpbiBjYXNlIGlmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgbWlkZGxlIG9mIHRoZSBidWlsZCBwcm9jZXNzXG4gICAgLy8gYW5kIHZpc3VhbHMgYXJlbid0IGJ1aWx0L3Nob3duIHlldC5cbiAgICB2aXN1YWxzLnNob3dWaXN1YWxzKClcblxuICAgIHNob3coKVxuXG4gICAgIXN0aWxsV2FpdCAmJiB2aXN1YWxzLmVuZFdhaXRpbmcoKVxuICB9XG59XG5cbnV0aWwuaW5oZXJpdHMoTm90aWZpZXIsIEV2ZW50RW1pdHRlcilcblxuZXhwb3J0IGRlZmF1bHQgTm90aWZpZXJcbiIsImltcG9ydCB3ZWJzb2NrZXQgZnJvbSAnd2Vic29ja2V0LXN0cmVhbSdcbmltcG9ydCBGcmFtZSBmcm9tICdjYW52YXMtdG8tYnVmZmVyJ1xuaW1wb3J0IHV0aWwgZnJvbSAndXRpbCdcbmltcG9ydCBoIGZyb20gJ2h5cGVyc2NyaXB0J1xuaW1wb3J0IGhpZGRlbiBmcm9tICdoaWRkZW4nXG5pbXBvcnQgYW5pbWl0dGVyIGZyb20gJ2FuaW1pdHRlcidcblxuaW1wb3J0IFVzZXJNZWRpYSBmcm9tICcuL3VzZXJNZWRpYSdcblxuaW1wb3J0IEV2ZW50cyBmcm9tICcuLy4uLy4uL2V2ZW50cydcbmltcG9ydCBDb25zdGFudHMgZnJvbSAnLi8uLi8uLi9jb25zdGFudHMnXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vLi4vLi4vdXRpbC9ldmVudEVtaXR0ZXInXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLy4uLy4uL3V0aWwvYnJvd3NlcidcbmltcG9ydCBIdW1hbml6ZSBmcm9tICcuLy4uLy4uL3V0aWwvaHVtYW5pemUnXG5pbXBvcnQgcHJldHR5IGZyb20gJy4vLi4vLi4vdXRpbC9wcmV0dHknXG5pbXBvcnQgVmlkZW9tYWlsRXJyb3IgZnJvbSAnLi8uLi8uLi91dGlsL3ZpZGVvbWFpbEVycm9yJ1xuXG4vLyBjcmVkaXRzIGh0dHA6Ly8xbGluZWFydC5rdWxhb25lLmNvbS8jL1xuY29uc3QgUElQRV9TWU1CT0wgPSAnwrDCusKkw7gswrjCuCzDuMKkwrrCsGDCsMK6wqTDuCzCuCzDuMKkwrDCusKkw7gswrjCuCzDuMKkwrrCsGDCsMK6wqTDuCzCuCAnXG5cbmNvbnN0IFJlY29yZGVyID0gZnVuY3Rpb24gKHZpc3VhbHMsIHJlcGxheSwgb3B0aW9ucykge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzLCBvcHRpb25zLCAnUmVjb3JkZXInKVxuXG4gICAgLy8gdmFsaWRhdGUgc29tZSBvcHRpb25zIHRoaXMgY2xhc3MgbmVlZHNcbiAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnZpZGVvIHx8ICFvcHRpb25zLnZpZGVvLmZwcykge1xuICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnRlBTIG11c3QgYmUgZGVmaW5lZCcsIG9wdGlvbnMpXG4gIH1cblxuICBjb25zdCBzZWxmID0gdGhpc1xuICBjb25zdCBicm93c2VyID0gbmV3IEJyb3dzZXIob3B0aW9ucylcbiAgY29uc3QgZGVidWcgPSBvcHRpb25zLmRlYnVnXG5cbiAgdmFyIGxvb3AgPSBudWxsXG5cbiAgdmFyIG9yaWdpbmFsQW5pbWF0aW9uRnJhbWVPYmplY3RcblxuICB2YXIgc2FtcGxlc0NvdW50ID0gMFxuICB2YXIgZnJhbWVzQ291bnQgPSAwXG5cbiAgdmFyIHJlY29yZGluZ1N0YXRzID0ge31cblxuICB2YXIgY29uZmlybWVkRnJhbWVOdW1iZXIgPSAwXG4gIHZhciBjb25maXJtZWRTYW1wbGVOdW1iZXIgPSAwXG5cbiAgdmFyIHJlY29yZGVyRWxlbWVudFxuICB2YXIgdXNlck1lZGlhXG5cbiAgdmFyIHVzZXJNZWRpYVRpbWVvdXRcbiAgdmFyIHJldHJ5VGltZW91dFxuXG4gIHZhciBieXRlc1N1bVxuXG4gIHZhciBmcmFtZVByb2dyZXNzXG4gIHZhciBzYW1wbGVQcm9ncmVzc1xuXG4gIHZhciBjYW52YXNcbiAgdmFyIGN0eFxuXG4gIHZhciB1c2VyTWVkaWFMb2FkZWRcbiAgdmFyIHVzZXJNZWRpYUxvYWRpbmdcbiAgdmFyIHN1Ym1pdHRpbmdcbiAgdmFyIHVubG9hZGVkXG4gIHZhciBzdG9wVGltZVxuICB2YXIgc3RyZWFtXG4gIHZhciBjb25uZWN0aW5nXG4gIHZhciBjb25uZWN0ZWRcbiAgdmFyIGJsb2NraW5nXG4gIHZhciBidWlsdFxuICB2YXIga2V5XG4gIHZhciB3YWl0aW5nVGltZVxuXG4gIHZhciBwaW5nSW50ZXJ2YWxcblxuICB2YXIgZnJhbWVcblxuICB2YXIgcmVjb3JkaW5nQnVmZmVyTGVuZ3RoXG4gIHZhciByZWNvcmRpbmdCdWZmZXJcblxuICBmdW5jdGlvbiB3cml0ZVN0cmVhbSAoYnVmZmVyLCBvcHRzKSB7XG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgICAgICdBbHJlYWR5IGRpc2Nvbm5lY3RlZCcsXG4gICAgICAgICAgJ1NvcnJ5LCB0aGUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIGhhcyBiZWVuIGRlc3Ryb3llZC4gUGxlYXNlIHJlbG9hZC4gJyArXG4gICAgICAgICAgJ0RldGFpbHMgb2YgYnVmZmVyOiAnICsgYnVmZmVyLnRvU3RyaW5nKCksXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb25GbHVzaGVkQ2FsbGJhY2sgPSBvcHRzICYmIG9wdHMub25GbHVzaGVkQ2FsbGJhY2tcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0cmVhbS53cml0ZShidWZmZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9uRmx1c2hlZENhbGxiYWNrICYmIG9uRmx1c2hlZENhbGxiYWNrKG9wdHMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgICAgICAgJ0ZhaWxlZCB3cml0aW5nIHRvIHNlcnZlcicsXG4gICAgICAgICAgICAnc3RyZWFtLndyaXRlKCkgZmFpbGVkIGJlY2F1c2Ugb2YgJyArIHByZXR0eShleGMpLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZW5kUGluZ3MgKCkge1xuICAgIHBpbmdJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygnUmVjb3JkZXI6IHBpbmdpbmcuLi4nKVxuICAgICAgd3JpdGVTdHJlYW0oQnVmZmVyLmZyb20oJycpKVxuICAgIH0sIG9wdGlvbnMudGltZW91dHMucGluZ0ludGVydmFsKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcFBpbmdzICgpIHtcbiAgICBjbGVhckludGVydmFsKHBpbmdJbnRlcnZhbClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQXVkaW9TYW1wbGUgKGF1ZGlvU2FtcGxlKSB7XG4gICAgc2FtcGxlc0NvdW50KytcblxuICAgIGNvbnN0IGF1ZGlvQnVmZmVyID0gYXVkaW9TYW1wbGUudG9CdWZmZXIoKVxuXG4gICAgLy8gaWYgKG9wdGlvbnMudmVyYm9zZSkge1xuICAgIC8vICAgICBkZWJ1ZyhcbiAgICAvLyAgICAgICAgICdTYW1wbGUgIycgKyBzYW1wbGVzQ291bnQgKyAnICgnICsgYXVkaW9CdWZmZXIubGVuZ3RoICsgJyBieXRlcyk6J1xuICAgIC8vICAgICApXG4gICAgLy8gfVxuXG4gICAgd3JpdGVTdHJlYW0oYXVkaW9CdWZmZXIpXG4gIH1cblxuICBmdW5jdGlvbiBzaG93ICgpIHtcbiAgICByZWNvcmRlckVsZW1lbnQgJiYgaGlkZGVuKHJlY29yZGVyRWxlbWVudCwgZmFsc2UpXG4gIH1cblxuICBmdW5jdGlvbiBvblVzZXJNZWRpYVJlYWR5ICgpIHtcbiAgICB0cnkge1xuICAgICAgZGVidWcoJ1JlY29yZGVyOiBvblVzZXJNZWRpYVJlYWR5KCknKVxuXG4gICAgICB1c2VyTWVkaWFMb2FkaW5nID0gYmxvY2tpbmcgPSB1bmxvYWRlZCA9IHN1Ym1pdHRpbmcgPSBmYWxzZVxuICAgICAgdXNlck1lZGlhTG9hZGVkID0gdHJ1ZVxuXG4gICAgICBsb29wID0gY3JlYXRlTG9vcCgpXG5cbiAgICAgIHNob3coKVxuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5VU0VSX01FRElBX1JFQURZLCB7cGF1c2VkOiBzZWxmLmlzUGF1c2VkKCl9KVxuICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXhjKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyUmV0cnlUaW1lb3V0ICgpIHtcbiAgICBkZWJ1ZygnUmVjb3JkZXI6IGNsZWFyUmV0cnlUaW1lb3V0KCknKVxuXG4gICAgcmV0cnlUaW1lb3V0ICYmIGNsZWFyVGltZW91dChyZXRyeVRpbWVvdXQpXG4gICAgcmV0cnlUaW1lb3V0ID0gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJVc2VyTWVkaWFUaW1lb3V0ICgpIHtcbiAgICBpZiAodXNlck1lZGlhVGltZW91dCkge1xuICAgICAgZGVidWcoJ1JlY29yZGVyOiBjbGVhclVzZXJNZWRpYVRpbWVvdXQoKScpXG5cbiAgICAgIHVzZXJNZWRpYVRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHVzZXJNZWRpYVRpbWVvdXQpXG4gICAgICB1c2VyTWVkaWFUaW1lb3V0ID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUZyYW1lUHJvZ3Jlc3MgKCkge1xuICAgIHJldHVybiAoY29uZmlybWVkRnJhbWVOdW1iZXIgLyAoZnJhbWVzQ291bnQgfHwgMSkgKiAxMDApLnRvRml4ZWQoMikgKyAnJSdcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZVNhbXBsZVByb2dyZXNzICgpIHtcbiAgICByZXR1cm4gKGNvbmZpcm1lZFNhbXBsZU51bWJlciAvIChzYW1wbGVzQ291bnQgfHwgMSkgKiAxMDApLnRvRml4ZWQoMikgKyAnJSdcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU92ZXJhbGxQcm9ncmVzcyAoKSB7XG4gICAgLy8gd2hlbiBwcm9ncmVzc2VzIGFyZW4ndCBpbml0aWFsaXplZCxcbiAgICAvLyB0aGVuIGRvIGEgZmlyc3QgY2FsY3VsYXRpb24gdG8gYXZvaWQgYGluZmluaXRlYCBvciBgbnVsbGAgZGlzcGxheXNcblxuICAgIGlmICghZnJhbWVQcm9ncmVzcykge1xuICAgICAgZnJhbWVQcm9ncmVzcyA9IGNhbGN1bGF0ZUZyYW1lUHJvZ3Jlc3MoKVxuICAgIH1cblxuICAgIGlmICghc2FtcGxlUHJvZ3Jlc3MpIHtcbiAgICAgIHNhbXBsZVByb2dyZXNzID0gY2FsY3VsYXRlU2FtcGxlUHJvZ3Jlc3MoKVxuICAgIH1cblxuICAgIHNlbGYuZW1pdChcbiAgICAgIEV2ZW50cy5QUk9HUkVTUyxcbiAgICAgIGZyYW1lUHJvZ3Jlc3MsXG4gICAgICBzYW1wbGVQcm9ncmVzc1xuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYW1lUHJvZ3Jlc3MgKGFyZ3MpIHtcbiAgICBjb25maXJtZWRGcmFtZU51bWJlciA9IGFyZ3MuZnJhbWUgPyBhcmdzLmZyYW1lIDogY29uZmlybWVkRnJhbWVOdW1iZXJcblxuICAgIGZyYW1lUHJvZ3Jlc3MgPSBjYWxjdWxhdGVGcmFtZVByb2dyZXNzKClcblxuICAgIHVwZGF0ZU92ZXJhbGxQcm9ncmVzcygpXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTYW1wbGVQcm9ncmVzcyAoYXJncykge1xuICAgIGNvbmZpcm1lZFNhbXBsZU51bWJlciA9IGFyZ3Muc2FtcGxlID8gYXJncy5zYW1wbGUgOiBjb25maXJtZWRTYW1wbGVOdW1iZXJcblxuICAgIHNhbXBsZVByb2dyZXNzID0gY2FsY3VsYXRlU2FtcGxlUHJvZ3Jlc3MoKVxuXG4gICAgdXBkYXRlT3ZlcmFsbFByb2dyZXNzKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXZpZXcgKGFyZ3MpIHtcbiAgICBjb25maXJtZWRGcmFtZU51bWJlciA9XG4gICAgY29uZmlybWVkU2FtcGxlTnVtYmVyID1cbiAgICBzYW1wbGVzQ291bnQgPVxuICAgIGZyYW1lc0NvdW50ID0gMFxuXG4gICAgc2FtcGxlUHJvZ3Jlc3MgPSBmcmFtZVByb2dyZXNzID0gbnVsbFxuXG4gICAga2V5ID0gYXJncy5rZXlcblxuICAgIGlmIChhcmdzLm1wNCkge1xuICAgICAgcmVwbGF5LnNldE1wNFNvdXJjZShcbiAgICAgICAgYXJncy5tcDQgKyBDb25zdGFudHMuU0lURV9OQU1FX0xBQkVMICsgJy8nICsgb3B0aW9ucy5zaXRlTmFtZSArICcvdmlkZW9tYWlsLm1wNCcsXG4gICAgICAgIHRydWVcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoYXJncy53ZWJtKSB7XG4gICAgICByZXBsYXkuc2V0V2ViTVNvdXJjZShcbiAgICAgICAgYXJncy53ZWJtICsgQ29uc3RhbnRzLlNJVEVfTkFNRV9MQUJFTCArICcvJyArIG9wdGlvbnMuc2l0ZU5hbWUgKyAnL3ZpZGVvbWFpbC53ZWJtJyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKVxuICAgIH1cblxuICAgIHNlbGYuaGlkZSgpXG4gICAgc2VsZi5lbWl0KEV2ZW50cy5QUkVWSUVXLCBrZXksIHNlbGYuZ2V0UmVjb3JkZXJXaWR0aCh0cnVlKSwgc2VsZi5nZXRSZWNvcmRlckhlaWdodCh0cnVlKSlcblxuICAgIC8vIGtlZXAgaXQgZm9yIHJlY29yZGluZyBzdGF0c1xuICAgIHdhaXRpbmdUaW1lID0gRGF0ZS5ub3coKSAtIHN0b3BUaW1lXG5cbiAgICByZWNvcmRpbmdTdGF0cy53YWl0aW5nVGltZSA9IHdhaXRpbmdUaW1lXG5cbiAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgZGVidWcoXG4gICAgICAgICdXaGlsZSByZWNvcmRpbmcsICVzIGhhdmUgYmVlbiB0cmFuc2ZlcnJlZCBhbmQgd2FpdGluZyB0aW1lIHdhcyAlcycsXG4gICAgICAgIEh1bWFuaXplLmZpbGVzaXplKGJ5dGVzU3VtLCAyKSxcbiAgICAgICAgSHVtYW5pemUudG9UaW1lKHdhaXRpbmdUaW1lKVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRTb2NrZXQgKGNiKSB7XG4gICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgIGNvbm5lY3RpbmcgPSB0cnVlXG5cbiAgICAgIGRlYnVnKCdSZWNvcmRlcjogaW5pdGlhbGlzaW5nIHdlYiBzb2NrZXQgdG8gJXMnLCBvcHRpb25zLnNvY2tldFVybClcblxuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5DT05ORUNUSU5HKVxuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vd2Vic29ja2V0LXN0cmVhbSNiaW5hcnktc29ja2V0c1xuXG4gICAgICAvLyB3ZSB1c2UgcXVlcnkgcGFyYW1ldGVycyBoZXJlIGJlY2F1c2Ugd2UgY2Fubm90IHNldCBjdXN0b20gaGVhZGVycyBpbiB3ZWIgc29ja2V0cyxcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvNDY3XG5cbiAgICAgIGNvbnN0IHVybDJDb25uZWN0ID1cbiAgICAgICAgb3B0aW9ucy5zb2NrZXRVcmwgK1xuICAgICAgICAnPycgK1xuICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoQ29uc3RhbnRzLlNJVEVfTkFNRV9MQUJFTCkgK1xuICAgICAgICAnPScgK1xuICAgICAgICBlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5zaXRlTmFtZSlcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gd2Vic29ja2V0IG9wdGlvbnMgY2Fubm90IGJlIHNldCBvbiBjbGllbnQgc2lkZSwgb25seSBvbiBzZXJ2ZXIsIHNlZVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vd2Vic29ja2V0LXN0cmVhbS9pc3N1ZXMvMTE2I2lzc3VlY29tbWVudC0yOTY0MjEwNzdcbiAgICAgICAgc3RyZWFtID0gd2Vic29ja2V0KHVybDJDb25uZWN0LCB7XG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vd2Vic29ja2V0LXN0cmVhbS9pc3N1ZXMvMTE3I2lzc3VlY29tbWVudC0yOTg4MjYwMTFcbiAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgICAgY29ubmVjdGluZyA9IGNvbm5lY3RlZCA9IGZhbHNlXG5cbiAgICAgICAgdmFyIGVyclxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2Vic29ja2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGVyciA9IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnVGhlcmUgaXMgbm8gd2Vic29ja2V0JywgJ0NhdXNlOiAnICsgcHJldHR5KGV4YyksIG9wdGlvbnMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyID0gVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgICAgICAgJ0ZhaWxlZCB0byBjb25uZWN0IHRvIHNlcnZlcicsXG4gICAgICAgICAgICAnUGxlYXNlIHVwZ3JhZGUgeW91ciBicm93c2VyLiBZb3VyIGN1cnJlbnQgdmVyc2lvbiBkb2VzIG5vdCBzZWVtIHRvIHN1cHBvcnQgd2Vic29ja2V0cy4nLFxuICAgICAgICAgICAgb3B0aW9ucywge1xuICAgICAgICAgICAgICBicm93c2VyUHJvYmxlbTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGVycilcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAvLyAvLyB1c2VmdWwgZm9yIGRlYnVnZ2luZyBzdHJlYW1zXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlmICghc3RyZWFtLm9yaWdpbmFsRW1pdCkge1xuICAgICAgICAvLyAgIHN0cmVhbS5vcmlnaW5hbEVtaXQgPSBzdHJlYW0uZW1pdFxuICAgICAgICAvLyB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHN0cmVhbS5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgLy8gICBpZiAoc3RyZWFtKSB7XG4gICAgICAgIC8vICAgICBkZWJ1ZyhQSVBFX1NZTUJPTCArICdEZWJ1Z2dpbmcgc3RyZWFtIGV2ZW50OicsIHR5cGUpXG4gICAgICAgIC8vICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcbiAgICAgICAgLy8gICAgIHJldHVybiBzdHJlYW0ub3JpZ2luYWxFbWl0LmFwcGx5KHN0cmVhbSwgYXJncylcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGRlYnVnKFBJUEVfU1lNQk9MICsgJ1N0cmVhbSBoYXMgY2xvc2VkJylcblxuICAgICAgICAgIGNvbm5lY3RpbmcgPSBjb25uZWN0ZWQgPSBmYWxzZVxuXG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXJyIHx8ICdVbmhhbmRsZWQgd2Vic29ja2V0IGVycm9yJylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5ESVNDT05ORUNURUQpXG5cbiAgICAgICAgICAgIC8vIHByZXZlbnRzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLmlvL2lzc3Vlcy8yOTcgaGFwcGVuaW5nXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWJ1ZyhQSVBFX1NZTUJPTCArICdTdHJlYW0gKmNvbm5lY3QqIGV2ZW50IGVtaXR0ZWQnKVxuXG4gICAgICAgICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbm5lY3RlZCA9IHRydWVcbiAgICAgICAgICAgIGNvbm5lY3RpbmcgPSB1bmxvYWRlZCA9IGZhbHNlXG5cbiAgICAgICAgICAgIHNlbGYuZW1pdChFdmVudHMuQ09OTkVDVEVEKVxuXG4gICAgICAgICAgICBkZWJ1ZygnR29pbmcgdG8gYXNrIGZvciB3ZWJjYW0gcGVybWlzc29ucyBub3cgLi4uJylcblxuICAgICAgICAgICAgY2IgJiYgY2IoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIGRlYnVnKFBJUEVfU1lNQk9MICsgJ1N0cmVhbSAqZGF0YSogZXZlbnQgZW1pdHRlZCcpXG5cbiAgICAgICAgICB2YXIgY29tbWFuZFxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1hbmQgPSBKU09OLnBhcnNlKGRhdGEudG9TdHJpbmcoKSlcbiAgICAgICAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgICAgICAgIGRlYnVnKCdGYWlsZWQgdG8gcGFyc2UgY29tbWFuZDonLCBleGMpXG5cbiAgICAgICAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIFZpZGVvbWFpbEVycm9yLmNyZWF0ZShcbiAgICAgICAgICAgICAgJ0ludmFsaWQgc2VydmVyIGNvbW1hbmQnLFxuICAgICAgICAgICAgICAvLyB0b1N0cmluZygpIHNpbmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC5pby9pc3N1ZXMvMjg4XG4gICAgICAgICAgICAgICdDb250YWN0IHVzIGFzYXAuIEJhZCBjb21tbWFuZCB3YXMgJyArIGRhdGEudG9TdHJpbmcoKSArICcuICcsXG4gICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGV4ZWN1dGVDb21tYW5kLmNhbGwoc2VsZiwgY29tbWFuZClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBkZWJ1ZyhQSVBFX1NZTUJPTCArICdTdHJlYW0gKmVycm9yKiBldmVudCBlbWl0dGVkJylcblxuICAgICAgICAgIGNvbm5lY3RpbmcgPSBjb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGVycilcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBqdXN0IGV4cGVyaW1lbnRhbFxuXG4gICAgICAgIHN0cmVhbS5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVidWcoUElQRV9TWU1CT0wgKyAnU3RyZWFtICpkcmFpbiogZXZlbnQgZW1pdHRlZCAoc2hvdWxkIG5vdCBoYXBwZW4hKScpXG4gICAgICAgIH0pXG5cbiAgICAgICAgc3RyZWFtLm9uKCdwcmVlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVidWcoUElQRV9TWU1CT0wgKyAnU3RyZWFtICpwcmVlbmQqIGV2ZW50IGVtaXR0ZWQnKVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlYnVnKFBJUEVfU1lNQk9MICsgJ1N0cmVhbSAqZW5kKiBldmVudCBlbWl0dGVkJylcbiAgICAgICAgfSlcblxuICAgICAgICBzdHJlYW0ub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlYnVnKFBJUEVfU1lNQk9MICsgJ1N0cmVhbSAqZHJhaW4qIGV2ZW50IGVtaXR0ZWQnKVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbigncGlwZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWJ1ZyhQSVBFX1NZTUJPTCArICdTdHJlYW0gKnBpcGUqIGV2ZW50IGVtaXR0ZWQnKVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbigndW5waXBlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlYnVnKFBJUEVfU1lNQk9MICsgJ1N0cmVhbSAqdW5waXBlKiBldmVudCBlbWl0dGVkJylcbiAgICAgICAgfSlcblxuICAgICAgICBzdHJlYW0ub24oJ3Jlc3VtZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWJ1ZyhQSVBFX1NZTUJPTCArICdTdHJlYW0gKnJlc3VtZSogZXZlbnQgZW1pdHRlZCcpXG4gICAgICAgIH0pXG5cbiAgICAgICAgc3RyZWFtLm9uKCd1bmNvcmsnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVidWcoUElQRV9TWU1CT0wgKyAnU3RyZWFtICp1bmNvcmsqIGV2ZW50IGVtaXR0ZWQnKVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbigncmVhZGFibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVidWcoUElQRV9TWU1CT0wgKyAnU3RyZWFtICpwcmVlbmQqIGV2ZW50IGVtaXR0ZWQnKVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbigncHJlZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRlYnVnKFBJUEVfU1lNQk9MICsgJ1N0cmVhbSAqcHJlZW5kKiBldmVudCBlbWl0dGVkJylcbiAgICAgICAgfSlcblxuICAgICAgICBzdHJlYW0ub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWJ1ZyhQSVBFX1NZTUJPTCArICdTdHJlYW0gKnByZWVuZCogZXZlbnQgZW1pdHRlZCcpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2hvd1VzZXJNZWRpYSAoKSB7XG4gICAgLy8gdXNlIGNvbm5lY3RlZCBmbGFnIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZ1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaW5hcnlraXRjaGVuL3ZpZGVvbWFpbC5pby9pc3N1ZXMvMzIzXG4gICAgcmV0dXJuIGNvbm5lY3RlZCAmJiAoaXNOb3RpZnlpbmcoKSB8fCAhaXNIaWRkZW4oKSB8fCBibG9ja2luZylcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZXJNZWRpYUVycm9yQ2FsbGJhY2sgKGVycikge1xuICAgIHVzZXJNZWRpYUxvYWRpbmcgPSBmYWxzZVxuICAgIGNsZWFyVXNlck1lZGlhVGltZW91dCgpXG5cbiAgICBkZWJ1ZyhcbiAgICAgICdSZWNvcmRlcjogdXNlck1lZGlhRXJyb3JDYWxsYmFjaygpJyxcbiAgICAgICcsIFdlYmNhbSBjaGFyYWN0ZXJpc3RpY3M6JyxcbiAgICAgIHVzZXJNZWRpYS5nZXRDaGFyYWN0ZXJpc3RpY3MoKSxcbiAgICAgICcsIHRlbXBvcmFyeSBlcnIgc3RhY2s6JyxcbiAgICAgIChlcnIgJiYgZXJyLnN0YWNrKSB8fCAnKHVuZGVmaW5lZCknXG4gICAgKVxuXG4gICAgY29uc3QgZXJyb3JMaXN0ZW5lcnMgPSBzZWxmLmxpc3RlbmVycyhFdmVudHMuRVJST1IpXG5cbiAgICBpZiAoZXJyb3JMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICBpZiAoZXJyLm5hbWUgIT09IFZpZGVvbWFpbEVycm9yLk1FRElBX0RFVklDRV9OT1RfU1VQUE9SVEVEKSB7XG4gICAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvIG5vdCBlbWl0IGJ1dCByZXRyeSBzaW5jZSBNRURJQV9ERVZJQ0VfTk9UX1NVUFBPUlRFRCBjYW4gYmUgYSByYWNlIGNvbmRpdGlvblxuICAgICAgICBkZWJ1ZygnUmVjb3JkZXI6IGlnbm9yZSB1c2VyIG1lZGlhIGVycm9yJywgZXJyKVxuICAgICAgfVxuXG4gICAgICAvLyByZXRyeSBhZnRlciBhIHdoaWxlXG4gICAgICByZXRyeVRpbWVvdXQgPSBzZXRUaW1lb3V0KGluaXRTb2NrZXQsIG9wdGlvbnMudGltZW91dHMudXNlck1lZGlhKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodW5sb2FkZWQpIHtcbiAgICAgICAgLy8gY2FuIGhhcHBlbiB0aGF0IGNvbnRhaW5lciBpcyB1bmxvYWRlZCBidXQgc29tZSB1c2VyIG1lZGlhIHJlbGF0ZWQgY2FsbGJhY2tzXG4gICAgICAgIC8vIGFyZSBzdGlsbCBpbiBwcm9jZXNzLiBpbiB0aGF0IGNhc2UgaWdub3JlIGVycm9yLlxuICAgICAgICBkZWJ1ZygnUmVjb3JkZXI6IGFscmVhZHkgdW5sb2FkZWQuIE5vdCBnb2luZyB0byB0aHJvdyBlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdSZWNvcmRlcjogbm8gZXJyb3IgbGlzdGVuZXJzIGF0dGFjaGVkIGJ1dCB0aHJvd2luZyBlcnJvcicsIGVycilcblxuICAgICAgICAvLyB3ZWlyZCBzaXR1YXRpb24sIHRocm93IGl0IGluc3RlYWQgb2YgZW1pdHRpbmcgc2luY2UgdGhlcmUgYXJlIG5vIGVycm9yIGxpc3RlbmVyc1xuICAgICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgICdVbmFibGUgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHNpbmNlIHRoZXJlIGFyZSBubyBlcnJvciBsaXN0ZW5lcnMgYW55bW9yZS4nLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVzZXJNZWRpYUNhbGxiYWNrIChsb2NhbFN0cmVhbSkge1xuICAgIGRlYnVnKCdSZWNvcmRlcjogZ2V0VXNlck1lZGlhQ2FsbGJhY2soKScpXG5cbiAgICBpZiAoc2hvd1VzZXJNZWRpYSgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjbGVhclVzZXJNZWRpYVRpbWVvdXQoKVxuXG4gICAgICAgIHVzZXJNZWRpYS5pbml0KFxuICAgICAgICAgIGxvY2FsU3RyZWFtLFxuICAgICAgICAgIG9uVXNlck1lZGlhUmVhZHkuYmluZChzZWxmKSxcbiAgICAgICAgICBvbkF1ZGlvU2FtcGxlLmJpbmQoc2VsZiksXG4gICAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGV4YylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkR2VudWluZVVzZXJNZWRpYSAoKSB7XG4gICAgaWYgKCFuYXZpZ2F0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmF2aWdhdG9yIGlzIG1pc3NpbmchJylcbiAgICB9XG5cbiAgICBkZWJ1ZygnUmVjb3JkZXI6IGxvYWRHZW51aW5lVXNlck1lZGlhKCknKVxuXG4gICAgc2VsZi5lbWl0KEV2ZW50cy5BU0tJTkdfV0VCQ0FNX1BFUk1JU1NJT04pXG5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFEZXZpY2VzL2dldFVzZXJNZWRpYVxuICAgIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgICAvLyBwcmVmZXIgdGhlIGZyb250IGNhbWVyYSAoaWYgb25lIGlzIGF2YWlsYWJsZSkgb3ZlciB0aGUgcmVhciBvbmVcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0ge1xuICAgICAgICB2aWRlbzoge1xuICAgICAgICAgIGZhY2luZ01vZGU6ICd1c2VyJyxcbiAgICAgICAgICBmcmFtZVJhdGU6IHtpZGVhbDogb3B0aW9ucy52aWRlby5mcHN9XG4gICAgICAgIH0sXG4gICAgICAgIGF1ZGlvOiBvcHRpb25zLmlzQXVkaW9FbmFibGVkKClcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaGFzRGVmaW5lZFdpZHRoKCkpIHtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8ud2lkdGggPSB7aWRlYWw6IG9wdGlvbnMudmlkZW8ud2lkdGh9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmhhc0RlZmluZWRIZWlnaHQoKSkge1xuICAgICAgICBjb25zdHJhaW50cy52aWRlby5oZWlnaHQgPSB7aWRlYWw6IG9wdGlvbnMudmlkZW8uaGVpZ2h0fVxuICAgICAgfVxuXG4gICAgICBkZWJ1ZygnUmVjb3JkZXI6IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKCknKVxuXG4gICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gICAgICAgIC5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgICAgIC50aGVuKGdldFVzZXJNZWRpYUNhbGxiYWNrKVxuICAgICAgICAuY2F0Y2godXNlck1lZGlhRXJyb3JDYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ1JlY29yZGVyOiBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhKCknKVxuXG4gICAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhXyh7XG4gICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICBhdWRpbzogb3B0aW9ucy5pc0F1ZGlvRW5hYmxlZCgpXG4gICAgICB9LCBnZXRVc2VyTWVkaWFDYWxsYmFjaywgdXNlck1lZGlhRXJyb3JDYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkVXNlck1lZGlhICgpIHtcbiAgICBpZiAodXNlck1lZGlhTG9hZGVkKSB7XG4gICAgICBkZWJ1ZygnUmVjb3JkZXI6IHNraXBwaW5nIGxvYWRVc2VyTWVkaWEoKSBiZWNhdXNlIGl0IGlzIGFscmVhZHkgbG9hZGVkJylcbiAgICAgIG9uVXNlck1lZGlhUmVhZHkoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmICh1c2VyTWVkaWFMb2FkaW5nKSB7XG4gICAgICBkZWJ1ZygnUmVjb3JkZXI6IHNraXBwaW5nIGxvYWRVc2VyTWVkaWEoKSBiZWNhdXNlIGl0IGlzIGFscmVhZHkgYXNraW5nIGZvciBwZXJtaXNzaW9uJylcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGRlYnVnKCdSZWNvcmRlcjogbG9hZFVzZXJNZWRpYSgpJylcblxuICAgIHNlbGYuZW1pdChFdmVudHMuTE9BRElOR19VU0VSX01FRElBKVxuXG4gICAgdHJ5IHtcbiAgICAgIHVzZXJNZWRpYVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFzZWxmLmlzUmVhZHkoKSkge1xuICAgICAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGJyb3dzZXIuZ2V0Tm9BY2Nlc3NJc3N1ZSgpKVxuICAgICAgICB9XG4gICAgICB9LCBvcHRpb25zLnRpbWVvdXRzLnVzZXJNZWRpYSlcblxuICAgICAgdXNlck1lZGlhTG9hZGluZyA9IHRydWVcblxuICAgICAgbG9hZEdlbnVpbmVVc2VyTWVkaWEoKVxuICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgZGVidWcoJ1JlY29yZGVyOiBmYWlsZWQgdG8gbG9hZCBnZW51aW5lIHVzZXIgbWVkaWEnKVxuXG4gICAgICB1c2VyTWVkaWFMb2FkaW5nID0gZmFsc2VcblxuICAgICAgY29uc3QgZXJyb3JMaXN0ZW5lcnMgPSBzZWxmLmxpc3RlbmVycyhFdmVudHMuRVJST1IpXG5cbiAgICAgIGlmIChlcnJvckxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXhjKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ1JlY29yZGVyOiBubyBlcnJvciBsaXN0ZW5lcnMgYXR0YWNoZWQgYnV0IHRocm93aW5nIGV4Y2VwdGlvbicsIGV4YylcbiAgICAgICAgdGhyb3cgZXhjIC8vIHRocm93IGl0IGZ1cnRoZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleGVjdXRlQ29tbWFuZCAoY29tbWFuZCkge1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgJ1NlcnZlciBjb21tYW5kZWQ6ICVzJyxcbiAgICAgICAgY29tbWFuZC5jb21tYW5kLFxuICAgICAgICBjb21tYW5kLmFyZ3MgPyAnLCAnICsgSlNPTi5zdHJpbmdpZnkoY29tbWFuZC5hcmdzKSA6ICcnXG4gICAgICApXG5cbiAgICAgIHN3aXRjaCAoY29tbWFuZC5jb21tYW5kKSB7XG4gICAgICAgIGNhc2UgJ3JlYWR5JzpcbiAgICAgICAgICBpZiAoIXVzZXJNZWRpYVRpbWVvdXQpIHsgbG9hZFVzZXJNZWRpYSgpIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwcmV2aWV3JzpcbiAgICAgICAgICBwcmV2aWV3KGNvbW1hbmQuYXJncylcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgdGhpcy5lbWl0KEV2ZW50cy5FUlJPUiwgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgICAgICAgJ09oIG5vLCBzZXJ2ZXIgZXJyb3IhJyxcbiAgICAgICAgICAgIGNvbW1hbmQuYXJncy5lcnIudG9TdHJpbmcoKSB8fCAnKE5vIGV4cGxhbmF0aW9uIGdpdmVuKScsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdjb25maXJtRnJhbWUnOlxuICAgICAgICAgIHVwZGF0ZUZyYW1lUHJvZ3Jlc3MoY29tbWFuZC5hcmdzKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2NvbmZpcm1TYW1wbGUnOlxuICAgICAgICAgIHVwZGF0ZVNhbXBsZVByb2dyZXNzKGNvbW1hbmQuYXJncylcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdiZWdpbkF1ZGlvRW5jb2RpbmcnOlxuICAgICAgICAgIHRoaXMuZW1pdChFdmVudHMuQkVHSU5fQVVESU9fRU5DT0RJTkcpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnYmVnaW5WaWRlb0VuY29kaW5nJzpcbiAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkJFR0lOX1ZJREVPX0VOQ09ESU5HKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5lbWl0KEV2ZW50cy5FUlJPUiwgJ1Vua25vd24gc2VydmVyIGNvbW1hbmQ6ICcgKyBjb21tYW5kLmNvbW1hbmQpXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGV4YylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc05vdGlmeWluZyAoKSB7XG4gICAgcmV0dXJuIHZpc3VhbHMuaXNOb3RpZnlpbmcoKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNIaWRkZW4gKCkge1xuICAgIHJldHVybiAhcmVjb3JkZXJFbGVtZW50IHx8IGhpZGRlbihyZWNvcmRlckVsZW1lbnQpXG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZUNvbW1hbmQgKGNvbW1hbmQsIGFyZ3MsIGNiKSB7XG4gICAgaWYgKCFjYiAmJiBhcmdzICYmIGFyZ3MuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XG4gICAgICBjYiA9IGFyZ3NcbiAgICAgIGFyZ3MgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgIGRlYnVnKCdSZWNvbm5lY3RpbmcgZm9yIHRoZSBjb21tYW5kJywgY29tbWFuZCwgJ+KApicpXG5cbiAgICAgIGluaXRTb2NrZXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB3cml0ZUNvbW1hbmQoY29tbWFuZCwgYXJncylcbiAgICAgICAgY2IgJiYgY2IoKVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKHN0cmVhbSkge1xuICAgICAgZGVidWcoJyQgJXMnLCBjb21tYW5kLCBhcmdzID8gSlNPTi5zdHJpbmdpZnkoYXJncykgOiAnJylcblxuICAgICAgY29uc3QgY29tbWFuZE9iaiA9IHtcbiAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgYXJnczogYXJnc1xuICAgICAgfVxuXG4gICAgICAvLyB0b2RvIGNvbW1lbnRlZCBvdXQgYmVjYXVzZSBmb3Igc29tZSByZWFzb25zIHNlcnZlciBkb2VzIG5vdCBhY2NlcHQgc3VjaCBhIGxvbmdcbiAgICAgIC8vIGFycmF5IG9mIG1hbnkgbG9nIGxpbmVzLiB0byBleGFtaW5lIGxhdGVyLlxuICAgICAgLy9cbiAgICAgIC8vIGFkZCBzb21lIHVzZWZ1bCBkZWJ1ZyBpbmZvIHRvIGV4YW1pbmUgd2VpcmQgc3R1ZmYgbGlrZSB0aGlzIG9uZVxuICAgICAgLy8gVW5wcm9jZXNzYWJsZUVycm9yOiBVbmFibGUgdG8gZW5jb2RlIGEgdmlkZW8gd2l0aCBGUFMgbmVhciB6ZXJvLlxuICAgICAgLy8gdG9kbyBjb25zaWRlciByZW1vdmluZyB0aGlzIGxhdGVyIG9yIGhhdmUgaXQgZm9yIGRlYnVnPTEgb25seT9cbiAgICAgIC8vXG4gICAgICAvLyBpZiAob3B0aW9ucy5sb2dnZXIgJiYgb3B0aW9ucy5sb2dnZXIuZ2V0TGluZXMpIHtcbiAgICAgIC8vICAgY29tbWFuZE9iai5sb2dMaW5lcyA9IG9wdGlvbnMubG9nZ2VyLmdldExpbmVzKClcbiAgICAgIC8vIH1cblxuICAgICAgd3JpdGVTdHJlYW0oQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoY29tbWFuZE9iaikpKVxuXG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgLy8ga2VlcCBhbGwgY2FsbGJhY2tzIGFzeW5jXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNiKClcbiAgICAgICAgfSwgMClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNjb25uZWN0ICgpIHtcbiAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICBkZWJ1ZygnUmVjb3JkZXI6IGRpc2Nvbm5lY3QoKScpXG5cbiAgICAgIGlmICh1c2VyTWVkaWEpIHtcbiAgICAgICAgLy8gcHJldmVudHMgaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLWNsaWVudC9pc3N1ZXMvMTE0XG4gICAgICAgIHVzZXJNZWRpYS51bmxvYWRSZW1haW5pbmdFdmVudExpc3RlbmVycygpXG4gICAgICB9XG5cbiAgICAgIGlmIChzdWJtaXR0aW5nKSB7XG4gICAgICAgIC8vIHNlcnZlciB3aWxsIGRpc2Nvbm5lY3Qgc29ja2V0IGF1dG9tYXRpY2FsbHkgYWZ0ZXIgc3VibWl0dGluZ1xuICAgICAgICBjb25uZWN0aW5nID0gY29ubmVjdGVkID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtKSB7XG4gICAgICAgIC8vIGZvcmNlIHRvIGRpc2Nvbm5lY3Qgc29ja2V0IHJpZ2h0IG5vdyB0byBjbGVhbiB0ZW1wIGZpbGVzIG9uIHNlcnZlclxuICAgICAgICAvLyBldmVudCBsaXN0ZW5lcnMgd2lsbCBkbyB0aGUgcmVzdFxuICAgICAgICBzdHJlYW0uZW5kKClcbiAgICAgICAgc3RyZWFtID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsQW5pbWF0aW9uRnJhbWUgKCkge1xuICAgIGxvb3AgJiYgbG9vcC5kaXNwb3NlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEludGVydmFsU3VtICgpIHtcbiAgICByZXR1cm4gbG9vcC5nZXRFbGFwc2VkVGltZSgpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRBdmdJbnRlcnZhbCAoKSB7XG4gICAgcmV0dXJuIChnZXRJbnRlcnZhbFN1bSgpIC8gZnJhbWVzQ291bnQpXG4gIH1cblxuICB0aGlzLmdldFJlY29yZGluZ1N0YXRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWNvcmRpbmdTdGF0c1xuICB9XG5cbiAgdGhpcy5nZXRBdWRpb1NhbXBsZVJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVzZXJNZWRpYS5nZXRBdWRpb1NhbXBsZVJhdGUoKVxuICB9XG5cbiAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIGRlYnVnKCdzdG9wKCknLCBwYXJhbXMpXG5cbiAgICBjb25zdCBsaW1pdFJlYWNoZWQgPSBwYXJhbXMubGltaXRSZWFjaGVkXG5cbiAgICB0aGlzLmVtaXQoRXZlbnRzLlNUT1BQSU5HLCBsaW1pdFJlYWNoZWQpXG5cbiAgICBsb29wLmNvbXBsZXRlKClcblxuICAgIHN0b3BUaW1lID0gRGF0ZS5ub3coKVxuXG4gICAgcmVjb3JkaW5nU3RhdHMgPSB7XG4gICAgICBhdmdGcHM6IGxvb3AuZ2V0RlBTKCksXG4gICAgICB3YW50ZWRGcHM6IG9wdGlvbnMudmlkZW8uZnBzLFxuICAgICAgYXZnSW50ZXJ2YWw6IGdldEF2Z0ludGVydmFsKCksXG4gICAgICB3YW50ZWRJbnRlcnZhbDogMWUzIC8gb3B0aW9ucy52aWRlby5mcHMsXG5cbiAgICAgIGludGVydmFsU3VtOiBnZXRJbnRlcnZhbFN1bSgpLFxuICAgICAgZnJhbWVzQ291bnQ6IGZyYW1lc0NvdW50LFxuICAgICAgdmlkZW9UeXBlOiByZXBsYXkuZ2V0VmlkZW9UeXBlKClcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pc0F1ZGlvRW5hYmxlZCgpKSB7XG4gICAgICByZWNvcmRpbmdTdGF0cy5zYW1wbGVzQ291bnQgPSBzYW1wbGVzQ291bnRcbiAgICAgIHJlY29yZGluZ1N0YXRzLnNhbXBsZVJhdGUgPSB1c2VyTWVkaWEuZ2V0QXVkaW9TYW1wbGVSYXRlKClcbiAgICB9XG5cbiAgICB3cml0ZUNvbW1hbmQoJ3N0b3AnLCByZWNvcmRpbmdTdGF0cylcblxuICAgIC8vIGJld2FyZSwgcmVzZXR0aW5nIHdpbGwgc2V0IGZyYW1lc0NvdW50IHRvIHplcm8sIHNvIGxlYXZlIHRoaXMgaGVyZVxuICAgIHRoaXMucmVzZXQoKVxuICB9XG5cbiAgdGhpcy5iYWNrID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgdGhpcy5lbWl0KEV2ZW50cy5HT0lOR19CQUNLKVxuXG4gICAgc2hvdygpXG4gICAgdGhpcy5yZXNldCgpXG5cbiAgICB3cml0ZUNvbW1hbmQoJ2JhY2snLCBjYilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlSW5pdGlhbGlzZUF1ZGlvICgpIHtcbiAgICBkZWJ1ZygnUmVjb3JkZXI6IHJlSW5pdGlhbGlzZUF1ZGlvKCknKVxuXG4gICAgY2xlYXJVc2VyTWVkaWFUaW1lb3V0KClcblxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZnJlZSBtZW1vcnlcbiAgICB1c2VyTWVkaWEgJiYgdXNlck1lZGlhLnN0b3AoKVxuXG4gICAgdXNlck1lZGlhTG9hZGVkID0ga2V5ID0gY2FudmFzID0gY3R4ID0gbnVsbFxuXG4gICAgbG9hZFVzZXJNZWRpYSgpXG4gIH1cblxuICB0aGlzLnVubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCF1bmxvYWRlZCkge1xuICAgICAgdmFyIGNhdXNlXG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNhdXNlID0gZS5uYW1lIHx8IGUuc3RhdHVzVGV4dCB8fCBlLnRvU3RyaW5nKClcbiAgICAgIH1cblxuICAgICAgZGVidWcoJ1JlY29yZGVyOiB1bmxvYWQoKScgKyAoY2F1c2UgPyAnLCBjYXVzZTogJyArIGNhdXNlIDogJycpKVxuXG4gICAgICB0aGlzLnJlc2V0KClcblxuICAgICAgY2xlYXJVc2VyTWVkaWFUaW1lb3V0KClcblxuICAgICAgZGlzY29ubmVjdCgpXG5cbiAgICAgIHVubG9hZGVkID0gdHJ1ZVxuXG4gICAgICBidWlsdCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBubyBuZWVkIHRvIHJlc2V0IHdoZW4gYWxyZWFkeSB1bmxvYWRlZFxuICAgIGlmICghdW5sb2FkZWQpIHtcbiAgICAgIGRlYnVnKCdSZWNvcmRlcjogcmVzZXQoKScpXG5cbiAgICAgIHRoaXMuZW1pdChFdmVudHMuUkVTRVRUSU5HKVxuXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSgpXG5cbiAgICAgIC8vIGltcG9ydGFudCB0byBmcmVlIG1lbW9yeVxuICAgICAgdXNlck1lZGlhICYmIHVzZXJNZWRpYS5zdG9wKClcblxuICAgICAgcmVwbGF5LnJlc2V0KClcblxuICAgICAgdXNlck1lZGlhTG9hZGVkID0ga2V5ID0gY2FudmFzID0gY3R4ID0gd2FpdGluZ1RpbWUgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgdGhpcy52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29ubmVjdGVkICYmIGZyYW1lc0NvdW50ID4gMCAmJiBjYW52YXMgPT09IG51bGxcbiAgfVxuXG4gIHRoaXMuaXNSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXNlck1lZGlhLmlzUmVhZHkoKVxuICB9XG5cbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBjb25zdCBlID0gcGFyYW1zICYmIHBhcmFtcy5ldmVudFxuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnQpIHtcbiAgICAgIHBhcmFtcy5ldmVudFR5cGUgPSBlLnR5cGVcbiAgICB9XG5cbiAgICBkZWJ1ZygncGF1c2UoKScsIHBhcmFtcylcblxuICAgIHVzZXJNZWRpYS5wYXVzZSgpXG4gICAgbG9vcC5zdG9wKClcblxuICAgIHRoaXMuZW1pdChFdmVudHMuUEFVU0VEKVxuXG4gICAgc2VuZFBpbmdzKClcbiAgfVxuXG4gIHRoaXMuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVzZXJNZWRpYSAmJiB1c2VyTWVkaWEuaXNQYXVzZWQoKVxuICB9XG5cbiAgdGhpcy5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ1JlY29yZGVyOiByZXN1bWUoKScpXG5cbiAgICBzdG9wUGluZ3MoKVxuXG4gICAgdGhpcy5lbWl0KEV2ZW50cy5SRVNVTUlORylcblxuICAgIHVzZXJNZWRpYS5yZXN1bWUoKVxuICAgIGxvb3Auc3RhcnQoKVxuICB9XG5cbiAgZnVuY3Rpb24gb25GbHVzaGVkIChvcHRzKSB7XG4gICAgY29uc3QgZnJhbWVOdW1iZXIgPSBvcHRzICYmIG9wdHMuZnJhbWVOdW1iZXJcblxuICAgIGlmIChmcmFtZU51bWJlciA9PT0gMSkge1xuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5GSVJTVF9GUkFNRV9TRU5UKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvb3AgKCkge1xuICAgIGNvbnN0IG5ld0xvb3AgPSBhbmltaXR0ZXIoe2Zwczogb3B0aW9ucy52aWRlby5mcHN9LCBkcmF3KVxuXG4gICAgLy8gcmVtZW1iZXIgaXQgZmlyc3RcbiAgICBvcmlnaW5hbEFuaW1hdGlvbkZyYW1lT2JqZWN0ID0gbmV3TG9vcC5nZXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVPYmplY3QoKVxuXG4gICAgcmV0dXJuIG5ld0xvb3BcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXcgKGRlbHRhVGltZSwgZWxhcHNlZFRpbWUpIHtcbiAgICB0cnkge1xuICAgICAgLy8gY3R4IGFuZCBzdHJlYW0gbWlnaHQgYmVjb21lIG51bGwgd2hpbGUgdW5sb2FkaW5nXG4gICAgICBpZiAoIXNlbGYuaXNQYXVzZWQoKSAmJiBzdHJlYW0gJiYgY3R4KSB7XG4gICAgICAgIGlmIChmcmFtZXNDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHNlbGYuZW1pdChFdmVudHMuU0VORElOR19GSVJTVF9GUkFNRSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lc0NvdW50KytcblxuICAgICAgICBjdHguZHJhd0ltYWdlKFxuICAgICAgICAgIHVzZXJNZWRpYS5nZXRSYXdWaXN1YWxzKCksXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGNhbnZhcy53aWR0aCxcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0XG4gICAgICAgIClcblxuICAgICAgICByZWNvcmRpbmdCdWZmZXIgPSBmcmFtZS50b0J1ZmZlcigpXG4gICAgICAgIHJlY29yZGluZ0J1ZmZlckxlbmd0aCA9IHJlY29yZGluZ0J1ZmZlci5sZW5ndGhcblxuICAgICAgICBpZiAocmVjb3JkaW5nQnVmZmVyTGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnRmFpbGVkIHRvIGV4dHJhY3Qgd2ViY2FtIGRhdGEuJywgb3B0aW9ucylcbiAgICAgICAgfVxuXG4gICAgICAgIGJ5dGVzU3VtICs9IHJlY29yZGluZ0J1ZmZlckxlbmd0aFxuXG4gICAgICAgIHdyaXRlU3RyZWFtKHJlY29yZGluZ0J1ZmZlciwge1xuICAgICAgICAgIGZyYW1lTnVtYmVyOiBmcmFtZXNDb3VudCxcbiAgICAgICAgICBvbkZsdXNoZWRDYWxsYmFjazogb25GbHVzaGVkXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gaWYgKG9wdGlvbnMudmVyYm9zZSkge1xuICAgICAgICAvLyAgIGRlYnVnKFxuICAgICAgICAvLyAgICAgJ0ZyYW1lICMnICsgZnJhbWVzQ291bnQgKyAnICgnICsgcmVjb3JkaW5nQnVmZmVyTGVuZ3RoICsgJyBieXRlcyk6JyxcbiAgICAgICAgLy8gICAgICcgZGVsdGE9JyArIGRlbHRhVGltZSArICdtcywgJyArXG4gICAgICAgIC8vICAgICAnIGVsYXBzZWQ9JyArIGVsYXBzZWRUaW1lICsgJ21zJ1xuICAgICAgICAvLyAgIClcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHZpc3VhbHMuY2hlY2tUaW1lcih7aW50ZXJ2YWxTdW06IGVsYXBzZWRUaW1lfSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgIHNlbGYuZW1pdChFdmVudHMuRVJST1IsIGV4YylcbiAgICB9XG4gIH1cblxuICB0aGlzLnJlY29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodW5sb2FkZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHJlY29ubmVjdCB3aGVuIG5lZWRlZFxuICAgIGlmICghY29ubmVjdGVkKSB7XG4gICAgICBkZWJ1ZygnUmVjb3JkZXI6IHJlY29ubmVjdGluZyBiZWZvcmUgcmVjb3JkaW5nIC4uLicpXG5cbiAgICAgIGluaXRTb2NrZXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uY2UoRXZlbnRzLlVTRVJfTUVESUFfUkVBRFksIHNlbGYucmVjb3JkKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNhbnZhcyA9IHVzZXJNZWRpYS5jcmVhdGVDYW52YXMoKVxuICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgc2VsZi5lbWl0KFxuICAgICAgICBFdmVudHMuRVJST1IsXG4gICAgICAgIFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnRmFpbGVkIHRvIGNyZWF0ZSBjYW52YXMuJywgZXhjLCBvcHRpb25zKVxuICAgICAgKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgaWYgKCFjYW52YXMud2lkdGgpIHtcbiAgICAgIHNlbGYuZW1pdChcbiAgICAgICAgRXZlbnRzLkVSUk9SLFxuICAgICAgICBWaWRlb21haWxFcnJvci5jcmVhdGUoJ0NhbnZhcyBoYXMgYW4gaW52YWxpZCB3aWR0aC4nLCBvcHRpb25zKVxuICAgICAgKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoIWNhbnZhcy5oZWlnaHQpIHtcbiAgICAgIHNlbGYuZW1pdChcbiAgICAgICAgRXZlbnRzLkVSUk9SLFxuICAgICAgICBWaWRlb21haWxFcnJvci5jcmVhdGUoJ0NhbnZhcyBoYXMgYW4gaW52YWxpZCBoZWlnaHQuJywgb3B0aW9ucylcbiAgICAgIClcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgYnl0ZXNTdW0gPSAwXG5cbiAgICBmcmFtZSA9IG5ldyBGcmFtZShjYW52YXMsIG9wdGlvbnMpXG5cbiAgICBkZWJ1ZygnUmVjb3JkZXI6IHJlY29yZCgpJylcbiAgICB1c2VyTWVkaWEucmVjb3JkKClcblxuICAgIHNlbGYuZW1pdChFdmVudHMuUkVDT1JESU5HLCBmcmFtZXNDb3VudClcblxuICAgIGxvb3Auc3RhcnQoKVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0QW5pbWF0aW9uRnJhbWVPYmplY3QgKG5ld09iaikge1xuICAgIC8vIG11c3Qgc3RvcCBhbmQgdGhlbiBzdGFydCB0byBtYWtlIGl0IGJlY29tZSBlZmZlY3RpdmUsIHNlZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9oYXB0aWNkYXRhL2FuaW1pdHRlci9pc3N1ZXMvNSNpc3N1ZWNvbW1lbnQtMjkyMDE5MTY4XG4gICAgaWYgKGxvb3ApIHtcbiAgICAgIGNvbnN0IGlzUmVjb3JkaW5nID0gc2VsZi5pc1JlY29yZGluZygpXG5cbiAgICAgIGxvb3Auc3RvcCgpXG4gICAgICBsb29wLnNldFJlcXVlc3RBbmltYXRpb25GcmFtZU9iamVjdChuZXdPYmopXG5cbiAgICAgIGlmIChpc1JlY29yZGluZykge1xuICAgICAgICBsb29wLnN0YXJ0KClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlQW5pbWF0aW9uRnJhbWVPYmplY3QgKCkge1xuICAgIGRlYnVnKCdSZWNvcmRlcjogcmVzdG9yZUFuaW1hdGlvbkZyYW1lT2JqZWN0KCknKVxuXG4gICAgc2V0QW5pbWF0aW9uRnJhbWVPYmplY3Qob3JpZ2luYWxBbmltYXRpb25GcmFtZU9iamVjdClcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvb3BXaXRoVGltZW91dHMgKCkge1xuICAgIGRlYnVnKCdSZWNvcmRlcjogbG9vcFdpdGhUaW1lb3V0cygpJylcblxuICAgIGNvbnN0IHdhbnRlZEludGVydmFsID0gMWUzIC8gb3B0aW9ucy52aWRlby5mcHNcblxuICAgIHZhciBwcm9jZXNzaW5nVGltZSA9IDBcbiAgICB2YXIgc3RhcnRcblxuICAgIGZ1bmN0aW9uIHJhZiAoZm4pIHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhcnQgPSBEYXRlLm5vdygpXG4gICAgICAgICAgZm4oKVxuICAgICAgICAgIHByb2Nlc3NpbmdUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJlZHVjaW5nIHdhbnRlZCBpbnRlcnZhbCBieSByZXNwZWN0aW5nIHRoZSB0aW1lIGl0IHRha2VzIHRvXG4gICAgICAgIC8vIGNvbXB1dGUgaW50ZXJuYWxseSBzaW5jZSB0aGlzIGlzIG5vdCBtdWx0aS10aHJlYWRlZCBsaWtlXG4gICAgICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICB3YW50ZWRJbnRlcnZhbCAtIHByb2Nlc3NpbmdUaW1lXG4gICAgICApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuY2VsIChpZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGlkKVxuICAgIH1cblxuICAgIHNldEFuaW1hdGlvbkZyYW1lT2JqZWN0KHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZTogcmFmLFxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWU6IGNhbmNlbFxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBidWlsZEVsZW1lbnQgKCkge1xuICAgIHJlY29yZGVyRWxlbWVudCA9IGgoJ3ZpZGVvLicgKyBvcHRpb25zLnNlbGVjdG9ycy51c2VyTWVkaWFDbGFzcylcbiAgICB2aXN1YWxzLmFwcGVuZENoaWxkKHJlY29yZGVyRWxlbWVudClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcnJlY3REaW1lbnNpb25zICgpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNEZWZpbmVkV2lkdGgoKSkge1xuICAgICAgcmVjb3JkZXJFbGVtZW50LndpZHRoID0gc2VsZi5nZXRSZWNvcmRlcldpZHRoKHRydWUpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGFzRGVmaW5lZEhlaWdodCgpKSB7XG4gICAgICByZWNvcmRlckVsZW1lbnQuaGVpZ2h0ID0gc2VsZi5nZXRSZWNvcmRlckhlaWdodCh0cnVlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRFdmVudHMgKCkge1xuICAgIHNlbGZcbiAgICAgIC5vbihFdmVudHMuU1VCTUlUVElORywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzdWJtaXR0aW5nID0gdHJ1ZVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuU1VCTUlUVEVELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN1Ym1pdHRpbmcgPSBmYWxzZVxuICAgICAgICBzZWxmLnVubG9hZCgpXG4gICAgICB9KVxuICAgICAgLm9uKEV2ZW50cy5CTE9DS0lORywgZnVuY3Rpb24gKCkge1xuICAgICAgICBibG9ja2luZyA9IHRydWVcbiAgICAgICAgY2xlYXJVc2VyTWVkaWFUaW1lb3V0KClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLkhJREUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5oaWRlKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLkxPQURFRF9NRVRBX0RBVEEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29ycmVjdERpbWVuc2lvbnMoKVxuICAgICAgfSlcbiAgICAgIC5vbihFdmVudHMuRElTQUJMSU5HX0FVRElPLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlSW5pdGlhbGlzZUF1ZGlvKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLkVOQUJMSU5HX0FVRElPLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlSW5pdGlhbGlzZUF1ZGlvKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLklOVklTSUJMRSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBsb29wV2l0aFRpbWVvdXRzKClcbiAgICAgIH0pXG4gICAgICAub24oRXZlbnRzLlZJU0lCTEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzdG9yZUFuaW1hdGlvbkZyYW1lT2JqZWN0KClcbiAgICAgIH0pXG4gIH1cblxuICB0aGlzLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlcnIgPSBicm93c2VyLmNoZWNrUmVjb3JkaW5nQ2FwYWJpbGl0aWVzKClcblxuICAgIGlmICghZXJyKSB7XG4gICAgICBlcnIgPSBicm93c2VyLmNoZWNrQnVmZmVyVHlwZXMoKVxuICAgIH1cblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXMuZW1pdChFdmVudHMuRVJST1IsIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb3JkZXJFbGVtZW50ID0gdmlzdWFscy5xdWVyeVNlbGVjdG9yKCd2aWRlby4nICsgb3B0aW9ucy5zZWxlY3RvcnMudXNlck1lZGlhQ2xhc3MpXG5cbiAgICAgIGlmICghcmVjb3JkZXJFbGVtZW50KSB7XG4gICAgICAgIGJ1aWxkRWxlbWVudCgpXG4gICAgICB9XG5cbiAgICAgIGNvcnJlY3REaW1lbnNpb25zKClcblxuICAgICAgLy8gcHJldmVudCBhdWRpbyBmZWVkYmFjaywgc2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwtY2xpZW50L2lzc3Vlcy8zNVxuICAgICAgcmVjb3JkZXJFbGVtZW50Lm11dGVkID0gdHJ1ZVxuXG4gICAgICBpZiAoIXVzZXJNZWRpYSkge1xuICAgICAgICB1c2VyTWVkaWEgPSBuZXcgVXNlck1lZGlhKHRoaXMsIG9wdGlvbnMpXG4gICAgICB9XG5cbiAgICAgIHNob3coKVxuXG4gICAgICBpZiAoIWJ1aWx0KSB7XG4gICAgICAgIGluaXRFdmVudHMoKVxuXG4gICAgICAgIGlmICghY29ubmVjdGVkKSB7XG4gICAgICAgICAgaW5pdFNvY2tldCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9hZFVzZXJNZWRpYSgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRVc2VyTWVkaWEoKVxuICAgICAgfVxuXG4gICAgICBidWlsdCA9IHRydWVcbiAgICB9XG4gIH1cblxuICB0aGlzLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1c2VyTWVkaWEgJiYgdXNlck1lZGlhLmlzUGF1c2VkKCkgJiYgIWxvb3AuaXNSdW5uaW5nKClcbiAgfVxuXG4gIHRoaXMuaXNSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY2hlY2tpbmcgZm9yIHN0cmVhbS5kZXN0cm95ZWQgbmVlZGVkIHNpbmNlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpbmFyeWtpdGNoZW4vdmlkZW9tYWlsLmlvL2lzc3Vlcy8yOTZcbiAgICByZXR1cm4gbG9vcCAmJiBsb29wLmlzUnVubmluZygpICYmICF0aGlzLmlzUGF1c2VkKCkgJiYgIWlzTm90aWZ5aW5nKCkgJiYgc3RyZWFtICYmICFzdHJlYW0uZGVzdHJveWVkXG4gIH1cblxuICB0aGlzLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc0hpZGRlbigpKSB7XG4gICAgICByZWNvcmRlckVsZW1lbnQgJiYgaGlkZGVuKHJlY29yZGVyRWxlbWVudCwgdHJ1ZSlcblxuICAgICAgY2xlYXJVc2VyTWVkaWFUaW1lb3V0KClcbiAgICAgIGNsZWFyUmV0cnlUaW1lb3V0KClcbiAgICB9XG4gIH1cblxuICB0aGlzLmlzVW5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVubG9hZGVkXG4gIH1cblxuICAvLyB0aGVzZSB0d28gcmV0dXJuIHRoZSB0cnVlIGRpbWVuc2lvbnMgb2YgdGhlIHdlYmNhbSBhcmVhLlxuICAvLyBuZWVkZWQgYmVjYXVzZSBvbiBtb2JpbGVzIHRoZXkgbWlnaHQgYmUgZGlmZmVyZW50LlxuXG4gIHRoaXMuZ2V0UmVjb3JkZXJXaWR0aCA9IGZ1bmN0aW9uIChyZXNwb25zaXZlKSB7XG4gICAgaWYgKHVzZXJNZWRpYSkge1xuICAgICAgcmV0dXJuIHVzZXJNZWRpYS5nZXRSYXdXaWR0aChyZXNwb25zaXZlKVxuICAgIH0gZWxzZSBpZiAocmVzcG9uc2l2ZSAmJiBvcHRpb25zLmhhc0RlZmluZWRXaWR0aCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5saW1pdFdpZHRoKG9wdGlvbnMudmlkZW8ud2lkdGgpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5nZXRSZWNvcmRlckhlaWdodCA9IGZ1bmN0aW9uIChyZXNwb25zaXZlKSB7XG4gICAgaWYgKHVzZXJNZWRpYSkge1xuICAgICAgcmV0dXJuIHVzZXJNZWRpYS5nZXRSYXdIZWlnaHQocmVzcG9uc2l2ZSlcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNpdmUgJiYgb3B0aW9ucy5oYXNEZWZpbmVkSGVpZ2h0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUhlaWdodChyZXNwb25zaXZlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhdGlvICgpIHtcbiAgICB2YXIgcmF0aW9cblxuICAgIGlmICh1c2VyTWVkaWEpIHtcbiAgICAgIGNvbnN0IHVzZXJNZWRpYVZpZGVvV2lkdGggPSB1c2VyTWVkaWEuZ2V0VmlkZW9XaWR0aCgpXG5cbiAgICAgIC8vIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm9cbiAgICAgIGlmICh1c2VyTWVkaWFWaWRlb1dpZHRoIDwgMSkge1xuICAgICAgICByYXRpbyA9IDBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhdGlvID0gdXNlck1lZGlhLmdldFZpZGVvSGVpZ2h0KCkgLyB1c2VyTWVkaWFWaWRlb1dpZHRoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhdGlvID0gb3B0aW9ucy5nZXRSYXRpbygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJhdGlvXG4gIH1cblxuICB0aGlzLmNhbGN1bGF0ZVdpZHRoID0gZnVuY3Rpb24gKHJlc3BvbnNpdmUpIHtcbiAgICB2YXIgdmlkZW9IZWlnaHRcblxuICAgIGlmICh1c2VyTWVkaWEpIHtcbiAgICAgIHZpZGVvSGVpZ2h0ID0gdXNlck1lZGlhLmdldFZpZGVvSGVpZ2h0KClcbiAgICB9IGVsc2UgaWYgKHJlY29yZGVyRWxlbWVudCkge1xuICAgICAgdmlkZW9IZWlnaHQgPSByZWNvcmRlckVsZW1lbnQudmlkZW9IZWlnaHRcbiAgICB9XG5cbiAgICByZXR1cm4gdmlzdWFscy5jYWxjdWxhdGVXaWR0aCh7XG4gICAgICByZXNwb25zaXZlOiByZXNwb25zaXZlLFxuICAgICAgcmF0aW86IGdldFJhdGlvKCksXG4gICAgICB2aWRlb0hlaWdodDogdmlkZW9IZWlnaHRcbiAgICB9KVxuICB9XG5cbiAgdGhpcy5jYWxjdWxhdGVIZWlnaHQgPSBmdW5jdGlvbiAocmVzcG9uc2l2ZSkge1xuICAgIHZhciB2aWRlb1dpZHRoXG5cbiAgICBpZiAodXNlck1lZGlhKSB7XG4gICAgICB2aWRlb1dpZHRoID0gdXNlck1lZGlhLmdldFZpZGVvV2lkdGgoKVxuICAgIH0gZWxzZSBpZiAocmVjb3JkZXJFbGVtZW50KSB7XG4gICAgICB2aWRlb1dpZHRoID0gcmVjb3JkZXJFbGVtZW50LnZpZGVvV2lkdGhcbiAgICB9XG5cbiAgICByZXR1cm4gdmlzdWFscy5jYWxjdWxhdGVIZWlnaHQoe1xuICAgICAgcmVzcG9uc2l2ZTogcmVzcG9uc2l2ZSxcbiAgICAgIHJhdGlvOiBnZXRSYXRpbygpLFxuICAgICAgdmlkZW9XaWR0aDogdmlkZW9XaWR0aFxuICAgIH0pXG4gIH1cblxuICB0aGlzLmdldFJhd1Zpc3VhbFVzZXJNZWRpYSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVjb3JkZXJFbGVtZW50XG4gIH1cblxuICB0aGlzLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb25uZWN0ZWRcbiAgfVxuXG4gIHRoaXMuaXNDb25uZWN0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb25uZWN0aW5nXG4gIH1cblxuICB0aGlzLmxpbWl0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICByZXR1cm4gdmlzdWFscy5saW1pdFdpZHRoKHdpZHRoKVxuICB9XG5cbiAgdGhpcy5saW1pdEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICByZXR1cm4gdmlzdWFscy5saW1pdEhlaWdodChoZWlnaHQpXG4gIH1cblxuICB0aGlzLmlzVXNlck1lZGlhTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1c2VyTWVkaWFMb2FkZWRcbiAgfVxufVxuXG51dGlsLmluaGVyaXRzKFJlY29yZGVyLCBFdmVudEVtaXR0ZXIpXG5cbmV4cG9ydCBkZWZhdWx0IFJlY29yZGVyXG4iLCJpbXBvcnQgdXRpbCBmcm9tICd1dGlsJ1xuaW1wb3J0IGggZnJvbSAnaHlwZXJzY3JpcHQnXG5pbXBvcnQgaGlkZGVuIGZyb20gJ2hpZGRlbidcbmltcG9ydCBhZGRFdmVudExpc3RlbmVyV2l0aE9wdGlvbnMgZnJvbSAnYWRkLWV2ZW50bGlzdGVuZXItd2l0aC1vcHRpb25zJ1xuXG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vLi4vLi4vZXZlbnRzJ1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi8uLi8uLi91dGlsL2Jyb3dzZXInXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vLi4vLi4vdXRpbC9ldmVudEVtaXR0ZXInXG5pbXBvcnQgVmlkZW9tYWlsRXJyb3IgZnJvbSAnLi8uLi8uLi91dGlsL3ZpZGVvbWFpbEVycm9yJ1xuXG5pbXBvcnQgZW5hYmxlSW5saW5lVmlkZW8gZnJvbSAnaXBob25lLWlubGluZS12aWRlbydcblxuY29uc3QgUmVwbGF5ID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgb3B0aW9ucywgJ1JlcGxheScpXG5cbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgYnJvd3NlciA9IG5ldyBCcm93c2VyKG9wdGlvbnMpXG4gIGNvbnN0IGRlYnVnID0gb3B0aW9ucy5kZWJ1Z1xuXG4gIHZhciBidWlsdFxuICB2YXIgcmVwbGF5RWxlbWVudFxuICB2YXIgdmlkZW9tYWlsXG5cbiAgZnVuY3Rpb24gYnVpbGRFbGVtZW50ICgpIHtcbiAgICBkZWJ1ZygnUmVwbGF5OiBidWlsZEVsZW1lbnQoKScpXG5cbiAgICByZXBsYXlFbGVtZW50ID0gaCgndmlkZW8uJyArIG9wdGlvbnMuc2VsZWN0b3JzLnJlcGxheUNsYXNzKVxuXG4gICAgaWYgKCFyZXBsYXlFbGVtZW50LnNldEF0dHJpYnV0ZSkge1xuICAgICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdQbGVhc2UgdXBncmFkZSBicm93c2VyJywgb3B0aW9ucylcbiAgICB9XG5cbiAgICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKHJlcGxheUVsZW1lbnQpXG4gIH1cblxuICBmdW5jdGlvbiBpc1N0YW5kYWxvbmUgKCkge1xuICAgIHJldHVybiBwYXJlbnRFbGVtZW50LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdIVE1MRGl2RWxlbWVudCdcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlBdHRyaWJ1dGVzIChuZXdWaWRlb21haWwpIHtcbiAgICB2YXIgYXR0cmlidXRlQ29udGFpbmVyXG5cbiAgICBPYmplY3Qua2V5cyhuZXdWaWRlb21haWwpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgYXR0cmlidXRlQ29udGFpbmVyID0gcGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIGF0dHJpYnV0ZSlcblxuICAgICAgaWYgKGF0dHJpYnV0ZUNvbnRhaW5lcikge1xuICAgICAgICBhdHRyaWJ1dGVDb250YWluZXIuaW5uZXJIVE1MID0gbmV3VmlkZW9tYWlsW2F0dHJpYnV0ZV1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY29ycmVjdERpbWVuc2lvbnMgKG9wdGlvbnMpIHtcbiAgICB2YXIgd2lkdGgsIGhlaWdodFxuXG4gICAgaWYgKHZpZGVvbWFpbCAmJiB2aWRlb21haWwucGxheWVyV2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdmlkZW9tYWlsLnBsYXllcldpZHRoXG4gICAgfSBlbHNlIGlmIChwYXJlbnRFbGVtZW50LmNhbGN1bGF0ZVdpZHRoKSB7XG4gICAgICB3aWR0aCA9IHBhcmVudEVsZW1lbnQuY2FsY3VsYXRlV2lkdGgob3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAodmlkZW9tYWlsICYmIHZpZGVvbWFpbC5wbGF5ZXJIZWlnaHQpIHtcbiAgICAgIGhlaWdodCA9IHZpZGVvbWFpbC5wbGF5ZXJIZWlnaHRcbiAgICB9IGVsc2UgaWYgKHBhcmVudEVsZW1lbnQuY2FsY3VsYXRlSGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBwYXJlbnRFbGVtZW50LmNhbGN1bGF0ZUhlaWdodChvcHRpb25zKVxuICAgIH1cblxuICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgIHJlcGxheUVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCdcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGF5RWxlbWVudC5zdHlsZS53aWR0aCA9ICdhdXRvJ1xuICAgIH1cblxuICAgIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgICByZXBsYXlFbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCdcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGF5RWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnYXV0bydcbiAgICB9XG4gIH1cblxuICB0aGlzLnNldFZpZGVvbWFpbCA9IGZ1bmN0aW9uIChuZXdWaWRlb21haWwpIHtcbiAgICB2aWRlb21haWwgPSBuZXdWaWRlb21haWxcblxuICAgIGlmICh2aWRlb21haWwud2VibSkge1xuICAgICAgdGhpcy5zZXRXZWJNU291cmNlKHZpZGVvbWFpbC53ZWJtKVxuICAgIH1cblxuICAgIGlmICh2aWRlb21haWwubXA0KSB7XG4gICAgICB0aGlzLnNldE1wNFNvdXJjZSh2aWRlb21haWwubXA0KVxuICAgIH1cblxuICAgIGlmICh2aWRlb21haWwucG9zdGVyKSB7XG4gICAgICByZXBsYXlFbGVtZW50LnNldEF0dHJpYnV0ZSgncG9zdGVyJywgdmlkZW9tYWlsLnBvc3RlcilcbiAgICB9XG5cbiAgICBjb3B5QXR0cmlidXRlcyh2aWRlb21haWwpXG5cbiAgICBjb25zdCBoYXNBdWRpbyA9IHZpZGVvbWFpbC5yZWNvcmRpbmdTdGF0cyAmJiB2aWRlb21haWwucmVjb3JkaW5nU3RhdHMuc2FtcGxlUmF0ZSA+IDBcblxuICAgIHRoaXMuc2hvdyh2aWRlb21haWwud2lkdGgsIHZpZGVvbWFpbC5oZWlnaHQsIGhhc0F1ZGlvKVxuICB9XG5cbiAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKHJlY29yZGVyV2lkdGgsIHJlY29yZGVySGVpZ2h0LCBoYXNBdWRpbykge1xuICAgIGNvcnJlY3REaW1lbnNpb25zKHtcbiAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICAvLyBiZXdhcmUgdGhhdCByZWNvcmRlcldpZHRoIGFuZCByZWNvcmRlckhlaWdodCBjYW4gYmUgbnVsbCBzb21ldGltZXNcbiAgICAgIHZpZGVvV2lkdGg6IHJlY29yZGVyV2lkdGggfHwgcmVwbGF5RWxlbWVudC52aWRlb1dpZHRoLFxuICAgICAgdmlkZW9IZWlnaHQ6IHJlY29yZGVySGVpZ2h0IHx8IHJlcGxheUVsZW1lbnQudmlkZW9IZWlnaHRcbiAgICB9KVxuXG4gICAgaGlkZGVuKHJlcGxheUVsZW1lbnQsIGZhbHNlKVxuXG4gICAgLy8gcGFyZW50IGVsZW1lbnQgY2FuIGJlIGFueSBvYmplY3QsIGJlIGNhcmVmdWwhXG4gICAgaWYgKHBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGlmIChwYXJlbnRFbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIGhpZGRlbihwYXJlbnRFbGVtZW50LCBmYWxzZSlcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50RWxlbWVudC5zaG93KSB7XG4gICAgICAgIHBhcmVudEVsZW1lbnQuc2hvdygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc0F1ZGlvKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwtY2xpZW50L2lzc3Vlcy8xMTVcbiAgICAgIC8vIGRvIG5vdCBzZXQgbXV0ZSB0byBmYWxzZSBhcyB0aGlzIHdpbGwgbWVzcyB1cC4ganVzdCBkbyBub3QgbWVudGlvbiB0aGlzIGF0dHJpYnV0ZSBhdCBhbGxcbiAgICAgIHJlcGxheUVsZW1lbnQuc2V0QXR0cmlidXRlKCd2b2x1bWUnLCAxKVxuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuaXNBdWRpb0VuYWJsZWQoKSkge1xuICAgICAgcmVwbGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ211dGVkJywgdHJ1ZSlcbiAgICB9XG5cbiAgICAvLyB0aGlzIG11c3QgYmUgY2FsbGVkIGFmdGVyIHNldHRpbmcgdGhlIHNvdXJjZXMgYW5kIHdoZW4gYmVjb21pbmcgdmlzaWJsZVxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYmZyZWQtaXQvaXBob25lLWlubGluZS12aWRlby9pc3N1ZXMvMTZcbiAgICBlbmFibGVJbmxpbmVWaWRlbyAmJiBlbmFibGVJbmxpbmVWaWRlbyhyZXBsYXlFbGVtZW50LCB7XG4gICAgICBpUGFkOiB0cnVlXG4gICAgfSlcblxuICAgIC8vIHRoaXMgZm9yY2VzIHRvIGFjdHVhbGx5IGZldGNoIHRoZSB2aWRlb3MgZnJvbSB0aGUgc2VydmVyXG4gICAgcmVwbGF5RWxlbWVudC5sb2FkKClcblxuICAgIGlmICghdmlkZW9tYWlsKSB7XG4gICAgICBzZWxmLmVtaXQoRXZlbnRzLlBSRVZJRVdfU0hPV04pXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuZW1pdChFdmVudHMuUkVQTEFZX1NIT1dOKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ1JlcGxheTogYnVpbGQoKScpXG5cbiAgICByZXBsYXlFbGVtZW50ID0gcGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCd2aWRlby4nICsgb3B0aW9ucy5zZWxlY3RvcnMucmVwbGF5Q2xhc3MpXG5cbiAgICBpZiAoIXJlcGxheUVsZW1lbnQpIHtcbiAgICAgIGJ1aWxkRWxlbWVudCgpXG4gICAgfVxuXG4gICAgdGhpcy5oaWRlKClcblxuICAgIHJlcGxheUVsZW1lbnQuc2V0QXR0cmlidXRlKCdhdXRvcGxheScsIHRydWUpXG4gICAgcmVwbGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F1dG9zdGFydCcsIHRydWUpXG4gICAgcmVwbGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F1dG9idWZmZXInLCB0cnVlKVxuICAgIHJlcGxheUVsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsIHRydWUpXG4gICAgcmVwbGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRyb2xzJywgJ2NvbnRyb2xzJylcbiAgICByZXBsYXlFbGVtZW50LnNldEF0dHJpYnV0ZSgncHJlbG9hZCcsICdhdXRvJylcbiAgICByZXBsYXlFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2Via2l0LXBsYXlzaW5saW5lJywgJ3dlYmtpdC1wbGF5c2lubGluZScpXG5cbiAgICBpZiAoIWJ1aWx0KSB7XG4gICAgICBpZiAoIWlzU3RhbmRhbG9uZSgpKSB7XG4gICAgICAgIHRoaXMub24oRXZlbnRzLlBSRVZJRVcsIGZ1bmN0aW9uIChrZXksIHJlY29yZGVyV2lkdGgsIHJlY29yZGVySGVpZ2h0KSB7XG4gICAgICAgICAgc2VsZi5zaG93KHJlY29yZGVyV2lkdGgsIHJlY29yZGVySGVpZ2h0KVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBtYWtlcyB1c2Ugb2YgcGFzc2l2ZSBvcHRpb24gYXV0b21hdGljYWxseSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgICAvLyBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9hZGQtZXZlbnRsaXN0ZW5lci13aXRoLW9wdGlvbnNcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXJXaXRoT3B0aW9ucyhyZXBsYXlFbGVtZW50LCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgcGxheSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF1c2UoKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICByZXBsYXlFbGVtZW50Lm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgIHBsYXkoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdXNlKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGJ1aWx0ID0gdHJ1ZVxuXG4gICAgZGVidWcoJ1JlcGxheTogYnVpbHQuJylcbiAgfVxuXG4gIHRoaXMudW5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIGJ1aWx0ID0gZmFsc2VcbiAgfVxuXG4gIHRoaXMuZ2V0VmlkZW9Tb3VyY2UgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGNvbnN0IHNvdXJjZXMgPSByZXBsYXlFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKVxuICAgIGNvbnN0IGwgPSBzb3VyY2VzLmxlbmd0aFxuICAgIGNvbnN0IHZpZGVvVHlwZSA9ICd2aWRlby8nICsgdHlwZVxuXG4gICAgdmFyIHNvdXJjZVxuXG4gICAgaWYgKGwpIHtcbiAgICAgIHZhciBpXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsICYmICFzb3VyY2U7IGkrKykge1xuICAgICAgICBpZiAoc291cmNlc1tpXS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gdmlkZW9UeXBlKSB7XG4gICAgICAgICAgc291cmNlID0gc291cmNlc1tpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VmlkZW9Tb3VyY2UgKHR5cGUsIHNyYywgYnVzdENhY2hlKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNlbGYuZ2V0VmlkZW9Tb3VyY2UodHlwZSlcblxuICAgIGlmIChzcmMgJiYgYnVzdENhY2hlKSB7XG4gICAgICBzcmMgKz0gJz8nICsgRGF0ZS5ub3coKVxuICAgIH1cblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIHNvdXJjZSA9IGgoJ3NvdXJjZScsIHtcbiAgICAgICAgICBzcmM6IHNyYyxcbiAgICAgICAgICB0eXBlOiAndmlkZW8vJyArIHR5cGVcbiAgICAgICAgfSlcblxuICAgICAgICByZXBsYXlFbGVtZW50LmFwcGVuZENoaWxkKHNvdXJjZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICBzb3VyY2Uuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYXlFbGVtZW50LnJlbW92ZUNoaWxkKHNvdXJjZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLnNldE1wNFNvdXJjZSA9IGZ1bmN0aW9uIChzcmMsIGJ1c3RDYWNoZSkge1xuICAgIHNldFZpZGVvU291cmNlKCdtcDQnLCBzcmMsIGJ1c3RDYWNoZSlcbiAgfVxuXG4gIHRoaXMuc2V0V2ViTVNvdXJjZSA9IGZ1bmN0aW9uIChzcmMsIGJ1c3RDYWNoZSkge1xuICAgIHNldFZpZGVvU291cmNlKCd3ZWJtJywgc3JjLCBidXN0Q2FjaGUpXG4gIH1cblxuICB0aGlzLmdldFZpZGVvVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYnJvd3Nlci5nZXRWaWRlb1R5cGUocmVwbGF5RWxlbWVudClcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdXNlIChjYikge1xuICAgIC8vIGF2b2lkcyByYWNlIGNvbmRpdGlvbiwgaW5zcGlyZWQgYnlcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM2ODAzMTc2L2hvdy10by1wcmV2ZW50LXRoZS1wbGF5LXJlcXVlc3Qtd2FzLWludGVycnVwdGVkLWJ5LWEtY2FsbC10by1wYXVzZS1lcnJvclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVwbGF5RWxlbWVudC5wYXVzZSgpXG4gICAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgICAgLy8ganVzdCBpZ25vcmUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYmluYXJ5a2l0Y2hlbi92aWRlb21haWwuaW8vaXNzdWVzLzM4NlxuICAgICAgICBvcHRpb25zLmxvZ2dlci53YXJuKGV4YylcbiAgICAgIH1cblxuICAgICAgY2IgJiYgY2IoKVxuICAgIH0sIDE1KVxuICB9XG5cbiAgZnVuY3Rpb24gcGxheSAoKSB7XG4gICAgaWYgKHJlcGxheUVsZW1lbnQgJiYgcmVwbGF5RWxlbWVudC5wbGF5KSB7XG4gICAgICBjb25zdCBwID0gcmVwbGF5RWxlbWVudC5wbGF5KClcblxuICAgICAgaWYgKHAgJiYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykgJiYgKHAgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICBwLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgICBvcHRpb25zLmxvZ2dlci53YXJuKCdDYXVnaHQgcGVuZGluZyBwbGF5IGV4Y2VwdGlvbjogJXMnLCByZWFzb24pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uIChjYikge1xuICAgIC8vIHBhdXNlIHZpZGVvIHRvIG1ha2Ugc3VyZSBpdCB3b24ndCBjb25zdW1lIGFueSBtZW1vcnlcbiAgICBwYXVzZSgoKSA9PiB7XG4gICAgICBpZiAocmVwbGF5RWxlbWVudCkge1xuICAgICAgICBzZWxmLnNldE1wNFNvdXJjZShudWxsKVxuICAgICAgICBzZWxmLnNldFdlYk1Tb3VyY2UobnVsbClcbiAgICAgIH1cblxuICAgICAgY2IgJiYgY2IoKVxuICAgIH0pXG4gIH1cblxuICB0aGlzLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ1JlcGxheTogaGlkZSgpJylcblxuICAgIGlmIChpc1N0YW5kYWxvbmUoKSkge1xuICAgICAgaGlkZGVuKHBhcmVudEVsZW1lbnQsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxheUVsZW1lbnQgJiYgaGlkZGVuKHJlcGxheUVsZW1lbnQsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5pc1Nob3duID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXBsYXlFbGVtZW50ICYmICFoaWRkZW4ocmVwbGF5RWxlbWVudClcbiAgfVxuXG4gIHRoaXMuZ2V0UGFyZW50RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyZW50RWxlbWVudFxuICB9XG59XG5cbnV0aWwuaW5oZXJpdHMoUmVwbGF5LCBFdmVudEVtaXR0ZXIpXG5cbmV4cG9ydCBkZWZhdWx0IFJlcGxheVxuIiwiaW1wb3J0IGggZnJvbSAnaHlwZXJzY3JpcHQnXG5cbmltcG9ydCBBdWRpb1JlY29yZGVyIGZyb20gJy4vLi4vLi4vdXRpbC9hdWRpb1JlY29yZGVyJ1xuaW1wb3J0IFZpZGVvbWFpbEVycm9yIGZyb20gJy4vLi4vLi4vdXRpbC92aWRlb21haWxFcnJvcidcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi8uLi8uLi91dGlsL2V2ZW50RW1pdHRlcidcbmltcG9ydCBNRURJQV9FVkVOVFMgZnJvbSAnLi8uLi8uLi91dGlsL21lZGlhRXZlbnRzJ1xuaW1wb3J0IHByZXR0eSBmcm9tICcuLy4uLy4uL3V0aWwvcHJldHR5J1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLy4uLy4uL2V2ZW50cydcblxuY29uc3QgRVZFTlRfQVNDSUkgPSAnfOKAlE/igJR8J1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAocmVjb3JkZXIsIG9wdGlvbnMpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgb3B0aW9ucywgJ1VzZXJNZWRpYScpXG5cbiAgY29uc3QgcmF3VmlzdWFsVXNlck1lZGlhID0gcmVjb3JkZXIgJiYgcmVjb3JkZXIuZ2V0UmF3VmlzdWFsVXNlck1lZGlhKClcbiAgY29uc3Qgc2VsZiA9IHRoaXNcblxuICB2YXIgcGF1c2VkID0gZmFsc2VcbiAgdmFyIHJlY29yZCA9IGZhbHNlXG5cbiAgdmFyIGF1ZGlvUmVjb3JkZXJcbiAgdmFyIGN1cnJlbnRWaXN1YWxTdHJlYW1cblxuICBmdW5jdGlvbiBhdHRhY2hNZWRpYVN0cmVhbSAoc3RyZWFtKSB7XG4gICAgY3VycmVudFZpc3VhbFN0cmVhbSA9IHN0cmVhbVxuXG4gICAgaWYgKHR5cGVvZiByYXdWaXN1YWxVc2VyTWVkaWEuc3JjT2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmF3VmlzdWFsVXNlck1lZGlhLnNyY09iamVjdCA9IHN0cmVhbVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJhd1Zpc3VhbFVzZXJNZWRpYS5zcmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkxcbiAgICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSkgfHwgc3RyZWFtXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZShcbiAgICAgICAgJ0Vycm9yIGF0dGFjaGluZyBzdHJlYW0gdG8gZWxlbWVudC4nLFxuICAgICAgICAnQ29udGFjdCB0aGUgZGV2ZWxvcGVyIGFib3V0IHRoaXMnLFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VmlzdWFsU3RyZWFtIChsb2NhbE1lZGlhU3RyZWFtKSB7XG4gICAgaWYgKGxvY2FsTWVkaWFTdHJlYW0pIHtcbiAgICAgIGF0dGFjaE1lZGlhU3RyZWFtKGxvY2FsTWVkaWFTdHJlYW0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5yZW1vdmVBdHRyaWJ1dGUoJ3NyY09iamVjdCcpXG4gICAgICByYXdWaXN1YWxVc2VyTWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzcmMnKVxuXG4gICAgICBjdXJyZW50VmlzdWFsU3RyZWFtID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFZpc3VhbFN0cmVhbSAoKSB7XG4gICAgaWYgKHJhd1Zpc3VhbFVzZXJNZWRpYS5tb3pTcmNPYmplY3QpIHtcbiAgICAgIHJldHVybiByYXdWaXN1YWxVc2VyTWVkaWEubW96U3JjT2JqZWN0XG4gICAgfSBlbHNlIGlmIChyYXdWaXN1YWxVc2VyTWVkaWEuc3JjT2JqZWN0KSB7XG4gICAgICByZXR1cm4gcmF3VmlzdWFsVXNlck1lZGlhLnNyY09iamVjdFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3VycmVudFZpc3VhbFN0cmVhbVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0VuZGVkICgpIHtcbiAgICBpZiAocmF3VmlzdWFsVXNlck1lZGlhLmVuZGVkKSB7XG4gICAgICByZXR1cm4gcmF3VmlzdWFsVXNlck1lZGlhLmVuZGVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZpc3VhbFN0cmVhbSA9IGdldFZpc3VhbFN0cmVhbSgpXG4gICAgICByZXR1cm4gdmlzdWFsU3RyZWFtICYmIHZpc3VhbFN0cmVhbS5lbmRlZFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0ludmFsaWREaW1lbnNpb25zICgpIHtcbiAgICBpZiAoKHJhd1Zpc3VhbFVzZXJNZWRpYS52aWRlb1dpZHRoICYmIHJhd1Zpc3VhbFVzZXJNZWRpYS52aWRlb1dpZHRoIDwgMykgfHxcbiAgICAgICAgKHJhd1Zpc3VhbFVzZXJNZWRpYS5oZWlnaHQgJiYgcmF3VmlzdWFsVXNlck1lZGlhLmhlaWdodCA8IDMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRyYWNrcyAobG9jYWxNZWRpYVN0cmVhbSkge1xuICAgIHZhciB0cmFja3NcblxuICAgIGlmIChsb2NhbE1lZGlhU3RyZWFtICYmIGxvY2FsTWVkaWFTdHJlYW0uZ2V0VHJhY2tzKSB7XG4gICAgICB0cmFja3MgPSBsb2NhbE1lZGlhU3RyZWFtLmdldFRyYWNrcygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYWNrc1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmlkZW9UcmFja3MgKGxvY2FsTWVkaWFTdHJlYW0pIHtcbiAgICB2YXIgdmlkZW9UcmFja3NcblxuICAgIGlmIChsb2NhbE1lZGlhU3RyZWFtICYmIGxvY2FsTWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MpIHtcbiAgICAgIHZpZGVvVHJhY2tzID0gbG9jYWxNZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZGVvVHJhY2tzXG4gIH1cblxuICBmdW5jdGlvbiBnZXRGaXJzdFZpZGVvVHJhY2sgKGxvY2FsTWVkaWFTdHJlYW0pIHtcbiAgICBjb25zdCB2aWRlb1RyYWNrcyA9IGdldFZpZGVvVHJhY2tzKGxvY2FsTWVkaWFTdHJlYW0pXG4gICAgdmFyIHZpZGVvVHJhY2tcblxuICAgIGlmICh2aWRlb1RyYWNrcyAmJiB2aWRlb1RyYWNrc1swXSkge1xuICAgICAgdmlkZW9UcmFjayA9IHZpZGVvVHJhY2tzWzBdXG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZGVvVHJhY2tcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ0V2ZW50IChldmVudCwgcGFyYW1zKSB7XG4gICAgb3B0aW9ucy5kZWJ1ZygnVXNlck1lZGlhOiAuLi4nLCBFVkVOVF9BU0NJSSwgJ2V2ZW50JywgZXZlbnQsIEpTT04uc3RyaW5naWZ5KHBhcmFtcykpXG4gIH1cblxuICBmdW5jdGlvbiBpc1Byb21pc2UgKGFueXRoaW5nKSB7XG4gICAgcmV0dXJuIChhbnl0aGluZyAmJiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSAmJiAoYW55dGhpbmcgaW5zdGFuY2VvZiBQcm9taXNlKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG91dHB1dEV2ZW50IChlKSB7XG4gICAgbG9nRXZlbnQoZS50eXBlLCB7cmVhZHlTdGF0ZTogcmF3VmlzdWFsVXNlck1lZGlhLnJlYWR5U3RhdGV9KVxuXG4gICAgLy8gcmVtb3ZlIG15c2VsZlxuICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyICYmXG4gICAgcmF3VmlzdWFsVXNlck1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoZS50eXBlLCBvdXRwdXRFdmVudClcbiAgfVxuXG4gIHRoaXMudW5sb2FkUmVtYWluaW5nRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgb3B0aW9ucy5kZWJ1ZygnVXNlck1lZGlhOiB1bmxvYWRSZW1haW5pbmdFdmVudExpc3RlbmVycygpJylcblxuICAgIE1FRElBX0VWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgb3V0cHV0RXZlbnQpXG4gICAgfSlcbiAgfVxuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChsb2NhbE1lZGlhU3RyZWFtLCB2aWRlb0NhbGxiYWNrLCBhdWRpb0NhbGxiYWNrLCBlbmRlZEVhcmx5Q2FsbGJhY2spIHtcbiAgICB0aGlzLnN0b3AobG9jYWxNZWRpYVN0cmVhbSwgdHJ1ZSlcblxuICAgIHZhciBvblBsYXlSZWFjaGVkID0gZmFsc2VcbiAgICB2YXIgb25Mb2FkZWRNZXRhRGF0YVJlYWNoZWQgPSBmYWxzZVxuICAgIHZhciBwbGF5aW5nUHJvbWlzZVJlYWNoZWQgPSBmYWxzZVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pc0F1ZGlvRW5hYmxlZCgpKSB7XG4gICAgICBhdWRpb1JlY29yZGVyID0gYXVkaW9SZWNvcmRlciB8fCBuZXcgQXVkaW9SZWNvcmRlcih0aGlzLCBvcHRpb25zKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF1ZGlvUmVjb3JkICgpIHtcbiAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoRXZlbnRzLlNFTkRJTkdfRklSU1RfRlJBTUUsIGF1ZGlvUmVjb3JkKVxuICAgICAgYXVkaW9SZWNvcmRlciAmJiBhdWRpb1JlY29yZGVyLnJlY29yZChhdWRpb0NhbGxiYWNrKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVubG9hZEFsbEV2ZW50TGlzdGVuZXJzICgpIHtcbiAgICAgIG9wdGlvbnMuZGVidWcoJ1VzZXJNZWRpYTogdW5sb2FkQWxsRXZlbnRMaXN0ZW5lcnMoKScpXG5cbiAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoRXZlbnRzLlNFTkRJTkdfRklSU1RfRlJBTUUsIGF1ZGlvUmVjb3JkKVxuXG4gICAgICByYXdWaXN1YWxVc2VyTWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJlxuICAgICAgcmF3VmlzdWFsVXNlck1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXknLCBvblBsYXkpXG5cbiAgICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyICYmXG4gICAgICByYXdWaXN1YWxVc2VyTWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCBvbkxvYWRlZE1ldGFEYXRhKVxuXG4gICAgICBzZWxmLnVubG9hZFJlbWFpbmluZ0V2ZW50TGlzdGVuZXJzKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwbGF5ICgpIHtcbiAgICAgIC8vIFJlc2V0cyB0aGUgbWVkaWEgZWxlbWVudCBhbmQgcmVzdGFydHMgdGhlIG1lZGlhIHJlc291cmNlLiBBbnkgcGVuZGluZyBldmVudHMgYXJlIGRpc2NhcmRlZC5cbiAgICAgIC8vIEJ1dCBkbyB0aGVtIGluIHRoZSBuZXh0IHRpY2sgdG8gZW5zdXJlIGV2ZW50IHF1ZXVlIGlzIHJlYWR5IGZvciBhIGxvdCB0byBjb21lXG4gICAgICAvL1xuICAgICAgLy8gdGhpcyBhbHNvIHRvIGhhdmUgdGhlIGFib3J0IGFuZCBlbXB0aWVkIGV2ZW50IHRvIGJlIHByb2Nlc3NlZCBhcyBlYXJseSBhcyBwb3NzaWJsZSBiZWZvcmVcbiAgICAgIC8vIGFsbCB0aGUgb3RoZXIgaW1wb3J0YW50IGV2ZW50cyB0byBjb21lXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyB0b2RvIGRlYnVnIGFuZCBmaXggdGhhdCB3ZWlyZCBlcnJvclxuICAgICAgICAgIC8vIFRoZSBwbGF5KCkgcmVxdWVzdCB3YXMgaW50ZXJydXB0ZWQgYnkgYSBuZXcgbG9hZCByZXF1ZXN0LlxuICAgICAgICAgIG9wdGlvbnMuZGVidWcoXG4gICAgICAgICAgICAnVXNlck1lZGlhOiBwbGF5KCknLFxuICAgICAgICAgICAgJ21lZGlhLnJlYWR5U3RhdGU9JyArIHJhd1Zpc3VhbFVzZXJNZWRpYS5yZWFkeVN0YXRlLFxuICAgICAgICAgICAgJ21lZGlhLnBhdXNlZD0nICsgcmF3VmlzdWFsVXNlck1lZGlhLnBhdXNlZCxcbiAgICAgICAgICAgICdtZWRpYS5lbmRlZD0nICsgcmF3VmlzdWFsVXNlck1lZGlhLmVuZGVkLFxuICAgICAgICAgICAgJ21lZGlhLnBsYXllZD0nICsgcHJldHR5KHJhd1Zpc3VhbFVzZXJNZWRpYS5wbGF5ZWQpXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgcmF3VmlzdWFsVXNlck1lZGlhLmxvYWQoKVxuICAgICAgICAgIGNvbnN0IHAgPSByYXdWaXN1YWxVc2VyTWVkaWEucGxheSgpXG5cbiAgICAgICAgICAvLyB1c2luZyB0aGUgcHJvbWlzZSBoZXJlIGp1c3QgZXhwZXJpbWVudGFsIGZvciBub3dcbiAgICAgICAgICAvLyBhbmQgdGhpcyB0byBjYXRjaCBhbnkgd2VpcmQgZXJyb3JzIGVhcmx5IGlmIHBvc3NpYmxlXG4gICAgICAgICAgaWYgKGlzUHJvbWlzZShwKSkge1xuICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKCFwbGF5aW5nUHJvbWlzZVJlYWNoZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRlYnVnKCdVc2VyTWVkaWE6IC4uLiBwbGF5IHByb21pc2Ugc3VjY2Vzc2Z1bC4gUGxheWluZyBub3cuJylcbiAgICAgICAgICAgICAgICBwbGF5aW5nUHJvbWlzZVJlYWNoZWQgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgLy8gcHJvbWlzZSBjYW4gYmUgaW50ZXJydXB0ZWQsIGkuRS4gd2hlbiBzd2l0Y2hpbmcgdGFic1xuICAgICAgICAgICAgICAvLyBhbmQgcHJvbWlzZSBjYW4gZ2V0IHJlc3VtZWQgd2hlbiBzd2l0Y2hpbmcgYmFjayB0byB0YWIsIGhlbmNlXG4gICAgICAgICAgICAgIC8vIGRvIG5vdCB0cmVhdCB0aGlzIGxpa2UgYW4gZXJyb3JcbiAgICAgICAgICAgICAgb3B0aW9ucy5kZWJ1ZygnVXNlck1lZGlhOicsIHJlYXNvbi50b1N0cmluZygpKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgICAgIHVubG9hZEFsbEV2ZW50TGlzdGVuZXJzKClcbiAgICAgICAgICBlbmRlZEVhcmx5Q2FsbGJhY2soZXhjKVxuICAgICAgICB9XG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpcmVDYWxsYmFja3MgKCkge1xuICAgICAgY29uc3QgcmVhZHlTdGF0ZSA9IHJhd1Zpc3VhbFVzZXJNZWRpYS5yZWFkeVN0YXRlXG5cbiAgICAgIC8vIHJlYWR5IHN0YXRlLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvcmVhZHlTdGF0ZVxuICAgICAgb3B0aW9ucy5kZWJ1ZyhcbiAgICAgICAgJ1VzZXJNZWRpYTogZmlyZUNhbGxiYWNrcygnICtcbiAgICAgICAgJ3JlYWR5U3RhdGU9JyArIHJlYWR5U3RhdGUgKyAnLCAnICtcbiAgICAgICAgJ29uUGxheVJlYWNoZWQ9JyArIG9uUGxheVJlYWNoZWQgKyAnLCAnICtcbiAgICAgICAgJ29uTG9hZGVkTWV0YURhdGFSZWFjaGVkPScgKyBvbkxvYWRlZE1ldGFEYXRhUmVhY2hlZCArICcpJ1xuICAgICAgKVxuXG4gICAgICBpZiAob25QbGF5UmVhY2hlZCAmJiBvbkxvYWRlZE1ldGFEYXRhUmVhY2hlZCkge1xuICAgICAgICB2aWRlb0NhbGxiYWNrKClcblxuICAgICAgICBpZiAoYXVkaW9SZWNvcmRlciAmJiBhdWRpb0NhbGxiYWNrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF1ZGlvUmVjb3JkZXIuaW5pdChsb2NhbE1lZGlhU3RyZWFtKVxuICAgICAgICAgICAgc2VsZi5vbihFdmVudHMuU0VORElOR19GSVJTVF9GUkFNRSwgYXVkaW9SZWNvcmQpXG4gICAgICAgICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICAgICAgICB1bmxvYWRBbGxFdmVudExpc3RlbmVycygpXG4gICAgICAgICAgICBlbmRlZEVhcmx5Q2FsbGJhY2soZXhjKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUGxheSAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dFdmVudCgncGxheScsIHtcbiAgICAgICAgICByZWFkeVN0YXRlOiByYXdWaXN1YWxVc2VyTWVkaWEucmVhZHlTdGF0ZSxcbiAgICAgICAgICBhdWRpbzogb3B0aW9ucy5pc0F1ZGlvRW5hYmxlZCgpLFxuICAgICAgICAgIHdpZHRoOiByYXdWaXN1YWxVc2VyTWVkaWEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiByYXdWaXN1YWxVc2VyTWVkaWEuaGVpZ2h0LFxuICAgICAgICAgIHZpZGVvV2lkdGg6IHJhd1Zpc3VhbFVzZXJNZWRpYS52aWRlb1dpZHRoLFxuICAgICAgICAgIHZpZGVvSGVpZ2h0OiByYXdWaXN1YWxVc2VyTWVkaWEudmlkZW9IZWlnaHRcbiAgICAgICAgfSlcblxuICAgICAgICByYXdWaXN1YWxVc2VyTWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJlxuICAgICAgICByYXdWaXN1YWxVc2VyTWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheScsIG9uUGxheSlcblxuICAgICAgICBpZiAoaGFzRW5kZWQoKSB8fCBoYXNJbnZhbGlkRGltZW5zaW9ucygpKSB7XG4gICAgICAgICAgZW5kZWRFYXJseUNhbGxiYWNrKFxuICAgICAgICAgICAgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKFxuICAgICAgICAgICAgICAnQWxyZWFkeSBidXN5JyxcbiAgICAgICAgICAgICAgJ1Byb2JhYmx5IGFub3RoZXIgYnJvd3NlciB3aW5kb3cgaXMgdXNpbmcgeW91ciB3ZWJjYW0/JyxcbiAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvblBsYXlSZWFjaGVkID0gdHJ1ZVxuICAgICAgICAgIGZpcmVDYWxsYmFja3MoKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChleGMpIHtcbiAgICAgICAgdW5sb2FkQWxsRXZlbnRMaXN0ZW5lcnMoKVxuICAgICAgICBlbmRlZEVhcmx5Q2FsbGJhY2soZXhjKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBsYXllciBtb2RpZmljYXRpb25zIHRvIHBlcmZvcm0gdGhhdCBtdXN0IHdhaXQgdW50aWwgYGxvYWRlZG1ldGFkYXRhYCBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICBmdW5jdGlvbiBvbkxvYWRlZE1ldGFEYXRhICgpIHtcbiAgICAgIGxvZ0V2ZW50KCdsb2FkZWRtZXRhZGF0YScsIHtcbiAgICAgICAgcmVhZHlTdGF0ZTogcmF3VmlzdWFsVXNlck1lZGlhLnJlYWR5U3RhdGUsXG4gICAgICAgIHdpZHRoOiByYXdWaXN1YWxVc2VyTWVkaWEud2lkdGgsXG4gICAgICAgIGhlaWdodDogcmF3VmlzdWFsVXNlck1lZGlhLmhlaWdodCxcbiAgICAgICAgdmlkZW9XaWR0aDogcmF3VmlzdWFsVXNlck1lZGlhLnZpZGVvV2lkdGgsXG4gICAgICAgIHZpZGVvSGVpZ2h0OiByYXdWaXN1YWxVc2VyTWVkaWEudmlkZW9IZWlnaHRcbiAgICAgIH0pXG5cbiAgICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyICYmXG4gICAgICByYXdWaXN1YWxVc2VyTWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCBvbkxvYWRlZE1ldGFEYXRhKVxuXG4gICAgICBpZiAoIWhhc0VuZGVkKCkgJiYgIWhhc0ludmFsaWREaW1lbnNpb25zKCkpIHtcbiAgICAgICAgc2VsZi5lbWl0KEV2ZW50cy5MT0FERURfTUVUQV9EQVRBKVxuXG4gICAgICAgIC8vIGZvciBhbmRyb2lkIGRldmljZXMsIHdlIGNhbm5vdCBjYWxsIHBsYXkoKSB1bmxlc3MgbWV0YSBkYXRhIGhhcyBiZWVuIGxvYWRlZCFcbiAgICAgICAgcGxheSgpXG5cbiAgICAgICAgb25Mb2FkZWRNZXRhRGF0YVJlYWNoZWQgPSB0cnVlXG4gICAgICAgIGZpcmVDYWxsYmFja3MoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB2aWRlb1RyYWNrID0gZ2V0Rmlyc3RWaWRlb1RyYWNrKGxvY2FsTWVkaWFTdHJlYW0pXG5cbiAgICAgIGlmICghdmlkZW9UcmFjaykge1xuICAgICAgICBvcHRpb25zLmRlYnVnKCdVc2VyTWVkaWE6IGRldGVjdGVkIChidXQgbm8gdmlkZW8gdHJhY2tzIGV4aXN0JylcbiAgICAgIH0gZWxzZSBpZiAoIXZpZGVvVHJhY2suZW5hYmxlZCkge1xuICAgICAgICB0aHJvdyBWaWRlb21haWxFcnJvci5jcmVhdGUoXG4gICAgICAgICAgJ1dlYmNhbSBpcyBkaXNhYmxlZCcsXG4gICAgICAgICAgJ1RoZSB2aWRlbyB0cmFjayBzZWVtcyB0byBiZSBkaXNhYmxlZC4gRW5hYmxlIGl0IGluIHlvdXIgc3lzdGVtLicsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVzY3JpcHRpb25cblxuICAgICAgICBpZiAodmlkZW9UcmFjay5sYWJlbCAmJiB2aWRlb1RyYWNrLmxhYmVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZXNjcmlwdGlvbiA9IHZpZGVvVHJhY2subGFiZWxcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2NyaXB0aW9uICs9ICcgd2l0aCBlbmFibGVkPScgKyB2aWRlb1RyYWNrLmVuYWJsZWRcbiAgICAgICAgZGVzY3JpcHRpb24gKz0gJywgbXV0ZWQ9JyArIHZpZGVvVHJhY2subXV0ZWRcbiAgICAgICAgZGVzY3JpcHRpb24gKz0gJywgcmVtb3RlPScgKyB2aWRlb1RyYWNrLnJlbW90ZVxuICAgICAgICBkZXNjcmlwdGlvbiArPSAnLCByZWFkeVN0YXRlPScgKyB2aWRlb1RyYWNrLnJlYWR5U3RhdGVcbiAgICAgICAgZGVzY3JpcHRpb24gKz0gJywgZXJyb3I9JyArIHZpZGVvVHJhY2suZXJyb3JcblxuICAgICAgICBvcHRpb25zLmRlYnVnKFxuICAgICAgICAgICdVc2VyTWVkaWE6ICcgKyB2aWRlb1RyYWNrLmtpbmQgKyAnIGRldGVjdGVkLicsXG4gICAgICAgICAgZGVzY3JpcHRpb24gfHwgJydcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyB2ZXJ5IHVzZWZ1bCBpIHRoaW5rLCBzbyBsZWF2ZSB0aGlzIGFuZCBqdXN0IHVzZSBvcHRpb25zLmRlYnVnKClcbiAgICAgIGNvbnN0IGhlYXZ5RGVidWdnaW5nID0gdHJ1ZVxuXG4gICAgICBpZiAoaGVhdnlEZWJ1Z2dpbmcpIHtcbiAgICAgICAgTUVESUFfRVZFTlRTLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHJhd1Zpc3VhbFVzZXJNZWRpYS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgb3V0cHV0RXZlbnQsIGZhbHNlKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByYXdWaXN1YWxVc2VyTWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCBvbkxvYWRlZE1ldGFEYXRhKVxuICAgICAgcmF3VmlzdWFsVXNlck1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCBvblBsYXkpXG5cbiAgICAgIC8vIGV4cGVyaW1lbnRhbCwgbm90IHN1cmUgaWYgdGhpcyBpcyBldmVyIG5lZWRlZC9jYWxsZWQ/IHNpbmNlIDIgYXByIDIwMTdcbiAgICAgIC8vIEFuIGVycm9yIG9jY3VycyB3aGlsZSBmZXRjaGluZyB0aGUgbWVkaWEgZGF0YS5cbiAgICAgIC8vIEVycm9yIGNhbiBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgY29kZSBNRURJQV9FUlJfTkVUV09SSyBvciBoaWdoZXIuXG4gICAgICAvLyBuZXR3b3JrU3RhdGUgZXF1YWxzIGVpdGhlciBORVRXT1JLX0VNUFRZIG9yIE5FVFdPUktfSURMRSwgZGVwZW5kaW5nIG9uIHdoZW4gdGhlIGRvd25sb2FkIHdhcyBhYm9ydGVkLlxuICAgICAgcmF3VmlzdWFsVXNlck1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBpZ25vcmUgaGVyZSwgZG8gbm90aGluZy4gSUUvRWRnZSBlbWl0IHRoYXQgc29tZXRpbWVzIGZvciB1bmtub3duIHJlYXNvbnMuXG4gICAgICAgIG9wdGlvbnMubG9nZ2VyLndhcm4oZXJyKVxuICAgICAgfSlcblxuICAgICAgc2V0VmlzdWFsU3RyZWFtKGxvY2FsTWVkaWFTdHJlYW0pXG5cbiAgICAgIHBsYXkoKVxuICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgc2VsZi5lbWl0KEV2ZW50cy5FUlJPUiwgZXhjKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaXNSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISFyYXdWaXN1YWxVc2VyTWVkaWEuc3JjXG4gIH1cblxuICB0aGlzLnN0b3AgPSBmdW5jdGlvbiAodmlzdWFsU3RyZWFtLCBhYm91dFRvSW5pdGlhbGl6ZSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBkbyBub3Qgc3RvcCBcInRvbyBtdWNoXCIgd2hlbiBnb2luZyB0byBpbml0aWFsaXplIGFueXdheVxuICAgICAgaWYgKCFhYm91dFRvSW5pdGlhbGl6ZSkge1xuICAgICAgICBpZiAoIXZpc3VhbFN0cmVhbSkge1xuICAgICAgICAgIHZpc3VhbFN0cmVhbSA9IGdldFZpc3VhbFN0cmVhbSgpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0cmFja3MgPSBnZXRUcmFja3ModmlzdWFsU3RyZWFtKVxuICAgICAgICB2YXIgbmV3U3RvcEFwaUZvdW5kID0gZmFsc2VcblxuICAgICAgICBpZiAodHJhY2tzKSB7XG4gICAgICAgICAgdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICBpZiAodHJhY2suc3RvcCkge1xuICAgICAgICAgICAgICBuZXdTdG9wQXBpRm91bmQgPSB0cnVlXG4gICAgICAgICAgICAgIHRyYWNrLnN0b3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aWxsIHByb2JhYmx5IGJlY29tZSBvYnNvbGV0ZSBpbiBvbmUgeWVhciAoYWZ0ZXIganVuZSAyMDE3KVxuICAgICAgICAhbmV3U3RvcEFwaUZvdW5kICYmIHZpc3VhbFN0cmVhbSAmJiB2aXN1YWxTdHJlYW0uc3RvcCAmJiB2aXN1YWxTdHJlYW0uc3RvcCgpXG5cbiAgICAgICAgc2V0VmlzdWFsU3RyZWFtKG51bGwpXG5cbiAgICAgICAgYXVkaW9SZWNvcmRlciAmJiBhdWRpb1JlY29yZGVyLnN0b3AoKVxuXG4gICAgICAgIGF1ZGlvUmVjb3JkZXIgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIHBhdXNlZCA9IHJlY29yZCA9IGZhbHNlXG4gICAgfSBjYXRjaCAoZXhjKSB7XG4gICAgICBzZWxmLmVtaXQoRXZlbnRzLkVSUk9SLCBleGMpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGgoJ2NhbnZhcycsIHtcbiAgICAgIHdpZHRoOiB0aGlzLmdldFJhd1dpZHRoKHRydWUpLFxuICAgICAgaGVpZ2h0OiB0aGlzLmdldFJhd0hlaWdodCh0cnVlKVxuICAgIH0pXG4gIH1cblxuICB0aGlzLmdldFZpZGVvSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByYXdWaXN1YWxVc2VyTWVkaWEudmlkZW9IZWlnaHRcbiAgfVxuXG4gIHRoaXMuZ2V0VmlkZW9XaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmF3VmlzdWFsVXNlck1lZGlhLnZpZGVvV2lkdGhcbiAgfVxuXG4gIHRoaXMuZ2V0UmF3V2lkdGggPSBmdW5jdGlvbiAocmVzcG9uc2l2ZSkge1xuICAgIHZhciByYXdXaWR0aCA9IHRoaXMuZ2V0VmlkZW9XaWR0aCgpXG4gICAgY29uc3Qgd2lkdGhEZWZpbmVkID0gb3B0aW9ucy5oYXNEZWZpbmVkV2lkdGgoKVxuXG4gICAgaWYgKHdpZHRoRGVmaW5lZCB8fCBvcHRpb25zLmhhc0RlZmluZWRIZWlnaHQoKSkge1xuICAgICAgaWYgKCFyZXNwb25zaXZlICYmIHdpZHRoRGVmaW5lZCkge1xuICAgICAgICByYXdXaWR0aCA9IG9wdGlvbnMudmlkZW8ud2lkdGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhd1dpZHRoID0gcmVjb3JkZXIuY2FsY3VsYXRlV2lkdGgocmVzcG9uc2l2ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2l2ZSkge1xuICAgICAgcmF3V2lkdGggPSByZWNvcmRlci5saW1pdFdpZHRoKHJhd1dpZHRoKVxuICAgIH1cblxuICAgIHJldHVybiByYXdXaWR0aFxuICB9XG5cbiAgdGhpcy5nZXRSYXdIZWlnaHQgPSBmdW5jdGlvbiAocmVzcG9uc2l2ZSkge1xuICAgIHZhciByYXdIZWlnaHRcblxuICAgIGlmIChvcHRpb25zLmhhc0RlZmluZWREaW1lbnNpb24oKSkge1xuICAgICAgcmF3SGVpZ2h0ID0gcmVjb3JkZXIuY2FsY3VsYXRlSGVpZ2h0KHJlc3BvbnNpdmUpXG5cbiAgICAgIGlmIChyYXdIZWlnaHQgPCAxKSB7XG4gICAgICAgIHRocm93IFZpZGVvbWFpbEVycm9yLmNyZWF0ZSgnQmFkIGRpbWVuc2lvbnMnLCAnQ2FsY3VsYXRlZCByYXcgaGVpZ2h0IGNhbm5vdCBiZSBsZXNzIHRoYW4gMSEnLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYXdIZWlnaHQgPSB0aGlzLmdldFZpZGVvSGVpZ2h0KClcblxuICAgICAgaWYgKHJhd0hlaWdodCA8IDEpIHtcbiAgICAgICAgdGhyb3cgVmlkZW9tYWlsRXJyb3IuY3JlYXRlKCdCYWQgZGltZW5zaW9ucycsICdSYXcgdmlkZW8gaGVpZ2h0IGZyb20gRE9NIGVsZW1lbnQgY2Fubm90IGJlIGxlc3MgdGhhbiAxIScsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNpdmUpIHtcbiAgICAgIHJhd0hlaWdodCA9IHJlY29yZGVyLmxpbWl0SGVpZ2h0KHJhd0hlaWdodClcbiAgICB9XG5cbiAgICByZXR1cm4gcmF3SGVpZ2h0XG4gIH1cblxuICB0aGlzLmdldFJhd1Zpc3VhbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJhd1Zpc3VhbFVzZXJNZWRpYVxuICB9XG5cbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYXVzZWQgPSB0cnVlXG4gIH1cblxuICB0aGlzLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXVzZWRcbiAgfVxuXG4gIHRoaXMucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlXG4gIH1cblxuICB0aGlzLnJlY29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZWNvcmQgPSB0cnVlXG4gIH1cblxuICB0aGlzLmlzUmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWNvcmRcbiAgfVxuXG4gIHRoaXMuZ2V0QXVkaW9TYW1wbGVSYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhdWRpb1JlY29yZGVyKSB7XG4gICAgICByZXR1cm4gYXVkaW9SZWNvcmRlci5nZXRTYW1wbGVSYXRlKClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICB9XG5cbiAgdGhpcy5nZXRDaGFyYWN0ZXJpc3RpY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvU2FtcGxlUmF0ZTogdGhpcy5nZXRBdWRpb1NhbXBsZVJhdGUoKSxcbiAgICAgIG11dGVkOiByYXdWaXN1YWxVc2VyTWVkaWEgJiYgcmF3VmlzdWFsVXNlck1lZGlhLm11dGVkLFxuICAgICAgd2lkdGg6IHJhd1Zpc3VhbFVzZXJNZWRpYSAmJiByYXdWaXN1YWxVc2VyTWVkaWEud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJhd1Zpc3VhbFVzZXJNZWRpYSAmJiByYXdWaXN1YWxVc2VyTWVkaWEuaGVpZ2h0LFxuICAgICAgdmlkZW9XaWR0aDogcmF3VmlzdWFsVXNlck1lZGlhICYmIHJhd1Zpc3VhbFVzZXJNZWRpYS52aWRlb1dpZHRoLFxuICAgICAgdmlkZW9IZWlnaHQ6IHJhd1Zpc3VhbFVzZXJNZWRpYSAmJiByYXdWaXN1YWxVc2VyTWVkaWEudmlkZW9IZWlnaHRcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBzdGFuZGFyZGl6ZSBmcm9tICcuL3V0aWwvc3RhbmRhcmRpemUnXG5pbXBvcnQgQ2xpZW50IGZyb20gJy4vY2xpZW50J1xuXG5pZiAoIW5hdmlnYXRvcikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05hdmlnYXRvciBpcyBtaXNzaW5nIScpXG59IGVsc2Uge1xuICAvLyBFbnN1cmVzIFZpZGVvbWFpbCBmdW5jdGlvbmFsaXR5IGlzIG5vdCBicm9rZW4gb24gZXhvdGljIGJyb3dzZXJzIHdpdGggc2hpbXMuXG4gIC8vXG4gIC8vIFVNRCAoVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uKSwgaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG4gIDsoZnVuY3Rpb24gKG5hdmlnYXRvcikge1xuICAgIHN0YW5kYXJkaXplKHdpbmRvdywgbmF2aWdhdG9yKVxuICB9KG5hdmlnYXRvcikpXG59XG5cbmV4cG9ydCBkZWZhdWx0IENsaWVudFxuXG4vLyBhbHNvIGFkZCB0aGF0IHNvIHRoYXQgd2UgY2FuIHJlcXVpcmUoKSBpdCB0aGUgbm9ybWFsIEVTNSB3YXlcbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50XG4iXX0=
